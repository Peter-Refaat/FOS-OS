
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 f0 17 00 	lgdtl  0x17f018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 f0 17 f0       	mov    $0xf017f000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 10 00 00 00       	call   f010004d <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <set_uheap_strategy>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;
/*2025*/ //Replaced by setter & getter function
static inline void set_uheap_strategy(uint32 strategy){_UHeapPlacementStrategy = strategy;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	8b 45 08             	mov    0x8(%ebp),%eax
f0100045:	a3 48 61 85 f0       	mov    %eax,0xf0856148
f010004a:	90                   	nop
f010004b:	5d                   	pop    %ebp
f010004c:	c3                   	ret    

f010004d <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
extern bool __autograde__ ;
void FOS_initialize()
{
f010004d:	55                   	push   %ebp
f010004e:	89 e5                	mov    %esp,%ebp
f0100050:	57                   	push   %edi
f0100051:	56                   	push   %esi
f0100052:	53                   	push   %ebx
f0100053:	81 ec 2c 20 00 00    	sub    $0x202c,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100059:	ba 30 cd 87 f0       	mov    $0xf087cd30,%edx
f010005e:	b8 9c 4f 81 f0       	mov    $0xf0814f9c,%eax
f0100063:	29 c2                	sub    %eax,%edx
f0100065:	89 d0                	mov    %edx,%eax
f0100067:	83 ec 04             	sub    $0x4,%esp
f010006a:	50                   	push   %eax
f010006b:	6a 00                	push   $0x0
f010006d:	68 9c 4f 81 f0       	push   $0xf0814f9c
f0100072:	e8 f4 ab 01 00       	call   f011ac6b <memset>
f0100077:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f010007a:	e8 46 19 00 00       	call   f01019c5 <cons_init>
		//print welcome message
		print_welcome_message();
f010007f:	e8 b2 0d 00 00       	call   f0100e36 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100084:	83 ec 0c             	sub    $0xc,%esp
f0100087:	68 a0 bb 11 f0       	push   $0xf011bba0
f010008c:	e8 cb 1a 00 00       	call   f0101b5c <cprintf>
f0100091:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f0100094:	83 ec 0c             	sub    $0xc,%esp
f0100097:	68 e7 bb 11 f0       	push   $0xf011bbe7
f010009c:	e8 bb 1a 00 00       	call   f0101b5c <cprintf>
f01000a1:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000a4:	83 ec 0c             	sub    $0xc,%esp
f01000a7:	68 fb bb 11 f0       	push   $0xf011bbfb
f01000ac:	e8 ab 1a 00 00       	call   f0101b5c <cprintf>
f01000b1:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000b4:	83 ec 0c             	sub    $0xc,%esp
f01000b7:	68 0f bc 11 f0       	push   $0xf011bc0f
f01000bc:	e8 9b 1a 00 00       	call   f0101b5c <cprintf>
f01000c1:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000c4:	83 ec 0c             	sub    $0xc,%esp
f01000c7:	6a 00                	push   $0x0
f01000c9:	e8 ac 7e 00 00       	call   f0107f7a <cpu_init>
f01000ce:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000d1:	83 ec 0c             	sub    $0xc,%esp
f01000d4:	68 1b bc 11 f0       	push   $0xf011bc1b
f01000d9:	e8 7e 1a 00 00       	call   f0101b5c <cprintf>
f01000de:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000e1:	83 ec 0c             	sub    $0xc,%esp
f01000e4:	68 23 bc 11 f0       	push   $0xf011bc23
f01000e9:	e8 6e 1a 00 00       	call   f0101b5c <cprintf>
f01000ee:	83 c4 10             	add    $0x10,%esp
	{
		detect_memory();
f01000f1:	e8 f2 87 00 00       	call   f01088e8 <detect_memory>
		initialize_kernel_VM();
f01000f6:	e8 92 83 00 00       	call   f010848d <initialize_kernel_VM>
		initialize_paging();
f01000fb:	e8 51 8b 00 00       	call   f0108c51 <initialize_paging>
#if USE_KHEAP
		kheap_init();
f0100100:	e8 78 99 00 00       	call   f0109a7d <kheap_init>
		sharing_init();
f0100105:	e8 ad 97 00 00       	call   f01098b7 <sharing_init>
#endif
		fault_handler_init();
f010010a:	e8 16 f8 00 00       	call   f010f925 <fault_handler_init>
		set_uheap_strategy(UHP_PLACE_CUSTOMFIT);
f010010f:	83 ec 0c             	sub    $0xc,%esp
f0100112:	6a 05                	push   $0x5
f0100114:	e8 26 ff ff ff       	call   f010003f <set_uheap_strategy>
f0100119:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) DISK...");
f010011c:	83 ec 0c             	sub    $0xc,%esp
f010011f:	68 31 bc 11 f0       	push   $0xf011bc31
f0100124:	e8 33 1a 00 00       	call   f0101b5c <cprintf>
f0100129:	83 c4 10             	add    $0x10,%esp
	{
		ide_init();
f010012c:	e8 8a b1 01 00       	call   f011b2bb <ide_init>
	}
	cprintf("[DONE]\n");
f0100131:	83 ec 0c             	sub    $0xc,%esp
f0100134:	68 1b bc 11 f0       	push   $0xf011bc1b
f0100139:	e8 1e 1a 00 00       	call   f0101b5c <cprintf>
f010013e:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) USER ENVs...");
f0100141:	83 ec 0c             	sub    $0xc,%esp
f0100144:	68 3e bc 11 f0       	push   $0xf011bc3e
f0100149:	e8 0e 1a 00 00       	call   f0101b5c <cprintf>
f010014e:	83 c4 10             	add    $0x10,%esp
	{
		env_init();
f0100151:	e8 73 ab 00 00       	call   f010acc9 <env_init>
		ts_init();
f0100156:	e8 64 cd 00 00       	call   f010cebf <ts_init>
	}
	cprintf("[DONE]\n");
f010015b:	83 ec 0c             	sub    $0xc,%esp
f010015e:	68 1b bc 11 f0       	push   $0xf011bc1b
f0100163:	e8 f4 19 00 00       	call   f0101b5c <cprintf>
f0100168:	83 c4 10             	add    $0x10,%esp

	cprintf("* 5) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f010016b:	83 ec 0c             	sub    $0xc,%esp
f010016e:	68 50 bc 11 f0       	push   $0xf011bc50
f0100173:	e8 e4 19 00 00       	call   f0101b5c <cprintf>
f0100178:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f010017b:	e8 e6 7a 00 00       	call   f0107c66 <pic_init>
		cprintf("*	PIC is initialized\n");
f0100180:	83 ec 0c             	sub    $0xc,%esp
f0100183:	68 79 bc 11 f0       	push   $0xf011bc79
f0100188:	e8 cf 19 00 00       	call   f0101b5c <cprintf>
f010018d:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f0100190:	83 ec 0c             	sub    $0xc,%esp
f0100193:	6a 00                	push   $0x0
f0100195:	e8 be 7c 00 00       	call   f0107e58 <irq_clear_mask>
f010019a:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f010019d:	83 ec 0c             	sub    $0xc,%esp
f01001a0:	68 8f bc 11 f0       	push   $0xf011bc8f
f01001a5:	e8 b2 19 00 00       	call   f0101b5c <cprintf>
f01001aa:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001ad:	83 ec 0c             	sub    $0xc,%esp
f01001b0:	6a 01                	push   $0x1
f01001b2:	e8 a1 7c 00 00       	call   f0107e58 <irq_clear_mask>
f01001b7:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001ba:	83 ec 0c             	sub    $0xc,%esp
f01001bd:	68 ac bc 11 f0       	push   $0xf011bcac
f01001c2:	e8 95 19 00 00       	call   f0101b5c <cprintf>
f01001c7:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001ca:	83 ec 0c             	sub    $0xc,%esp
f01001cd:	6a 04                	push   $0x4
f01001cf:	e8 84 7c 00 00       	call   f0107e58 <irq_clear_mask>
f01001d4:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001d7:	83 ec 0c             	sub    $0xc,%esp
f01001da:	68 cb bc 11 f0       	push   $0xf011bccb
f01001df:	e8 78 19 00 00       	call   f0101b5c <cprintf>
f01001e4:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
		irq_clear_mask(14);
f01001e7:	83 ec 0c             	sub    $0xc,%esp
f01001ea:	6a 0e                	push   $0xe
f01001ec:	e8 67 7c 00 00       	call   f0107e58 <irq_clear_mask>
f01001f1:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
f01001f4:	83 ec 0c             	sub    $0xc,%esp
f01001f7:	68 e8 bc 11 f0       	push   $0xf011bce8
f01001fc:	e8 5b 19 00 00       	call   f0101b5c <cprintf>
f0100201:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("* 6) SCHEDULER & MULTI-TASKING:\n");
f0100204:	83 ec 0c             	sub    $0xc,%esp
f0100207:	68 18 bd 11 f0       	push   $0xf011bd18
f010020c:	e8 4b 19 00 00       	call   f0101b5c <cprintf>
f0100211:	83 c4 10             	add    $0x10,%esp
	{
		kclock_init();
f0100214:	e8 40 59 00 00       	call   f0105b59 <kclock_init>
		sched_init() ;
f0100219:	e8 c5 74 00 00       	call   f01076e3 <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 7) ESP to SCHED KERN STACK:\n");
f010021e:	83 ec 0c             	sub    $0xc,%esp
f0100221:	68 3c bd 11 f0       	push   $0xf011bd3c
f0100226:	e8 31 19 00 00       	call   f0101b5c <cprintf>
f010022b:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010022e:	89 e0                	mov    %esp,%eax
f0100230:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return esp;
f0100233:	8b 45 d8             	mov    -0x28(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100236:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100239:	b8 00 f0 17 f0       	mov    $0xf017f000,%eax
f010023e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0100241:	89 45 e0             	mov    %eax,-0x20(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f0100244:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100249:	2b 45 e0             	sub    -0x20(%ebp),%eax
f010024c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010024f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100252:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100255:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100258:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010025a:	89 e0                	mov    %esp,%eax
f010025c:	89 45 d0             	mov    %eax,-0x30(%ebp)
        return esp;
f010025f:	8b 45 d0             	mov    -0x30(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f0100262:	83 ec 04             	sub    $0x4,%esp
f0100265:	50                   	push   %eax
f0100266:	ff 75 e4             	pushl  -0x1c(%ebp)
f0100269:	68 5c bd 11 f0       	push   $0xf011bd5c
f010026e:	e8 e9 18 00 00       	call   f0101b5c <cprintf>
f0100273:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("* [DONE]\n");
	cprintf("********************************************************************\n");
f0100276:	83 ec 0c             	sub    $0xc,%esp
f0100279:	68 80 bd 11 f0       	push   $0xf011bd80
f010027e:	e8 d9 18 00 00       	call   f0101b5c <cprintf>
f0100283:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f0100286:	83 ec 0c             	sub    $0xc,%esp
f0100289:	68 c8 bd 11 f0       	push   $0xf011bdc8
f010028e:	e8 c9 18 00 00       	call   f0101b5c <cprintf>
f0100293:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f0100296:	83 ec 0c             	sub    $0xc,%esp
f0100299:	68 f4 bd 11 f0       	push   $0xf011bdf4
f010029e:	e8 b9 18 00 00       	call   f0101b5c <cprintf>
f01002a3:	83 c4 10             	add    $0x10,%esp
		if (__autograde__)
f01002a6:	a1 20 f0 17 f0       	mov    0xf017f020,%eax
f01002ab:	85 c0                	test   %eax,%eax
f01002ad:	0f 84 7e 0b 00 00    	je     f0100e31 <FOS_initialize+0xde4>
			/*CHECK THE FOLLOWING:
			 * 1) time of each test
			 * 2) "unhandled trap in" message
			 */

			cprintf("\nPROJECT Automatic testing is STARTED...\n") ;
f01002b3:	83 ec 0c             	sub    $0xc,%esp
f01002b6:	68 1c be 11 f0       	push   $0xf011be1c
f01002bb:	e8 9c 18 00 00       	call   f0101b5c <cprintf>
f01002c0:	83 c4 10             	add    $0x10,%esp

			//TEST#1: DYNAMIC ALLOCATOR
			{
				char cmd1[BUFLEN] = "tst dynalloc init";
f01002c3:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f01002c9:	bb 6c be 11 f0       	mov    $0xf011be6c,%ebx
f01002ce:	ba 12 00 00 00       	mov    $0x12,%edx
f01002d3:	89 c7                	mov    %eax,%edi
f01002d5:	89 de                	mov    %ebx,%esi
f01002d7:	89 d1                	mov    %edx,%ecx
f01002d9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01002db:	8d 95 e2 ef ff ff    	lea    -0x101e(%ebp),%edx
f01002e1:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f01002e6:	b0 00                	mov    $0x0,%al
f01002e8:	89 d7                	mov    %edx,%edi
f01002ea:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "tst dynalloc alloc";
f01002ec:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01002f2:	bb 6c c2 11 f0       	mov    $0xf011c26c,%ebx
f01002f7:	ba 13 00 00 00       	mov    $0x13,%edx
f01002fc:	89 c7                	mov    %eax,%edi
f01002fe:	89 de                	mov    %ebx,%esi
f0100300:	89 d1                	mov    %edx,%ecx
f0100302:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100304:	8d 95 e3 f3 ff ff    	lea    -0xc1d(%ebp),%edx
f010030a:	b9 ed 03 00 00       	mov    $0x3ed,%ecx
f010030f:	b0 00                	mov    $0x0,%al
f0100311:	89 d7                	mov    %edx,%edi
f0100313:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "tst dynalloc free";
f0100315:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f010031b:	bb 6c c6 11 f0       	mov    $0xf011c66c,%ebx
f0100320:	ba 12 00 00 00       	mov    $0x12,%edx
f0100325:	89 c7                	mov    %eax,%edi
f0100327:	89 de                	mov    %ebx,%esi
f0100329:	89 d1                	mov    %edx,%ecx
f010032b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010032d:	8d 95 e2 f7 ff ff    	lea    -0x81e(%ebp),%edx
f0100333:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100338:	b0 00                	mov    $0x0,%al
f010033a:	89 d7                	mov    %edx,%edi
f010033c:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "tst dynalloc realloc";
f010033e:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100344:	bb 6c ca 11 f0       	mov    $0xf011ca6c,%ebx
f0100349:	ba 15 00 00 00       	mov    $0x15,%edx
f010034e:	89 c7                	mov    %eax,%edi
f0100350:	89 de                	mov    %ebx,%esi
f0100352:	89 d1                	mov    %edx,%ecx
f0100354:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100356:	8d 95 e5 fb ff ff    	lea    -0x41b(%ebp),%edx
f010035c:	b9 eb 03 00 00       	mov    $0x3eb,%ecx
f0100361:	b0 00                	mov    $0x0,%al
f0100363:	89 d7                	mov    %edx,%edi
f0100365:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd4);
			}
			//TEST#2: KERNEL HEAP [PARTIAL GRADING]
			{
				char cmd1[BUFLEN] = "tst kheap CF kmalloc blk";
f0100367:	8d 85 d0 df ff ff    	lea    -0x2030(%ebp),%eax
f010036d:	bb 6c ce 11 f0       	mov    $0xf011ce6c,%ebx
f0100372:	ba 19 00 00 00       	mov    $0x19,%edx
f0100377:	89 c7                	mov    %eax,%edi
f0100379:	89 de                	mov    %ebx,%esi
f010037b:	89 d1                	mov    %edx,%ecx
f010037d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010037f:	8d 95 e9 df ff ff    	lea    -0x2017(%ebp),%edx
f0100385:	b9 e7 03 00 00       	mov    $0x3e7,%ecx
f010038a:	b0 00                	mov    $0x0,%al
f010038c:	89 d7                	mov    %edx,%edi
f010038e:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "tst kheap CF kmalloc page";
f0100390:	8d 85 d0 e3 ff ff    	lea    -0x1c30(%ebp),%eax
f0100396:	bb 6c d2 11 f0       	mov    $0xf011d26c,%ebx
f010039b:	ba 1a 00 00 00       	mov    $0x1a,%edx
f01003a0:	89 c7                	mov    %eax,%edi
f01003a2:	89 de                	mov    %ebx,%esi
f01003a4:	89 d1                	mov    %edx,%ecx
f01003a6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01003a8:	8d 95 ea e3 ff ff    	lea    -0x1c16(%ebp),%edx
f01003ae:	b9 e6 03 00 00       	mov    $0x3e6,%ecx
f01003b3:	b0 00                	mov    $0x0,%al
f01003b5:	89 d7                	mov    %edx,%edi
f01003b7:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "tst kheap CF kmalloc both";
f01003b9:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f01003bf:	bb 6c d6 11 f0       	mov    $0xf011d66c,%ebx
f01003c4:	ba 1a 00 00 00       	mov    $0x1a,%edx
f01003c9:	89 c7                	mov    %eax,%edi
f01003cb:	89 de                	mov    %ebx,%esi
f01003cd:	89 d1                	mov    %edx,%ecx
f01003cf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01003d1:	8d 95 ea e7 ff ff    	lea    -0x1816(%ebp),%edx
f01003d7:	b9 e6 03 00 00       	mov    $0x3e6,%ecx
f01003dc:	b0 00                	mov    $0x0,%al
f01003de:	89 d7                	mov    %edx,%edi
f01003e0:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "tst kheap CF kfree blk";
f01003e2:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f01003e8:	bb 6c da 11 f0       	mov    $0xf011da6c,%ebx
f01003ed:	ba 17 00 00 00       	mov    $0x17,%edx
f01003f2:	89 c7                	mov    %eax,%edi
f01003f4:	89 de                	mov    %ebx,%esi
f01003f6:	89 d1                	mov    %edx,%ecx
f01003f8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01003fa:	8d 95 e7 eb ff ff    	lea    -0x1419(%ebp),%edx
f0100400:	b9 e9 03 00 00       	mov    $0x3e9,%ecx
f0100405:	b0 00                	mov    $0x0,%al
f0100407:	89 d7                	mov    %edx,%edi
f0100409:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "tst kheap CF kfree page";
f010040b:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100411:	bb 6c de 11 f0       	mov    $0xf011de6c,%ebx
f0100416:	ba 06 00 00 00       	mov    $0x6,%edx
f010041b:	89 c7                	mov    %eax,%edi
f010041d:	89 de                	mov    %ebx,%esi
f010041f:	89 d1                	mov    %edx,%ecx
f0100421:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100423:	8d 95 e8 ef ff ff    	lea    -0x1018(%ebp),%edx
f0100429:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f010042e:	b8 00 00 00 00       	mov    $0x0,%eax
f0100433:	89 d7                	mov    %edx,%edi
f0100435:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd6[BUFLEN] = "tst kheap CF kfree both";
f0100437:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f010043d:	bb 6c e2 11 f0       	mov    $0xf011e26c,%ebx
f0100442:	ba 06 00 00 00       	mov    $0x6,%edx
f0100447:	89 c7                	mov    %eax,%edi
f0100449:	89 de                	mov    %ebx,%esi
f010044b:	89 d1                	mov    %edx,%ecx
f010044d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010044f:	8d 95 e8 f3 ff ff    	lea    -0xc18(%ebp),%edx
f0100455:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f010045a:	b8 00 00 00 00       	mov    $0x0,%eax
f010045f:	89 d7                	mov    %edx,%edi
f0100461:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd7[BUFLEN] = "tst kheap kvirtaddr";
f0100463:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100469:	bb 6c e6 11 f0       	mov    $0xf011e66c,%ebx
f010046e:	ba 05 00 00 00       	mov    $0x5,%edx
f0100473:	89 c7                	mov    %eax,%edi
f0100475:	89 de                	mov    %ebx,%esi
f0100477:	89 d1                	mov    %edx,%ecx
f0100479:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010047b:	8d 95 e4 f7 ff ff    	lea    -0x81c(%ebp),%edx
f0100481:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100486:	b8 00 00 00 00       	mov    $0x0,%eax
f010048b:	89 d7                	mov    %edx,%edi
f010048d:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd8[BUFLEN] = "tst kheap kphysaddr";
f010048f:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100495:	bb 6c ea 11 f0       	mov    $0xf011ea6c,%ebx
f010049a:	ba 05 00 00 00       	mov    $0x5,%edx
f010049f:	89 c7                	mov    %eax,%edi
f01004a1:	89 de                	mov    %ebx,%esi
f01004a3:	89 d1                	mov    %edx,%ecx
f01004a5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01004a7:	8d 95 e4 fb ff ff    	lea    -0x41c(%ebp),%edx
f01004ad:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f01004b2:	b8 00 00 00 00       	mov    $0x0,%eax
f01004b7:	89 d7                	mov    %edx,%edi
f01004b9:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd8);
			}
			//TEST#3: FAULT HANDLER I [PARTIAL GRADING]
			{
				char cmd1[BUFLEN] = "run tia 15";
f01004bb:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01004c1:	bb 6c ee 11 f0       	mov    $0xf011ee6c,%ebx
f01004c6:	ba 0b 00 00 00       	mov    $0xb,%edx
f01004cb:	89 c7                	mov    %eax,%edi
f01004cd:	89 de                	mov    %ebx,%esi
f01004cf:	89 d1                	mov    %edx,%ecx
f01004d1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01004d3:	8d 95 db f7 ff ff    	lea    -0x825(%ebp),%edx
f01004d9:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f01004de:	b0 00                	mov    $0x0,%al
f01004e0:	89 d7                	mov    %edx,%edi
f01004e2:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run tpp 20";
f01004e4:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01004ea:	bb 6c f2 11 f0       	mov    $0xf011f26c,%ebx
f01004ef:	ba 0b 00 00 00       	mov    $0xb,%edx
f01004f4:	89 c7                	mov    %eax,%edi
f01004f6:	89 de                	mov    %ebx,%esi
f01004f8:	89 d1                	mov    %edx,%ecx
f01004fa:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01004fc:	8d 95 db fb ff ff    	lea    -0x425(%ebp),%edx
f0100502:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f0100507:	b0 00                	mov    $0x0,%al
f0100509:	89 d7                	mov    %edx,%edi
f010050b:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd2);
			}
			//TEST: FAULT HANDLER II [OPTIMAL] 	[10 sec]
			{
				char cmd0[BUFLEN] = "optimal";
f010050d:	c7 85 d0 ef ff ff 6f 	movl   $0x6974706f,-0x1030(%ebp)
f0100514:	70 74 69 
f0100517:	c7 85 d4 ef ff ff 6d 	movl   $0x6c616d,-0x102c(%ebp)
f010051e:	61 6c 00 
f0100521:	8d 95 d8 ef ff ff    	lea    -0x1028(%ebp),%edx
f0100527:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f010052c:	b8 00 00 00 00       	mov    $0x0,%eax
f0100531:	89 d7                	mov    %edx,%edi
f0100533:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run toptimal1 11";
f0100535:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f010053b:	bb 6c f6 11 f0       	mov    $0xf011f66c,%ebx
f0100540:	ba 11 00 00 00       	mov    $0x11,%edx
f0100545:	89 c7                	mov    %eax,%edi
f0100547:	89 de                	mov    %ebx,%esi
f0100549:	89 d1                	mov    %edx,%ecx
f010054b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010054d:	8d 95 e1 f3 ff ff    	lea    -0xc1f(%ebp),%edx
f0100553:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100558:	b0 00                	mov    $0x0,%al
f010055a:	89 d7                	mov    %edx,%edi
f010055c:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run toptimal2 11";
f010055e:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100564:	bb 6c fa 11 f0       	mov    $0xf011fa6c,%ebx
f0100569:	ba 11 00 00 00       	mov    $0x11,%edx
f010056e:	89 c7                	mov    %eax,%edi
f0100570:	89 de                	mov    %ebx,%esi
f0100572:	89 d1                	mov    %edx,%ecx
f0100574:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100576:	8d 95 e1 f7 ff ff    	lea    -0x81f(%ebp),%edx
f010057c:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100581:	b0 00                	mov    $0x0,%al
f0100583:	89 d7                	mov    %edx,%edi
f0100585:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run toptimal3 11";
f0100587:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f010058d:	bb 6c fe 11 f0       	mov    $0xf011fe6c,%ebx
f0100592:	ba 11 00 00 00       	mov    $0x11,%edx
f0100597:	89 c7                	mov    %eax,%edi
f0100599:	89 de                	mov    %ebx,%esi
f010059b:	89 d1                	mov    %edx,%ecx
f010059d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010059f:	8d 95 e1 fb ff ff    	lea    -0x41f(%ebp),%edx
f01005a5:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f01005aa:	b0 00                	mov    $0x0,%al
f01005ac:	89 d7                	mov    %edx,%edi
f01005ae:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd3);
			}
			//TEST: FAULT HANDLER II [CLOCK] 	[10 sec]
			{
				char cmd0[BUFLEN] = "clock";
f01005b0:	c7 85 d0 eb ff ff 63 	movl   $0x636f6c63,-0x1430(%ebp)
f01005b7:	6c 6f 63 
f01005ba:	c7 85 d4 eb ff ff 6b 	movl   $0x6b,-0x142c(%ebp)
f01005c1:	00 00 00 
f01005c4:	8d 95 d8 eb ff ff    	lea    -0x1428(%ebp),%edx
f01005ca:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f01005cf:	b8 00 00 00 00       	mov    $0x0,%eax
f01005d4:	89 d7                	mov    %edx,%edi
f01005d6:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tpr1 11";
f01005d8:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f01005de:	bb 6c 02 12 f0       	mov    $0xf012026c,%ebx
f01005e3:	ba 03 00 00 00       	mov    $0x3,%edx
f01005e8:	89 c7                	mov    %eax,%edi
f01005ea:	89 de                	mov    %ebx,%esi
f01005ec:	89 d1                	mov    %edx,%ecx
f01005ee:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01005f0:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f01005f6:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01005fb:	b8 00 00 00 00       	mov    $0x0,%eax
f0100600:	89 d7                	mov    %edx,%edi
f0100602:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tpr2 6";
f0100604:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f010060a:	bb 6c 06 12 f0       	mov    $0xf012066c,%ebx
f010060f:	ba 0b 00 00 00       	mov    $0xb,%edx
f0100614:	89 c7                	mov    %eax,%edi
f0100616:	89 de                	mov    %ebx,%esi
f0100618:	89 d1                	mov    %edx,%ecx
f010061a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010061c:	8d 95 db f3 ff ff    	lea    -0xc25(%ebp),%edx
f0100622:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f0100627:	b0 00                	mov    $0x0,%al
f0100629:	89 d7                	mov    %edx,%edi
f010062b:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tclock1 11";
f010062d:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100633:	bb 6c 0a 12 f0       	mov    $0xf0120a6c,%ebx
f0100638:	ba 0f 00 00 00       	mov    $0xf,%edx
f010063d:	89 c7                	mov    %eax,%edi
f010063f:	89 de                	mov    %ebx,%esi
f0100641:	89 d1                	mov    %edx,%ecx
f0100643:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100645:	8d 95 df f7 ff ff    	lea    -0x821(%ebp),%edx
f010064b:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0100650:	b0 00                	mov    $0x0,%al
f0100652:	89 d7                	mov    %edx,%edi
f0100654:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tclock2 11";	//depend on USER HEAP (allocate_user_mem, free_user_mem)
f0100656:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f010065c:	bb 6c 0e 12 f0       	mov    $0xf0120e6c,%ebx
f0100661:	ba 0f 00 00 00       	mov    $0xf,%edx
f0100666:	89 c7                	mov    %eax,%edi
f0100668:	89 de                	mov    %ebx,%esi
f010066a:	89 d1                	mov    %edx,%ecx
f010066c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010066e:	8d 95 df fb ff ff    	lea    -0x421(%ebp),%edx
f0100674:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0100679:	b0 00                	mov    $0x0,%al
f010067b:	89 d7                	mov    %edx,%edi
f010067d:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd4);
			}
			//TEST: FAULT HANDLER II [MODIFIED CLOCK] 	[10 sec]
			{
				char cmd0[BUFLEN] = "modclock";
f010067f:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100685:	bb 6c 12 12 f0       	mov    $0xf012126c,%ebx
f010068a:	ba 09 00 00 00       	mov    $0x9,%edx
f010068f:	89 c7                	mov    %eax,%edi
f0100691:	89 de                	mov    %ebx,%esi
f0100693:	89 d1                	mov    %edx,%ecx
f0100695:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100697:	8d 95 d9 eb ff ff    	lea    -0x1427(%ebp),%edx
f010069d:	b9 f7 03 00 00       	mov    $0x3f7,%ecx
f01006a2:	b0 00                	mov    $0x0,%al
f01006a4:	89 d7                	mov    %edx,%edi
f01006a6:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd1[BUFLEN] = "run tpr1 11";
f01006a8:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f01006ae:	bb 6c 02 12 f0       	mov    $0xf012026c,%ebx
f01006b3:	ba 03 00 00 00       	mov    $0x3,%edx
f01006b8:	89 c7                	mov    %eax,%edi
f01006ba:	89 de                	mov    %ebx,%esi
f01006bc:	89 d1                	mov    %edx,%ecx
f01006be:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01006c0:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f01006c6:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01006cb:	b8 00 00 00 00       	mov    $0x0,%eax
f01006d0:	89 d7                	mov    %edx,%edi
f01006d2:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tpr2 6";
f01006d4:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01006da:	bb 6c 06 12 f0       	mov    $0xf012066c,%ebx
f01006df:	ba 0b 00 00 00       	mov    $0xb,%edx
f01006e4:	89 c7                	mov    %eax,%edi
f01006e6:	89 de                	mov    %ebx,%esi
f01006e8:	89 d1                	mov    %edx,%ecx
f01006ea:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01006ec:	8d 95 db f3 ff ff    	lea    -0xc25(%ebp),%edx
f01006f2:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f01006f7:	b0 00                	mov    $0x0,%al
f01006f9:	89 d7                	mov    %edx,%edi
f01006fb:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tmodclk1 11";
f01006fd:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100703:	bb 6c 16 12 f0       	mov    $0xf012166c,%ebx
f0100708:	ba 04 00 00 00       	mov    $0x4,%edx
f010070d:	89 c7                	mov    %eax,%edi
f010070f:	89 de                	mov    %ebx,%esi
f0100711:	89 d1                	mov    %edx,%ecx
f0100713:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100715:	8d 95 e0 f7 ff ff    	lea    -0x820(%ebp),%edx
f010071b:	b9 fc 00 00 00       	mov    $0xfc,%ecx
f0100720:	b8 00 00 00 00       	mov    $0x0,%eax
f0100725:	89 d7                	mov    %edx,%edi
f0100727:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd4[BUFLEN] = "run tmodclk2 11";	//depend on USER HEAP (allocate_user_mem, free_user_mem)
f0100729:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f010072f:	bb 6c 1a 12 f0       	mov    $0xf0121a6c,%ebx
f0100734:	ba 04 00 00 00       	mov    $0x4,%edx
f0100739:	89 c7                	mov    %eax,%edi
f010073b:	89 de                	mov    %ebx,%esi
f010073d:	89 d1                	mov    %edx,%ecx
f010073f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100741:	8d 95 e0 fb ff ff    	lea    -0x420(%ebp),%edx
f0100747:	b9 fc 00 00 00       	mov    $0xfc,%ecx
f010074c:	b8 00 00 00 00       	mov    $0x0,%eax
f0100751:	89 d7                	mov    %edx,%edi
f0100753:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd4);
			}
			//TEST: FAULT HANDLER II [LRU] 	[10 sec]
			{
				char cmd0[BUFLEN] = "lru 1";
f0100755:	c7 85 d0 ef ff ff 6c 	movl   $0x2075726c,-0x1030(%ebp)
f010075c:	72 75 20 
f010075f:	c7 85 d4 ef ff ff 31 	movl   $0x31,-0x102c(%ebp)
f0100766:	00 00 00 
f0100769:	8d 95 d8 ef ff ff    	lea    -0x1028(%ebp),%edx
f010076f:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f0100774:	b8 00 00 00 00       	mov    $0x0,%eax
f0100779:	89 d7                	mov    %edx,%edi
f010077b:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tpr1 11";
f010077d:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100783:	bb 6c 02 12 f0       	mov    $0xf012026c,%ebx
f0100788:	ba 03 00 00 00       	mov    $0x3,%edx
f010078d:	89 c7                	mov    %eax,%edi
f010078f:	89 de                	mov    %ebx,%esi
f0100791:	89 d1                	mov    %edx,%ecx
f0100793:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100795:	8d 95 dc f3 ff ff    	lea    -0xc24(%ebp),%edx
f010079b:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01007a0:	b8 00 00 00 00       	mov    $0x0,%eax
f01007a5:	89 d7                	mov    %edx,%edi
f01007a7:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tpr2 6";
f01007a9:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01007af:	bb 6c 06 12 f0       	mov    $0xf012066c,%ebx
f01007b4:	ba 0b 00 00 00       	mov    $0xb,%edx
f01007b9:	89 c7                	mov    %eax,%edi
f01007bb:	89 de                	mov    %ebx,%esi
f01007bd:	89 d1                	mov    %edx,%ecx
f01007bf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01007c1:	8d 95 db f7 ff ff    	lea    -0x825(%ebp),%edx
f01007c7:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f01007cc:	b0 00                	mov    $0x0,%al
f01007ce:	89 d7                	mov    %edx,%edi
f01007d0:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tlru 11";
f01007d2:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01007d8:	bb 6c 1e 12 f0       	mov    $0xf0121e6c,%ebx
f01007dd:	ba 03 00 00 00       	mov    $0x3,%edx
f01007e2:	89 c7                	mov    %eax,%edi
f01007e4:	89 de                	mov    %ebx,%esi
f01007e6:	89 d1                	mov    %edx,%ecx
f01007e8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01007ea:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
f01007f0:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01007f5:	b8 00 00 00 00       	mov    $0x0,%eax
f01007fa:	89 d7                	mov    %edx,%edi
f01007fc:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd3);
			}
			//TEST: USER HEAP	[PARTIAL GRADING]
			{
				char cmd0[BUFLEN] = "uhcustomfit";
f01007fe:	8d 85 d0 e3 ff ff    	lea    -0x1c30(%ebp),%eax
f0100804:	bb 6c 22 12 f0       	mov    $0xf012226c,%ebx
f0100809:	ba 03 00 00 00       	mov    $0x3,%edx
f010080e:	89 c7                	mov    %eax,%edi
f0100810:	89 de                	mov    %ebx,%esi
f0100812:	89 d1                	mov    %edx,%ecx
f0100814:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100816:	8d 95 dc e3 ff ff    	lea    -0x1c24(%ebp),%edx
f010081c:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100821:	b8 00 00 00 00       	mov    $0x0,%eax
f0100826:	89 d7                	mov    %edx,%edi
f0100828:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tm1 3000";
f010082a:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f0100830:	bb 6c 26 12 f0       	mov    $0xf012266c,%ebx
f0100835:	ba 0d 00 00 00       	mov    $0xd,%edx
f010083a:	89 c7                	mov    %eax,%edi
f010083c:	89 de                	mov    %ebx,%esi
f010083e:	89 d1                	mov    %edx,%ecx
f0100840:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100842:	8d 95 dd e7 ff ff    	lea    -0x1823(%ebp),%edx
f0100848:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f010084d:	b0 00                	mov    $0x0,%al
f010084f:	89 d7                	mov    %edx,%edi
f0100851:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run tm2 3000";
f0100853:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100859:	bb 6c 2a 12 f0       	mov    $0xf0122a6c,%ebx
f010085e:	ba 0d 00 00 00       	mov    $0xd,%edx
f0100863:	89 c7                	mov    %eax,%edi
f0100865:	89 de                	mov    %ebx,%esi
f0100867:	89 d1                	mov    %edx,%ecx
f0100869:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010086b:	8d 95 dd eb ff ff    	lea    -0x1423(%ebp),%edx
f0100871:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f0100876:	b0 00                	mov    $0x0,%al
f0100878:	89 d7                	mov    %edx,%edi
f010087a:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tf1 3000";
f010087c:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100882:	bb 6c 2e 12 f0       	mov    $0xf0122e6c,%ebx
f0100887:	ba 0d 00 00 00       	mov    $0xd,%edx
f010088c:	89 c7                	mov    %eax,%edi
f010088e:	89 de                	mov    %ebx,%esi
f0100890:	89 d1                	mov    %edx,%ecx
f0100892:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100894:	8d 95 dd ef ff ff    	lea    -0x1023(%ebp),%edx
f010089a:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f010089f:	b0 00                	mov    $0x0,%al
f01008a1:	89 d7                	mov    %edx,%edi
f01008a3:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tf2 3000";
f01008a5:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01008ab:	bb 6c 32 12 f0       	mov    $0xf012326c,%ebx
f01008b0:	ba 0d 00 00 00       	mov    $0xd,%edx
f01008b5:	89 c7                	mov    %eax,%edi
f01008b7:	89 de                	mov    %ebx,%esi
f01008b9:	89 d1                	mov    %edx,%ecx
f01008bb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01008bd:	8d 95 dd f3 ff ff    	lea    -0xc23(%ebp),%edx
f01008c3:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f01008c8:	b0 00                	mov    $0x0,%al
f01008ca:	89 d7                	mov    %edx,%edi
f01008cc:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "run tcf1 3000";
f01008ce:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01008d4:	bb 6c 36 12 f0       	mov    $0xf012366c,%ebx
f01008d9:	ba 0e 00 00 00       	mov    $0xe,%edx
f01008de:	89 c7                	mov    %eax,%edi
f01008e0:	89 de                	mov    %ebx,%esi
f01008e2:	89 d1                	mov    %edx,%ecx
f01008e4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01008e6:	8d 95 de f7 ff ff    	lea    -0x822(%ebp),%edx
f01008ec:	b9 f2 03 00 00       	mov    $0x3f2,%ecx
f01008f1:	b0 00                	mov    $0x0,%al
f01008f3:	89 d7                	mov    %edx,%edi
f01008f5:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd6[BUFLEN] = "run tcf2 10000";
f01008f7:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01008fd:	bb 6c 3a 12 f0       	mov    $0xf0123a6c,%ebx
f0100902:	ba 0f 00 00 00       	mov    $0xf,%edx
f0100907:	89 c7                	mov    %eax,%edi
f0100909:	89 de                	mov    %ebx,%esi
f010090b:	89 d1                	mov    %edx,%ecx
f010090d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010090f:	8d 95 df fb ff ff    	lea    -0x421(%ebp),%edx
f0100915:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f010091a:	b0 00                	mov    $0x0,%al
f010091c:	89 d7                	mov    %edx,%edi
f010091e:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd6);
			}
			//TEST: SHARED MEMORY	[PARTIAL GRADING]
			{
				char cmd0[BUFLEN] = "uhcustomfit";
f0100920:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f0100926:	bb 6c 22 12 f0       	mov    $0xf012226c,%ebx
f010092b:	ba 03 00 00 00       	mov    $0x3,%edx
f0100930:	89 c7                	mov    %eax,%edi
f0100932:	89 de                	mov    %ebx,%esi
f0100934:	89 d1                	mov    %edx,%ecx
f0100936:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100938:	8d 95 dc e7 ff ff    	lea    -0x1824(%ebp),%edx
f010093e:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100943:	b8 00 00 00 00       	mov    $0x0,%eax
f0100948:	89 d7                	mov    %edx,%edi
f010094a:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tshr1 3000";
f010094c:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100952:	bb 6c 3e 12 f0       	mov    $0xf0123e6c,%ebx
f0100957:	ba 0f 00 00 00       	mov    $0xf,%edx
f010095c:	89 c7                	mov    %eax,%edi
f010095e:	89 de                	mov    %ebx,%esi
f0100960:	89 d1                	mov    %edx,%ecx
f0100962:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100964:	8d 95 df eb ff ff    	lea    -0x1421(%ebp),%edx
f010096a:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f010096f:	b0 00                	mov    $0x0,%al
f0100971:	89 d7                	mov    %edx,%edi
f0100973:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run tshr2 3000";
f0100975:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f010097b:	bb 6c 42 12 f0       	mov    $0xf012426c,%ebx
f0100980:	ba 0f 00 00 00       	mov    $0xf,%edx
f0100985:	89 c7                	mov    %eax,%edi
f0100987:	89 de                	mov    %ebx,%esi
f0100989:	89 d1                	mov    %edx,%ecx
f010098b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010098d:	8d 95 df ef ff ff    	lea    -0x1021(%ebp),%edx
f0100993:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0100998:	b0 00                	mov    $0x0,%al
f010099a:	89 d7                	mov    %edx,%edi
f010099c:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tshr3 3000";
f010099e:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01009a4:	bb 6c 46 12 f0       	mov    $0xf012466c,%ebx
f01009a9:	ba 0f 00 00 00       	mov    $0xf,%edx
f01009ae:	89 c7                	mov    %eax,%edi
f01009b0:	89 de                	mov    %ebx,%esi
f01009b2:	89 d1                	mov    %edx,%ecx
f01009b4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01009b6:	8d 95 df f3 ff ff    	lea    -0xc21(%ebp),%edx
f01009bc:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f01009c1:	b0 00                	mov    $0x0,%al
f01009c3:	89 d7                	mov    %edx,%edi
f01009c5:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tcf3 3000";	//depend on USER HEAP (malloc, free)
f01009c7:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01009cd:	bb 6c 4a 12 f0       	mov    $0xf0124a6c,%ebx
f01009d2:	ba 0e 00 00 00       	mov    $0xe,%edx
f01009d7:	89 c7                	mov    %eax,%edi
f01009d9:	89 de                	mov    %ebx,%esi
f01009db:	89 d1                	mov    %edx,%ecx
f01009dd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01009df:	8d 95 de f7 ff ff    	lea    -0x822(%ebp),%edx
f01009e5:	b9 f2 03 00 00       	mov    $0x3f2,%ecx
f01009ea:	b0 00                	mov    $0x0,%al
f01009ec:	89 d7                	mov    %edx,%edi
f01009ee:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "run tst_protection 5000"; //[0/1 GRADING] [time limit: 3 mins]
f01009f0:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01009f6:	bb 6c 4e 12 f0       	mov    $0xf0124e6c,%ebx
f01009fb:	ba 06 00 00 00       	mov    $0x6,%edx
f0100a00:	89 c7                	mov    %eax,%edi
f0100a02:	89 de                	mov    %ebx,%esi
f0100a04:	89 d1                	mov    %edx,%ecx
f0100a06:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100a08:	8d 95 e8 fb ff ff    	lea    -0x418(%ebp),%edx
f0100a0e:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100a13:	b8 00 00 00 00       	mov    $0x0,%eax
f0100a18:	89 d7                	mov    %edx,%edi
f0100a1a:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd5);
			}
			//TEST: PRIORITY RR SCHEDULER
			{
				char cmd01[BUFLEN] = "schedPRIRR 10 40 1000";
f0100a1c:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100a22:	bb 6c 52 12 f0       	mov    $0xf012526c,%ebx
f0100a27:	ba 16 00 00 00       	mov    $0x16,%edx
f0100a2c:	89 c7                	mov    %eax,%edi
f0100a2e:	89 de                	mov    %ebx,%esi
f0100a30:	89 d1                	mov    %edx,%ecx
f0100a32:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100a34:	8d 95 e6 eb ff ff    	lea    -0x141a(%ebp),%edx
f0100a3a:	b9 ea 03 00 00       	mov    $0x3ea,%ecx
f0100a3f:	b0 00                	mov    $0x0,%al
f0100a41:	89 d7                	mov    %edx,%edi
f0100a43:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd03[BUFLEN] = "schedPRIRR 10 40 20";
f0100a45:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100a4b:	bb 6c 56 12 f0       	mov    $0xf012566c,%ebx
f0100a50:	ba 05 00 00 00       	mov    $0x5,%edx
f0100a55:	89 c7                	mov    %eax,%edi
f0100a57:	89 de                	mov    %ebx,%esi
f0100a59:	89 d1                	mov    %edx,%ecx
f0100a5b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100a5d:	8d 95 e4 ef ff ff    	lea    -0x101c(%ebp),%edx
f0100a63:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100a68:	b8 00 00 00 00       	mov    $0x0,%eax
f0100a6d:	89 d7                	mov    %edx,%edi
f0100a6f:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd03);
				char cmdU1_1[BUFLEN] = "tst priorityRR 0";	//52 sec
f0100a71:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100a77:	bb 6c 5a 12 f0       	mov    $0xf0125a6c,%ebx
f0100a7c:	ba 11 00 00 00       	mov    $0x11,%edx
f0100a81:	89 c7                	mov    %eax,%edi
f0100a83:	89 de                	mov    %ebx,%esi
f0100a85:	89 d1                	mov    %edx,%ecx
f0100a87:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100a89:	8d 95 e1 f3 ff ff    	lea    -0xc1f(%ebp),%edx
f0100a8f:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100a94:	b0 00                	mov    $0x0,%al
f0100a96:	89 d7                	mov    %edx,%edi
f0100a98:	f3 aa                	rep stos %al,%es:(%edi)
				char cmdU2_1[BUFLEN] = "tst priorityRR 1";	//58 sec
f0100a9a:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100aa0:	bb 6c 5e 12 f0       	mov    $0xf0125e6c,%ebx
f0100aa5:	ba 11 00 00 00       	mov    $0x11,%edx
f0100aaa:	89 c7                	mov    %eax,%edi
f0100aac:	89 de                	mov    %ebx,%esi
f0100aae:	89 d1                	mov    %edx,%ecx
f0100ab0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100ab2:	8d 95 e1 f7 ff ff    	lea    -0x81f(%ebp),%edx
f0100ab8:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100abd:	b0 00                	mov    $0x0,%al
f0100abf:	89 d7                	mov    %edx,%edi
f0100ac1:	f3 aa                	rep stos %al,%es:(%edi)
				char cmdU3_1[BUFLEN] = "tst priorityRR 2";	//90 sec
f0100ac3:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100ac9:	bb 6c 62 12 f0       	mov    $0xf012626c,%ebx
f0100ace:	ba 11 00 00 00       	mov    $0x11,%edx
f0100ad3:	89 c7                	mov    %eax,%edi
f0100ad5:	89 de                	mov    %ebx,%esi
f0100ad7:	89 d1                	mov    %edx,%ecx
f0100ad9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100adb:	8d 95 e1 fb ff ff    	lea    -0x41f(%ebp),%edx
f0100ae1:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100ae6:	b0 00                	mov    $0x0,%al
f0100ae8:	89 d7                	mov    %edx,%edi
f0100aea:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmdU3_1);
			}
			//TEST: PROTECTION
			{
				char cmd1[BUFLEN] = "run tst_chan_all 20";
f0100aec:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100af2:	bb 6c 66 12 f0       	mov    $0xf012666c,%ebx
f0100af7:	ba 05 00 00 00       	mov    $0x5,%edx
f0100afc:	89 c7                	mov    %eax,%edi
f0100afe:	89 de                	mov    %ebx,%esi
f0100b00:	89 d1                	mov    %edx,%ecx
f0100b02:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100b04:	8d 95 e4 eb ff ff    	lea    -0x141c(%ebp),%edx
f0100b0a:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100b0f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b14:	89 d7                	mov    %edx,%edi
f0100b16:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tst_chan_one 20";
f0100b18:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100b1e:	bb 6c 6a 12 f0       	mov    $0xf0126a6c,%ebx
f0100b23:	ba 05 00 00 00       	mov    $0x5,%edx
f0100b28:	89 c7                	mov    %eax,%edi
f0100b2a:	89 de                	mov    %ebx,%esi
f0100b2c:	89 d1                	mov    %edx,%ecx
f0100b2e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100b30:	8d 95 e4 ef ff ff    	lea    -0x101c(%ebp),%edx
f0100b36:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100b3b:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b40:	89 d7                	mov    %edx,%edi
f0100b42:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd3[BUFLEN] = "run tst_sleeplock 20";
f0100b44:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100b4a:	bb 6c 6e 12 f0       	mov    $0xf0126e6c,%ebx
f0100b4f:	ba 15 00 00 00       	mov    $0x15,%edx
f0100b54:	89 c7                	mov    %eax,%edi
f0100b56:	89 de                	mov    %ebx,%esi
f0100b58:	89 d1                	mov    %edx,%ecx
f0100b5a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100b5c:	8d 95 e5 f3 ff ff    	lea    -0xc1b(%ebp),%edx
f0100b62:	b9 eb 03 00 00       	mov    $0x3eb,%ecx
f0100b67:	b0 00                	mov    $0x0,%al
f0100b69:	89 d7                	mov    %edx,%edi
f0100b6b:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tst_ksem1 500";	//5 sec
f0100b6d:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100b73:	bb 6c 72 12 f0       	mov    $0xf012726c,%ebx
f0100b78:	ba 12 00 00 00       	mov    $0x12,%edx
f0100b7d:	89 c7                	mov    %eax,%edi
f0100b7f:	89 de                	mov    %ebx,%esi
f0100b81:	89 d1                	mov    %edx,%ecx
f0100b83:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100b85:	8d 95 e2 f7 ff ff    	lea    -0x81e(%ebp),%edx
f0100b8b:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100b90:	b0 00                	mov    $0x0,%al
f0100b92:	89 d7                	mov    %edx,%edi
f0100b94:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "run tst_ksem2 500";	//20 sec
f0100b96:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100b9c:	bb 6c 76 12 f0       	mov    $0xf012766c,%ebx
f0100ba1:	ba 12 00 00 00       	mov    $0x12,%edx
f0100ba6:	89 c7                	mov    %eax,%edi
f0100ba8:	89 de                	mov    %ebx,%esi
f0100baa:	89 d1                	mov    %edx,%ecx
f0100bac:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100bae:	8d 95 e2 fb ff ff    	lea    -0x41e(%ebp),%edx
f0100bb4:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100bb9:	b0 00                	mov    $0x0,%al
f0100bbb:	89 d7                	mov    %edx,%edi
f0100bbd:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd5);
			}
			//TEST#X: BONUS - DA: BLOCK IF NO BLOCK
			{
				char cmd1[BUFLEN] = "run tst_da_block 500";
f0100bbf:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100bc5:	bb 6c 7a 12 f0       	mov    $0xf0127a6c,%ebx
f0100bca:	ba 15 00 00 00       	mov    $0x15,%edx
f0100bcf:	89 c7                	mov    %eax,%edi
f0100bd1:	89 de                	mov    %ebx,%esi
f0100bd3:	89 d1                	mov    %edx,%ecx
f0100bd5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100bd7:	8d 95 e5 fb ff ff    	lea    -0x41b(%ebp),%edx
f0100bdd:	b9 eb 03 00 00       	mov    $0x3eb,%ecx
f0100be2:	b0 00                	mov    $0x0,%al
f0100be4:	89 d7                	mov    %edx,%edi
f0100be6:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd1);
			}
			//TEST#X: BONUS - KREALLOC
			{
				char cmd0[BUFLEN] = "khcustomfit";
f0100be8:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100bee:	bb 6c 7e 12 f0       	mov    $0xf0127e6c,%ebx
f0100bf3:	ba 03 00 00 00       	mov    $0x3,%edx
f0100bf8:	89 c7                	mov    %eax,%edi
f0100bfa:	89 de                	mov    %ebx,%esi
f0100bfc:	89 d1                	mov    %edx,%ecx
f0100bfe:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c00:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f0100c06:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100c0b:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c10:	89 d7                	mov    %edx,%edi
f0100c12:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "tst kheap CF krealloc 1";
f0100c14:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100c1a:	bb 6c 82 12 f0       	mov    $0xf012826c,%ebx
f0100c1f:	ba 06 00 00 00       	mov    $0x6,%edx
f0100c24:	89 c7                	mov    %eax,%edi
f0100c26:	89 de                	mov    %ebx,%esi
f0100c28:	89 d1                	mov    %edx,%ecx
f0100c2a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c2c:	8d 95 e8 f3 ff ff    	lea    -0xc18(%ebp),%edx
f0100c32:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100c37:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c3c:	89 d7                	mov    %edx,%edi
f0100c3e:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "tst kheap CF krealloc 2";
f0100c40:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100c46:	bb 6c 86 12 f0       	mov    $0xf012866c,%ebx
f0100c4b:	ba 06 00 00 00       	mov    $0x6,%edx
f0100c50:	89 c7                	mov    %eax,%edi
f0100c52:	89 de                	mov    %ebx,%esi
f0100c54:	89 d1                	mov    %edx,%ecx
f0100c56:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c58:	8d 95 e8 f7 ff ff    	lea    -0x818(%ebp),%edx
f0100c5e:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100c63:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c68:	89 d7                	mov    %edx,%edi
f0100c6a:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd3[BUFLEN] = "tst kheap CF krealloc 3";
f0100c6c:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100c72:	bb 6c 8a 12 f0       	mov    $0xf0128a6c,%ebx
f0100c77:	ba 06 00 00 00       	mov    $0x6,%edx
f0100c7c:	89 c7                	mov    %eax,%edi
f0100c7e:	89 de                	mov    %ebx,%esi
f0100c80:	89 d1                	mov    %edx,%ecx
f0100c82:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c84:	8d 95 e8 fb ff ff    	lea    -0x418(%ebp),%edx
f0100c8a:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100c8f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c94:	89 d7                	mov    %edx,%edi
f0100c96:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd1);
			}
			//TEST#X: BONUS - FAST PAGE ALLOCATOR
			{
				char cmd0[BUFLEN] = "khcustomfit";
f0100c98:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100c9e:	bb 6c 7e 12 f0       	mov    $0xf0127e6c,%ebx
f0100ca3:	ba 03 00 00 00       	mov    $0x3,%edx
f0100ca8:	89 c7                	mov    %eax,%edi
f0100caa:	89 de                	mov    %ebx,%esi
f0100cac:	89 d1                	mov    %edx,%ecx
f0100cae:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100cb0:	8d 95 dc f7 ff ff    	lea    -0x824(%ebp),%edx
f0100cb6:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100cbb:	b8 00 00 00 00       	mov    $0x0,%eax
f0100cc0:	89 d7                	mov    %edx,%edi
f0100cc2:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "tst kheap CF fast"; //[0/1 GRADING] [time limit: 10 secs]
f0100cc4:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100cca:	bb 6c 8e 12 f0       	mov    $0xf0128e6c,%ebx
f0100ccf:	ba 12 00 00 00       	mov    $0x12,%edx
f0100cd4:	89 c7                	mov    %eax,%edi
f0100cd6:	89 de                	mov    %ebx,%esi
f0100cd8:	89 d1                	mov    %edx,%ecx
f0100cda:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100cdc:	8d 95 e2 fb ff ff    	lea    -0x41e(%ebp),%edx
f0100ce2:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100ce7:	b0 00                	mov    $0x0,%al
f0100ce9:	89 d7                	mov    %edx,%edi
f0100ceb:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd1);
			}
			//TEST#X: BONUS - EXIT
			{
				char cmd0[BUFLEN] = "fifo";
f0100ced:	c7 85 d0 e3 ff ff 66 	movl   $0x6f666966,-0x1c30(%ebp)
f0100cf4:	69 66 6f 
f0100cf7:	c7 85 d4 e3 ff ff 00 	movl   $0x0,-0x1c2c(%ebp)
f0100cfe:	00 00 00 
f0100d01:	8d 95 d8 e3 ff ff    	lea    -0x1c28(%ebp),%edx
f0100d07:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f0100d0c:	b8 00 00 00 00       	mov    $0x0,%eax
f0100d11:	89 d7                	mov    %edx,%edi
f0100d13:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 1: without using dynamic allocation/de-allocation [PLACEMENT]
				char cmd1[BUFLEN] = "run tef1 100";
f0100d15:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f0100d1b:	bb 6c 92 12 f0       	mov    $0xf012926c,%ebx
f0100d20:	ba 0d 00 00 00       	mov    $0xd,%edx
f0100d25:	89 c7                	mov    %eax,%edi
f0100d27:	89 de                	mov    %ebx,%esi
f0100d29:	89 d1                	mov    %edx,%ecx
f0100d2b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100d2d:	8d 95 dd e7 ff ff    	lea    -0x1823(%ebp),%edx
f0100d33:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f0100d38:	b0 00                	mov    $0x0,%al
f0100d3a:	89 d7                	mov    %edx,%edi
f0100d3c:	f3 aa                	rep stos %al,%es:(%edi)
				//Scenario 2: using dynamic allocation and free [REPLACEMENT]
				char cmd2[BUFLEN] = "run tef2 20";
f0100d3e:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100d44:	bb 6c 96 12 f0       	mov    $0xf012966c,%ebx
f0100d49:	ba 03 00 00 00       	mov    $0x3,%edx
f0100d4e:	89 c7                	mov    %eax,%edi
f0100d50:	89 de                	mov    %ebx,%esi
f0100d52:	89 d1                	mov    %edx,%ecx
f0100d54:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100d56:	8d 95 dc eb ff ff    	lea    -0x1424(%ebp),%edx
f0100d5c:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100d61:	b8 00 00 00 00       	mov    $0x0,%eax
f0100d66:	89 d7                	mov    %edx,%edi
f0100d68:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario3: using dynamic allocation and free [process kill itself] [REPLACEMENT]
				char cmd3[BUFLEN] = "run tef3 20";
f0100d6a:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100d70:	bb 6c 9a 12 f0       	mov    $0xf0129a6c,%ebx
f0100d75:	ba 03 00 00 00       	mov    $0x3,%edx
f0100d7a:	89 c7                	mov    %eax,%edi
f0100d7c:	89 de                	mov    %ebx,%esi
f0100d7e:	89 d1                	mov    %edx,%ecx
f0100d80:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100d82:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f0100d88:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100d8d:	b8 00 00 00 00       	mov    $0x0,%eax
f0100d92:	89 d7                	mov    %edx,%edi
f0100d94:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 4: using create & get of shared variables [REPLACEMENT]
				char cmd4[BUFLEN] = "run tef4 10";
f0100d96:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100d9c:	bb 6c 9e 12 f0       	mov    $0xf0129e6c,%ebx
f0100da1:	ba 03 00 00 00       	mov    $0x3,%edx
f0100da6:	89 c7                	mov    %eax,%edi
f0100da8:	89 de                	mov    %ebx,%esi
f0100daa:	89 d1                	mov    %edx,%ecx
f0100dac:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100dae:	8d 95 dc f3 ff ff    	lea    -0xc24(%ebp),%edx
f0100db4:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100db9:	b8 00 00 00 00       	mov    $0x0,%eax
f0100dbe:	89 d7                	mov    %edx,%edi
f0100dc0:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 5: using create, get and free shared variables by the created environment itself before calling env_free [PLACEMENT]
				char cmd5[BUFLEN] = "run tef5_2 3000";
f0100dc2:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100dc8:	bb 6c a2 12 f0       	mov    $0xf012a26c,%ebx
f0100dcd:	ba 04 00 00 00       	mov    $0x4,%edx
f0100dd2:	89 c7                	mov    %eax,%edi
f0100dd4:	89 de                	mov    %ebx,%esi
f0100dd6:	89 d1                	mov    %edx,%ecx
f0100dd8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100dda:	8d 95 e0 f7 ff ff    	lea    -0x820(%ebp),%edx
f0100de0:	b9 fc 00 00 00       	mov    $0xfc,%ecx
f0100de5:	b8 00 00 00 00       	mov    $0x0,%eax
f0100dea:	89 d7                	mov    %edx,%edi
f0100dec:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 6: using shared variables and semaphores together [PLACEMENT]
				char cmd6[BUFLEN] = "run tef6 3000";
f0100dee:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100df4:	bb 6c a6 12 f0       	mov    $0xf012a66c,%ebx
f0100df9:	ba 0e 00 00 00       	mov    $0xe,%edx
f0100dfe:	89 c7                	mov    %eax,%edi
f0100e00:	89 de                	mov    %ebx,%esi
f0100e02:	89 d1                	mov    %edx,%ecx
f0100e04:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100e06:	8d 95 de fb ff ff    	lea    -0x422(%ebp),%edx
f0100e0c:	b9 f2 03 00 00       	mov    $0x3f2,%ecx
f0100e11:	b0 00                	mov    $0x0,%al
f0100e13:	89 d7                	mov    %edx,%edi
f0100e15:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd5);

			}

			cprintf("PROJECT Automatic testing is ENDED\n") ;
f0100e17:	83 ec 0c             	sub    $0xc,%esp
f0100e1a:	68 48 be 11 f0       	push   $0xf011be48
f0100e1f:	e8 38 0d 00 00       	call   f0101b5c <cprintf>
f0100e24:	83 c4 10             	add    $0x10,%esp
			__autograde__ = 0;
f0100e27:	c7 05 20 f0 17 f0 00 	movl   $0x0,0xf017f020
f0100e2e:	00 00 00 
		}
		get_into_prompt();
f0100e31:	e8 ac 0e 00 00       	call   f0101ce2 <get_into_prompt>

f0100e36 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f0100e36:	55                   	push   %ebp
f0100e37:	89 e5                	mov    %esp,%ebp
f0100e39:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f0100e3c:	83 ec 0c             	sub    $0xc,%esp
f0100e3f:	68 6c aa 12 f0       	push   $0xf012aa6c
f0100e44:	e8 13 0d 00 00       	call   f0101b5c <cprintf>
f0100e49:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100e4c:	83 ec 0c             	sub    $0xc,%esp
f0100e4f:	68 70 aa 12 f0       	push   $0xf012aa70
f0100e54:	e8 03 0d 00 00       	call   f0101b5c <cprintf>
f0100e59:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100e5c:	83 ec 0c             	sub    $0xc,%esp
f0100e5f:	68 b8 aa 12 f0       	push   $0xf012aab8
f0100e64:	e8 f3 0c 00 00       	call   f0101b5c <cprintf>
f0100e69:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f0100e6c:	83 ec 0c             	sub    $0xc,%esp
f0100e6f:	68 00 ab 12 f0       	push   $0xf012ab00
f0100e74:	e8 e3 0c 00 00       	call   f0101b5c <cprintf>
f0100e79:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100e7c:	83 ec 0c             	sub    $0xc,%esp
f0100e7f:	68 b8 aa 12 f0       	push   $0xf012aab8
f0100e84:	e8 d3 0c 00 00       	call   f0101b5c <cprintf>
f0100e89:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100e8c:	83 ec 0c             	sub    $0xc,%esp
f0100e8f:	68 70 aa 12 f0       	push   $0xf012aa70
f0100e94:	e8 c3 0c 00 00       	call   f0101b5c <cprintf>
f0100e99:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100e9c:	83 ec 0c             	sub    $0xc,%esp
f0100e9f:	68 45 ab 12 f0       	push   $0xf012ab45
f0100ea4:	e8 b3 0c 00 00       	call   f0101b5c <cprintf>
f0100ea9:	83 c4 10             	add    $0x10,%esp
}
f0100eac:	90                   	nop
f0100ead:	c9                   	leave  
f0100eae:	c3                   	ret    

f0100eaf <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100eaf:	55                   	push   %ebp
f0100eb0:	89 e5                	mov    %esp,%ebp
f0100eb2:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0100eb5:	e8 61 ab 00 00       	call   f010ba1b <get_cpu_proc>
f0100eba:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100ebd:	8b 45 10             	mov    0x10(%ebp),%eax
f0100ec0:	a3 a0 4f 81 f0       	mov    %eax,0xf0814fa0

	va_start(ap, fmt);
f0100ec5:	8d 45 10             	lea    0x10(%ebp),%eax
f0100ec8:	83 c0 04             	add    $0x4,%eax
f0100ecb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf_colored(TEXT_PANIC_CLR, "\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100ece:	ff 75 0c             	pushl  0xc(%ebp)
f0100ed1:	ff 75 08             	pushl  0x8(%ebp)
f0100ed4:	68 4c ab 12 f0       	push   $0xf012ab4c
f0100ed9:	6a 74                	push   $0x74
f0100edb:	e8 ac 0c 00 00       	call   f0101b8c <cprintf_colored>
f0100ee0:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100ee3:	8b 45 10             	mov    0x10(%ebp),%eax
f0100ee6:	83 ec 08             	sub    $0x8,%esp
f0100ee9:	ff 75 f0             	pushl  -0x10(%ebp)
f0100eec:	50                   	push   %eax
f0100eed:	e8 41 0c 00 00       	call   f0101b33 <vcprintf>
f0100ef2:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100ef5:	83 ec 0c             	sub    $0xc,%esp
f0100ef8:	68 71 ab 12 f0       	push   $0xf012ab71
f0100efd:	e8 5a 0c 00 00       	call   f0101b5c <cprintf>
f0100f02:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100f05:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f09:	74 10                	je     f0100f1b <_panic+0x6c>
f0100f0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f0e:	8b 40 18             	mov    0x18(%eax),%eax
f0100f11:	83 f8 02             	cmp    $0x2,%eax
f0100f14:	75 05                	jne    f0100f1b <_panic+0x6c>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f0100f16:	e8 be aa 00 00       	call   f010b9d9 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100f1b:	89 e0                	mov    %esp,%eax
f0100f1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f0100f20:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f0100f23:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f0100f26:	83 ec 08             	sub    $0x8,%esp
f0100f29:	ff 75 ec             	pushl  -0x14(%ebp)
f0100f2c:	68 73 ab 12 f0       	push   $0xf012ab73
f0100f31:	e8 26 0c 00 00       	call   f0101b5c <cprintf>
f0100f36:	83 c4 10             	add    $0x10,%esp
		//			//2024: make sure that the SP points to the kernel stack (either the one above KERN_BASE or below it)
		//			assert((esp < ptr_stack_top && esp >= ptr_stack_bottom) ||
		//					(esp < (char*)SCHD_KERN_STACK_TOP && esp >= (char*)SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE)) ;

		get_into_prompt();
f0100f39:	e8 a4 0d 00 00       	call   f0101ce2 <get_into_prompt>

f0100f3e <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 28             	sub    $0x28,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100f44:	8b 45 10             	mov    0x10(%ebp),%eax
f0100f47:	a3 a0 4f 81 f0       	mov    %eax,0xf0814fa0

	va_start(ap, fmt);
f0100f4c:	8d 45 10             	lea    0x10(%ebp),%eax
f0100f4f:	83 c0 04             	add    $0x4,%eax
f0100f52:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf_colored(TEXT_PANIC_CLR, "\nkernel panic at %s:%d: ", file, line);
f0100f55:	ff 75 0c             	pushl  0xc(%ebp)
f0100f58:	ff 75 08             	pushl  0x8(%ebp)
f0100f5b:	68 7d ab 12 f0       	push   $0xf012ab7d
f0100f60:	6a 74                	push   $0x74
f0100f62:	e8 25 0c 00 00       	call   f0101b8c <cprintf_colored>
f0100f67:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100f6a:	8b 45 10             	mov    0x10(%ebp),%eax
f0100f6d:	83 ec 08             	sub    $0x8,%esp
f0100f70:	ff 75 f4             	pushl  -0xc(%ebp)
f0100f73:	50                   	push   %eax
f0100f74:	e8 ba 0b 00 00       	call   f0101b33 <vcprintf>
f0100f79:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100f7c:	83 ec 0c             	sub    $0xc,%esp
f0100f7f:	68 71 ab 12 f0       	push   $0xf012ab71
f0100f84:	e8 d3 0b 00 00       	call   f0101b5c <cprintf>
f0100f89:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100f8c:	e8 a2 70 00 00       	call   f0108033 <pushcli>
	struct cpu *c = mycpu();
f0100f91:	e8 da 6f 00 00       	call   f0107f70 <mycpu>
f0100f96:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100f99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100f9c:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0100fa2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100fa5:	e8 db 70 00 00       	call   f0108085 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100faa:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f0100fae:	74 23                	je     f0100fd3 <_panic_all+0x95>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f0100fb0:	e8 a1 64 00 00       	call   f0107456 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100fb5:	e8 61 aa 00 00       	call   f010ba1b <get_cpu_proc>
f0100fba:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100fbd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0100fc1:	74 10                	je     f0100fd3 <_panic_all+0x95>
f0100fc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100fc6:	8b 40 18             	mov    0x18(%eax),%eax
f0100fc9:	83 f8 02             	cmp    $0x2,%eax
f0100fcc:	75 05                	jne    f0100fd3 <_panic_all+0x95>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f0100fce:	e8 06 aa 00 00       	call   f010b9d9 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100fd3:	89 e0                	mov    %esp,%eax
f0100fd5:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f0100fd8:	8b 45 e0             	mov    -0x20(%ebp),%eax
		//		fos_scheduler();
	}
	//else //2024: panic from Kernel and no current running env
	{
		//2024: make sure that the SP points to the kernel stack (either the one above KERN_BASE or below it)
		char* esp = (char*)read_esp();
f0100fdb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//		assert((esp < ptr_stack_top && esp >= ptr_stack_bottom) ||
		//				(esp < (char*)SCHD_KERN_STACK_TOP && esp >= (char*)SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE)) ;

		get_into_prompt();
f0100fde:	e8 ff 0c 00 00       	call   f0101ce2 <get_into_prompt>

f0100fe3 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100fe3:	55                   	push   %ebp
f0100fe4:	89 e5                	mov    %esp,%ebp
f0100fe6:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100fe9:	8b 45 10             	mov    0x10(%ebp),%eax
f0100fec:	a3 a0 4f 81 f0       	mov    %eax,0xf0814fa0

	va_start(ap, fmt);
f0100ff1:	8d 45 10             	lea    0x10(%ebp),%eax
f0100ff4:	83 c0 04             	add    $0x4,%eax
f0100ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf_colored(TEXT_PANIC_CLR,"\nkernel panic at %s:%d: ", file, line);
f0100ffa:	ff 75 0c             	pushl  0xc(%ebp)
f0100ffd:	ff 75 08             	pushl  0x8(%ebp)
f0101000:	68 7d ab 12 f0       	push   $0xf012ab7d
f0101005:	6a 74                	push   $0x74
f0101007:	e8 80 0b 00 00       	call   f0101b8c <cprintf_colored>
f010100c:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010100f:	8b 45 10             	mov    0x10(%ebp),%eax
f0101012:	83 ec 08             	sub    $0x8,%esp
f0101015:	ff 75 f4             	pushl  -0xc(%ebp)
f0101018:	50                   	push   %eax
f0101019:	e8 15 0b 00 00       	call   f0101b33 <vcprintf>
f010101e:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0101021:	83 ec 0c             	sub    $0xc,%esp
f0101024:	68 71 ab 12 f0       	push   $0xf012ab71
f0101029:	e8 2e 0b 00 00       	call   f0101b5c <cprintf>
f010102e:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f0101031:	e8 e5 a9 00 00       	call   f010ba1b <get_cpu_proc>
f0101036:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0101039:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010103d:	74 10                	je     f010104f <_panic_into_prompt+0x6c>
f010103f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101042:	8b 40 18             	mov    0x18(%eax),%eax
f0101045:	83 f8 02             	cmp    $0x2,%eax
f0101048:	75 05                	jne    f010104f <_panic_into_prompt+0x6c>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010104a:	e8 8a a9 00 00       	call   f010b9d9 <env_exit>
	}

	get_into_prompt();
f010104f:	e8 8e 0c 00 00       	call   f0101ce2 <get_into_prompt>

f0101054 <_warn>:

}

/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f0101054:	55                   	push   %ebp
f0101055:	89 e5                	mov    %esp,%ebp
f0101057:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f010105a:	8d 45 10             	lea    0x10(%ebp),%eax
f010105d:	83 c0 04             	add    $0x4,%eax
f0101060:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf_colored(TEXT_WARN_CLR, "\nkernel warning at %s:%d: ", file, line);
f0101063:	ff 75 0c             	pushl  0xc(%ebp)
f0101066:	ff 75 08             	pushl  0x8(%ebp)
f0101069:	68 96 ab 12 f0       	push   $0xf012ab96
f010106e:	6a 7e                	push   $0x7e
f0101070:	e8 17 0b 00 00       	call   f0101b8c <cprintf_colored>
f0101075:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0101078:	8b 45 10             	mov    0x10(%ebp),%eax
f010107b:	83 ec 08             	sub    $0x8,%esp
f010107e:	ff 75 f4             	pushl  -0xc(%ebp)
f0101081:	50                   	push   %eax
f0101082:	e8 ac 0a 00 00       	call   f0101b33 <vcprintf>
f0101087:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010108a:	83 ec 0c             	sub    $0xc,%esp
f010108d:	68 71 ab 12 f0       	push   $0xf012ab71
f0101092:	e8 c5 0a 00 00       	call   f0101b5c <cprintf>
f0101097:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010109a:	90                   	nop
f010109b:	c9                   	leave  
f010109c:	c3                   	ret    

f010109d <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f010109d:	55                   	push   %ebp
f010109e:	89 e5                	mov    %esp,%ebp
f01010a0:	83 ec 10             	sub    $0x10,%esp
f01010a3:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01010aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01010ad:	89 c2                	mov    %eax,%edx
f01010af:	ec                   	in     (%dx),%al
f01010b0:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f01010b3:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f01010b6:	0f b6 c0             	movzbl %al,%eax
f01010b9:	83 e0 01             	and    $0x1,%eax
f01010bc:	85 c0                	test   %eax,%eax
f01010be:	75 07                	jne    f01010c7 <serial_proc_data+0x2a>
		return -1;
f01010c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01010c5:	eb 16                	jmp    f01010dd <serial_proc_data+0x40>
f01010c7:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01010ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01010d1:	89 c2                	mov    %eax,%edx
f01010d3:	ec                   	in     (%dx),%al
f01010d4:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f01010d7:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f01010da:	0f b6 c0             	movzbl %al,%eax
}
f01010dd:	c9                   	leave  
f01010de:	c3                   	ret    

f01010df <serial_intr>:

void
serial_intr(void)
{
f01010df:	55                   	push   %ebp
f01010e0:	89 e5                	mov    %esp,%ebp
f01010e2:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f01010e5:	a1 c4 4f 81 f0       	mov    0xf0814fc4,%eax
f01010ea:	85 c0                	test   %eax,%eax
f01010ec:	74 10                	je     f01010fe <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f01010ee:	83 ec 0c             	sub    $0xc,%esp
f01010f1:	68 9d 10 10 f0       	push   $0xf010109d
f01010f6:	e8 ae 07 00 00       	call   f01018a9 <cons_intr>
f01010fb:	83 c4 10             	add    $0x10,%esp
}
f01010fe:	90                   	nop
f01010ff:	c9                   	leave  
f0101100:	c3                   	ret    

f0101101 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0101101:	55                   	push   %ebp
f0101102:	89 e5                	mov    %esp,%ebp
f0101104:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f0101107:	83 ec 0c             	sub    $0xc,%esp
f010110a:	68 b4 ab 12 f0       	push   $0xf012abb4
f010110f:	e8 48 0a 00 00       	call   f0101b5c <cprintf>
f0101114:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f0101117:	e8 c3 ff ff ff       	call   f01010df <serial_intr>
}
f010111c:	90                   	nop
f010111d:	c9                   	leave  
f010111e:	c3                   	ret    

f010111f <serial_init>:

void
serial_init(void)
{
f010111f:	55                   	push   %ebp
f0101120:	89 e5                	mov    %esp,%ebp
f0101122:	83 ec 48             	sub    $0x48,%esp
f0101125:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f010112c:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101130:	8a 45 c6             	mov    -0x3a(%ebp),%al
f0101133:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101136:	ee                   	out    %al,(%dx)
f0101137:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f010113e:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f0101142:	8a 45 c7             	mov    -0x39(%ebp),%al
f0101145:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101148:	ee                   	out    %al,(%dx)
f0101149:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f0101150:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f0101154:	8a 45 c8             	mov    -0x38(%ebp),%al
f0101157:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010115a:	ee                   	out    %al,(%dx)
f010115b:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f0101162:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f0101166:	8a 45 c9             	mov    -0x37(%ebp),%al
f0101169:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010116c:	ee                   	out    %al,(%dx)
f010116d:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f0101174:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f0101178:	8a 45 ca             	mov    -0x36(%ebp),%al
f010117b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010117e:	ee                   	out    %al,(%dx)
f010117f:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0101186:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010118a:	8a 45 cb             	mov    -0x35(%ebp),%al
f010118d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0101190:	ee                   	out    %al,(%dx)
f0101191:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f0101198:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010119c:	8a 45 cc             	mov    -0x34(%ebp),%al
f010119f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01011a2:	ee                   	out    %al,(%dx)
f01011a3:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01011aa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01011ad:	89 c2                	mov    %eax,%edx
f01011af:	ec                   	in     (%dx),%al
f01011b0:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f01011b3:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f01011b6:	3c ff                	cmp    $0xff,%al
f01011b8:	0f 95 c0             	setne  %al
f01011bb:	0f b6 c0             	movzbl %al,%eax
f01011be:	a3 c4 4f 81 f0       	mov    %eax,0xf0814fc4
f01011c3:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01011ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01011cd:	89 c2                	mov    %eax,%edx
f01011cf:	ec                   	in     (%dx),%al
f01011d0:	88 45 ce             	mov    %al,-0x32(%ebp)
f01011d3:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f01011da:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01011dd:	89 c2                	mov    %eax,%edx
f01011df:	ec                   	in     (%dx),%al
f01011e0:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f01011e3:	83 ec 08             	sub    $0x8,%esp
f01011e6:	68 01 11 10 f0       	push   $0xf0101101
f01011eb:	6a 04                	push   $0x4
f01011ed:	e8 d1 cf 00 00       	call   f010e1c3 <irq_install_handler>
f01011f2:	83 c4 10             	add    $0x10,%esp

}
f01011f5:	90                   	nop
f01011f6:	c9                   	leave  
f01011f7:	c3                   	ret    

f01011f8 <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f01011f8:	55                   	push   %ebp
f01011f9:	89 e5                	mov    %esp,%ebp
f01011fb:	83 ec 20             	sub    $0x20,%esp
f01011fe:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0101205:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0101208:	89 c2                	mov    %eax,%edx
f010120a:	ec                   	in     (%dx),%al
f010120b:	88 45 ec             	mov    %al,-0x14(%ebp)
f010120e:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0101215:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0101218:	89 c2                	mov    %eax,%edx
f010121a:	ec                   	in     (%dx),%al
f010121b:	88 45 ed             	mov    %al,-0x13(%ebp)
f010121e:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f0101225:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101228:	89 c2                	mov    %eax,%edx
f010122a:	ec                   	in     (%dx),%al
f010122b:	88 45 ee             	mov    %al,-0x12(%ebp)
f010122e:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f0101235:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101238:	89 c2                	mov    %eax,%edx
f010123a:	ec                   	in     (%dx),%al
f010123b:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f010123e:	90                   	nop
f010123f:	c9                   	leave  
f0101240:	c3                   	ret    

f0101241 <lpt_putc>:

static void
lpt_putc(int c)
{
f0101241:	55                   	push   %ebp
f0101242:	89 e5                	mov    %esp,%ebp
f0101244:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f0101247:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010124e:	eb 08                	jmp    f0101258 <lpt_putc+0x17>
		delay();
f0101250:	e8 a3 ff ff ff       	call   f01011f8 <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f0101255:	ff 45 fc             	incl   -0x4(%ebp)
f0101258:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f010125f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101262:	89 c2                	mov    %eax,%edx
f0101264:	ec                   	in     (%dx),%al
f0101265:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f0101268:	8a 45 eb             	mov    -0x15(%ebp),%al
f010126b:	84 c0                	test   %al,%al
f010126d:	78 09                	js     f0101278 <lpt_putc+0x37>
f010126f:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f0101276:	7e d8                	jle    f0101250 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f0101278:	8b 45 08             	mov    0x8(%ebp),%eax
f010127b:	0f b6 c0             	movzbl %al,%eax
f010127e:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0101285:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101288:	8a 45 e8             	mov    -0x18(%ebp),%al
f010128b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010128e:	ee                   	out    %al,(%dx)
f010128f:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0101296:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010129a:	8a 45 e9             	mov    -0x17(%ebp),%al
f010129d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01012a0:	ee                   	out    %al,(%dx)
f01012a1:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f01012a8:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f01012ac:	8a 45 ea             	mov    -0x16(%ebp),%al
f01012af:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01012b2:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f01012b3:	90                   	nop
f01012b4:	c9                   	leave  
f01012b5:	c3                   	ret    

f01012b6 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f01012b6:	55                   	push   %ebp
f01012b7:	89 e5                	mov    %esp,%ebp
f01012b9:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f01012bc:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f01012c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01012c6:	66 8b 00             	mov    (%eax),%ax
f01012c9:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f01012cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01012d0:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f01012d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01012d8:	66 8b 00             	mov    (%eax),%ax
f01012db:	66 3d 5a a5          	cmp    $0xa55a,%ax
f01012df:	74 13                	je     f01012f4 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f01012e1:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f01012e8:	c7 05 c8 4f 81 f0 b4 	movl   $0x3b4,0xf0814fc8
f01012ef:	03 00 00 
f01012f2:	eb 14                	jmp    f0101308 <cga_init+0x52>
	} else {
		*cp = was;
f01012f4:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01012f7:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f01012fb:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f01012fe:	c7 05 c8 4f 81 f0 d4 	movl   $0x3d4,0xf0814fc8
f0101305:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f0101308:	a1 c8 4f 81 f0       	mov    0xf0814fc8,%eax
f010130d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0101310:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0101314:	8a 45 e0             	mov    -0x20(%ebp),%al
f0101317:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010131a:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010131b:	a1 c8 4f 81 f0       	mov    0xf0814fc8,%eax
f0101320:	40                   	inc    %eax
f0101321:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101324:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101327:	89 c2                	mov    %eax,%edx
f0101329:	ec                   	in     (%dx),%al
f010132a:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f010132d:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0101330:	0f b6 c0             	movzbl %al,%eax
f0101333:	c1 e0 08             	shl    $0x8,%eax
f0101336:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f0101339:	a1 c8 4f 81 f0       	mov    0xf0814fc8,%eax
f010133e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101341:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101345:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0101348:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010134b:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f010134c:	a1 c8 4f 81 f0       	mov    0xf0814fc8,%eax
f0101351:	40                   	inc    %eax
f0101352:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101355:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101358:	89 c2                	mov    %eax,%edx
f010135a:	ec                   	in     (%dx),%al
f010135b:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f010135e:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0101361:	0f b6 c0             	movzbl %al,%eax
f0101364:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f0101367:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010136a:	a3 cc 4f 81 f0       	mov    %eax,0xf0814fcc
	crt_pos = pos;
f010136f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101372:	66 a3 d0 4f 81 f0    	mov    %ax,0xf0814fd0
}
f0101378:	90                   	nop
f0101379:	c9                   	leave  
f010137a:	c3                   	ret    

f010137b <cga_putc>:

//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.
void
cga_putc(int c)
{
f010137b:	55                   	push   %ebp
f010137c:	89 e5                	mov    %esp,%ebp
f010137e:	53                   	push   %ebx
f010137f:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use the text color
	if (!(c & ~0xFF))
f0101382:	8b 45 08             	mov    0x8(%ebp),%eax
f0101385:	b0 00                	mov    $0x0,%al
f0101387:	85 c0                	test   %eax,%eax
f0101389:	75 18                	jne    f01013a3 <cga_putc+0x28>
	{
		c |= current_text_color == 0? 0x700 : current_text_color;
f010138b:	a1 50 61 85 f0       	mov    0xf0856150,%eax
f0101390:	85 c0                	test   %eax,%eax
f0101392:	74 07                	je     f010139b <cga_putc+0x20>
f0101394:	a1 50 61 85 f0       	mov    0xf0856150,%eax
f0101399:	eb 05                	jmp    f01013a0 <cga_putc+0x25>
f010139b:	b8 00 07 00 00       	mov    $0x700,%eax
f01013a0:	09 45 08             	or     %eax,0x8(%ebp)
		//c |= 0x700; /*black and white*/
	}
	switch (c & 0xff) {
f01013a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01013a6:	0f b6 c0             	movzbl %al,%eax
f01013a9:	83 f8 0a             	cmp    $0xa,%eax
f01013ac:	74 77                	je     f0101425 <cga_putc+0xaa>
f01013ae:	83 f8 0a             	cmp    $0xa,%eax
f01013b1:	7f 13                	jg     f01013c6 <cga_putc+0x4b>
f01013b3:	83 f8 08             	cmp    $0x8,%eax
f01013b6:	74 2e                	je     f01013e6 <cga_putc+0x6b>
f01013b8:	83 f8 09             	cmp    $0x9,%eax
f01013bb:	0f 84 a8 00 00 00    	je     f0101469 <cga_putc+0xee>
f01013c1:	e9 22 01 00 00       	jmp    f01014e8 <cga_putc+0x16d>
f01013c6:	3d e4 00 00 00       	cmp    $0xe4,%eax
f01013cb:	0f 84 de 00 00 00    	je     f01014af <cga_putc+0x134>
f01013d1:	3d e5 00 00 00       	cmp    $0xe5,%eax
f01013d6:	0f 84 f1 00 00 00    	je     f01014cd <cga_putc+0x152>
f01013dc:	83 f8 0d             	cmp    $0xd,%eax
f01013df:	74 5d                	je     f010143e <cga_putc+0xc3>
f01013e1:	e9 02 01 00 00       	jmp    f01014e8 <cga_putc+0x16d>
	case '\b':
		if (crt_pos > 0) {
f01013e6:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f01013ec:	66 85 c0             	test   %ax,%ax
f01013ef:	0f 84 4f 01 00 00    	je     f0101544 <cga_putc+0x1c9>
			crt_pos--;
f01013f5:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f01013fb:	48                   	dec    %eax
f01013fc:	66 a3 d0 4f 81 f0    	mov    %ax,0xf0814fd0
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0101402:	8b 15 cc 4f 81 f0    	mov    0xf0814fcc,%edx
f0101408:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f010140e:	0f b7 c0             	movzwl %ax,%eax
f0101411:	01 c0                	add    %eax,%eax
f0101413:	01 c2                	add    %eax,%edx
f0101415:	8b 45 08             	mov    0x8(%ebp),%eax
f0101418:	b0 00                	mov    $0x0,%al
f010141a:	83 c8 20             	or     $0x20,%eax
f010141d:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0101420:	e9 1f 01 00 00       	jmp    f0101544 <cga_putc+0x1c9>
	case '\n':
		crt_pos += CRT_COLS;
f0101425:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f010142b:	83 c0 50             	add    $0x50,%eax
f010142e:	66 a3 d0 4f 81 f0    	mov    %ax,0xf0814fd0
		text_length = 0;
f0101434:	c7 05 c0 4f 81 f0 00 	movl   $0x0,0xf0814fc0
f010143b:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f010143e:	66 8b 0d d0 4f 81 f0 	mov    0xf0814fd0,%cx
f0101445:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f010144b:	bb 50 00 00 00       	mov    $0x50,%ebx
f0101450:	ba 00 00 00 00       	mov    $0x0,%edx
f0101455:	66 f7 f3             	div    %bx
f0101458:	89 d0                	mov    %edx,%eax
f010145a:	29 c1                	sub    %eax,%ecx
f010145c:	89 c8                	mov    %ecx,%eax
f010145e:	66 a3 d0 4f 81 f0    	mov    %ax,0xf0814fd0
		break;
f0101464:	e9 e5 00 00 00       	jmp    f010154e <cga_putc+0x1d3>
	case '\t':
		cons_putc(' ');
f0101469:	83 ec 0c             	sub    $0xc,%esp
f010146c:	6a 20                	push   $0x20
f010146e:	e8 30 05 00 00       	call   f01019a3 <cons_putc>
f0101473:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0101476:	83 ec 0c             	sub    $0xc,%esp
f0101479:	6a 20                	push   $0x20
f010147b:	e8 23 05 00 00       	call   f01019a3 <cons_putc>
f0101480:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0101483:	83 ec 0c             	sub    $0xc,%esp
f0101486:	6a 20                	push   $0x20
f0101488:	e8 16 05 00 00       	call   f01019a3 <cons_putc>
f010148d:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0101490:	83 ec 0c             	sub    $0xc,%esp
f0101493:	6a 20                	push   $0x20
f0101495:	e8 09 05 00 00       	call   f01019a3 <cons_putc>
f010149a:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010149d:	83 ec 0c             	sub    $0xc,%esp
f01014a0:	6a 20                	push   $0x20
f01014a2:	e8 fc 04 00 00       	call   f01019a3 <cons_putc>
f01014a7:	83 c4 10             	add    $0x10,%esp
		break;
f01014aa:	e9 9f 00 00 00       	jmp    f010154e <cga_putc+0x1d3>
	case KEY_LF:
		if(crt_pos>0)
f01014af:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f01014b5:	66 85 c0             	test   %ax,%ax
f01014b8:	0f 84 89 00 00 00    	je     f0101547 <cga_putc+0x1cc>
			crt_pos--;
f01014be:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f01014c4:	48                   	dec    %eax
f01014c5:	66 a3 d0 4f 81 f0    	mov    %ax,0xf0814fd0
		break;
f01014cb:	eb 7a                	jmp    f0101547 <cga_putc+0x1cc>
	case KEY_RT:
		if (crt_pos < CRT_SIZE)
f01014cd:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f01014d3:	66 3d cf 07          	cmp    $0x7cf,%ax
f01014d7:	77 71                	ja     f010154a <cga_putc+0x1cf>
			crt_pos++;
f01014d9:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f01014df:	40                   	inc    %eax
f01014e0:	66 a3 d0 4f 81 f0    	mov    %ax,0xf0814fd0
		break;
f01014e6:	eb 62                	jmp    f010154a <cga_putc+0x1cf>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f01014e8:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f01014ef:	74 5c                	je     f010154d <cga_putc+0x1d2>
f01014f1:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f01014f8:	74 53                	je     f010154d <cga_putc+0x1d2>
			crt_buf[crt_pos++] = c;		/* write the character */
f01014fa:	8b 0d cc 4f 81 f0    	mov    0xf0814fcc,%ecx
f0101500:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f0101506:	8d 50 01             	lea    0x1(%eax),%edx
f0101509:	66 89 15 d0 4f 81 f0 	mov    %dx,0xf0814fd0
f0101510:	0f b7 c0             	movzwl %ax,%eax
f0101513:	01 c0                	add    %eax,%eax
f0101515:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0101518:	8b 45 08             	mov    0x8(%ebp),%eax
f010151b:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f010151e:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f0101524:	0f b7 c0             	movzwl %ax,%eax
f0101527:	8b 15 c0 4f 81 f0    	mov    0xf0814fc0,%edx
f010152d:	81 c2 80 07 00 00    	add    $0x780,%edx
f0101533:	39 d0                	cmp    %edx,%eax
f0101535:	7e 16                	jle    f010154d <cga_putc+0x1d2>
				text_length++;
f0101537:	a1 c0 4f 81 f0       	mov    0xf0814fc0,%eax
f010153c:	40                   	inc    %eax
f010153d:	a3 c0 4f 81 f0       	mov    %eax,0xf0814fc0
		}
		break;
f0101542:	eb 09                	jmp    f010154d <cga_putc+0x1d2>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f0101544:	90                   	nop
f0101545:	eb 07                	jmp    f010154e <cga_putc+0x1d3>
		cons_putc(' ');
		break;
	case KEY_LF:
		if(crt_pos>0)
			crt_pos--;
		break;
f0101547:	90                   	nop
f0101548:	eb 04                	jmp    f010154e <cga_putc+0x1d3>
	case KEY_RT:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f010154a:	90                   	nop
f010154b:	eb 01                	jmp    f010154e <cga_putc+0x1d3>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f010154d:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f010154e:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f0101554:	66 3d cf 07          	cmp    $0x7cf,%ax
f0101558:	76 58                	jbe    f01015b2 <cga_putc+0x237>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f010155a:	a1 cc 4f 81 f0       	mov    0xf0814fcc,%eax
f010155f:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f0101565:	a1 cc 4f 81 f0       	mov    0xf0814fcc,%eax
f010156a:	83 ec 04             	sub    $0x4,%esp
f010156d:	68 00 0f 00 00       	push   $0xf00
f0101572:	52                   	push   %edx
f0101573:	50                   	push   %eax
f0101574:	e8 95 97 01 00       	call   f011ad0e <memcpy>
f0101579:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f010157c:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f0101583:	eb 15                	jmp    f010159a <cga_putc+0x21f>
			crt_buf[i] = 0x0700 | ' ';
f0101585:	8b 15 cc 4f 81 f0    	mov    0xf0814fcc,%edx
f010158b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010158e:	01 c0                	add    %eax,%eax
f0101590:	01 d0                	add    %edx,%eax
f0101592:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0101597:	ff 45 f4             	incl   -0xc(%ebp)
f010159a:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f01015a1:	7e e2                	jle    f0101585 <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f01015a3:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f01015a9:	83 e8 50             	sub    $0x50,%eax
f01015ac:	66 a3 d0 4f 81 f0    	mov    %ax,0xf0814fd0
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f01015b2:	a1 c8 4f 81 f0       	mov    0xf0814fc8,%eax
f01015b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01015ba:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01015be:	8a 45 e0             	mov    -0x20(%ebp),%al
f01015c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01015c4:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f01015c5:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f01015cb:	66 c1 e8 08          	shr    $0x8,%ax
f01015cf:	0f b6 c0             	movzbl %al,%eax
f01015d2:	8b 15 c8 4f 81 f0    	mov    0xf0814fc8,%edx
f01015d8:	42                   	inc    %edx
f01015d9:	89 55 ec             	mov    %edx,-0x14(%ebp)
f01015dc:	88 45 e1             	mov    %al,-0x1f(%ebp)
f01015df:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01015e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01015e5:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f01015e6:	a1 c8 4f 81 f0       	mov    0xf0814fc8,%eax
f01015eb:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01015ee:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f01015f2:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01015f5:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01015f8:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f01015f9:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f01015ff:	0f b6 c0             	movzbl %al,%eax
f0101602:	8b 15 c8 4f 81 f0    	mov    0xf0814fc8,%edx
f0101608:	42                   	inc    %edx
f0101609:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010160c:	88 45 e3             	mov    %al,-0x1d(%ebp)
f010160f:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0101612:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0101615:	ee                   	out    %al,(%dx)
}
f0101616:	90                   	nop
f0101617:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010161a:	c9                   	leave  
f010161b:	c3                   	ret    

f010161c <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f010161c:	55                   	push   %ebp
f010161d:	89 e5                	mov    %esp,%ebp
f010161f:	83 ec 28             	sub    $0x28,%esp
f0101622:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101629:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010162c:	89 c2                	mov    %eax,%edx
f010162e:	ec                   	in     (%dx),%al
f010162f:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0101632:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0101635:	0f b6 c0             	movzbl %al,%eax
f0101638:	83 e0 01             	and    $0x1,%eax
f010163b:	85 c0                	test   %eax,%eax
f010163d:	75 0a                	jne    f0101649 <kbd_proc_data+0x2d>
		return -1;
f010163f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0101644:	e9 2a 02 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
f0101649:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101650:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101653:	89 c2                	mov    %eax,%edx
f0101655:	ec                   	in     (%dx),%al
f0101656:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0101659:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f010165c:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f010165f:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0101663:	75 17                	jne    f010167c <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0101665:	a1 e8 51 81 f0       	mov    0xf08151e8,%eax
f010166a:	83 c8 40             	or     $0x40,%eax
f010166d:	a3 e8 51 81 f0       	mov    %eax,0xf08151e8
		return 0;
f0101672:	b8 00 00 00 00       	mov    $0x0,%eax
f0101677:	e9 f7 01 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f010167c:	8a 45 f3             	mov    -0xd(%ebp),%al
f010167f:	84 c0                	test   %al,%al
f0101681:	79 44                	jns    f01016c7 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0101683:	a1 e8 51 81 f0       	mov    0xf08151e8,%eax
f0101688:	83 e0 40             	and    $0x40,%eax
f010168b:	85 c0                	test   %eax,%eax
f010168d:	75 08                	jne    f0101697 <kbd_proc_data+0x7b>
f010168f:	8a 45 f3             	mov    -0xd(%ebp),%al
f0101692:	83 e0 7f             	and    $0x7f,%eax
f0101695:	eb 03                	jmp    f010169a <kbd_proc_data+0x7e>
f0101697:	8a 45 f3             	mov    -0xd(%ebp),%al
f010169a:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f010169d:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f01016a1:	8a 80 40 f0 17 f0    	mov    -0xfe80fc0(%eax),%al
f01016a7:	83 c8 40             	or     $0x40,%eax
f01016aa:	0f b6 c0             	movzbl %al,%eax
f01016ad:	f7 d0                	not    %eax
f01016af:	89 c2                	mov    %eax,%edx
f01016b1:	a1 e8 51 81 f0       	mov    0xf08151e8,%eax
f01016b6:	21 d0                	and    %edx,%eax
f01016b8:	a3 e8 51 81 f0       	mov    %eax,0xf08151e8
		return 0;
f01016bd:	b8 00 00 00 00       	mov    $0x0,%eax
f01016c2:	e9 ac 01 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f01016c7:	a1 e8 51 81 f0       	mov    0xf08151e8,%eax
f01016cc:	83 e0 40             	and    $0x40,%eax
f01016cf:	85 c0                	test   %eax,%eax
f01016d1:	74 11                	je     f01016e4 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f01016d3:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f01016d7:	a1 e8 51 81 f0       	mov    0xf08151e8,%eax
f01016dc:	83 e0 bf             	and    $0xffffffbf,%eax
f01016df:	a3 e8 51 81 f0       	mov    %eax,0xf08151e8
	}

	shift |= shiftcode[data];
f01016e4:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f01016e8:	8a 80 40 f0 17 f0    	mov    -0xfe80fc0(%eax),%al
f01016ee:	0f b6 d0             	movzbl %al,%edx
f01016f1:	a1 e8 51 81 f0       	mov    0xf08151e8,%eax
f01016f6:	09 d0                	or     %edx,%eax
f01016f8:	a3 e8 51 81 f0       	mov    %eax,0xf08151e8
	shift ^= togglecode[data];
f01016fd:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0101701:	8a 80 40 f1 17 f0    	mov    -0xfe80ec0(%eax),%al
f0101707:	0f b6 d0             	movzbl %al,%edx
f010170a:	a1 e8 51 81 f0       	mov    0xf08151e8,%eax
f010170f:	31 d0                	xor    %edx,%eax
f0101711:	a3 e8 51 81 f0       	mov    %eax,0xf08151e8

	c = charcode[shift & (CTL | SHIFT)][data];
f0101716:	a1 e8 51 81 f0       	mov    0xf08151e8,%eax
f010171b:	83 e0 03             	and    $0x3,%eax
f010171e:	8b 14 85 40 f5 17 f0 	mov    -0xfe80ac0(,%eax,4),%edx
f0101725:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0101729:	01 d0                	add    %edx,%eax
f010172b:	8a 00                	mov    (%eax),%al
f010172d:	0f b6 c0             	movzbl %al,%eax
f0101730:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0101733:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f010173a:	0f 85 9c 00 00 00    	jne    f01017dc <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0101740:	a1 c0 4f 81 f0       	mov    0xf0814fc0,%eax
f0101745:	85 c0                	test   %eax,%eax
f0101747:	0f 8e 85 00 00 00    	jle    f01017d2 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f010174d:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f0101753:	0f b7 c0             	movzwl %ax,%eax
f0101756:	8b 15 c0 4f 81 f0    	mov    0xf0814fc0,%edx
f010175c:	81 c2 80 07 00 00    	add    $0x780,%edx
f0101762:	39 d0                	cmp    %edx,%eax
f0101764:	75 0a                	jne    f0101770 <kbd_proc_data+0x154>
				return 0;
f0101766:	b8 00 00 00 00       	mov    $0x0,%eax
f010176b:	e9 03 01 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
			else {
				text_length--;
f0101770:	a1 c0 4f 81 f0       	mov    0xf0814fc0,%eax
f0101775:	48                   	dec    %eax
f0101776:	a3 c0 4f 81 f0       	mov    %eax,0xf0814fc0
				int crt_pos_Length = crt_pos - 1925;
f010177b:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f0101781:	0f b7 c0             	movzwl %ax,%eax
f0101784:	2d 85 07 00 00       	sub    $0x785,%eax
f0101789:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f010178c:	66 a1 d0 4f 81 f0    	mov    0xf0814fd0,%ax
f0101792:	0f b7 c0             	movzwl %ax,%eax
f0101795:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101798:	eb 26                	jmp    f01017c0 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f010179a:	8b 15 cc 4f 81 f0    	mov    0xf0814fcc,%edx
f01017a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01017a3:	01 c0                	add    %eax,%eax
f01017a5:	01 c2                	add    %eax,%edx
f01017a7:	a1 cc 4f 81 f0       	mov    0xf0814fcc,%eax
f01017ac:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f01017af:	41                   	inc    %ecx
f01017b0:	01 c9                	add    %ecx,%ecx
f01017b2:	01 c8                	add    %ecx,%eax
f01017b4:	66 8b 00             	mov    (%eax),%ax
f01017b7:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f01017ba:	ff 45 e8             	incl   -0x18(%ebp)
f01017bd:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f01017c0:	a1 c0 4f 81 f0       	mov    0xf0814fc0,%eax
f01017c5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01017c8:	7e d0                	jle    f010179a <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f01017ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01017cd:	e9 a1 00 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
			}
		}
		return 0;
f01017d2:	b8 00 00 00 00       	mov    $0x0,%eax
f01017d7:	e9 97 00 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f01017dc:	a1 e8 51 81 f0       	mov    0xf08151e8,%eax
f01017e1:	83 e0 08             	and    $0x8,%eax
f01017e4:	85 c0                	test   %eax,%eax
f01017e6:	74 22                	je     f010180a <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f01017e8:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f01017ec:	7e 0c                	jle    f01017fa <kbd_proc_data+0x1de>
f01017ee:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f01017f2:	7f 06                	jg     f01017fa <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f01017f4:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f01017f8:	eb 10                	jmp    f010180a <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f01017fa:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f01017fe:	7e 0a                	jle    f010180a <kbd_proc_data+0x1ee>
f0101800:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0101804:	7f 04                	jg     f010180a <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0101806:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f010180a:	a1 e8 51 81 f0       	mov    0xf08151e8,%eax
f010180f:	83 f8 10             	cmp    $0x10,%eax
f0101812:	75 13                	jne    f0101827 <kbd_proc_data+0x20b>
f0101814:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0101818:	7e 0d                	jle    f0101827 <kbd_proc_data+0x20b>
f010181a:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f010181e:	7f 07                	jg     f0101827 <kbd_proc_data+0x20b>
		return 0;
f0101820:	b8 00 00 00 00       	mov    $0x0,%eax
f0101825:	eb 4c                	jmp    f0101873 <kbd_proc_data+0x257>
	if (c == 255)
f0101827:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f010182e:	75 07                	jne    f0101837 <kbd_proc_data+0x21b>
		return 0;
f0101830:	b8 00 00 00 00       	mov    $0x0,%eax
f0101835:	eb 3c                	jmp    f0101873 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0101837:	a1 e8 51 81 f0       	mov    0xf08151e8,%eax
f010183c:	f7 d0                	not    %eax
f010183e:	83 e0 06             	and    $0x6,%eax
f0101841:	85 c0                	test   %eax,%eax
f0101843:	75 2b                	jne    f0101870 <kbd_proc_data+0x254>
f0101845:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f010184c:	75 22                	jne    f0101870 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f010184e:	83 ec 0c             	sub    $0xc,%esp
f0101851:	68 c7 ab 12 f0       	push   $0xf012abc7
f0101856:	e8 01 03 00 00       	call   f0101b5c <cprintf>
f010185b:	83 c4 10             	add    $0x10,%esp
f010185e:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0101865:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101869:	8a 45 d9             	mov    -0x27(%ebp),%al
f010186c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010186f:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0101870:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0101873:	c9                   	leave  
f0101874:	c3                   	ret    

f0101875 <kbd_intr>:

void
kbd_intr(void)
{
f0101875:	55                   	push   %ebp
f0101876:	89 e5                	mov    %esp,%ebp
f0101878:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f010187b:	83 ec 0c             	sub    $0xc,%esp
f010187e:	68 1c 16 10 f0       	push   $0xf010161c
f0101883:	e8 21 00 00 00       	call   f01018a9 <cons_intr>
f0101888:	83 c4 10             	add    $0x10,%esp
}
f010188b:	90                   	nop
f010188c:	c9                   	leave  
f010188d:	c3                   	ret    

f010188e <kbd_init>:

void
kbd_init(void)
{
f010188e:	55                   	push   %ebp
f010188f:	89 e5                	mov    %esp,%ebp
f0101891:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0101894:	83 ec 08             	sub    $0x8,%esp
f0101897:	68 73 1a 10 f0       	push   $0xf0101a73
f010189c:	6a 01                	push   $0x1
f010189e:	e8 20 c9 00 00       	call   f010e1c3 <irq_install_handler>
f01018a3:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f01018a6:	90                   	nop
f01018a7:	c9                   	leave  
f01018a8:	c3                   	ret    

f01018a9 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f01018a9:	55                   	push   %ebp
f01018aa:	89 e5                	mov    %esp,%ebp
f01018ac:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f01018af:	eb 35                	jmp    f01018e6 <cons_intr+0x3d>
		if (c == 0)
f01018b1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01018b5:	75 02                	jne    f01018b9 <cons_intr+0x10>
			continue;
f01018b7:	eb 2d                	jmp    f01018e6 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f01018b9:	a1 e4 51 81 f0       	mov    0xf08151e4,%eax
f01018be:	8d 50 01             	lea    0x1(%eax),%edx
f01018c1:	89 15 e4 51 81 f0    	mov    %edx,0xf08151e4
f01018c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01018ca:	88 90 e0 4f 81 f0    	mov    %dl,-0xf7eb020(%eax)
		if (cons.wpos == CONSBUFSIZE)
f01018d0:	a1 e4 51 81 f0       	mov    0xf08151e4,%eax
f01018d5:	3d 00 02 00 00       	cmp    $0x200,%eax
f01018da:	75 0a                	jne    f01018e6 <cons_intr+0x3d>
			cons.wpos = 0;
f01018dc:	c7 05 e4 51 81 f0 00 	movl   $0x0,0xf08151e4
f01018e3:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f01018e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01018e9:	ff d0                	call   *%eax
f01018eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01018ee:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f01018f2:	75 bd                	jne    f01018b1 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f01018f4:	90                   	nop
f01018f5:	c9                   	leave  
f01018f6:	c3                   	ret    

f01018f7 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f01018f7:	55                   	push   %ebp
f01018f8:	89 e5                	mov    %esp,%ebp
f01018fa:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f01018fd:	e8 dd f7 ff ff       	call   f01010df <serial_intr>
	kbd_intr();
f0101902:	e8 6e ff ff ff       	call   f0101875 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0101907:	8b 15 e0 51 81 f0    	mov    0xf08151e0,%edx
f010190d:	a1 e4 51 81 f0       	mov    0xf08151e4,%eax
f0101912:	39 c2                	cmp    %eax,%edx
f0101914:	74 35                	je     f010194b <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0101916:	a1 e0 51 81 f0       	mov    0xf08151e0,%eax
f010191b:	8d 50 01             	lea    0x1(%eax),%edx
f010191e:	89 15 e0 51 81 f0    	mov    %edx,0xf08151e0
f0101924:	8a 80 e0 4f 81 f0    	mov    -0xf7eb020(%eax),%al
f010192a:	0f b6 c0             	movzbl %al,%eax
f010192d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0101930:	a1 e0 51 81 f0       	mov    0xf08151e0,%eax
f0101935:	3d 00 02 00 00       	cmp    $0x200,%eax
f010193a:	75 0a                	jne    f0101946 <cons_getc+0x4f>
			cons.rpos = 0;
f010193c:	c7 05 e0 51 81 f0 00 	movl   $0x0,0xf08151e0
f0101943:	00 00 00 
		return c;
f0101946:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101949:	eb 05                	jmp    f0101950 <cons_getc+0x59>
	}
	return 0;
f010194b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101950:	c9                   	leave  
f0101951:	c3                   	ret    

f0101952 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0101952:	55                   	push   %ebp
f0101953:	89 e5                	mov    %esp,%ebp
f0101955:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0101958:	8b 15 e0 51 81 f0    	mov    0xf08151e0,%edx
f010195e:	a1 e4 51 81 f0       	mov    0xf08151e4,%eax
f0101963:	39 c2                	cmp    %eax,%edx
f0101965:	74 35                	je     f010199c <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0101967:	a1 e0 51 81 f0       	mov    0xf08151e0,%eax
f010196c:	8d 50 01             	lea    0x1(%eax),%edx
f010196f:	89 15 e0 51 81 f0    	mov    %edx,0xf08151e0
f0101975:	8a 80 e0 4f 81 f0    	mov    -0xf7eb020(%eax),%al
f010197b:	0f b6 c0             	movzbl %al,%eax
f010197e:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0101981:	a1 e0 51 81 f0       	mov    0xf08151e0,%eax
f0101986:	3d 00 02 00 00       	cmp    $0x200,%eax
f010198b:	75 0a                	jne    f0101997 <cons_getc2+0x45>
			cons.rpos = 0;
f010198d:	c7 05 e0 51 81 f0 00 	movl   $0x0,0xf08151e0
f0101994:	00 00 00 
		return c;
f0101997:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010199a:	eb 05                	jmp    f01019a1 <cons_getc2+0x4f>
	}
	return 0;
f010199c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01019a1:	c9                   	leave  
f01019a2:	c3                   	ret    

f01019a3 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f01019a3:	55                   	push   %ebp
f01019a4:	89 e5                	mov    %esp,%ebp
f01019a6:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f01019a9:	ff 75 08             	pushl  0x8(%ebp)
f01019ac:	e8 90 f8 ff ff       	call   f0101241 <lpt_putc>
f01019b1:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f01019b4:	83 ec 0c             	sub    $0xc,%esp
f01019b7:	ff 75 08             	pushl  0x8(%ebp)
f01019ba:	e8 bc f9 ff ff       	call   f010137b <cga_putc>
f01019bf:	83 c4 10             	add    $0x10,%esp
}
f01019c2:	90                   	nop
f01019c3:	c9                   	leave  
f01019c4:	c3                   	ret    

f01019c5 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f01019c5:	55                   	push   %ebp
f01019c6:	89 e5                	mov    %esp,%ebp
f01019c8:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f01019cb:	e8 e6 f8 ff ff       	call   f01012b6 <cga_init>
	kbd_init();
f01019d0:	e8 b9 fe ff ff       	call   f010188e <kbd_init>
	serial_init();
f01019d5:	e8 45 f7 ff ff       	call   f010111f <serial_init>

	if (!serial_exists)
f01019da:	a1 c4 4f 81 f0       	mov    0xf0814fc4,%eax
f01019df:	85 c0                	test   %eax,%eax
f01019e1:	75 10                	jne    f01019f3 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f01019e3:	83 ec 0c             	sub    $0xc,%esp
f01019e6:	68 d3 ab 12 f0       	push   $0xf012abd3
f01019eb:	e8 6c 01 00 00       	call   f0101b5c <cprintf>
f01019f0:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f01019f3:	90                   	nop
f01019f4:	c9                   	leave  
f01019f5:	c3                   	ret    

f01019f6 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f01019f6:	55                   	push   %ebp
f01019f7:	89 e5                	mov    %esp,%ebp
f01019f9:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f01019fc:	83 ec 0c             	sub    $0xc,%esp
f01019ff:	ff 75 08             	pushl  0x8(%ebp)
f0101a02:	e8 9c ff ff ff       	call   f01019a3 <cons_putc>
f0101a07:	83 c4 10             	add    $0x10,%esp
}
f0101a0a:	90                   	nop
f0101a0b:	c9                   	leave  
f0101a0c:	c3                   	ret    

f0101a0d <getchar>:

int
getchar(void)
{
f0101a0d:	55                   	push   %ebp
f0101a0e:	89 e5                	mov    %esp,%ebp
f0101a10:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0101a13:	e8 df fe ff ff       	call   f01018f7 <cons_getc>
f0101a18:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0101a1b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101a1f:	74 f2                	je     f0101a13 <getchar+0x6>
		/* do nothing */;
	return c;
f0101a21:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0101a24:	c9                   	leave  
f0101a25:	c3                   	ret    

f0101a26 <iscons>:

int
iscons(int fdnum)
{
f0101a26:	55                   	push   %ebp
f0101a27:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0101a29:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0101a2e:	5d                   	pop    %ebp
f0101a2f:	c3                   	ret    

f0101a30 <clear_screen_buffer>:

// *************** This clear screen feature is implemented by *************
// ********* Abd-Alrahman Zedan From Team Frozen-Bytes - FCIS'24-25 ********
void
clear_screen_buffer(void)
{
f0101a30:	55                   	push   %ebp
f0101a31:	89 e5                	mov    %esp,%ebp
f0101a33:	83 ec 10             	sub    $0x10,%esp
	// accessing the screen buffer in the memory
	uint32 *crt_buf = (uint32*)(KERNEL_BASE + CGA_BUF);
f0101a36:	c7 45 f8 00 80 0b f0 	movl   $0xf00b8000,-0x8(%ebp)
	// setting the screen buffer content to spaces with black background
	for (int i = 0; i < CRT_SIZE; i++)
f0101a3d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0101a44:	eb 18                	jmp    f0101a5e <clear_screen_buffer+0x2e>
		crt_buf[i] = 0x0700 | ' ';
f0101a46:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0101a49:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0101a50:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0101a53:	01 d0                	add    %edx,%eax
f0101a55:	c7 00 20 07 00 00    	movl   $0x720,(%eax)
clear_screen_buffer(void)
{
	// accessing the screen buffer in the memory
	uint32 *crt_buf = (uint32*)(KERNEL_BASE + CGA_BUF);
	// setting the screen buffer content to spaces with black background
	for (int i = 0; i < CRT_SIZE; i++)
f0101a5b:	ff 45 fc             	incl   -0x4(%ebp)
f0101a5e:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
f0101a65:	7e df                	jle    f0101a46 <clear_screen_buffer+0x16>
		crt_buf[i] = 0x0700 | ' ';
	crt_pos = 0; // reset_cursor_position
f0101a67:	66 c7 05 d0 4f 81 f0 	movw   $0x0,0xf0814fd0
f0101a6e:	00 00 
}
f0101a70:	90                   	nop
f0101a71:	c9                   	leave  
f0101a72:	c3                   	ret    

f0101a73 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0101a73:	55                   	push   %ebp
f0101a74:	89 e5                	mov    %esp,%ebp
f0101a76:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0101a79:	e8 f7 fd ff ff       	call   f0101875 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0101a7e:	90                   	nop
f0101a7f:	c9                   	leave  
f0101a80:	c3                   	ret    

f0101a81 <cons_lock>:

void cons_lock(void)
{
f0101a81:	55                   	push   %ebp
f0101a82:	89 e5                	mov    %esp,%ebp
f0101a84:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0101a87:	e8 8f 41 00 00       	call   f0105c1b <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101a8c:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0101a8d:	e8 89 9f 00 00       	call   f010ba1b <get_cpu_proc>
f0101a92:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0101a95:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101a99:	75 17                	jne    f0101ab2 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0101a9b:	83 ec 04             	sub    $0x4,%esp
f0101a9e:	68 f0 ab 12 f0       	push   $0xf012abf0
f0101aa3:	68 3b 02 00 00       	push   $0x23b
f0101aa8:	68 17 ac 12 f0       	push   $0xf012ac17
f0101aad:	e8 fd f3 ff ff       	call   f0100eaf <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0101ab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101ab5:	8b 00                	mov    (%eax),%eax
f0101ab7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101aba:	8b 12                	mov    (%edx),%edx
f0101abc:	8b 52 38             	mov    0x38(%edx),%edx
f0101abf:	80 e6 fd             	and    $0xfd,%dh
f0101ac2:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0101ac5:	90                   	nop
f0101ac6:	c9                   	leave  
f0101ac7:	c3                   	ret    

f0101ac8 <cons_unlock>:

void cons_unlock(void)
{
f0101ac8:	55                   	push   %ebp
f0101ac9:	89 e5                	mov    %esp,%ebp
f0101acb:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0101ace:	e8 48 41 00 00       	call   f0105c1b <kclock_stop>
f0101ad3:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0101ad4:	e8 42 9f 00 00       	call   f010ba1b <get_cpu_proc>
f0101ad9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0101adc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101ae0:	75 17                	jne    f0101af9 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0101ae2:	83 ec 04             	sub    $0x4,%esp
f0101ae5:	68 2c ac 12 f0       	push   $0xf012ac2c
f0101aea:	68 54 02 00 00       	push   $0x254
f0101aef:	68 17 ac 12 f0       	push   $0xf012ac17
f0101af4:	e8 b6 f3 ff ff       	call   f0100eaf <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0101af9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101afc:	8b 00                	mov    (%eax),%eax
f0101afe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101b01:	8b 12                	mov    (%edx),%edx
f0101b03:	8b 52 38             	mov    0x38(%edx),%edx
f0101b06:	80 ce 02             	or     $0x2,%dh
f0101b09:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0101b0c:	90                   	nop
f0101b0d:	c9                   	leave  
f0101b0e:	c3                   	ret    

f0101b0f <putch>:
#include <kern/cons/console.h>


static void
putch(int ch, int *cnt)
{
f0101b0f:	55                   	push   %ebp
f0101b10:	89 e5                	mov    %esp,%ebp
f0101b12:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0101b15:	83 ec 0c             	sub    $0xc,%esp
f0101b18:	ff 75 08             	pushl  0x8(%ebp)
f0101b1b:	e8 d6 fe ff ff       	call   f01019f6 <cputchar>
f0101b20:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0101b23:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b26:	8b 00                	mov    (%eax),%eax
f0101b28:	8d 50 01             	lea    0x1(%eax),%edx
f0101b2b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b2e:	89 10                	mov    %edx,(%eax)
}
f0101b30:	90                   	nop
f0101b31:	c9                   	leave  
f0101b32:	c3                   	ret    

f0101b33 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0101b33:	55                   	push   %ebp
f0101b34:	89 e5                	mov    %esp,%ebp
f0101b36:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0101b39:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0101b40:	ff 75 0c             	pushl  0xc(%ebp)
f0101b43:	ff 75 08             	pushl  0x8(%ebp)
f0101b46:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0101b49:	50                   	push   %eax
f0101b4a:	68 0f 1b 10 f0       	push   $0xf0101b0f
f0101b4f:	e8 67 88 01 00       	call   f011a3bb <vprintfmt>
f0101b54:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0101b57:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0101b5a:	c9                   	leave  
f0101b5b:	c3                   	ret    

f0101b5c <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0101b5c:	55                   	push   %ebp
f0101b5d:	89 e5                	mov    %esp,%ebp
f0101b5f:	83 ec 18             	sub    $0x18,%esp
	int cnt;
	pushcli();	//disable interrupts
f0101b62:	e8 cc 64 00 00       	call   f0108033 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0101b67:	8d 45 0c             	lea    0xc(%ebp),%eax
f0101b6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0101b6d:	8b 45 08             	mov    0x8(%ebp),%eax
f0101b70:	83 ec 08             	sub    $0x8,%esp
f0101b73:	ff 75 f4             	pushl  -0xc(%ebp)
f0101b76:	50                   	push   %eax
f0101b77:	e8 b7 ff ff ff       	call   f0101b33 <vcprintf>
f0101b7c:	83 c4 10             	add    $0x10,%esp
f0101b7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0101b82:	e8 fe 64 00 00       	call   f0108085 <popcli>

	return cnt;
f0101b87:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0101b8a:	c9                   	leave  
f0101b8b:	c3                   	ret    

f0101b8c <cprintf_colored>:

// *************** This text coloring feature is implemented by *************
// ********** Abd-Alrahman Zedan From Team Frozen-Bytes - FCIS'24-25 ********
int
cprintf_colored(int textClr, const char *fmt, ...)
{
f0101b8c:	55                   	push   %ebp
f0101b8d:	89 e5                	mov    %esp,%ebp
f0101b8f:	83 ec 18             	sub    $0x18,%esp
	current_text_color = (textClr << 8) ;
f0101b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0101b95:	c1 e0 08             	shl    $0x8,%eax
f0101b98:	a3 50 61 85 f0       	mov    %eax,0xf0856150
	int cnt;
	pushcli();	//disable interrupts
f0101b9d:	e8 91 64 00 00       	call   f0108033 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0101ba2:	8d 45 0c             	lea    0xc(%ebp),%eax
f0101ba5:	83 c0 04             	add    $0x4,%eax
f0101ba8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0101bab:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bae:	83 ec 08             	sub    $0x8,%esp
f0101bb1:	ff 75 f4             	pushl  -0xc(%ebp)
f0101bb4:	50                   	push   %eax
f0101bb5:	e8 79 ff ff ff       	call   f0101b33 <vcprintf>
f0101bba:	83 c4 10             	add    $0x10,%esp
f0101bbd:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0101bc0:	e8 c0 64 00 00       	call   f0108085 <popcli>
	current_text_color = TEXT_DEFAULT_CLR; //restore default text color
f0101bc5:	c7 05 50 61 85 f0 00 	movl   $0x700,0xf0856150
f0101bcc:	07 00 00 

	return cnt;
f0101bcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0101bd2:	c9                   	leave  
f0101bd3:	c3                   	ret    

f0101bd4 <run_command_prompt>:
#include "commands.h"

extern bool __autograde__ ;
extern void command_prompt_readline(const char *prompt, char* buf);
void run_command_prompt()
{
f0101bd4:	55                   	push   %ebp
f0101bd5:	89 e5                	mov    %esp,%ebp
f0101bd7:	57                   	push   %edi
f0101bd8:	56                   	push   %esi
f0101bd9:	53                   	push   %ebx
f0101bda:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (__autograde__)
f0101be0:	a1 20 f0 17 f0       	mov    0xf017f020,%eax
f0101be5:	85 c0                	test   %eax,%eax
f0101be7:	0f 84 85 00 00 00    	je     f0101c72 <run_command_prompt+0x9e>
	{
		char cmdU1_2[BUFLEN] = "tst priorityRR 0";	//
f0101bed:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101bf3:	bb 5e ac 12 f0       	mov    $0xf012ac5e,%ebx
f0101bf8:	ba 11 00 00 00       	mov    $0x11,%edx
f0101bfd:	89 c7                	mov    %eax,%edi
f0101bff:	89 de                	mov    %ebx,%esi
f0101c01:	89 d1                	mov    %edx,%ecx
f0101c03:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101c05:	8d 95 f9 ef ff ff    	lea    -0x1007(%ebp),%edx
f0101c0b:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0101c10:	b0 00                	mov    $0x0,%al
f0101c12:	89 d7                	mov    %edx,%edi
f0101c14:	f3 aa                	rep stos %al,%es:(%edi)
		char cmdU2_2[BUFLEN] = "tst priorityRR 1";	//
f0101c16:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101c1c:	bb 5e b0 12 f0       	mov    $0xf012b05e,%ebx
f0101c21:	ba 11 00 00 00       	mov    $0x11,%edx
f0101c26:	89 c7                	mov    %eax,%edi
f0101c28:	89 de                	mov    %ebx,%esi
f0101c2a:	89 d1                	mov    %edx,%ecx
f0101c2c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101c2e:	8d 95 f9 f3 ff ff    	lea    -0xc07(%ebp),%edx
f0101c34:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0101c39:	b0 00                	mov    $0x0,%al
f0101c3b:	89 d7                	mov    %edx,%edi
f0101c3d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmdU3_2[BUFLEN] = "tst priorityRR 2";	//
f0101c3f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101c45:	bb 5e b4 12 f0       	mov    $0xf012b45e,%ebx
f0101c4a:	ba 11 00 00 00       	mov    $0x11,%edx
f0101c4f:	89 c7                	mov    %eax,%edi
f0101c51:	89 de                	mov    %ebx,%esi
f0101c53:	89 d1                	mov    %edx,%ecx
f0101c55:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101c57:	8d 95 f9 f7 ff ff    	lea    -0x807(%ebp),%edx
f0101c5d:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0101c62:	b0 00                	mov    $0x0,%al
f0101c64:	89 d7                	mov    %edx,%edi
f0101c66:	f3 aa                	rep stos %al,%es:(%edi)
//		execute_command(cmdU3_2);
		__autograde__ = 0;
f0101c68:	c7 05 20 f0 17 f0 00 	movl   $0x0,0xf017f020
f0101c6f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101c72:	c7 05 cc 63 85 f0 00 	movl   $0x0,0xf08563cc
f0101c79:	00 00 00 
f0101c7c:	c7 05 d0 63 85 f0 00 	movl   $0x0,0xf08563d0
f0101c83:	00 00 00 
f0101c86:	c7 05 d8 63 85 f0 00 	movl   $0x0,0xf08563d8
f0101c8d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101c90:	83 ec 04             	sub    $0x4,%esp
f0101c93:	68 00 04 00 00       	push   $0x400
f0101c98:	6a 00                	push   $0x0
f0101c9a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101ca0:	50                   	push   %eax
f0101ca1:	e8 c5 8f 01 00       	call   f011ac6b <memset>
f0101ca6:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101ca9:	83 ec 08             	sub    $0x8,%esp
f0101cac:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101cb2:	50                   	push   %eax
f0101cb3:	68 58 ac 12 f0       	push   $0xf012ac58
f0101cb8:	e8 42 06 00 00       	call   f01022ff <command_prompt_readline>
f0101cbd:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101cc0:	83 ec 0c             	sub    $0xc,%esp
f0101cc3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101cc9:	50                   	push   %eax
f0101cca:	e8 4c 01 00 00       	call   f0101e1b <execute_command>
f0101ccf:	83 c4 10             	add    $0x10,%esp
f0101cd2:	85 c0                	test   %eax,%eax
f0101cd4:	78 02                	js     f0101cd8 <run_command_prompt+0x104>
				break;
	}
f0101cd6:	eb b8                	jmp    f0101c90 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101cd8:	90                   	nop
	}
}
f0101cd9:	90                   	nop
f0101cda:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101cdd:	5b                   	pop    %ebx
f0101cde:	5e                   	pop    %esi
f0101cdf:	5f                   	pop    %edi
f0101ce0:	5d                   	pop    %ebp
f0101ce1:	c3                   	ret    

f0101ce2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101ce2:	55                   	push   %ebp
f0101ce3:	89 e5                	mov    %esp,%ebp
f0101ce5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101ce8:	9c                   	pushf  
f0101ce9:	58                   	pop    %eax
f0101cea:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101ced:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101cf0:	25 00 02 00 00       	and    $0x200,%eax
f0101cf5:	85 c0                	test   %eax,%eax
f0101cf7:	74 01                	je     f0101cfa <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101cf9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101cfa:	e8 a2 9f 00 00       	call   f010bca1 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101cff:	e8 6c 62 00 00       	call   f0107f70 <mycpu>
f0101d04:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101d07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d0a:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101d11:	00 00 00 
		c->intena = 0;
f0101d14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d17:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101d1e:	00 00 00 
		c->scheduler = NULL;
f0101d21:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d24:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101d2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d2e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101d35:	00 00 00 
		c->proc = NULL;
f0101d38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d3b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101d42:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101d45:	89 e0                	mov    %esp,%eax
f0101d47:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101d4a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101d4d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101d50:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d53:	8b 40 08             	mov    0x8(%eax),%eax
f0101d56:	05 00 80 00 00       	add    $0x8000,%eax
f0101d5b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101d5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d61:	8b 40 08             	mov    0x8(%eax),%eax
f0101d64:	05 00 10 00 00       	add    $0x1000,%eax
f0101d69:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101d6c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101d6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101d72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101d75:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101d77:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101d7a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101d7d:	73 44                	jae    f0101dc3 <get_into_prompt+0xe1>
f0101d7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101d82:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101d85:	72 3c                	jb     f0101dc3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101d87:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101d8a:	a3 d4 64 85 f0       	mov    %eax,0xf08564d4
			m = cpuStackTop - cur_esp;
f0101d8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101d92:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101d95:	a3 d8 64 85 f0       	mov    %eax,0xf08564d8
			while (--m >= 0)
f0101d9a:	eb 11                	jmp    f0101dad <get_into_prompt+0xcb>
				*p++ = 0;
f0101d9c:	a1 d4 64 85 f0       	mov    0xf08564d4,%eax
f0101da1:	8d 50 01             	lea    0x1(%eax),%edx
f0101da4:	89 15 d4 64 85 f0    	mov    %edx,0xf08564d4
f0101daa:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101dad:	a1 d8 64 85 f0       	mov    0xf08564d8,%eax
f0101db2:	48                   	dec    %eax
f0101db3:	a3 d8 64 85 f0       	mov    %eax,0xf08564d8
f0101db8:	a1 d8 64 85 f0       	mov    0xf08564d8,%eax
f0101dbd:	85 c0                	test   %eax,%eax
f0101dbf:	79 db                	jns    f0101d9c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101dc1:	eb 3a                	jmp    f0101dfd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101dc3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101dc6:	a3 d4 64 85 f0       	mov    %eax,0xf08564d4
			m = cpuStackTop - cpuStackBottom;
f0101dcb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101dce:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101dd1:	a3 d8 64 85 f0       	mov    %eax,0xf08564d8
			while (--m >= 0)
f0101dd6:	eb 11                	jmp    f0101de9 <get_into_prompt+0x107>
				*p++ = 0;
f0101dd8:	a1 d4 64 85 f0       	mov    0xf08564d4,%eax
f0101ddd:	8d 50 01             	lea    0x1(%eax),%edx
f0101de0:	89 15 d4 64 85 f0    	mov    %edx,0xf08564d4
f0101de6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101de9:	a1 d8 64 85 f0       	mov    0xf08564d8,%eax
f0101dee:	48                   	dec    %eax
f0101def:	a3 d8 64 85 f0       	mov    %eax,0xf08564d8
f0101df4:	a1 d8 64 85 f0       	mov    0xf08564d8,%eax
f0101df9:	85 c0                	test   %eax,%eax
f0101dfb:	79 db                	jns    f0101dd8 <get_into_prompt+0xf6>
f0101dfd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101e04:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101e07:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101e09:	83 ec 0c             	sub    $0xc,%esp
f0101e0c:	6a 00                	push   $0x0
f0101e0e:	e8 c1 fd ff ff       	call   f0101bd4 <run_command_prompt>
f0101e13:	83 c4 10             	add    $0x10,%esp
	}
f0101e16:	e9 cd fe ff ff       	jmp    f0101ce8 <get_into_prompt+0x6>

f0101e1b <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101e1b:	55                   	push   %ebp
f0101e1c:	89 e5                	mov    %esp,%ebp
f0101e1e:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101e21:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101e24:	50                   	push   %eax
f0101e25:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101e28:	50                   	push   %eax
f0101e29:	68 5e b8 12 f0       	push   $0xf012b85e
f0101e2e:	ff 75 08             	pushl  0x8(%ebp)
f0101e31:	e8 0b 93 01 00       	call   f011b141 <strsplit>
f0101e36:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101e39:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101e3c:	85 c0                	test   %eax,%eax
f0101e3e:	75 0a                	jne    f0101e4a <execute_command+0x2f>
		return 0;
f0101e40:	b8 00 00 00 00       	mov    $0x0,%eax
f0101e45:	e9 a4 02 00 00       	jmp    f01020ee <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101e4a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101e4d:	83 ec 08             	sub    $0x8,%esp
f0101e50:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101e53:	52                   	push   %edx
f0101e54:	50                   	push   %eax
f0101e55:	e8 96 02 00 00       	call   f01020f0 <process_command>
f0101e5a:	83 c4 10             	add    $0x10,%esp
f0101e5d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if (ret == CMD_INVALID)
f0101e60:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101e64:	75 19                	jne    f0101e7f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101e66:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101e69:	83 ec 08             	sub    $0x8,%esp
f0101e6c:	50                   	push   %eax
f0101e6d:	68 63 b8 12 f0       	push   $0xf012b863
f0101e72:	e8 e5 fc ff ff       	call   f0101b5c <cprintf>
f0101e77:	83 c4 10             	add    $0x10,%esp
f0101e7a:	e9 6a 02 00 00       	jmp    f01020e9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101e7f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101e83:	75 4f                	jne    f0101ed4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101e85:	a1 d8 63 85 f0       	mov    0xf08563d8,%eax
f0101e8a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101e8d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101e91:	74 17                	je     f0101eaa <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101e93:	83 ec 04             	sub    $0x4,%esp
f0101e96:	68 7c b8 12 f0       	push   $0xf012b87c
f0101e9b:	68 90 00 00 00       	push   $0x90
f0101ea0:	68 cd b8 12 f0       	push   $0xf012b8cd
f0101ea5:	e8 05 f0 ff ff       	call   f0100eaf <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101eaa:	a1 cc 63 85 f0       	mov    0xf08563cc,%eax
f0101eaf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101eb2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101eb5:	8b 50 04             	mov    0x4(%eax),%edx
f0101eb8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101ebb:	8b 00                	mov    (%eax),%eax
f0101ebd:	83 ec 04             	sub    $0x4,%esp
f0101ec0:	52                   	push   %edx
f0101ec1:	50                   	push   %eax
f0101ec2:	68 e8 b8 12 f0       	push   $0xf012b8e8
f0101ec7:	e8 90 fc ff ff       	call   f0101b5c <cprintf>
f0101ecc:	83 c4 10             	add    $0x10,%esp
f0101ecf:	e9 15 02 00 00       	jmp    f01020e9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101ed4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101ed8:	0f 85 e6 01 00 00    	jne    f01020c4 <execute_command+0x2a9>
	{
		int i = 1;
f0101ede:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101ee5:	a1 d8 63 85 f0       	mov    0xf08563d8,%eax
f0101eea:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101eed:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101ef1:	75 17                	jne    f0101f0a <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101ef3:	83 ec 04             	sub    $0x4,%esp
f0101ef6:	68 18 b9 12 f0       	push   $0xf012b918
f0101efb:	68 9b 00 00 00       	push   $0x9b
f0101f00:	68 cd b8 12 f0       	push   $0xf012b8cd
f0101f05:	e8 a5 ef ff ff       	call   f0100eaf <_panic>
		}
		struct Command * cmd = NULL;
f0101f0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101f11:	a1 cc 63 85 f0       	mov    0xf08563cc,%eax
f0101f16:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101f19:	eb 28                	jmp    f0101f43 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101f1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101f1e:	8b 10                	mov    (%eax),%edx
f0101f20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101f23:	8d 48 01             	lea    0x1(%eax),%ecx
f0101f26:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0101f29:	83 ec 04             	sub    $0x4,%esp
f0101f2c:	52                   	push   %edx
f0101f2d:	50                   	push   %eax
f0101f2e:	68 42 b9 12 f0       	push   $0xf012b942
f0101f33:	e8 24 fc ff ff       	call   f0101b5c <cprintf>
f0101f38:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f0101f3b:	a1 d4 63 85 f0       	mov    0xf08563d4,%eax
f0101f40:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101f43:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0101f47:	74 08                	je     f0101f51 <execute_command+0x136>
f0101f49:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101f4c:	8b 40 10             	mov    0x10(%eax),%eax
f0101f4f:	eb 05                	jmp    f0101f56 <execute_command+0x13b>
f0101f51:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f56:	a3 d4 63 85 f0       	mov    %eax,0xf08563d4
f0101f5b:	a1 d4 63 85 f0       	mov    0xf08563d4,%eax
f0101f60:	85 c0                	test   %eax,%eax
f0101f62:	75 b7                	jne    f0101f1b <execute_command+0x100>
f0101f64:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0101f68:	75 b1                	jne    f0101f1b <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f0101f6a:	83 ec 08             	sub    $0x8,%esp
f0101f6d:	ff 75 dc             	pushl  -0x24(%ebp)
f0101f70:	68 4c b9 12 f0       	push   $0xf012b94c
f0101f75:	e8 e2 fb ff ff       	call   f0101b5c <cprintf>
f0101f7a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f0101f7d:	e8 8b fa ff ff       	call   f0101a0d <getchar>
f0101f82:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0101f85:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0101f89:	83 ec 0c             	sub    $0xc,%esp
f0101f8c:	50                   	push   %eax
f0101f8d:	e8 64 fa ff ff       	call   f01019f6 <cputchar>
f0101f92:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0101f95:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f0101f9c:	eb 40                	jmp    f0101fde <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f0101f9e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0101fa1:	89 d0                	mov    %edx,%eax
f0101fa3:	c1 e0 02             	shl    $0x2,%eax
f0101fa6:	01 d0                	add    %edx,%eax
f0101fa8:	01 c0                	add    %eax,%eax
f0101faa:	89 c2                	mov    %eax,%edx
f0101fac:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0101fb0:	83 e8 30             	sub    $0x30,%eax
f0101fb3:	01 d0                	add    %edx,%eax
f0101fb5:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0101fb8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0101fbc:	7e 2c                	jle    f0101fea <execute_command+0x1cf>
f0101fbe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101fc1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0101fc4:	7f 24                	jg     f0101fea <execute_command+0x1cf>
				break;

			Chose = getchar();
f0101fc6:	e8 42 fa ff ff       	call   f0101a0d <getchar>
f0101fcb:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f0101fce:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0101fd2:	83 ec 0c             	sub    $0xc,%esp
f0101fd5:	50                   	push   %eax
f0101fd6:	e8 1b fa ff ff       	call   f01019f6 <cputchar>
f0101fdb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f0101fde:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f0101fe2:	7e 06                	jle    f0101fea <execute_command+0x1cf>
f0101fe4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f0101fe8:	7e b4                	jle    f0101f9e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f0101fea:	83 ec 0c             	sub    $0xc,%esp
f0101fed:	6a 0a                	push   $0xa
f0101fef:	e8 02 fa ff ff       	call   f01019f6 <cputchar>
f0101ff4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f0101ff7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0101ffb:	0f 8e e8 00 00 00    	jle    f01020e9 <execute_command+0x2ce>
f0102001:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102004:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0102007:	0f 8f dc 00 00 00    	jg     f01020e9 <execute_command+0x2ce>
		{
			int c = 1;
f010200d:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f0102014:	a1 cc 63 85 f0       	mov    0xf08563cc,%eax
f0102019:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010201c:	eb 75                	jmp    f0102093 <execute_command+0x278>
			{
				if (c++ == selection)
f010201e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102021:	8d 50 01             	lea    0x1(%eax),%edx
f0102024:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102027:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010202a:	75 5f                	jne    f010208b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010202c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102032:	85 c0                	test   %eax,%eax
f0102034:	75 31                	jne    f0102067 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102036:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102039:	8b 00                	mov    (%eax),%eax
f010203b:	83 ec 08             	sub    $0x8,%esp
f010203e:	50                   	push   %eax
f010203f:	68 af b9 12 f0       	push   $0xf012b9af
f0102044:	e8 13 fb ff ff       	call   f0101b5c <cprintf>
f0102049:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010204c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010204f:	8b 40 08             	mov    0x8(%eax),%eax
f0102052:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102055:	83 ec 08             	sub    $0x8,%esp
f0102058:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010205b:	51                   	push   %ecx
f010205c:	52                   	push   %edx
f010205d:	ff d0                	call   *%eax
f010205f:	83 c4 10             	add    $0x10,%esp
f0102062:	e9 87 00 00 00       	jmp    f01020ee <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102067:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010206a:	8b 50 04             	mov    0x4(%eax),%edx
f010206d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102070:	8b 00                	mov    (%eax),%eax
f0102072:	83 ec 04             	sub    $0x4,%esp
f0102075:	52                   	push   %edx
f0102076:	50                   	push   %eax
f0102077:	68 b8 b9 12 f0       	push   $0xf012b9b8
f010207c:	e8 db fa ff ff       	call   f0101b5c <cprintf>
f0102081:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102084:	b8 00 00 00 00       	mov    $0x0,%eax
f0102089:	eb 63                	jmp    f01020ee <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010208b:	a1 d4 63 85 f0       	mov    0xf08563d4,%eax
f0102090:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102093:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102097:	74 08                	je     f01020a1 <execute_command+0x286>
f0102099:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010209c:	8b 40 10             	mov    0x10(%eax),%eax
f010209f:	eb 05                	jmp    f01020a6 <execute_command+0x28b>
f01020a1:	b8 00 00 00 00       	mov    $0x0,%eax
f01020a6:	a3 d4 63 85 f0       	mov    %eax,0xf08563d4
f01020ab:	a1 d4 63 85 f0       	mov    0xf08563d4,%eax
f01020b0:	85 c0                	test   %eax,%eax
f01020b2:	0f 85 66 ff ff ff    	jne    f010201e <execute_command+0x203>
f01020b8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01020bc:	0f 85 5c ff ff ff    	jne    f010201e <execute_command+0x203>
f01020c2:	eb 25                	jmp    f01020e9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01020c4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01020c7:	89 d0                	mov    %edx,%eax
f01020c9:	01 c0                	add    %eax,%eax
f01020cb:	01 d0                	add    %edx,%eax
f01020cd:	c1 e0 03             	shl    $0x3,%eax
f01020d0:	05 68 f5 17 f0       	add    $0xf017f568,%eax
f01020d5:	8b 00                	mov    (%eax),%eax
f01020d7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01020da:	83 ec 08             	sub    $0x8,%esp
f01020dd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01020e0:	51                   	push   %ecx
f01020e1:	52                   	push   %edx
f01020e2:	ff d0                	call   *%eax
f01020e4:	83 c4 10             	add    $0x10,%esp
f01020e7:	eb 05                	jmp    f01020ee <execute_command+0x2d3>
	}
	return 0;
f01020e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01020ee:	c9                   	leave  
f01020ef:	c3                   	ret    

f01020f0 <process_command>:


int process_command(int number_of_arguments, char** arguments)
{
f01020f0:	55                   	push   %ebp
f01020f1:	89 e5                	mov    %esp,%ebp
f01020f3:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01020f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01020fd:	eb 31                	jmp    f0102130 <process_command+0x40>
	{
		if (strcmp(arguments[0], commands[i].name) == 0)
f01020ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102102:	89 d0                	mov    %edx,%eax
f0102104:	01 c0                	add    %eax,%eax
f0102106:	01 d0                	add    %edx,%eax
f0102108:	c1 e0 03             	shl    $0x3,%eax
f010210b:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f0102110:	8b 10                	mov    (%eax),%edx
f0102112:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102115:	8b 00                	mov    (%eax),%eax
f0102117:	83 ec 08             	sub    $0x8,%esp
f010211a:	52                   	push   %edx
f010211b:	50                   	push   %eax
f010211c:	e8 68 8a 01 00       	call   f011ab89 <strcmp>
f0102121:	83 c4 10             	add    $0x10,%esp
f0102124:	85 c0                	test   %eax,%eax
f0102126:	75 05                	jne    f010212d <process_command+0x3d>
		{
			return i;
f0102128:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010212b:	eb 14                	jmp    f0102141 <process_command+0x51>
}


int process_command(int number_of_arguments, char** arguments)
{
	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f010212d:	ff 45 f4             	incl   -0xc(%ebp)
f0102130:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102133:	a1 a8 fb 17 f0       	mov    0xf017fba8,%eax
f0102138:	39 c2                	cmp    %eax,%edx
f010213a:	72 c3                	jb     f01020ff <process_command+0xf>
		if (strcmp(arguments[0], commands[i].name) == 0)
		{
			return i;
		}
	}
	return CMD_INVALID;
f010213c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f0102141:	c9                   	leave  
f0102142:	c3                   	ret    

f0102143 <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty_buf[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0102143:	55                   	push   %ebp
f0102144:	89 e5                	mov    %esp,%ebp
f0102146:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0102149:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102150:	eb 10                	jmp    f0102162 <clearandwritecommand+0x1f>
		cputchar('\b');
f0102152:	83 ec 0c             	sub    $0xc,%esp
f0102155:	6a 08                	push   $0x8
f0102157:	e8 9a f8 ff ff       	call   f01019f6 <cputchar>
f010215c:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty_buf[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f010215f:	ff 45 f4             	incl   -0xc(%ebp)
f0102162:	8b 45 08             	mov    0x8(%ebp),%eax
f0102165:	8b 00                	mov    (%eax),%eax
f0102167:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010216a:	7f e6                	jg     f0102152 <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f010216c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010216f:	c1 e0 0a             	shl    $0xa,%eax
f0102172:	05 e0 f4 86 f0       	add    $0xf086f4e0,%eax
f0102177:	83 ec 0c             	sub    $0xc,%esp
f010217a:	50                   	push   %eax
f010217b:	e8 fd 88 01 00       	call   f011aa7d <strlen>
f0102180:	83 c4 10             	add    $0x10,%esp
f0102183:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty_buf, BUFLEN);
f0102186:	83 ec 04             	sub    $0x4,%esp
f0102189:	68 00 04 00 00       	push   $0x400
f010218e:	68 e0 44 87 f0       	push   $0xf08744e0
f0102193:	ff 75 10             	pushl  0x10(%ebp)
f0102196:	e8 73 8b 01 00       	call   f011ad0e <memcpy>
f010219b:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f010219e:	8b 45 08             	mov    0x8(%ebp),%eax
f01021a1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01021a7:	eb 52                	jmp    f01021fb <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f01021a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01021ac:	8b 00                	mov    (%eax),%eax
f01021ae:	8b 55 0c             	mov    0xc(%ebp),%edx
f01021b1:	c1 e2 0a             	shl    $0xa,%edx
f01021b4:	01 d0                	add    %edx,%eax
f01021b6:	05 e0 f4 86 f0       	add    $0xf086f4e0,%eax
f01021bb:	8a 00                	mov    (%eax),%al
f01021bd:	0f be c0             	movsbl %al,%eax
f01021c0:	83 ec 0c             	sub    $0xc,%esp
f01021c3:	50                   	push   %eax
f01021c4:	e8 2d f8 ff ff       	call   f01019f6 <cputchar>
f01021c9:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f01021cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01021cf:	8b 00                	mov    (%eax),%eax
f01021d1:	89 c2                	mov    %eax,%edx
f01021d3:	8b 45 10             	mov    0x10(%ebp),%eax
f01021d6:	01 c2                	add    %eax,%edx
f01021d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01021db:	8b 00                	mov    (%eax),%eax
f01021dd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01021e0:	c1 e1 0a             	shl    $0xa,%ecx
f01021e3:	01 c8                	add    %ecx,%eax
f01021e5:	05 e0 f4 86 f0       	add    $0xf086f4e0,%eax
f01021ea:	8a 00                	mov    (%eax),%al
f01021ec:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty_buf, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f01021ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01021f1:	8b 00                	mov    (%eax),%eax
f01021f3:	8d 50 01             	lea    0x1(%eax),%edx
f01021f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01021f9:	89 10                	mov    %edx,(%eax)
f01021fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01021fe:	8b 00                	mov    (%eax),%eax
f0102200:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0102203:	7c a4                	jl     f01021a9 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f0102205:	8b 45 14             	mov    0x14(%ebp),%eax
f0102208:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010220b:	89 10                	mov    %edx,(%eax)
}
f010220d:	90                   	nop
f010220e:	c9                   	leave  
f010220f:	c3                   	ret    

f0102210 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0102210:	55                   	push   %ebp
f0102211:	89 e5                	mov    %esp,%ebp
f0102213:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f0102216:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010221d:	eb 10                	jmp    f010222f <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f010221f:	83 ec 0c             	sub    $0xc,%esp
f0102222:	6a 08                	push   $0x8
f0102224:	e8 cd f7 ff ff       	call   f01019f6 <cputchar>
f0102229:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f010222c:	ff 45 f4             	incl   -0xc(%ebp)
f010222f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102232:	3b 45 08             	cmp    0x8(%ebp),%eax
f0102235:	7c e8                	jl     f010221f <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f0102237:	83 ec 0c             	sub    $0xc,%esp
f010223a:	ff 75 0c             	pushl  0xc(%ebp)
f010223d:	e8 3b 88 01 00       	call   f011aa7d <strlen>
f0102242:	83 c4 10             	add    $0x10,%esp
f0102245:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty_buf, BUFLEN);
f0102248:	83 ec 04             	sub    $0x4,%esp
f010224b:	68 00 04 00 00       	push   $0x400
f0102250:	68 e0 44 87 f0       	push   $0xf08744e0
f0102255:	ff 75 10             	pushl  0x10(%ebp)
f0102258:	e8 b1 8a 01 00       	call   f011ad0e <memcpy>
f010225d:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0102260:	8b 45 14             	mov    0x14(%ebp),%eax
f0102263:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0102269:	eb 46                	jmp    f01022b1 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f010226b:	8b 45 14             	mov    0x14(%ebp),%eax
f010226e:	8b 00                	mov    (%eax),%eax
f0102270:	89 c2                	mov    %eax,%edx
f0102272:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102275:	01 d0                	add    %edx,%eax
f0102277:	8a 00                	mov    (%eax),%al
f0102279:	0f be c0             	movsbl %al,%eax
f010227c:	83 ec 0c             	sub    $0xc,%esp
f010227f:	50                   	push   %eax
f0102280:	e8 71 f7 ff ff       	call   f01019f6 <cputchar>
f0102285:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0102288:	8b 45 14             	mov    0x14(%ebp),%eax
f010228b:	8b 00                	mov    (%eax),%eax
f010228d:	89 c2                	mov    %eax,%edx
f010228f:	8b 45 10             	mov    0x10(%ebp),%eax
f0102292:	01 c2                	add    %eax,%edx
f0102294:	8b 45 14             	mov    0x14(%ebp),%eax
f0102297:	8b 00                	mov    (%eax),%eax
f0102299:	89 c1                	mov    %eax,%ecx
f010229b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010229e:	01 c8                	add    %ecx,%eax
f01022a0:	8a 00                	mov    (%eax),%al
f01022a2:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty_buf, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f01022a4:	8b 45 14             	mov    0x14(%ebp),%eax
f01022a7:	8b 00                	mov    (%eax),%eax
f01022a9:	8d 50 01             	lea    0x1(%eax),%edx
f01022ac:	8b 45 14             	mov    0x14(%ebp),%eax
f01022af:	89 10                	mov    %edx,(%eax)
f01022b1:	8b 45 14             	mov    0x14(%ebp),%eax
f01022b4:	8b 00                	mov    (%eax),%eax
f01022b6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01022b9:	7c b0                	jl     f010226b <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f01022bb:	8b 45 18             	mov    0x18(%ebp),%eax
f01022be:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01022c1:	89 10                	mov    %edx,(%eax)
}
f01022c3:	90                   	nop
f01022c4:	c9                   	leave  
f01022c5:	c3                   	ret    

f01022c6 <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f01022c6:	55                   	push   %ebp
f01022c7:	89 e5                	mov    %esp,%ebp
f01022c9:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f01022cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01022d3:	eb 21                	jmp    f01022f6 <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f01022d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01022d8:	c1 e0 0a             	shl    $0xa,%eax
f01022db:	05 e0 64 85 f0       	add    $0xf08564e0,%eax
f01022e0:	83 ec 04             	sub    $0x4,%esp
f01022e3:	68 00 04 00 00       	push   $0x400
f01022e8:	6a 00                	push   $0x0
f01022ea:	50                   	push   %eax
f01022eb:	e8 7b 89 01 00       	call   f011ac6b <memset>
f01022f0:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f01022f3:	ff 45 f4             	incl   -0xc(%ebp)
f01022f6:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f01022fa:	7e d9                	jle    f01022d5 <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f01022fc:	90                   	nop
f01022fd:	c9                   	leave  
f01022fe:	c3                   	ret    

f01022ff <command_prompt_readline>:

//Array of tests
extern struct Test tests[] ;
extern uint32 NUM_OF_TESTS;

void command_prompt_readline(const char *prompt, char* buf) {
f01022ff:	55                   	push   %ebp
f0102300:	89 e5                	mov    %esp,%ebp
f0102302:	57                   	push   %edi
f0102303:	53                   	push   %ebx
f0102304:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f010230a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010230e:	74 13                	je     f0102323 <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0102310:	83 ec 08             	sub    $0x8,%esp
f0102313:	ff 75 08             	pushl  0x8(%ebp)
f0102316:	68 c0 b9 12 f0       	push   $0xf012b9c0
f010231b:	e8 3c f8 ff ff       	call   f0101b5c <cprintf>
f0102320:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f0102323:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102328:	40                   	inc    %eax
f0102329:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f010232c:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f0102333:	00 00 00 
f0102336:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010233c:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102342:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102348:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f010234b:	83 ec 0c             	sub    $0xc,%esp
f010234e:	6a 00                	push   $0x0
f0102350:	e8 d1 f6 ff ff       	call   f0101a26 <iscons>
f0102355:	83 c4 10             	add    $0x10,%esp
f0102358:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f010235b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f0102362:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f0102369:	e8 9f f6 ff ff       	call   f0101a0d <getchar>
f010236e:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f0102371:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0102377:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010237d:	39 c2                	cmp    %eax,%edx
f010237f:	7e 0c                	jle    f010238d <command_prompt_readline+0x8e>
			lastIndex = i;
f0102381:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102387:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f010238d:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0102391:	79 22                	jns    f01023b5 <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f0102393:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f0102397:	0f 84 94 0a 00 00    	je     f0102e31 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f010239d:	83 ec 08             	sub    $0x8,%esp
f01023a0:	ff 75 94             	pushl  -0x6c(%ebp)
f01023a3:	68 c3 b9 12 f0       	push   $0xf012b9c3
f01023a8:	e8 af f7 ff ff       	call   f0101b5c <cprintf>
f01023ad:	83 c4 10             	add    $0x10,%esp
			return;
f01023b0:	e9 7c 0a 00 00       	jmp    f0102e31 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f01023b5:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f01023bc:	75 2a                	jne    f01023e8 <command_prompt_readline+0xe9>
			if (commandidx)
f01023be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01023c2:	74 03                	je     f01023c7 <command_prompt_readline+0xc8>
				commandidx--;
f01023c4:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f01023c7:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f01023cd:	50                   	push   %eax
f01023ce:	ff 75 0c             	pushl  0xc(%ebp)
f01023d1:	ff 75 f4             	pushl  -0xc(%ebp)
f01023d4:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01023da:	50                   	push   %eax
f01023db:	e8 63 fd ff ff       	call   f0102143 <clearandwritecommand>
f01023e0:	83 c4 10             	add    $0x10,%esp
f01023e3:	e9 32 0a 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f01023e8:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f01023ef:	75 3b                	jne    f010242c <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f01023f1:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f01023f6:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f01023f9:	7d 03                	jge    f01023fe <command_prompt_readline+0xff>
				commandidx++;
f01023fb:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f01023fe:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102403:	85 c0                	test   %eax,%eax
f0102405:	0f 88 0f 0a 00 00    	js     f0102e1a <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010240b:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0102411:	50                   	push   %eax
f0102412:	ff 75 0c             	pushl  0xc(%ebp)
f0102415:	ff 75 f4             	pushl  -0xc(%ebp)
f0102418:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010241e:	50                   	push   %eax
f010241f:	e8 1f fd ff ff       	call   f0102143 <clearandwritecommand>
f0102424:	83 c4 10             	add    $0x10,%esp
f0102427:	e9 ee 09 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f010242c:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f0102430:	0f 85 6d 07 00 00    	jne    f0102ba3 <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f0102436:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f010243a:	0f 84 fc 06 00 00    	je     f0102b3c <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f0102440:	83 ec 08             	sub    $0x8,%esp
f0102443:	6a 64                	push   $0x64
f0102445:	68 e0 64 85 f0       	push   $0xf08564e0
f010244a:	e8 77 fe ff ff       	call   f01022c6 <clear_prefix_list>
f010244f:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f0102452:	83 ec 0c             	sub    $0xc,%esp
f0102455:	ff 75 0c             	pushl  0xc(%ebp)
f0102458:	e8 20 86 01 00       	call   f011aa7d <strlen>
f010245d:	83 c4 10             	add    $0x10,%esp
f0102460:	85 c0                	test   %eax,%eax
f0102462:	0f 84 bd 09 00 00    	je     f0102e25 <command_prompt_readline+0xb26>
f0102468:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f010246f:	0f 84 b0 09 00 00    	je     f0102e25 <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f0102475:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010247c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010247f:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f0102485:	83 ec 08             	sub    $0x8,%esp
f0102488:	ff 75 0c             	pushl  0xc(%ebp)
f010248b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102491:	50                   	push   %eax
f0102492:	e8 35 86 01 00       	call   f011aacc <strcpy>
f0102497:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f010249a:	83 ec 0c             	sub    $0xc,%esp
f010249d:	ff 75 0c             	pushl  0xc(%ebp)
f01024a0:	e8 d8 85 01 00       	call   f011aa7d <strlen>
f01024a5:	83 c4 10             	add    $0x10,%esp
f01024a8:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f01024ab:	8b 45 90             	mov    -0x70(%ebp),%eax
f01024ae:	8d 50 ff             	lea    -0x1(%eax),%edx
f01024b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01024b4:	01 d0                	add    %edx,%eax
f01024b6:	8a 00                	mov    (%eax),%al
f01024b8:	3c 20                	cmp    $0x20,%al
f01024ba:	0f 84 6b 09 00 00    	je     f0102e2b <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f01024c0:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f01024c6:	50                   	push   %eax
f01024c7:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f01024cd:	50                   	push   %eax
f01024ce:	68 d3 b9 12 f0       	push   $0xf012b9d3
f01024d3:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01024d9:	50                   	push   %eax
f01024da:	e8 62 8c 01 00       	call   f011b141 <strsplit>
f01024df:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f01024e2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f01024e9:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01024ef:	83 f8 01             	cmp    $0x1,%eax
f01024f2:	0f 8e 28 01 00 00    	jle    f0102620 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f01024f8:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01024fe:	83 ec 08             	sub    $0x8,%esp
f0102501:	68 d8 b9 12 f0       	push   $0xf012b9d8
f0102506:	50                   	push   %eax
f0102507:	e8 7d 86 01 00       	call   f011ab89 <strcmp>
f010250c:	83 c4 10             	add    $0x10,%esp
f010250f:	85 c0                	test   %eax,%eax
f0102511:	74 3c                	je     f010254f <command_prompt_readline+0x250>
f0102513:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0102519:	83 ec 08             	sub    $0x8,%esp
f010251c:	68 dc b9 12 f0       	push   $0xf012b9dc
f0102521:	50                   	push   %eax
f0102522:	e8 62 86 01 00       	call   f011ab89 <strcmp>
f0102527:	83 c4 10             	add    $0x10,%esp
f010252a:	85 c0                	test   %eax,%eax
f010252c:	74 21                	je     f010254f <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f010252e:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0102534:	83 ec 08             	sub    $0x8,%esp
f0102537:	68 e1 b9 12 f0       	push   $0xf012b9e1
f010253c:	50                   	push   %eax
f010253d:	e8 47 86 01 00       	call   f011ab89 <strcmp>
f0102542:	83 c4 10             	add    $0x10,%esp
f0102545:	85 c0                	test   %eax,%eax
f0102547:	74 06                	je     f010254f <command_prompt_readline+0x250>
						continue;
f0102549:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f010254a:	e9 d6 08 00 00       	jmp    f0102e25 <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f010254f:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0102555:	83 ec 08             	sub    $0x8,%esp
f0102558:	68 e1 b9 12 f0       	push   $0xf012b9e1
f010255d:	50                   	push   %eax
f010255e:	e8 26 86 01 00       	call   f011ab89 <strcmp>
f0102563:	83 c4 10             	add    $0x10,%esp
f0102566:	85 c0                	test   %eax,%eax
f0102568:	75 09                	jne    f0102573 <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f010256a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f0102571:	eb 07                	jmp    f010257a <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f0102573:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f010257a:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0102581:	00 00 00 
f0102584:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f010258a:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010258f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102594:	89 d7                	mov    %edx,%edi
f0102596:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0102598:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010259e:	48                   	dec    %eax
f010259f:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f01025a6:	83 ec 0c             	sub    $0xc,%esp
f01025a9:	50                   	push   %eax
f01025aa:	e8 ce 84 01 00       	call   f011aa7d <strlen>
f01025af:	83 c4 10             	add    $0x10,%esp
f01025b2:	8b 55 90             	mov    -0x70(%ebp),%edx
f01025b5:	29 c2                	sub    %eax,%edx
f01025b7:	89 d0                	mov    %edx,%eax
f01025b9:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f01025bc:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01025c3:	eb 1d                	jmp    f01025e2 <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f01025c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01025c8:	8d 50 01             	lea    0x1(%eax),%edx
f01025cb:	89 55 dc             	mov    %edx,-0x24(%ebp)
f01025ce:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f01025d1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01025d4:	01 ca                	add    %ecx,%edx
f01025d6:	8a 12                	mov    (%edx),%dl
f01025d8:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f01025df:	ff 45 d8             	incl   -0x28(%ebp)
f01025e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01025e5:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f01025e8:	7c db                	jl     f01025c5 <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f01025ea:	83 ec 08             	sub    $0x8,%esp
f01025ed:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01025f3:	50                   	push   %eax
f01025f4:	ff 75 0c             	pushl  0xc(%ebp)
f01025f7:	e8 d0 84 01 00       	call   f011aacc <strcpy>
f01025fc:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f01025ff:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0102605:	48                   	dec    %eax
f0102606:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010260d:	83 ec 08             	sub    $0x8,%esp
f0102610:	50                   	push   %eax
f0102611:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102617:	50                   	push   %eax
f0102618:	e8 af 84 01 00       	call   f011aacc <strcpy>
f010261d:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0102620:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f0102627:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010262d:	83 f8 01             	cmp    $0x1,%eax
f0102630:	0f 85 30 01 00 00    	jne    f0102766 <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f0102636:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f010263d:	e9 0f 01 00 00       	jmp    f0102751 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f0102642:	83 ec 0c             	sub    $0xc,%esp
f0102645:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010264b:	50                   	push   %eax
f010264c:	e8 2c 84 01 00       	call   f011aa7d <strlen>
f0102651:	83 c4 10             	add    $0x10,%esp
f0102654:	89 c1                	mov    %eax,%ecx
f0102656:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102659:	89 d0                	mov    %edx,%eax
f010265b:	01 c0                	add    %eax,%eax
f010265d:	01 d0                	add    %edx,%eax
f010265f:	c1 e0 03             	shl    $0x3,%eax
f0102662:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f0102667:	8b 00                	mov    (%eax),%eax
f0102669:	83 ec 04             	sub    $0x4,%esp
f010266c:	51                   	push   %ecx
f010266d:	50                   	push   %eax
f010266e:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102674:	50                   	push   %eax
f0102675:	e8 47 85 01 00       	call   f011abc1 <strncmp>
f010267a:	83 c4 10             	add    $0x10,%esp
f010267d:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f0102680:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f0102684:	0f 85 c4 00 00 00    	jne    f010274e <command_prompt_readline+0x44f>
							it_str = -1;
f010268a:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0102691:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0102698:	00 00 00 
f010269b:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01026a1:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01026a6:	b8 00 00 00 00       	mov    $0x0,%eax
f01026ab:	89 d7                	mov    %edx,%edi
f01026ad:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f01026af:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f01026b6:	eb 2d                	jmp    f01026e5 <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f01026b8:	ff 45 dc             	incl   -0x24(%ebp)
f01026bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01026be:	89 d0                	mov    %edx,%eax
f01026c0:	01 c0                	add    %eax,%eax
f01026c2:	01 d0                	add    %edx,%eax
f01026c4:	c1 e0 03             	shl    $0x3,%eax
f01026c7:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f01026cc:	8b 10                	mov    (%eax),%edx
f01026ce:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01026d1:	01 d0                	add    %edx,%eax
f01026d3:	8a 00                	mov    (%eax),%al
f01026d5:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01026db:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01026de:	01 ca                	add    %ecx,%edx
f01026e0:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f01026e2:	ff 45 cc             	incl   -0x34(%ebp)
f01026e5:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01026e8:	89 d0                	mov    %edx,%eax
f01026ea:	01 c0                	add    %eax,%eax
f01026ec:	01 d0                	add    %edx,%eax
f01026ee:	c1 e0 03             	shl    $0x3,%eax
f01026f1:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f01026f6:	8b 00                	mov    (%eax),%eax
f01026f8:	83 ec 0c             	sub    $0xc,%esp
f01026fb:	50                   	push   %eax
f01026fc:	e8 7c 83 01 00       	call   f011aa7d <strlen>
f0102701:	83 c4 10             	add    $0x10,%esp
f0102704:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f0102707:	7f af                	jg     f01026b8 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0102709:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010270c:	c1 e0 0a             	shl    $0xa,%eax
f010270f:	05 e0 64 85 f0       	add    $0xf08564e0,%eax
f0102714:	83 ec 04             	sub    $0x4,%esp
f0102717:	68 00 04 00 00       	push   $0x400
f010271c:	6a 00                	push   $0x0
f010271e:	50                   	push   %eax
f010271f:	e8 47 85 01 00       	call   f011ac6b <memset>
f0102724:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0102727:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010272a:	40                   	inc    %eax
f010272b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010272e:	c1 e2 0a             	shl    $0xa,%edx
f0102731:	81 c2 e0 64 85 f0    	add    $0xf08564e0,%edx
f0102737:	83 ec 04             	sub    $0x4,%esp
f010273a:	50                   	push   %eax
f010273b:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0102741:	50                   	push   %eax
f0102742:	52                   	push   %edx
f0102743:	e8 b2 83 01 00       	call   f011aafa <strncpy>
f0102748:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f010274b:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f010274e:	ff 45 d0             	incl   -0x30(%ebp)
f0102751:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102754:	a1 a8 fb 17 f0       	mov    0xf017fba8,%eax
f0102759:	39 c2                	cmp    %eax,%edx
f010275b:	0f 82 e1 fe ff ff    	jb     f0102642 <command_prompt_readline+0x343>
f0102761:	e9 fe 02 00 00       	jmp    f0102a64 <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f0102766:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010276a:	0f 84 7b 01 00 00    	je     f01028eb <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f0102770:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f0102777:	e9 5c 01 00 00       	jmp    f01028d8 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f010277c:	83 ec 0c             	sub    $0xc,%esp
f010277f:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102785:	50                   	push   %eax
f0102786:	e8 f2 82 01 00       	call   f011aa7d <strlen>
f010278b:	83 c4 10             	add    $0x10,%esp
f010278e:	89 c1                	mov    %eax,%ecx
f0102790:	8b 1d 9c 00 18 f0    	mov    0xf018009c,%ebx
f0102796:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0102799:	89 d0                	mov    %edx,%eax
f010279b:	01 c0                	add    %eax,%eax
f010279d:	01 d0                	add    %edx,%eax
f010279f:	c1 e0 02             	shl    $0x2,%eax
f01027a2:	01 d8                	add    %ebx,%eax
f01027a4:	8b 00                	mov    (%eax),%eax
f01027a6:	83 ec 04             	sub    $0x4,%esp
f01027a9:	51                   	push   %ecx
f01027aa:	50                   	push   %eax
f01027ab:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01027b1:	50                   	push   %eax
f01027b2:	e8 0a 84 01 00       	call   f011abc1 <strncmp>
f01027b7:	83 c4 10             	add    $0x10,%esp
f01027ba:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f01027bd:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f01027c1:	0f 85 0e 01 00 00    	jne    f01028d5 <command_prompt_readline+0x5d6>
								it_str = -1;
f01027c7:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01027ce:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01027d5:	00 00 00 
f01027d8:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01027de:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01027e3:	b8 00 00 00 00       	mov    $0x0,%eax
f01027e8:	89 d7                	mov    %edx,%edi
f01027ea:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01027ec:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01027f2:	83 f8 01             	cmp    $0x1,%eax
f01027f5:	7e 39                	jle    f0102830 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01027f7:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f01027fe:	eb 1d                	jmp    f010281d <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0102800:	ff 45 dc             	incl   -0x24(%ebp)
f0102803:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0102806:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102809:	01 d0                	add    %edx,%eax
f010280b:	8a 00                	mov    (%eax),%al
f010280d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0102813:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102816:	01 ca                	add    %ecx,%edx
f0102818:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010281a:	ff 45 c4             	incl   -0x3c(%ebp)
f010281d:	83 ec 0c             	sub    $0xc,%esp
f0102820:	ff 75 0c             	pushl  0xc(%ebp)
f0102823:	e8 55 82 01 00       	call   f011aa7d <strlen>
f0102828:	83 c4 10             	add    $0x10,%esp
f010282b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f010282e:	7f d0                	jg     f0102800 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f0102830:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f0102837:	eb 30                	jmp    f0102869 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f0102839:	ff 45 dc             	incl   -0x24(%ebp)
f010283c:	8b 0d 9c 00 18 f0    	mov    0xf018009c,%ecx
f0102842:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0102845:	89 d0                	mov    %edx,%eax
f0102847:	01 c0                	add    %eax,%eax
f0102849:	01 d0                	add    %edx,%eax
f010284b:	c1 e0 02             	shl    $0x2,%eax
f010284e:	01 c8                	add    %ecx,%eax
f0102850:	8b 10                	mov    (%eax),%edx
f0102852:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0102855:	01 d0                	add    %edx,%eax
f0102857:	8a 00                	mov    (%eax),%al
f0102859:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010285f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102862:	01 ca                	add    %ecx,%edx
f0102864:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f0102866:	ff 45 c0             	incl   -0x40(%ebp)
f0102869:	8b 0d 9c 00 18 f0    	mov    0xf018009c,%ecx
f010286f:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0102872:	89 d0                	mov    %edx,%eax
f0102874:	01 c0                	add    %eax,%eax
f0102876:	01 d0                	add    %edx,%eax
f0102878:	c1 e0 02             	shl    $0x2,%eax
f010287b:	01 c8                	add    %ecx,%eax
f010287d:	8b 00                	mov    (%eax),%eax
f010287f:	83 ec 0c             	sub    $0xc,%esp
f0102882:	50                   	push   %eax
f0102883:	e8 f5 81 01 00       	call   f011aa7d <strlen>
f0102888:	83 c4 10             	add    $0x10,%esp
f010288b:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f010288e:	7f a9                	jg     f0102839 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0102890:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102893:	c1 e0 0a             	shl    $0xa,%eax
f0102896:	05 e0 64 85 f0       	add    $0xf08564e0,%eax
f010289b:	83 ec 04             	sub    $0x4,%esp
f010289e:	68 00 04 00 00       	push   $0x400
f01028a3:	6a 00                	push   $0x0
f01028a5:	50                   	push   %eax
f01028a6:	e8 c0 83 01 00       	call   f011ac6b <memset>
f01028ab:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01028ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01028b1:	40                   	inc    %eax
f01028b2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01028b5:	c1 e2 0a             	shl    $0xa,%edx
f01028b8:	81 c2 e0 64 85 f0    	add    $0xf08564e0,%edx
f01028be:	83 ec 04             	sub    $0x4,%esp
f01028c1:	50                   	push   %eax
f01028c2:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01028c8:	50                   	push   %eax
f01028c9:	52                   	push   %edx
f01028ca:	e8 2b 82 01 00       	call   f011aafa <strncpy>
f01028cf:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01028d2:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01028d5:	ff 45 c8             	incl   -0x38(%ebp)
f01028d8:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f01028dd:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f01028e0:	0f 8c 96 fe ff ff    	jl     f010277c <command_prompt_readline+0x47d>
f01028e6:	e9 79 01 00 00       	jmp    f0102a64 <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f01028eb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01028ef:	0f 84 6f 01 00 00    	je     f0102a64 <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01028f5:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f01028fc:	e9 53 01 00 00       	jmp    f0102a54 <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0102901:	83 ec 0c             	sub    $0xc,%esp
f0102904:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010290a:	50                   	push   %eax
f010290b:	e8 6d 81 01 00       	call   f011aa7d <strlen>
f0102910:	83 c4 10             	add    $0x10,%esp
f0102913:	89 c1                	mov    %eax,%ecx
f0102915:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0102918:	89 d0                	mov    %edx,%eax
f010291a:	01 c0                	add    %eax,%eax
f010291c:	01 d0                	add    %edx,%eax
f010291e:	c1 e0 02             	shl    $0x2,%eax
f0102921:	05 c0 00 18 f0       	add    $0xf01800c0,%eax
f0102926:	8b 00                	mov    (%eax),%eax
f0102928:	83 ec 04             	sub    $0x4,%esp
f010292b:	51                   	push   %ecx
f010292c:	50                   	push   %eax
f010292d:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102933:	50                   	push   %eax
f0102934:	e8 88 82 01 00       	call   f011abc1 <strncmp>
f0102939:	83 c4 10             	add    $0x10,%esp
f010293c:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f010293f:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0102943:	0f 85 08 01 00 00    	jne    f0102a51 <command_prompt_readline+0x752>
								it_str = -1;
f0102949:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0102950:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0102957:	00 00 00 
f010295a:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0102960:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0102965:	b8 00 00 00 00       	mov    $0x0,%eax
f010296a:	89 d7                	mov    %edx,%edi
f010296c:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f010296e:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0102974:	83 f8 01             	cmp    $0x1,%eax
f0102977:	7e 39                	jle    f01029b2 <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0102979:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f0102980:	eb 1d                	jmp    f010299f <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f0102982:	ff 45 dc             	incl   -0x24(%ebp)
f0102985:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0102988:	8b 45 0c             	mov    0xc(%ebp),%eax
f010298b:	01 d0                	add    %edx,%eax
f010298d:	8a 00                	mov    (%eax),%al
f010298f:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0102995:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102998:	01 ca                	add    %ecx,%edx
f010299a:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010299c:	ff 45 b8             	incl   -0x48(%ebp)
f010299f:	83 ec 0c             	sub    $0xc,%esp
f01029a2:	ff 75 0c             	pushl  0xc(%ebp)
f01029a5:	e8 d3 80 01 00       	call   f011aa7d <strlen>
f01029aa:	83 c4 10             	add    $0x10,%esp
f01029ad:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f01029b0:	7f d0                	jg     f0102982 <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f01029b2:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f01029b9:	eb 2d                	jmp    f01029e8 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f01029bb:	ff 45 dc             	incl   -0x24(%ebp)
f01029be:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01029c1:	89 d0                	mov    %edx,%eax
f01029c3:	01 c0                	add    %eax,%eax
f01029c5:	01 d0                	add    %edx,%eax
f01029c7:	c1 e0 02             	shl    $0x2,%eax
f01029ca:	05 c0 00 18 f0       	add    $0xf01800c0,%eax
f01029cf:	8b 10                	mov    (%eax),%edx
f01029d1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01029d4:	01 d0                	add    %edx,%eax
f01029d6:	8a 00                	mov    (%eax),%al
f01029d8:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01029de:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01029e1:	01 ca                	add    %ecx,%edx
f01029e3:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f01029e5:	ff 45 b4             	incl   -0x4c(%ebp)
f01029e8:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01029eb:	89 d0                	mov    %edx,%eax
f01029ed:	01 c0                	add    %eax,%eax
f01029ef:	01 d0                	add    %edx,%eax
f01029f1:	c1 e0 02             	shl    $0x2,%eax
f01029f4:	05 c0 00 18 f0       	add    $0xf01800c0,%eax
f01029f9:	8b 00                	mov    (%eax),%eax
f01029fb:	83 ec 0c             	sub    $0xc,%esp
f01029fe:	50                   	push   %eax
f01029ff:	e8 79 80 01 00       	call   f011aa7d <strlen>
f0102a04:	83 c4 10             	add    $0x10,%esp
f0102a07:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0102a0a:	7f af                	jg     f01029bb <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0102a0c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a0f:	c1 e0 0a             	shl    $0xa,%eax
f0102a12:	05 e0 64 85 f0       	add    $0xf08564e0,%eax
f0102a17:	83 ec 04             	sub    $0x4,%esp
f0102a1a:	68 00 04 00 00       	push   $0x400
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 44 82 01 00       	call   f011ac6b <memset>
f0102a27:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0102a2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102a2d:	40                   	inc    %eax
f0102a2e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0102a31:	c1 e2 0a             	shl    $0xa,%edx
f0102a34:	81 c2 e0 64 85 f0    	add    $0xf08564e0,%edx
f0102a3a:	83 ec 04             	sub    $0x4,%esp
f0102a3d:	50                   	push   %eax
f0102a3e:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0102a44:	50                   	push   %eax
f0102a45:	52                   	push   %edx
f0102a46:	e8 af 80 01 00       	call   f011aafa <strncpy>
f0102a4b:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f0102a4e:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f0102a51:	ff 45 bc             	incl   -0x44(%ebp)
f0102a54:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0102a57:	a1 80 01 18 f0       	mov    0xf0180180,%eax
f0102a5c:	39 c2                	cmp    %eax,%edx
f0102a5e:	0f 82 9d fe ff ff    	jb     f0102901 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f0102a64:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a67:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f0102a6a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0102a6e:	0f 84 a6 03 00 00    	je     f0102e1a <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f0102a74:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0102a7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102a7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f0102a81:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0102a88:	eb 1f                	jmp    f0102aa9 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0102a8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102a8d:	8d 50 01             	lea    0x1(%eax),%edx
f0102a90:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0102a93:	89 c2                	mov    %eax,%edx
f0102a95:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a98:	01 c2                	add    %eax,%edx
f0102a9a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0102a9d:	05 e0 64 85 f0       	add    $0xf08564e0,%eax
f0102aa2:	8a 00                	mov    (%eax),%al
f0102aa4:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f0102aa6:	ff 45 b0             	incl   -0x50(%ebp)
f0102aa9:	83 ec 0c             	sub    $0xc,%esp
f0102aac:	68 e0 64 85 f0       	push   $0xf08564e0
f0102ab1:	e8 c7 7f 01 00       	call   f011aa7d <strlen>
f0102ab6:	83 c4 10             	add    $0x10,%esp
f0102ab9:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0102abc:	7f cc                	jg     f0102a8a <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0102abe:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f0102ac5:	eb 10                	jmp    f0102ad7 <command_prompt_readline+0x7d8>
						cputchar('\b');}
f0102ac7:	83 ec 0c             	sub    $0xc,%esp
f0102aca:	6a 08                	push   $0x8
f0102acc:	e8 25 ef ff ff       	call   f01019f6 <cputchar>
f0102ad1:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0102ad4:	ff 45 ac             	incl   -0x54(%ebp)
f0102ad7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0102ada:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0102add:	7c e8                	jl     f0102ac7 <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0102adf:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f0102ae6:	eb 1c                	jmp    f0102b04 <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0102ae8:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0102aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aee:	01 d0                	add    %edx,%eax
f0102af0:	8a 00                	mov    (%eax),%al
f0102af2:	0f be c0             	movsbl %al,%eax
f0102af5:	83 ec 0c             	sub    $0xc,%esp
f0102af8:	50                   	push   %eax
f0102af9:	e8 f8 ee ff ff       	call   f01019f6 <cputchar>
f0102afe:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0102b01:	ff 45 a8             	incl   -0x58(%ebp)
f0102b04:	83 ec 0c             	sub    $0xc,%esp
f0102b07:	ff 75 0c             	pushl  0xc(%ebp)
f0102b0a:	e8 6e 7f 01 00       	call   f011aa7d <strlen>
f0102b0f:	83 c4 10             	add    $0x10,%esp
f0102b12:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f0102b15:	7f d1                	jg     f0102ae8 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f0102b17:	83 ec 0c             	sub    $0xc,%esp
f0102b1a:	ff 75 0c             	pushl  0xc(%ebp)
f0102b1d:	e8 5b 7f 01 00       	call   f011aa7d <strlen>
f0102b22:	83 c4 10             	add    $0x10,%esp
f0102b25:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102b2b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102b31:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0102b37:	e9 de 02 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f0102b3c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0102b40:	0f 8e d4 02 00 00    	jle    f0102e1a <command_prompt_readline+0xb1b>
f0102b46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102b49:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f0102b4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102b52:	40                   	inc    %eax
f0102b53:	99                   	cltd   
f0102b54:	f7 7d ec             	idivl  -0x14(%ebp)
f0102b57:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f0102b5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102b5d:	c1 e0 0a             	shl    $0xa,%eax
f0102b60:	8d 98 e0 64 85 f0    	lea    -0xf7a9b20(%eax),%ebx
f0102b66:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f0102b6c:	c1 e0 0a             	shl    $0xa,%eax
f0102b6f:	05 e0 64 85 f0       	add    $0xf08564e0,%eax
f0102b74:	83 ec 0c             	sub    $0xc,%esp
f0102b77:	50                   	push   %eax
f0102b78:	e8 00 7f 01 00       	call   f011aa7d <strlen>
f0102b7d:	83 c4 10             	add    $0x10,%esp
f0102b80:	83 ec 0c             	sub    $0xc,%esp
f0102b83:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0102b89:	52                   	push   %edx
f0102b8a:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0102b90:	52                   	push   %edx
f0102b91:	ff 75 0c             	pushl  0xc(%ebp)
f0102b94:	53                   	push   %ebx
f0102b95:	50                   	push   %eax
f0102b96:	e8 75 f6 ff ff       	call   f0102210 <RoundAutoCompleteCommandWithTheSamePrefix>
f0102b9b:	83 c4 20             	add    $0x20,%esp
f0102b9e:	e9 77 02 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0102ba3:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0102baa:	75 2e                	jne    f0102bda <command_prompt_readline+0x8db>
			if (i > 0) {
f0102bac:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102bb2:	85 c0                	test   %eax,%eax
f0102bb4:	0f 8e 60 02 00 00    	jle    f0102e1a <command_prompt_readline+0xb1b>
				i--;
f0102bba:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102bc0:	48                   	dec    %eax
f0102bc1:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0102bc7:	83 ec 0c             	sub    $0xc,%esp
f0102bca:	ff 75 94             	pushl  -0x6c(%ebp)
f0102bcd:	e8 24 ee ff ff       	call   f01019f6 <cputchar>
f0102bd2:	83 c4 10             	add    $0x10,%esp
f0102bd5:	e9 40 02 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0102bda:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0102be1:	75 34                	jne    f0102c17 <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0102be3:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0102be9:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102bef:	39 c2                	cmp    %eax,%edx
f0102bf1:	0f 8d 23 02 00 00    	jge    f0102e1a <command_prompt_readline+0xb1b>
				i++;
f0102bf7:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102bfd:	40                   	inc    %eax
f0102bfe:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0102c04:	83 ec 0c             	sub    $0xc,%esp
f0102c07:	ff 75 94             	pushl  -0x6c(%ebp)
f0102c0a:	e8 e7 ed ff ff       	call   f01019f6 <cputchar>
f0102c0f:	83 c4 10             	add    $0x10,%esp
f0102c12:	e9 03 02 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0102c17:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0102c1e:	75 4c                	jne    f0102c6c <command_prompt_readline+0x96d>
f0102c20:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	7e 42                	jle    f0102c6c <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0102c2a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102c30:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0102c33:	eb 1a                	jmp    f0102c4f <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0102c35:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0102c38:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c3b:	01 c2                	add    %eax,%edx
f0102c3d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0102c40:	8d 48 01             	lea    0x1(%eax),%ecx
f0102c43:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c46:	01 c8                	add    %ecx,%eax
f0102c48:	8a 00                	mov    (%eax),%al
f0102c4a:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0102c4c:	ff 45 a4             	incl   -0x5c(%ebp)
f0102c4f:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102c55:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0102c58:	7e db                	jle    f0102c35 <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0102c5a:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102c60:	48                   	dec    %eax
f0102c61:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102c67:	e9 ae 01 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0102c6c:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0102c70:	7e 60                	jle    f0102cd2 <command_prompt_readline+0x9d3>
f0102c72:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102c78:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0102c7d:	7f 53                	jg     f0102cd2 <command_prompt_readline+0x9d3>
f0102c7f:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0102c86:	74 4a                	je     f0102cd2 <command_prompt_readline+0x9d3>
f0102c88:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0102c8f:	74 41                	je     f0102cd2 <command_prompt_readline+0x9d3>
			if (echoing)
f0102c91:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0102c95:	74 0e                	je     f0102ca5 <command_prompt_readline+0x9a6>
				cputchar(c);
f0102c97:	83 ec 0c             	sub    $0xc,%esp
f0102c9a:	ff 75 94             	pushl  -0x6c(%ebp)
f0102c9d:	e8 54 ed ff ff       	call   f01019f6 <cputchar>
f0102ca2:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0102ca5:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102cab:	8d 50 01             	lea    0x1(%eax),%edx
f0102cae:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0102cb4:	89 c2                	mov    %eax,%edx
f0102cb6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102cb9:	01 d0                	add    %edx,%eax
f0102cbb:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0102cbe:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0102cc0:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102cc6:	40                   	inc    %eax
f0102cc7:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102ccd:	e9 48 01 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0102cd2:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0102cd6:	75 60                	jne    f0102d38 <command_prompt_readline+0xa39>
f0102cd8:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102cde:	85 c0                	test   %eax,%eax
f0102ce0:	7e 56                	jle    f0102d38 <command_prompt_readline+0xa39>

			if (echoing)
f0102ce2:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0102ce6:	74 0e                	je     f0102cf6 <command_prompt_readline+0x9f7>
				cputchar(c);
f0102ce8:	83 ec 0c             	sub    $0xc,%esp
f0102ceb:	ff 75 94             	pushl  -0x6c(%ebp)
f0102cee:	e8 03 ed ff ff       	call   f01019f6 <cputchar>
f0102cf3:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0102cf6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102cfc:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0102cff:	eb 1a                	jmp    f0102d1b <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0102d01:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0102d04:	8d 50 ff             	lea    -0x1(%eax),%edx
f0102d07:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d0a:	01 c2                	add    %eax,%edx
f0102d0c:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0102d0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d12:	01 c8                	add    %ecx,%eax
f0102d14:	8a 00                	mov    (%eax),%al
f0102d16:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0102d18:	ff 45 a0             	incl   -0x60(%ebp)
f0102d1b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102d21:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0102d24:	7e db                	jle    f0102d01 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0102d26:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102d2c:	48                   	dec    %eax
f0102d2d:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0102d33:	e9 e2 00 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0102d38:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0102d3c:	74 0a                	je     f0102d48 <command_prompt_readline+0xa49>
f0102d3e:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0102d42:	0f 85 d2 00 00 00    	jne    f0102e1a <command_prompt_readline+0xb1b>

			if (echoing)
f0102d48:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0102d4c:	74 0e                	je     f0102d5c <command_prompt_readline+0xa5d>
				cputchar(c);
f0102d4e:	83 ec 0c             	sub    $0xc,%esp
f0102d51:	ff 75 94             	pushl  -0x6c(%ebp)
f0102d54:	e8 9d ec ff ff       	call   f01019f6 <cputchar>
f0102d59:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0102d5c:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102d62:	89 c2                	mov    %eax,%edx
f0102d64:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d67:	01 d0                	add    %edx,%eax
f0102d69:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0102d6c:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102d71:	83 f8 13             	cmp    $0x13,%eax
f0102d74:	75 56                	jne    f0102dcc <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0102d76:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0102d7d:	eb 2d                	jmp    f0102dac <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0102d7f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0102d82:	40                   	inc    %eax
f0102d83:	c1 e0 0a             	shl    $0xa,%eax
f0102d86:	8d 90 e0 f4 86 f0    	lea    -0xf790b20(%eax),%edx
f0102d8c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0102d8f:	c1 e0 0a             	shl    $0xa,%eax
f0102d92:	05 e0 f4 86 f0       	add    $0xf086f4e0,%eax
f0102d97:	83 ec 04             	sub    $0x4,%esp
f0102d9a:	68 00 04 00 00       	push   $0x400
f0102d9f:	52                   	push   %edx
f0102da0:	50                   	push   %eax
f0102da1:	e8 68 7f 01 00       	call   f011ad0e <memcpy>
f0102da6:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0102da9:	ff 45 9c             	incl   -0x64(%ebp)
f0102dac:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0102db0:	7e cd                	jle    f0102d7f <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0102db2:	83 ec 04             	sub    $0x4,%esp
f0102db5:	68 00 04 00 00       	push   $0x400
f0102dba:	ff 75 0c             	pushl  0xc(%ebp)
f0102dbd:	68 e0 40 87 f0       	push   $0xf08740e0
f0102dc2:	e8 47 7f 01 00       	call   f011ad0e <memcpy>
f0102dc7:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0102dca:	eb 68                	jmp    f0102e34 <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0102dcc:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102dd1:	c1 e0 0a             	shl    $0xa,%eax
f0102dd4:	05 e0 f4 86 f0       	add    $0xf086f4e0,%eax
f0102dd9:	83 ec 08             	sub    $0x8,%esp
f0102ddc:	ff 75 0c             	pushl  0xc(%ebp)
f0102ddf:	50                   	push   %eax
f0102de0:	e8 a4 7d 01 00       	call   f011ab89 <strcmp>
f0102de5:	83 c4 10             	add    $0x10,%esp
f0102de8:	85 c0                	test   %eax,%eax
f0102dea:	74 48                	je     f0102e34 <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0102dec:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102df1:	40                   	inc    %eax
f0102df2:	a3 50 f5 17 f0       	mov    %eax,0xf017f550
f0102df7:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102dfc:	c1 e0 0a             	shl    $0xa,%eax
f0102dff:	05 e0 f4 86 f0       	add    $0xf086f4e0,%eax
f0102e04:	83 ec 04             	sub    $0x4,%esp
f0102e07:	68 00 04 00 00       	push   $0x400
f0102e0c:	ff 75 0c             	pushl  0xc(%ebp)
f0102e0f:	50                   	push   %eax
f0102e10:	e8 f9 7e 01 00       	call   f011ad0e <memcpy>
f0102e15:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0102e18:	eb 1a                	jmp    f0102e34 <command_prompt_readline+0xb35>

		}
		last_c = c;
f0102e1a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0102e1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0102e20:	e9 44 f5 ff ff       	jmp    f0102369 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0102e25:	90                   	nop
f0102e26:	e9 3e f5 ff ff       	jmp    f0102369 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0102e2b:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0102e2c:	e9 38 f5 ff ff       	jmp    f0102369 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0102e31:	90                   	nop
f0102e32:	eb 01                	jmp    f0102e35 <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0102e34:	90                   	nop

		}
		last_c = c;
	}
}
f0102e35:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102e38:	5b                   	pop    %ebx
f0102e39:	5f                   	pop    %edi
f0102e3a:	5d                   	pop    %ebp
f0102e3b:	c3                   	ret    

f0102e3c <set_kheap_strategy>:
uint32 kheapPageAllocStart ;
uint32 kheapPageAllocBreak ;
uint32 kheapPlacementStrategy;

/*2025*/ //Replaced by setter & getter function
static inline void set_kheap_strategy(uint32 strategy){kheapPlacementStrategy = strategy;}
f0102e3c:	55                   	push   %ebp
f0102e3d:	89 e5                	mov    %esp,%ebp
f0102e3f:	8b 45 08             	mov    0x8(%ebp),%eax
f0102e42:	a3 24 60 85 f0       	mov    %eax,0xf0856024
f0102e47:	90                   	nop
f0102e48:	5d                   	pop    %ebp
f0102e49:	c3                   	ret    

f0102e4a <get_kheap_strategy>:
static inline uint32 get_kheap_strategy(){return kheapPlacementStrategy ;}
f0102e4a:	55                   	push   %ebp
f0102e4b:	89 e5                	mov    %esp,%ebp
f0102e4d:	a1 24 60 85 f0       	mov    0xf0856024,%eax
f0102e52:	5d                   	pop    %ebp
f0102e53:	c3                   	ret    

f0102e54 <set_uheap_strategy>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;
/*2025*/ //Replaced by setter & getter function
static inline void set_uheap_strategy(uint32 strategy){_UHeapPlacementStrategy = strategy;}
f0102e54:	55                   	push   %ebp
f0102e55:	89 e5                	mov    %esp,%ebp
f0102e57:	8b 45 08             	mov    0x8(%ebp),%eax
f0102e5a:	a3 48 61 85 f0       	mov    %eax,0xf0856148
f0102e5f:	90                   	nop
f0102e60:	5d                   	pop    %ebp
f0102e61:	c3                   	ret    

f0102e62 <get_uheap_strategy>:
static inline uint32 get_uheap_strategy(){return _UHeapPlacementStrategy ;}
f0102e62:	55                   	push   %ebp
f0102e63:	89 e5                	mov    %esp,%ebp
f0102e65:	a1 48 61 85 f0       	mov    0xf0856148,%eax
f0102e6a:	5d                   	pop    %ebp
f0102e6b:	c3                   	ret    

f0102e6c <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102e6c:	55                   	push   %ebp
f0102e6d:	89 e5                	mov    %esp,%ebp
f0102e6f:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102e72:	8b 45 08             	mov    0x8(%ebp),%eax
f0102e75:	c1 e8 0c             	shr    $0xc,%eax
f0102e78:	89 c2                	mov    %eax,%edx
f0102e7a:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f0102e7f:	39 c2                	cmp    %eax,%edx
f0102e81:	72 14                	jb     f0102e97 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0102e83:	83 ec 04             	sub    $0x4,%esp
f0102e86:	68 e8 b9 12 f0       	push   $0xf012b9e8
f0102e8b:	6a 4e                	push   $0x4e
f0102e8d:	68 10 ba 12 f0       	push   $0xf012ba10
f0102e92:	e8 18 e0 ff ff       	call   f0100eaf <_panic>
	return &frames_info[PPN(physical_address)];
f0102e97:	8b 15 68 61 85 f0    	mov    0xf0856168,%edx
f0102e9d:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ea0:	c1 e8 0c             	shr    $0xc,%eax
f0102ea3:	89 c1                	mov    %eax,%ecx
f0102ea5:	89 c8                	mov    %ecx,%eax
f0102ea7:	c1 e0 02             	shl    $0x2,%eax
f0102eaa:	01 c8                	add    %ecx,%eax
f0102eac:	c1 e0 02             	shl    $0x2,%eax
f0102eaf:	01 d0                	add    %edx,%eax
}
f0102eb1:	c9                   	leave  
f0102eb2:	c3                   	ret    

f0102eb3 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102eb3:	55                   	push   %ebp
f0102eb4:	89 e5                	mov    %esp,%ebp
f0102eb6:	53                   	push   %ebx
f0102eb7:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102eba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102ec1:	eb 3b                	jmp    f0102efe <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102ec3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102ec6:	89 d0                	mov    %edx,%eax
f0102ec8:	01 c0                	add    %eax,%eax
f0102eca:	01 d0                	add    %edx,%eax
f0102ecc:	c1 e0 03             	shl    $0x3,%eax
f0102ecf:	05 64 f5 17 f0       	add    $0xf017f564,%eax
f0102ed4:	8b 10                	mov    (%eax),%edx
f0102ed6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102ed9:	89 c8                	mov    %ecx,%eax
f0102edb:	01 c0                	add    %eax,%eax
f0102edd:	01 c8                	add    %ecx,%eax
f0102edf:	c1 e0 03             	shl    $0x3,%eax
f0102ee2:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f0102ee7:	8b 00                	mov    (%eax),%eax
f0102ee9:	83 ec 04             	sub    $0x4,%esp
f0102eec:	52                   	push   %edx
f0102eed:	50                   	push   %eax
f0102eee:	68 4b c9 12 f0       	push   $0xf012c94b
f0102ef3:	e8 64 ec ff ff       	call   f0101b5c <cprintf>
f0102ef8:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102efb:	ff 45 f4             	incl   -0xc(%ebp)
f0102efe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102f01:	a1 a8 fb 17 f0       	mov    0xf017fba8,%eax
f0102f06:	39 c2                	cmp    %eax,%edx
f0102f08:	72 b9                	jb     f0102ec3 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f0102f0a:	83 ec 0c             	sub    $0xc,%esp
f0102f0d:	68 54 c9 12 f0       	push   $0xf012c954
f0102f12:	e8 45 ec ff ff       	call   f0101b5c <cprintf>
f0102f17:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102f1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102f21:	eb 42                	jmp    f0102f65 <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f0102f23:	8b 0d 9c 00 18 f0    	mov    0xf018009c,%ecx
f0102f29:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102f2c:	89 d0                	mov    %edx,%eax
f0102f2e:	01 c0                	add    %eax,%eax
f0102f30:	01 d0                	add    %edx,%eax
f0102f32:	c1 e0 02             	shl    $0x2,%eax
f0102f35:	01 c8                	add    %ecx,%eax
f0102f37:	8b 50 04             	mov    0x4(%eax),%edx
f0102f3a:	8b 1d 9c 00 18 f0    	mov    0xf018009c,%ebx
f0102f40:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102f43:	89 c8                	mov    %ecx,%eax
f0102f45:	01 c0                	add    %eax,%eax
f0102f47:	01 c8                	add    %ecx,%eax
f0102f49:	c1 e0 02             	shl    $0x2,%eax
f0102f4c:	01 d8                	add    %ebx,%eax
f0102f4e:	8b 00                	mov    (%eax),%eax
f0102f50:	83 ec 04             	sub    $0x4,%esp
f0102f53:	52                   	push   %edx
f0102f54:	50                   	push   %eax
f0102f55:	68 69 c9 12 f0       	push   $0xf012c969
f0102f5a:	e8 fd eb ff ff       	call   f0101b5c <cprintf>
f0102f5f:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102f62:	ff 45 f4             	incl   -0xc(%ebp)
f0102f65:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f0102f6a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102f6d:	7c b4                	jl     f0102f23 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102f6f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102f74:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102f77:	c9                   	leave  
f0102f78:	c3                   	ret    

f0102f79 <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f0102f79:	55                   	push   %ebp
f0102f7a:	89 e5                	mov    %esp,%ebp
f0102f7c:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102f7f:	83 ec 0c             	sub    $0xc,%esp
f0102f82:	68 85 c9 12 f0       	push   $0xf012c985
f0102f87:	e8 d0 eb ff ff       	call   f0101b5c <cprintf>
f0102f8c:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102f8f:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f0102f94:	83 ec 04             	sub    $0x4,%esp
f0102f97:	50                   	push   %eax
f0102f98:	68 0c 00 10 f0       	push   $0xf010000c
f0102f9d:	68 a0 c9 12 f0       	push   $0xf012c9a0
f0102fa2:	e8 b5 eb ff ff       	call   f0101b5c <cprintf>
f0102fa7:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102faa:	b8 8d bb 11 00       	mov    $0x11bb8d,%eax
f0102faf:	83 ec 04             	sub    $0x4,%esp
f0102fb2:	50                   	push   %eax
f0102fb3:	68 8d bb 11 f0       	push   $0xf011bb8d
f0102fb8:	68 dc c9 12 f0       	push   $0xf012c9dc
f0102fbd:	e8 9a eb ff ff       	call   f0101b5c <cprintf>
f0102fc2:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f0102fc5:	b8 9c 4f 81 00       	mov    $0x814f9c,%eax
f0102fca:	83 ec 04             	sub    $0x4,%esp
f0102fcd:	50                   	push   %eax
f0102fce:	68 9c 4f 81 f0       	push   $0xf0814f9c
f0102fd3:	68 18 ca 12 f0       	push   $0xf012ca18
f0102fd8:	e8 7f eb ff ff       	call   f0101b5c <cprintf>
f0102fdd:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f0102fe0:	b8 30 cd 87 00       	mov    $0x87cd30,%eax
f0102fe5:	83 ec 04             	sub    $0x4,%esp
f0102fe8:	50                   	push   %eax
f0102fe9:	68 30 cd 87 f0       	push   $0xf087cd30
f0102fee:	68 60 ca 12 f0       	push   $0xf012ca60
f0102ff3:	e8 64 eb ff ff       	call   f0101b5c <cprintf>
f0102ff8:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f0102ffb:	b8 30 cd 87 f0       	mov    $0xf087cd30,%eax
f0103000:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f0103006:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f010300b:	29 c2                	sub    %eax,%edx
f010300d:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f010300f:	85 c0                	test   %eax,%eax
f0103011:	79 05                	jns    f0103018 <command_kernel_info+0x9f>
f0103013:	05 ff 03 00 00       	add    $0x3ff,%eax
f0103018:	c1 f8 0a             	sar    $0xa,%eax
f010301b:	83 ec 08             	sub    $0x8,%esp
f010301e:	50                   	push   %eax
f010301f:	68 9c ca 12 f0       	push   $0xf012ca9c
f0103024:	e8 33 eb ff ff       	call   f0101b5c <cprintf>
f0103029:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f010302c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103031:	c9                   	leave  
f0103032:	c3                   	ret    

f0103033 <command_writemem_k>:
//*****************************************************************************************//
//===========================================================================
//Lab2.Examples
//=============
int command_writemem_k(int number_of_arguments, char **arguments)
{
f0103033:	55                   	push   %ebp
f0103034:	89 e5                	mov    %esp,%ebp
f0103036:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB2 Example: corresponding command name is "wm"

	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0103039:	8b 45 0c             	mov    0xc(%ebp),%eax
f010303c:	83 c0 04             	add    $0x4,%eax
f010303f:	8b 00                	mov    (%eax),%eax
f0103041:	83 ec 04             	sub    $0x4,%esp
f0103044:	6a 10                	push   $0x10
f0103046:	6a 00                	push   $0x0
f0103048:	50                   	push   %eax
f0103049:	e8 3e 7e 01 00       	call   f011ae8c <strtol>
f010304e:	83 c4 10             	add    $0x10,%esp
f0103051:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0103056:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int stringLen = strlen(arguments[2]);
f0103059:	8b 45 0c             	mov    0xc(%ebp),%eax
f010305c:	83 c0 08             	add    $0x8,%eax
f010305f:	8b 00                	mov    (%eax),%eax
f0103061:	83 ec 0c             	sub    $0xc,%esp
f0103064:	50                   	push   %eax
f0103065:	e8 13 7a 01 00       	call   f011aa7d <strlen>
f010306a:	83 c4 10             	add    $0x10,%esp
f010306d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(int i=0;i < stringLen; i++)
f0103070:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0103077:	eb 1c                	jmp    f0103095 <command_writemem_k+0x62>
	{
		*address = arguments[2][i];
f0103079:	8b 45 0c             	mov    0xc(%ebp),%eax
f010307c:	83 c0 08             	add    $0x8,%eax
f010307f:	8b 10                	mov    (%eax),%edx
f0103081:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103084:	01 d0                	add    %edx,%eax
f0103086:	8a 00                	mov    (%eax),%al
f0103088:	88 c2                	mov    %al,%dl
f010308a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010308d:	88 10                	mov    %dl,(%eax)
		address++;
f010308f:	ff 45 f4             	incl   -0xc(%ebp)
	//TODO: LAB2 Example: corresponding command name is "wm"

	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int stringLen = strlen(arguments[2]);

	for(int i=0;i < stringLen; i++)
f0103092:	ff 45 f0             	incl   -0x10(%ebp)
f0103095:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103098:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010309b:	7c dc                	jl     f0103079 <command_writemem_k+0x46>
	{
		*address = arguments[2][i];
		address++;
	}
	return 0;
f010309d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01030a2:	c9                   	leave  
f01030a3:	c3                   	ret    

f01030a4 <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f01030a4:	55                   	push   %ebp
f01030a5:	89 e5                	mov    %esp,%ebp
f01030a7:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB2 Example: corresponding command name is "rm"

	unsigned int address = strtol(arguments[1], NULL, 16);
f01030aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030ad:	83 c0 04             	add    $0x4,%eax
f01030b0:	8b 00                	mov    (%eax),%eax
f01030b2:	83 ec 04             	sub    $0x4,%esp
f01030b5:	6a 10                	push   $0x10
f01030b7:	6a 00                	push   $0x0
f01030b9:	50                   	push   %eax
f01030ba:	e8 cd 7d 01 00       	call   f011ae8c <strtol>
f01030bf:	83 c4 10             	add    $0x10,%esp
f01030c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unsigned char *ptr = (unsigned char *)(address + KERNEL_BASE) ;
f01030c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01030c8:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01030cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//Read value at the given address
	cprintf("value at virtual address %x = %c\n", ptr, *ptr);
f01030d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01030d3:	8a 00                	mov    (%eax),%al
f01030d5:	0f b6 c0             	movzbl %al,%eax
f01030d8:	83 ec 04             	sub    $0x4,%esp
f01030db:	50                   	push   %eax
f01030dc:	ff 75 f0             	pushl  -0x10(%ebp)
f01030df:	68 c8 ca 12 f0       	push   $0xf012cac8
f01030e4:	e8 73 ea ff ff       	call   f0101b5c <cprintf>
f01030e9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01030ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01030f1:	c9                   	leave  
f01030f2:	c3                   	ret    

f01030f3 <command_get_page_table>:

//===========================================================================
//Lab3.Examples
//=============
int command_get_page_table(int number_of_arguments, char **arguments)
{
f01030f3:	55                   	push   %ebp
f01030f4:	89 e5                	mov    %esp,%ebp
f01030f6:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#1,2: fill this function. corresponding command name is "gpt"
	//Comment the following line
	panic("Function is not implemented yet!");
f01030f9:	83 ec 04             	sub    $0x4,%esp
f01030fc:	68 ec ca 12 f0       	push   $0xf012caec
f0103101:	68 cd 00 00 00       	push   $0xcd
f0103106:	68 0d cb 12 f0       	push   $0xf012cb0d
f010310b:	e8 9f dd ff ff       	call   f0100eaf <_panic>

f0103110 <command_kernel_base_info>:

	return 0;
}

int command_kernel_base_info(int number_of_arguments, char **arguments)
{
f0103110:	55                   	push   %ebp
f0103111:	89 e5                	mov    %esp,%ebp
f0103113:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#3: fill this function. corresponding command name is "ikb"
	//Comment the following line
	panic("Function is not implemented yet!");
f0103116:	83 ec 04             	sub    $0x4,%esp
f0103119:	68 ec ca 12 f0       	push   $0xf012caec
f010311e:	68 d6 00 00 00       	push   $0xd6
f0103123:	68 0d cb 12 f0       	push   $0xf012cb0d
f0103128:	e8 82 dd ff ff       	call   f0100eaf <_panic>

f010312d <command_del_kernel_base>:

	return 0;
}

int command_del_kernel_base(int number_of_arguments, char **arguments)
{
f010312d:	55                   	push   %ebp
f010312e:	89 e5                	mov    %esp,%ebp
f0103130:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#4: fill this function. corresponding command name is "dkb"
	//Comment the following line
	panic("Function is not implemented yet!");
f0103133:	83 ec 04             	sub    $0x4,%esp
f0103136:	68 ec ca 12 f0       	push   $0xf012caec
f010313b:	68 df 00 00 00       	push   $0xdf
f0103140:	68 0d cb 12 f0       	push   $0xf012cb0d
f0103145:	e8 65 dd ff ff       	call   f0100eaf <_panic>

f010314a <command_share_page>:

	return 0;
}

int command_share_page(int number_of_arguments, char **arguments)
{
f010314a:	55                   	push   %ebp
f010314b:	89 e5                	mov    %esp,%ebp
f010314d:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#5: fill this function. corresponding command name is "shr"
	//Comment the following line
	panic("Function is not implemented yet!");
f0103150:	83 ec 04             	sub    $0x4,%esp
f0103153:	68 ec ca 12 f0       	push   $0xf012caec
f0103158:	68 e8 00 00 00       	push   $0xe8
f010315d:	68 0d cb 12 f0       	push   $0xf012cb0d
f0103162:	e8 48 dd ff ff       	call   f0100eaf <_panic>

f0103167 <command_nr>:
//===========================================================================
//Lab4.Examples
//==============
//[1] Number of references on the given physical address
int command_nr(int number_of_arguments, char **arguments)
{
f0103167:	55                   	push   %ebp
f0103168:	89 e5                	mov    %esp,%ebp
f010316a:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#1: corresponding command name is "nr"

	uint32 pa  = strtol(arguments[1], NULL, 16);
f010316d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103170:	83 c0 04             	add    $0x4,%eax
f0103173:	8b 00                	mov    (%eax),%eax
f0103175:	83 ec 04             	sub    $0x4,%esp
f0103178:	6a 10                	push   $0x10
f010317a:	6a 00                	push   $0x0
f010317c:	50                   	push   %eax
f010317d:	e8 0a 7d 01 00       	call   f011ae8c <strtol>
f0103182:	83 c4 10             	add    $0x10,%esp
f0103185:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int num_of_ref = num_of_references(pa);
f0103188:	83 ec 0c             	sub    $0xc,%esp
f010318b:	ff 75 f4             	pushl  -0xc(%ebp)
f010318e:	e8 9c 6b 00 00       	call   f0109d2f <num_of_references>
f0103193:	83 c4 10             	add    $0x10,%esp
f0103196:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("Num of ref's @ pa %x = %d\n", pa, num_of_ref);
f0103199:	83 ec 04             	sub    $0x4,%esp
f010319c:	ff 75 f0             	pushl  -0x10(%ebp)
f010319f:	ff 75 f4             	pushl  -0xc(%ebp)
f01031a2:	68 21 cb 12 f0       	push   $0xf012cb21
f01031a7:	e8 b0 e9 ff ff       	call   f0101b5c <cprintf>
f01031ac:	83 c4 10             	add    $0x10,%esp
	return 0;
f01031af:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031b4:	c9                   	leave  
f01031b5:	c3                   	ret    

f01031b6 <command_ap>:

//[2] Allocate Page
int command_ap(int number_of_arguments, char **arguments)
{
f01031b6:	55                   	push   %ebp
f01031b7:	89 e5                	mov    %esp,%ebp
f01031b9:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#2: corresponding command name is "ap"

	uint32 va = strtol(arguments[1], NULL, 16);
f01031bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031bf:	83 c0 04             	add    $0x4,%eax
f01031c2:	8b 00                	mov    (%eax),%eax
f01031c4:	83 ec 04             	sub    $0x4,%esp
f01031c7:	6a 10                	push   $0x10
f01031c9:	6a 00                	push   $0x0
f01031cb:	50                   	push   %eax
f01031cc:	e8 bb 7c 01 00       	call   f011ae8c <strtol>
f01031d1:	83 c4 10             	add    $0x10,%esp
f01031d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	bool set_to_zero = 0;
f01031d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (number_of_arguments == 3)
f01031de:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01031e2:	75 15                	jne    f01031f9 <command_ap+0x43>
	{
		if (arguments[2][0] == '0')
f01031e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031e7:	83 c0 08             	add    $0x8,%eax
f01031ea:	8b 00                	mov    (%eax),%eax
f01031ec:	8a 00                	mov    (%eax),%al
f01031ee:	3c 30                	cmp    $0x30,%al
f01031f0:	75 07                	jne    f01031f9 <command_ap+0x43>
			set_to_zero = 1;
f01031f2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	int ret = alloc_page(ptr_page_directory, va, PERM_USER | PERM_WRITEABLE, set_to_zero);
f01031f9:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01031fe:	ff 75 f4             	pushl  -0xc(%ebp)
f0103201:	6a 06                	push   $0x6
f0103203:	ff 75 f0             	pushl  -0x10(%ebp)
f0103206:	50                   	push   %eax
f0103207:	e8 45 6b 00 00       	call   f0109d51 <alloc_page>
f010320c:	83 c4 10             	add    $0x10,%esp
f010320f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (ret == 1)
f0103212:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
f0103216:	75 15                	jne    f010322d <command_ap+0x77>
	{
		cprintf("Page @ va %x already exists!\n", va);
f0103218:	83 ec 08             	sub    $0x8,%esp
f010321b:	ff 75 f0             	pushl  -0x10(%ebp)
f010321e:	68 3c cb 12 f0       	push   $0xf012cb3c
f0103223:	e8 34 e9 ff ff       	call   f0101b5c <cprintf>
f0103228:	83 c4 10             	add    $0x10,%esp
f010322b:	eb 41                	jmp    f010326e <command_ap+0xb8>
	}
	else if (ret == E_NO_MEM)
f010322d:	83 7d ec fc          	cmpl   $0xfffffffc,-0x14(%ebp)
f0103231:	75 12                	jne    f0103245 <command_ap+0x8f>
	{
		cprintf("No enough memory!\n");
f0103233:	83 ec 0c             	sub    $0xc,%esp
f0103236:	68 5a cb 12 f0       	push   $0xf012cb5a
f010323b:	e8 1c e9 ff ff       	call   f0101b5c <cprintf>
f0103240:	83 c4 10             	add    $0x10,%esp
f0103243:	eb 29                	jmp    f010326e <command_ap+0xb8>
	}
	else
	{
		cprintf("New page is allocated @ va %x\n", va);
f0103245:	83 ec 08             	sub    $0x8,%esp
f0103248:	ff 75 f0             	pushl  -0x10(%ebp)
f010324b:	68 70 cb 12 f0       	push   $0xf012cb70
f0103250:	e8 07 e9 ff ff       	call   f0101b5c <cprintf>
f0103255:	83 c4 10             	add    $0x10,%esp
		if (set_to_zero)
f0103258:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010325c:	74 10                	je     f010326e <command_ap+0xb8>
			cprintf("and initialized by ZERO\n");
f010325e:	83 ec 0c             	sub    $0xc,%esp
f0103261:	68 8f cb 12 f0       	push   $0xf012cb8f
f0103266:	e8 f1 e8 ff ff       	call   f0101b5c <cprintf>
f010326b:	83 c4 10             	add    $0x10,%esp
	}
	return 0 ;
f010326e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103273:	c9                   	leave  
f0103274:	c3                   	ret    

f0103275 <command_fp>:

//[3] Free Page: Un-map a single page at the given virtual address in the user space
int command_fp(int number_of_arguments, char **arguments)
{
f0103275:	55                   	push   %ebp
f0103276:	89 e5                	mov    %esp,%ebp
f0103278:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#3: corresponding command name is "fp"

	uint32 va = strtol(arguments[1], NULL, 16);
f010327b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010327e:	83 c0 04             	add    $0x4,%eax
f0103281:	8b 00                	mov    (%eax),%eax
f0103283:	83 ec 04             	sub    $0x4,%esp
f0103286:	6a 10                	push   $0x10
f0103288:	6a 00                	push   $0x0
f010328a:	50                   	push   %eax
f010328b:	e8 fc 7b 01 00       	call   f011ae8c <strtol>
f0103290:	83 c4 10             	add    $0x10,%esp
f0103293:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unmap_frame(ptr_page_directory, va);
f0103296:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f010329b:	83 ec 08             	sub    $0x8,%esp
f010329e:	ff 75 f4             	pushl  -0xc(%ebp)
f01032a1:	50                   	push   %eax
f01032a2:	e8 ab 63 00 00       	call   f0109652 <unmap_frame>
f01032a7:	83 c4 10             	add    $0x10,%esp

	return 0;
f01032aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032af:	c9                   	leave  
f01032b0:	c3                   	ret    

f01032b1 <command_cfp>:
//===========================================================================
//Lab4.Hands-on
//==============
//Count Free Pages in Range
int command_cfp(int number_of_arguments, char **arguments)
{
f01032b1:	55                   	push   %ebp
f01032b2:	89 e5                	mov    %esp,%ebp
f01032b4:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Hands-on: corresponding command name is "cfp"

	uint32* dir_ptr = clone_kern_dir();
f01032b7:	e8 da 6e 01 00       	call   f011a196 <clone_kern_dir>
f01032bc:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 va1 = strtol(arguments[1], NULL, 16);
f01032bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032c2:	83 c0 04             	add    $0x4,%eax
f01032c5:	8b 00                	mov    (%eax),%eax
f01032c7:	83 ec 04             	sub    $0x4,%esp
f01032ca:	6a 10                	push   $0x10
f01032cc:	6a 00                	push   $0x0
f01032ce:	50                   	push   %eax
f01032cf:	e8 b8 7b 01 00       	call   f011ae8c <strtol>
f01032d4:	83 c4 10             	add    $0x10,%esp
f01032d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 va2 = strtol(arguments[2], NULL, 16);
f01032da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032dd:	83 c0 08             	add    $0x8,%eax
f01032e0:	8b 00                	mov    (%eax),%eax
f01032e2:	83 ec 04             	sub    $0x4,%esp
f01032e5:	6a 10                	push   $0x10
f01032e7:	6a 00                	push   $0x0
f01032e9:	50                   	push   %eax
f01032ea:	e8 9d 7b 01 00       	call   f011ae8c <strtol>
f01032ef:	83 c4 10             	add    $0x10,%esp
f01032f2:	89 45 ec             	mov    %eax,-0x14(%ebp)

	uint32 num_of_free = calculate_free_space(dir_ptr, va1, va2);
f01032f5:	83 ec 04             	sub    $0x4,%esp
f01032f8:	ff 75 ec             	pushl  -0x14(%ebp)
f01032fb:	ff 75 f0             	pushl  -0x10(%ebp)
f01032fe:	ff 75 f4             	pushl  -0xc(%ebp)
f0103301:	e8 e4 78 00 00       	call   f010abea <calculate_free_space>
f0103306:	83 c4 10             	add    $0x10,%esp
f0103309:	89 45 e8             	mov    %eax,-0x18(%ebp)

	cprintf("Num of free pages in va range [%x, %x) = %d\n", va1, va2, num_of_free);
f010330c:	ff 75 e8             	pushl  -0x18(%ebp)
f010330f:	ff 75 ec             	pushl  -0x14(%ebp)
f0103312:	ff 75 f0             	pushl  -0x10(%ebp)
f0103315:	68 a8 cb 12 f0       	push   $0xf012cba8
f010331a:	e8 3d e8 ff ff       	call   f0101b5c <cprintf>
f010331f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103322:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103327:	c9                   	leave  
f0103328:	c3                   	ret    

f0103329 <command_asp>:

//===========================================================================
//Lab5.Hands.On
//=============
int command_asp(int number_of_arguments, char **arguments)
{
f0103329:	55                   	push   %ebp
f010332a:	89 e5                	mov    %esp,%ebp
f010332c:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB5 Hands-on: corresponding command name is "asp"

	uint32* dir_ptr = clone_kern_dir();
f010332f:	e8 62 6e 01 00       	call   f011a196 <clone_kern_dir>
f0103334:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 va1 = strtol(arguments[1], NULL, 16);
f0103337:	8b 45 0c             	mov    0xc(%ebp),%eax
f010333a:	83 c0 04             	add    $0x4,%eax
f010333d:	8b 00                	mov    (%eax),%eax
f010333f:	83 ec 04             	sub    $0x4,%esp
f0103342:	6a 10                	push   $0x10
f0103344:	6a 00                	push   $0x0
f0103346:	50                   	push   %eax
f0103347:	e8 40 7b 01 00       	call   f011ae8c <strtol>
f010334c:	83 c4 10             	add    $0x10,%esp
f010334f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 va2 = strtol(arguments[2], NULL, 16);
f0103352:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103355:	83 c0 08             	add    $0x8,%eax
f0103358:	8b 00                	mov    (%eax),%eax
f010335a:	83 ec 04             	sub    $0x4,%esp
f010335d:	6a 10                	push   $0x10
f010335f:	6a 00                	push   $0x0
f0103361:	50                   	push   %eax
f0103362:	e8 25 7b 01 00       	call   f011ae8c <strtol>
f0103367:	83 c4 10             	add    $0x10,%esp
f010336a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int ret = alloc_shared_page(dir_ptr, va1, dir_ptr, va2, PERM_USER | PERM_WRITEABLE);
f010336d:	83 ec 0c             	sub    $0xc,%esp
f0103370:	6a 06                	push   $0x6
f0103372:	ff 75 ec             	pushl  -0x14(%ebp)
f0103375:	ff 75 f4             	pushl  -0xc(%ebp)
f0103378:	ff 75 f0             	pushl  -0x10(%ebp)
f010337b:	ff 75 f4             	pushl  -0xc(%ebp)
f010337e:	e8 71 6a 00 00       	call   f0109df4 <alloc_shared_page>
f0103383:	83 c4 20             	add    $0x20,%esp
f0103386:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0103389:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f010338d:	75 10                	jne    f010339f <command_asp+0x76>
	{
		cprintf("No enough memory!\n");
f010338f:	83 ec 0c             	sub    $0xc,%esp
f0103392:	68 5a cb 12 f0       	push   $0xf012cb5a
f0103397:	e8 c0 e7 ff ff       	call   f0101b5c <cprintf>
f010339c:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f010339f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033a4:	c9                   	leave  
f01033a5:	c3                   	ret    

f01033a6 <command_shmp>:

int command_shmp(int number_of_arguments, char **arguments)
{
f01033a6:	55                   	push   %ebp
f01033a7:	89 e5                	mov    %esp,%ebp
f01033a9:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB5 Hands-on: fill this function. corresponding command name is "sm"
	//Comment the following line
	panic("Function is not implemented yet!");
f01033ac:	83 ec 04             	sub    $0x4,%esp
f01033af:	68 ec ca 12 f0       	push   $0xf012caec
f01033b4:	68 4d 01 00 00       	push   $0x14d
f01033b9:	68 0d cb 12 f0       	push   $0xf012cb0d
f01033be:	e8 ec da ff ff       	call   f0100eaf <_panic>

f01033c3 <command_scp>:

	return 0 ;
}

int command_scp(int number_of_arguments, char **arguments)
{
f01033c3:	55                   	push   %ebp
f01033c4:	89 e5                	mov    %esp,%ebp
f01033c6:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB5 Hands-on: fill this function. corresponding command name is "sp"
	//Comment the following line
	panic("Function is not implemented yet!");
f01033c9:	83 ec 04             	sub    $0x4,%esp
f01033cc:	68 ec ca 12 f0       	push   $0xf012caec
f01033d1:	68 56 01 00 00       	push   $0x156
f01033d6:	68 0d cb 12 f0       	push   $0xf012cb0d
f01033db:	e8 cf da ff ff       	call   f0100eaf <_panic>

f01033e0 <command_shrr>:

	return 0 ;
}

int command_shrr(int number_of_arguments, char **arguments)
{
f01033e0:	55                   	push   %ebp
f01033e1:	89 e5                	mov    %esp,%ebp
f01033e3:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB5 Hands-on: fill this function. corresponding command name is "sr"
	//Comment the following line
	panic("Function is not implemented yet!");
f01033e6:	83 ec 04             	sub    $0x4,%esp
f01033e9:	68 ec ca 12 f0       	push   $0xf012caec
f01033ee:	68 5f 01 00 00       	push   $0x15f
f01033f3:	68 0d cb 12 f0       	push   $0xf012cb0d
f01033f8:	e8 b2 da ff ff       	call   f0100eaf <_panic>

f01033fd <command_v2p>:

	return 0;
}

int command_v2p(int number_of_arguments, char **arguments)
{
f01033fd:	55                   	push   %ebp
f01033fe:	89 e5                	mov    %esp,%ebp
f0103400:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB5 Hands-on: corresponding command name is "v2p"

	uint32 va = strtol(arguments[1], NULL, 16);
f0103403:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103406:	83 c0 04             	add    $0x4,%eax
f0103409:	8b 00                	mov    (%eax),%eax
f010340b:	83 ec 04             	sub    $0x4,%esp
f010340e:	6a 10                	push   $0x10
f0103410:	6a 00                	push   $0x0
f0103412:	50                   	push   %eax
f0103413:	e8 74 7a 01 00       	call   f011ae8c <strtol>
f0103418:	83 c4 10             	add    $0x10,%esp
f010341b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 pa = virtual_to_physical(ptr_page_directory, va);
f010341e:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0103423:	83 ec 08             	sub    $0x8,%esp
f0103426:	ff 75 f4             	pushl  -0xc(%ebp)
f0103429:	50                   	push   %eax
f010342a:	e8 cc 68 00 00       	call   f0109cfb <virtual_to_physical>
f010342f:	83 c4 10             	add    $0x10,%esp
f0103432:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pa == -1)
f0103435:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0103439:	75 12                	jne    f010344d <command_v2p+0x50>
		cprintf("NOT FOUND\n");
f010343b:	83 ec 0c             	sub    $0xc,%esp
f010343e:	68 d5 cb 12 f0       	push   $0xf012cbd5
f0103443:	e8 14 e7 ff ff       	call   f0101b5c <cprintf>
f0103448:	83 c4 10             	add    $0x10,%esp
f010344b:	eb 16                	jmp    f0103463 <command_v2p+0x66>
	else
		cprintf("PA of VA %x = %x\n", va, pa);
f010344d:	83 ec 04             	sub    $0x4,%esp
f0103450:	ff 75 f0             	pushl  -0x10(%ebp)
f0103453:	ff 75 f4             	pushl  -0xc(%ebp)
f0103456:	68 e0 cb 12 f0       	push   $0xf012cbe0
f010345b:	e8 fc e6 ff ff       	call   f0101b5c <cprintf>
f0103460:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103463:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103468:	c9                   	leave  
f0103469:	c3                   	ret    

f010346a <command_p2v>:

int command_p2v(int number_of_arguments, char **arguments)
{
f010346a:	55                   	push   %ebp
f010346b:	89 e5                	mov    %esp,%ebp
f010346d:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB5 Hands-on: corresponding command name is "p2v"

	uint32 pa = strtol(arguments[1], NULL, 16);
f0103470:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103473:	83 c0 04             	add    $0x4,%eax
f0103476:	8b 00                	mov    (%eax),%eax
f0103478:	83 ec 04             	sub    $0x4,%esp
f010347b:	6a 10                	push   $0x10
f010347d:	6a 00                	push   $0x0
f010347f:	50                   	push   %eax
f0103480:	e8 07 7a 01 00       	call   f011ae8c <strtol>
f0103485:	83 c4 10             	add    $0x10,%esp
f0103488:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 va = physical_to_virtual(ptr_page_directory, pa);
f010348b:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0103490:	83 ec 08             	sub    $0x8,%esp
f0103493:	ff 75 f4             	pushl  -0xc(%ebp)
f0103496:	50                   	push   %eax
f0103497:	e8 79 68 00 00       	call   f0109d15 <physical_to_virtual>
f010349c:	83 c4 10             	add    $0x10,%esp
f010349f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (va == 0xFFFFFFFF)
f01034a2:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f01034a6:	75 12                	jne    f01034ba <command_p2v+0x50>
		cprintf("NOT FOUND\n");
f01034a8:	83 ec 0c             	sub    $0xc,%esp
f01034ab:	68 d5 cb 12 f0       	push   $0xf012cbd5
f01034b0:	e8 a7 e6 ff ff       	call   f0101b5c <cprintf>
f01034b5:	83 c4 10             	add    $0x10,%esp
f01034b8:	eb 16                	jmp    f01034d0 <command_p2v+0x66>
	else
		cprintf("VA of PA %x = %x\n", pa, va);
f01034ba:	83 ec 04             	sub    $0x4,%esp
f01034bd:	ff 75 f0             	pushl  -0x10(%ebp)
f01034c0:	ff 75 f4             	pushl  -0xc(%ebp)
f01034c3:	68 f2 cb 12 f0       	push   $0xf012cbf2
f01034c8:	e8 8f e6 ff ff       	call   f0101b5c <cprintf>
f01034cd:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034d5:	c9                   	leave  
f01034d6:	c3                   	ret    

f01034d7 <command_ft>:

//===========================================================================
//Lab6.Examples
//=============
int command_ft(int number_of_arguments, char **arguments)
{
f01034d7:	55                   	push   %ebp
f01034d8:	89 e5                	mov    %esp,%ebp
f01034da:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB6 Example: corresponding command name is "ft"

	uint32 va = strtol(arguments[1], NULL, 16);
f01034dd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01034e0:	83 c0 04             	add    $0x4,%eax
f01034e3:	8b 00                	mov    (%eax),%eax
f01034e5:	83 ec 04             	sub    $0x4,%esp
f01034e8:	6a 10                	push   $0x10
f01034ea:	6a 00                	push   $0x0
f01034ec:	50                   	push   %eax
f01034ed:	e8 9a 79 01 00       	call   f011ae8c <strtol>
f01034f2:	83 c4 10             	add    $0x10,%esp
f01034f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	del_page_table(ptr_page_directory, va);
f01034f8:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01034fd:	83 ec 08             	sub    $0x8,%esp
f0103500:	ff 75 f4             	pushl  -0xc(%ebp)
f0103503:	50                   	push   %eax
f0103504:	e8 08 69 00 00       	call   f0109e11 <del_page_table>
f0103509:	83 c4 10             	add    $0x10,%esp

	return 0;
f010350c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103511:	c9                   	leave  
f0103512:	c3                   	ret    

f0103513 <command_writeusermem>:

//*****************************************************************************************//
//***************************** UTILITY/TESING COMMANDS ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0103513:	55                   	push   %ebp
f0103514:	89 e5                	mov    %esp,%ebp
f0103516:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f0103519:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010351d:	75 37                	jne    f0103556 <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f010351f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103522:	83 c0 04             	add    $0x4,%eax
f0103525:	8b 00                	mov    (%eax),%eax
f0103527:	83 ec 04             	sub    $0x4,%esp
f010352a:	6a 10                	push   $0x10
f010352c:	6a 00                	push   $0x0
f010352e:	50                   	push   %eax
f010352f:	e8 58 79 01 00       	call   f011ae8c <strtol>
f0103534:	83 c4 10             	add    $0x10,%esp
f0103537:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f010353a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010353d:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0103540:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103543:	83 c0 08             	add    $0x8,%eax
f0103546:	8b 00                	mov    (%eax),%eax
f0103548:	8a 00                	mov    (%eax),%al
f010354a:	88 c2                	mov    %al,%dl
f010354c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010354f:	88 10                	mov    %dl,(%eax)
f0103551:	e9 b9 00 00 00       	jmp    f010360f <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f0103556:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010355a:	0f 85 9f 00 00 00    	jne    f01035ff <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0103560:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103563:	83 c0 04             	add    $0x4,%eax
f0103566:	8b 00                	mov    (%eax),%eax
f0103568:	83 ec 04             	sub    $0x4,%esp
f010356b:	6a 0a                	push   $0xa
f010356d:	6a 00                	push   $0x0
f010356f:	50                   	push   %eax
f0103570:	e8 17 79 01 00       	call   f011ae8c <strtol>
f0103575:	83 c4 10             	add    $0x10,%esp
f0103578:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f010357b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0103582:	83 ec 04             	sub    $0x4,%esp
f0103585:	6a 00                	push   $0x0
f0103587:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010358a:	50                   	push   %eax
f010358b:	ff 75 f4             	pushl  -0xc(%ebp)
f010358e:	e8 d8 84 00 00       	call   f010ba6b <envid2env>
f0103593:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0103596:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103599:	83 c0 08             	add    $0x8,%eax
f010359c:	8b 00                	mov    (%eax),%eax
f010359e:	83 ec 04             	sub    $0x4,%esp
f01035a1:	6a 10                	push   $0x10
f01035a3:	6a 00                	push   $0x0
f01035a5:	50                   	push   %eax
f01035a6:	e8 e1 78 01 00       	call   f011ae8c <strtol>
f01035ab:	83 c4 10             	add    $0x10,%esp
f01035ae:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01035b1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01035b4:	85 c0                	test   %eax,%eax
f01035b6:	75 07                	jne    f01035bf <command_writeusermem+0xac>
f01035b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01035bd:	eb 55                	jmp    f0103614 <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01035bf:	0f 20 d8             	mov    %cr3,%eax
f01035c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01035c5:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01035c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01035cb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01035ce:	8b 40 68             	mov    0x68(%eax),%eax
f01035d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01035d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01035d7:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01035da:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01035dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01035e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01035e3:	83 c0 0c             	add    $0xc,%eax
f01035e6:	8b 00                	mov    (%eax),%eax
f01035e8:	8a 00                	mov    (%eax),%al
f01035ea:	88 c2                	mov    %al,%dl
f01035ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01035ef:	88 10                	mov    %dl,(%eax)
f01035f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01035f4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01035f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01035fa:	0f 22 d8             	mov    %eax,%cr3
f01035fd:	eb 10                	jmp    f010360f <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01035ff:	83 ec 0c             	sub    $0xc,%esp
f0103602:	68 04 cc 12 f0       	push   $0xf012cc04
f0103607:	e8 50 e5 ff ff       	call   f0101b5c <cprintf>
f010360c:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f010360f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103614:	c9                   	leave  
f0103615:	c3                   	ret    

f0103616 <command_readusermem>:


int command_readusermem(int number_of_arguments, char **arguments)
{
f0103616:	55                   	push   %ebp
f0103617:	89 e5                	mov    %esp,%ebp
f0103619:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010361c:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0103620:	75 42                	jne    f0103664 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0103622:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103625:	83 c0 04             	add    $0x4,%eax
f0103628:	8b 00                	mov    (%eax),%eax
f010362a:	83 ec 04             	sub    $0x4,%esp
f010362d:	6a 10                	push   $0x10
f010362f:	6a 00                	push   $0x0
f0103631:	50                   	push   %eax
f0103632:	e8 55 78 01 00       	call   f011ae8c <strtol>
f0103637:	83 c4 10             	add    $0x10,%esp
f010363a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f010363d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103640:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f0103643:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103646:	8a 00                	mov    (%eax),%al
f0103648:	0f b6 c0             	movzbl %al,%eax
f010364b:	83 ec 04             	sub    $0x4,%esp
f010364e:	50                   	push   %eax
f010364f:	ff 75 d8             	pushl  -0x28(%ebp)
f0103652:	68 2e cc 12 f0       	push   $0xf012cc2e
f0103657:	e8 00 e5 ff ff       	call   f0101b5c <cprintf>
f010365c:	83 c4 10             	add    $0x10,%esp
f010365f:	e9 c4 00 00 00       	jmp    f0103728 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f0103664:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0103668:	0f 85 aa 00 00 00    	jne    f0103718 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f010366e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103671:	83 c0 04             	add    $0x4,%eax
f0103674:	8b 00                	mov    (%eax),%eax
f0103676:	83 ec 04             	sub    $0x4,%esp
f0103679:	6a 0a                	push   $0xa
f010367b:	6a 00                	push   $0x0
f010367d:	50                   	push   %eax
f010367e:	e8 09 78 01 00       	call   f011ae8c <strtol>
f0103683:	83 c4 10             	add    $0x10,%esp
f0103686:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0103689:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0103690:	83 ec 04             	sub    $0x4,%esp
f0103693:	6a 00                	push   $0x0
f0103695:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0103698:	50                   	push   %eax
f0103699:	ff 75 f4             	pushl  -0xc(%ebp)
f010369c:	e8 ca 83 00 00       	call   f010ba6b <envid2env>
f01036a1:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f01036a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036a7:	83 c0 08             	add    $0x8,%eax
f01036aa:	8b 00                	mov    (%eax),%eax
f01036ac:	83 ec 04             	sub    $0x4,%esp
f01036af:	6a 10                	push   $0x10
f01036b1:	6a 00                	push   $0x0
f01036b3:	50                   	push   %eax
f01036b4:	e8 d3 77 01 00       	call   f011ae8c <strtol>
f01036b9:	83 c4 10             	add    $0x10,%esp
f01036bc:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01036bf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01036c2:	85 c0                	test   %eax,%eax
f01036c4:	75 07                	jne    f01036cd <command_readusermem+0xb7>
f01036c6:	b8 00 00 00 00       	mov    $0x0,%eax
f01036cb:	eb 60                	jmp    f010372d <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01036cd:	0f 20 d8             	mov    %cr3,%eax
f01036d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01036d3:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01036d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f01036d9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01036dc:	8b 40 68             	mov    0x68(%eax),%eax
f01036df:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01036e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01036e5:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01036e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01036eb:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f01036ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01036f1:	8a 00                	mov    (%eax),%al
f01036f3:	0f b6 c0             	movzbl %al,%eax
f01036f6:	83 ec 04             	sub    $0x4,%esp
f01036f9:	50                   	push   %eax
f01036fa:	ff 75 f0             	pushl  -0x10(%ebp)
f01036fd:	68 2e cc 12 f0       	push   $0xf012cc2e
f0103702:	e8 55 e4 ff ff       	call   f0101b5c <cprintf>
f0103707:	83 c4 10             	add    $0x10,%esp
f010370a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010370d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0103710:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0103713:	0f 22 d8             	mov    %eax,%cr3
f0103716:	eb 10                	jmp    f0103728 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0103718:	83 ec 0c             	sub    $0xc,%esp
f010371b:	68 48 cc 12 f0       	push   $0xf012cc48
f0103720:	e8 37 e4 ff ff       	call   f0101b5c <cprintf>
f0103725:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103728:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010372d:	c9                   	leave  
f010372e:	c3                   	ret    

f010372f <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f010372f:	55                   	push   %ebp
f0103730:	89 e5                	mov    %esp,%ebp
f0103732:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103735:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103738:	83 c0 04             	add    $0x4,%eax
f010373b:	8b 00                	mov    (%eax),%eax
f010373d:	83 ec 04             	sub    $0x4,%esp
f0103740:	6a 0a                	push   $0xa
f0103742:	6a 00                	push   $0x0
f0103744:	50                   	push   %eax
f0103745:	e8 42 77 01 00       	call   f011ae8c <strtol>
f010374a:	83 c4 10             	add    $0x10,%esp
f010374d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0103750:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0103757:	83 ec 04             	sub    $0x4,%esp
f010375a:	6a 00                	push   $0x0
f010375c:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010375f:	50                   	push   %eax
f0103760:	ff 75 ec             	pushl  -0x14(%ebp)
f0103763:	e8 03 83 00 00       	call   f010ba6b <envid2env>
f0103768:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f010376b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010376e:	83 c0 08             	add    $0x8,%eax
f0103771:	8b 00                	mov    (%eax),%eax
f0103773:	83 ec 04             	sub    $0x4,%esp
f0103776:	6a 10                	push   $0x10
f0103778:	6a 00                	push   $0x0
f010377a:	50                   	push   %eax
f010377b:	e8 0c 77 01 00       	call   f011ae8c <strtol>
f0103780:	83 c4 10             	add    $0x10,%esp
f0103783:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0103786:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103789:	83 c0 0c             	add    $0xc,%eax
f010378c:	8b 00                	mov    (%eax),%eax
f010378e:	83 ec 04             	sub    $0x4,%esp
f0103791:	6a 0a                	push   $0xa
f0103793:	6a 00                	push   $0x0
f0103795:	50                   	push   %eax
f0103796:	e8 f1 76 01 00       	call   f011ae8c <strtol>
f010379b:	83 c4 10             	add    $0x10,%esp
f010379e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f01037a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01037a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f01037a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01037aa:	85 c0                	test   %eax,%eax
f01037ac:	75 07                	jne    f01037b5 <command_readuserblock+0x86>
f01037ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01037b3:	eb 65                	jmp    f010381a <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01037b5:	0f 20 d8             	mov    %cr3,%eax
f01037b8:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f01037bb:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f01037be:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f01037c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01037c4:	8b 40 68             	mov    0x68(%eax),%eax
f01037c7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01037ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01037cd:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f01037d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01037d7:	eb 28                	jmp    f0103801 <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f01037d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01037dc:	8a 00                	mov    (%eax),%al
f01037de:	0f b6 d0             	movzbl %al,%edx
f01037e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01037e4:	8a 00                	mov    (%eax),%al
f01037e6:	0f b6 c0             	movzbl %al,%eax
f01037e9:	52                   	push   %edx
f01037ea:	50                   	push   %eax
f01037eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01037ee:	68 72 cc 12 f0       	push   $0xf012cc72
f01037f3:	e8 64 e3 ff ff       	call   f0101b5c <cprintf>
f01037f8:	83 c4 10             	add    $0x10,%esp
		ptr++;
f01037fb:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f01037fe:	ff 45 f0             	incl   -0x10(%ebp)
f0103801:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103804:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0103807:	7c d0                	jl     f01037d9 <command_readuserblock+0xaa>
f0103809:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010380c:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010380f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103812:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0103815:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010381a:	c9                   	leave  
f010381b:	c3                   	ret    

f010381c <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f010381c:	55                   	push   %ebp
f010381d:	89 e5                	mov    %esp,%ebp
f010381f:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103822:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103825:	83 c0 04             	add    $0x4,%eax
f0103828:	8b 00                	mov    (%eax),%eax
f010382a:	83 ec 04             	sub    $0x4,%esp
f010382d:	6a 0a                	push   $0xa
f010382f:	6a 00                	push   $0x0
f0103831:	50                   	push   %eax
f0103832:	e8 55 76 01 00       	call   f011ae8c <strtol>
f0103837:	83 c4 10             	add    $0x10,%esp
f010383a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f010383d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0103844:	83 ec 04             	sub    $0x4,%esp
f0103847:	6a 00                	push   $0x0
f0103849:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010384c:	50                   	push   %eax
f010384d:	ff 75 f4             	pushl  -0xc(%ebp)
f0103850:	e8 16 82 00 00       	call   f010ba6b <envid2env>
f0103855:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0103858:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010385b:	85 c0                	test   %eax,%eax
f010385d:	75 0a                	jne    f0103869 <command_remove_table+0x4d>
f010385f:	b8 00 00 00 00       	mov    $0x0,%eax
f0103864:	e9 c7 00 00 00       	jmp    f0103930 <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0103869:	8b 45 0c             	mov    0xc(%ebp),%eax
f010386c:	83 c0 08             	add    $0x8,%eax
f010386f:	8b 00                	mov    (%eax),%eax
f0103871:	83 ec 04             	sub    $0x4,%esp
f0103874:	6a 10                	push   $0x10
f0103876:	6a 00                	push   $0x0
f0103878:	50                   	push   %eax
f0103879:	e8 0e 76 01 00       	call   f011ae8c <strtol>
f010387e:	83 c4 10             	add    $0x10,%esp
f0103881:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0103884:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103887:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f010388a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010388d:	8b 40 64             	mov    0x64(%eax),%eax
f0103890:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103893:	c1 ea 16             	shr    $0x16,%edx
f0103896:	c1 e2 02             	shl    $0x2,%edx
f0103899:	01 d0                	add    %edx,%eax
f010389b:	8b 00                	mov    (%eax),%eax
f010389d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01038a2:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f01038a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01038a8:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f01038ad:	77 1c                	ja     f01038cb <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f01038af:	83 ec 0c             	sub    $0xc,%esp
f01038b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01038b5:	e8 b3 62 00 00       	call   f0109b6d <kheap_virtual_address>
f01038ba:	83 c4 10             	add    $0x10,%esp
f01038bd:	83 ec 0c             	sub    $0xc,%esp
f01038c0:	50                   	push   %eax
f01038c1:	e8 8d 62 00 00       	call   f0109b53 <kfree>
f01038c6:	83 c4 10             	add    $0x10,%esp
f01038c9:	eb 28                	jmp    f01038f3 <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f01038cb:	83 ec 0c             	sub    $0xc,%esp
f01038ce:	ff 75 e8             	pushl  -0x18(%ebp)
f01038d1:	e8 96 f5 ff ff       	call   f0102e6c <to_frame_info>
f01038d6:	83 c4 10             	add    $0x10,%esp
f01038d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f01038dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01038df:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f01038e5:	83 ec 0c             	sub    $0xc,%esp
f01038e8:	ff 75 e4             	pushl  -0x1c(%ebp)
f01038eb:	e8 7d 58 00 00       	call   f010916d <free_frame>
f01038f0:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f01038f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01038f6:	c1 e8 16             	shr    $0x16,%eax
f01038f9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f01038fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01038ff:	8b 40 64             	mov    0x64(%eax),%eax
f0103902:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0103905:	c1 e2 02             	shl    $0x2,%edx
f0103908:	01 c2                	add    %eax,%edx
f010390a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010390d:	8b 40 64             	mov    0x64(%eax),%eax
f0103910:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0103913:	c1 e1 02             	shl    $0x2,%ecx
f0103916:	01 c8                	add    %ecx,%eax
f0103918:	8b 00                	mov    (%eax),%eax
f010391a:	83 e0 fe             	and    $0xfffffffe,%eax
f010391d:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010391f:	0f 20 d8             	mov    %cr3,%eax
f0103922:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0103925:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103928:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f010392b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103930:	c9                   	leave  
f0103931:	c3                   	ret    

f0103932 <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0103932:	55                   	push   %ebp
f0103933:	89 e5                	mov    %esp,%ebp
f0103935:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0103938:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010393c:	7e 06                	jle    f0103944 <command_allocuserpage+0x12>
f010393e:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0103942:	7e 1a                	jle    f010395e <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0103944:	83 ec 0c             	sub    $0xc,%esp
f0103947:	68 84 cc 12 f0       	push   $0xf012cc84
f010394c:	e8 0b e2 ff ff       	call   f0101b5c <cprintf>
f0103951:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103954:	b8 00 00 00 00       	mov    $0x0,%eax
f0103959:	e9 46 01 00 00       	jmp    f0103aa4 <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f010395e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103961:	83 c0 04             	add    $0x4,%eax
f0103964:	8b 00                	mov    (%eax),%eax
f0103966:	83 ec 04             	sub    $0x4,%esp
f0103969:	6a 0a                	push   $0xa
f010396b:	6a 00                	push   $0x0
f010396d:	50                   	push   %eax
f010396e:	e8 19 75 01 00       	call   f011ae8c <strtol>
f0103973:	83 c4 10             	add    $0x10,%esp
f0103976:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0103979:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0103980:	83 ec 04             	sub    $0x4,%esp
f0103983:	6a 00                	push   $0x0
f0103985:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103988:	50                   	push   %eax
f0103989:	ff 75 f0             	pushl  -0x10(%ebp)
f010398c:	e8 da 80 00 00       	call   f010ba6b <envid2env>
f0103991:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0103994:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103997:	85 c0                	test   %eax,%eax
f0103999:	75 0a                	jne    f01039a5 <command_allocuserpage+0x73>
f010399b:	b8 00 00 00 00       	mov    $0x0,%eax
f01039a0:	e9 ff 00 00 00       	jmp    f0103aa4 <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f01039a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01039a8:	83 c0 08             	add    $0x8,%eax
f01039ab:	8b 00                	mov    (%eax),%eax
f01039ad:	83 ec 04             	sub    $0x4,%esp
f01039b0:	6a 10                	push   $0x10
f01039b2:	6a 00                	push   $0x0
f01039b4:	50                   	push   %eax
f01039b5:	e8 d2 74 01 00       	call   f011ae8c <strtol>
f01039ba:	83 c4 10             	add    $0x10,%esp
f01039bd:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f01039c0:	83 ec 0c             	sub    $0xc,%esp
f01039c3:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01039c6:	50                   	push   %eax
f01039c7:	e8 79 56 00 00       	call   f0109045 <allocate_frame>
f01039cc:	83 c4 10             	add    $0x10,%esp
f01039cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f01039d2:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f01039d6:	75 1a                	jne    f01039f2 <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f01039d8:	83 ec 0c             	sub    $0xc,%esp
f01039db:	68 ae cc 12 f0       	push   $0xf012ccae
f01039e0:	e8 77 e1 ff ff       	call   f0101b5c <cprintf>
f01039e5:	83 c4 10             	add    $0x10,%esp
		return 0;
f01039e8:	b8 00 00 00 00       	mov    $0x0,%eax
f01039ed:	e9 b2 00 00 00       	jmp    f0103aa4 <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f01039f2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01039f6:	75 1d                	jne    f0103a15 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f01039f8:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01039fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01039fe:	8b 40 64             	mov    0x64(%eax),%eax
f0103a01:	6a 06                	push   $0x6
f0103a03:	ff 75 ec             	pushl  -0x14(%ebp)
f0103a06:	52                   	push   %edx
f0103a07:	50                   	push   %eax
f0103a08:	e8 d9 5a 00 00       	call   f01094e6 <map_frame>
f0103a0d:	83 c4 10             	add    $0x10,%esp
f0103a10:	e9 8a 00 00 00       	jmp    f0103a9f <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0103a15:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0103a19:	0f 85 80 00 00 00    	jne    f0103a9f <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0103a1f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a22:	83 c0 0c             	add    $0xc,%eax
f0103a25:	8b 00                	mov    (%eax),%eax
f0103a27:	8a 00                	mov    (%eax),%al
f0103a29:	3c 72                	cmp    $0x72,%al
f0103a2b:	74 0e                	je     f0103a3b <command_allocuserpage+0x109>
f0103a2d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a30:	83 c0 0c             	add    $0xc,%eax
f0103a33:	8b 00                	mov    (%eax),%eax
f0103a35:	8a 00                	mov    (%eax),%al
f0103a37:	3c 52                	cmp    $0x52,%al
f0103a39:	75 09                	jne    f0103a44 <command_allocuserpage+0x112>
			rw = 0 ;
f0103a3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103a42:	eb 3c                	jmp    f0103a80 <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0103a44:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a47:	83 c0 0c             	add    $0xc,%eax
f0103a4a:	8b 00                	mov    (%eax),%eax
f0103a4c:	8a 00                	mov    (%eax),%al
f0103a4e:	3c 77                	cmp    $0x77,%al
f0103a50:	74 0e                	je     f0103a60 <command_allocuserpage+0x12e>
f0103a52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a55:	83 c0 0c             	add    $0xc,%eax
f0103a58:	8b 00                	mov    (%eax),%eax
f0103a5a:	8a 00                	mov    (%eax),%al
f0103a5c:	3c 57                	cmp    $0x57,%al
f0103a5e:	75 09                	jne    f0103a69 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0103a60:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0103a67:	eb 17                	jmp    f0103a80 <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0103a69:	83 ec 0c             	sub    $0xc,%esp
f0103a6c:	68 c8 cc 12 f0       	push   $0xf012ccc8
f0103a71:	e8 e6 e0 ff ff       	call   f0101b5c <cprintf>
f0103a76:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0103a79:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0103a80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103a83:	83 c8 04             	or     $0x4,%eax
f0103a86:	89 c1                	mov    %eax,%ecx
f0103a88:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0103a8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103a8e:	8b 40 64             	mov    0x64(%eax),%eax
f0103a91:	51                   	push   %ecx
f0103a92:	ff 75 ec             	pushl  -0x14(%ebp)
f0103a95:	52                   	push   %edx
f0103a96:	50                   	push   %eax
f0103a97:	e8 4a 5a 00 00       	call   f01094e6 <map_frame>
f0103a9c:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a9f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103aa4:	c9                   	leave  
f0103aa5:	c3                   	ret    

f0103aa6 <command_meminfo>:
//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//

int command_meminfo(int number_of_arguments, char **arguments)
{
f0103aa6:	55                   	push   %ebp
f0103aa7:	89 e5                	mov    %esp,%ebp
f0103aa9:	56                   	push   %esi
f0103aaa:	53                   	push   %ebx
f0103aab:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0103aae:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0103ab1:	83 ec 0c             	sub    $0xc,%esp
f0103ab4:	50                   	push   %eax
f0103ab5:	e8 1a 5d 00 00       	call   f01097d4 <calculate_available_frames>
f0103aba:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0103abd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103ac0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103ac3:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0103ac6:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0103ac9:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0103acc:	01 de                	add    %ebx,%esi
f0103ace:	8b 5d f4             	mov    -0xc(%ebp),%ebx
//*****************************************************************************************//

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0103ad1:	01 f3                	add    %esi,%ebx
f0103ad3:	83 ec 0c             	sub    $0xc,%esp
f0103ad6:	51                   	push   %ecx
f0103ad7:	52                   	push   %edx
f0103ad8:	50                   	push   %eax
f0103ad9:	53                   	push   %ebx
f0103ada:	68 0c cd 12 f0       	push   $0xf012cd0c
f0103adf:	e8 78 e0 ff ff       	call   f0101b5c <cprintf>
f0103ae4:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0103ae7:	a1 90 62 85 f0       	mov    0xf0856290,%eax
f0103aec:	83 ec 08             	sub    $0x8,%esp
f0103aef:	50                   	push   %eax
f0103af0:	68 64 cd 12 f0       	push   $0xf012cd64
f0103af5:	e8 62 e0 ff ff       	call   f0101b5c <cprintf>
f0103afa:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103afd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b02:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103b05:	5b                   	pop    %ebx
f0103b06:	5e                   	pop    %esi
f0103b07:	5d                   	pop    %ebp
f0103b08:	c3                   	ret    

f0103b09 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0103b09:	55                   	push   %ebp
f0103b0a:	89 e5                	mov    %esp,%ebp
f0103b0c:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0103b0f:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0103b16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0103b1d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0103b24:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)
	int PRIRRSchedPriority = 0;				//arg#5 default
f0103b2b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0103b32:	8b 45 08             	mov    0x8(%ebp),%eax
f0103b35:	83 f8 04             	cmp    $0x4,%eax
f0103b38:	0f 84 c3 00 00 00    	je     f0103c01 <CreateEnv+0xf8>
f0103b3e:	83 f8 05             	cmp    $0x5,%eax
f0103b41:	74 0e                	je     f0103b51 <CreateEnv+0x48>
f0103b43:	83 f8 03             	cmp    $0x3,%eax
f0103b46:	0f 84 4a 01 00 00    	je     f0103c96 <CreateEnv+0x18d>
f0103b4c:	e9 8d 01 00 00       	jmp    f0103cde <CreateEnv+0x1d5>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103b51:	83 ec 0c             	sub    $0xc,%esp
f0103b54:	6a 02                	push   $0x2
f0103b56:	e8 ca bc 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f0103b5b:	83 c4 10             	add    $0x10,%esp
f0103b5e:	85 c0                	test   %eax,%eax
f0103b60:	75 1a                	jne    f0103b7c <CreateEnv+0x73>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0103b62:	83 ec 0c             	sub    $0xc,%esp
f0103b65:	68 a0 cd 12 f0       	push   $0xf012cda0
f0103b6a:	e8 ed df ff ff       	call   f0101b5c <cprintf>
f0103b6f:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103b72:	b8 00 00 00 00       	mov    $0x0,%eax
f0103b77:	e9 7b 02 00 00       	jmp    f0103df7 <CreateEnv+0x2ee>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			if (isSchedMethodBSD())
f0103b7c:	e8 3c 3b 00 00       	call   f01076bd <isSchedMethodBSD>
f0103b81:	85 c0                	test   %eax,%eax
f0103b83:	74 1d                	je     f0103ba2 <CreateEnv+0x99>
				BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0103b85:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b88:	83 c0 10             	add    $0x10,%eax
f0103b8b:	8b 00                	mov    (%eax),%eax
f0103b8d:	83 ec 04             	sub    $0x4,%esp
f0103b90:	6a 0a                	push   $0xa
f0103b92:	6a 00                	push   $0x0
f0103b94:	50                   	push   %eax
f0103b95:	e8 f2 72 01 00       	call   f011ae8c <strtol>
f0103b9a:	83 c4 10             	add    $0x10,%esp
f0103b9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103ba0:	eb 24                	jmp    f0103bc6 <CreateEnv+0xbd>
			else if (isSchedMethodPRIRR())
f0103ba2:	e8 29 3b 00 00       	call   f01076d0 <isSchedMethodPRIRR>
f0103ba7:	85 c0                	test   %eax,%eax
f0103ba9:	74 1b                	je     f0103bc6 <CreateEnv+0xbd>
				PRIRRSchedPriority = strtol(arguments[4], NULL, 10);
f0103bab:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103bae:	83 c0 10             	add    $0x10,%eax
f0103bb1:	8b 00                	mov    (%eax),%eax
f0103bb3:	83 ec 04             	sub    $0x4,%esp
f0103bb6:	6a 0a                	push   $0xa
f0103bb8:	6a 00                	push   $0x0
f0103bba:	50                   	push   %eax
f0103bbb:	e8 cc 72 01 00       	call   f011ae8c <strtol>
f0103bc0:	83 c4 10             	add    $0x10,%esp
f0103bc3:	89 45 e8             	mov    %eax,-0x18(%ebp)

			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0103bc6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103bc9:	83 c0 0c             	add    $0xc,%eax
f0103bcc:	8b 00                	mov    (%eax),%eax
f0103bce:	83 ec 04             	sub    $0x4,%esp
f0103bd1:	6a 0a                	push   $0xa
f0103bd3:	6a 00                	push   $0x0
f0103bd5:	50                   	push   %eax
f0103bd6:	e8 b1 72 01 00       	call   f011ae8c <strtol>
f0103bdb:	83 c4 10             	add    $0x10,%esp
f0103bde:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103be1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103be4:	83 c0 08             	add    $0x8,%eax
f0103be7:	8b 00                	mov    (%eax),%eax
f0103be9:	83 ec 04             	sub    $0x4,%esp
f0103bec:	6a 0a                	push   $0xa
f0103bee:	6a 00                	push   $0x0
f0103bf0:	50                   	push   %eax
f0103bf1:	e8 96 72 01 00       	call   f011ae8c <strtol>
f0103bf6:	83 c4 10             	add    $0x10,%esp
f0103bf9:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103bfc:	e9 f7 00 00 00       	jmp    f0103cf8 <CreateEnv+0x1ef>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103c01:	83 ec 0c             	sub    $0xc,%esp
f0103c04:	6a 02                	push   $0x2
f0103c06:	e8 1a bc 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f0103c0b:	83 c4 10             	add    $0x10,%esp
f0103c0e:	85 c0                	test   %eax,%eax
f0103c10:	75 4c                	jne    f0103c5e <CreateEnv+0x155>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				if (isSchedMethodBSD())
f0103c12:	e8 a6 3a 00 00       	call   f01076bd <isSchedMethodBSD>
f0103c17:	85 c0                	test   %eax,%eax
f0103c19:	74 1d                	je     f0103c38 <CreateEnv+0x12f>
					BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0103c1b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c1e:	83 c0 0c             	add    $0xc,%eax
f0103c21:	8b 00                	mov    (%eax),%eax
f0103c23:	83 ec 04             	sub    $0x4,%esp
f0103c26:	6a 0a                	push   $0xa
f0103c28:	6a 00                	push   $0x0
f0103c2a:	50                   	push   %eax
f0103c2b:	e8 5c 72 01 00       	call   f011ae8c <strtol>
f0103c30:	83 c4 10             	add    $0x10,%esp
f0103c33:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103c36:	eb 41                	jmp    f0103c79 <CreateEnv+0x170>
				else if (isSchedMethodPRIRR())
f0103c38:	e8 93 3a 00 00       	call   f01076d0 <isSchedMethodPRIRR>
f0103c3d:	85 c0                	test   %eax,%eax
f0103c3f:	74 38                	je     f0103c79 <CreateEnv+0x170>
					PRIRRSchedPriority = strtol(arguments[3], NULL, 10);			}
f0103c41:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c44:	83 c0 0c             	add    $0xc,%eax
f0103c47:	8b 00                	mov    (%eax),%eax
f0103c49:	83 ec 04             	sub    $0x4,%esp
f0103c4c:	6a 0a                	push   $0xa
f0103c4e:	6a 00                	push   $0x0
f0103c50:	50                   	push   %eax
f0103c51:	e8 36 72 01 00       	call   f011ae8c <strtol>
f0103c56:	83 c4 10             	add    $0x10,%esp
f0103c59:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0103c5c:	eb 1b                	jmp    f0103c79 <CreateEnv+0x170>
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0103c5e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c61:	83 c0 0c             	add    $0xc,%eax
f0103c64:	8b 00                	mov    (%eax),%eax
f0103c66:	83 ec 04             	sub    $0x4,%esp
f0103c69:	6a 0a                	push   $0xa
f0103c6b:	6a 00                	push   $0x0
f0103c6d:	50                   	push   %eax
f0103c6e:	e8 19 72 01 00       	call   f011ae8c <strtol>
f0103c73:	83 c4 10             	add    $0x10,%esp
f0103c76:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103c79:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c7c:	83 c0 08             	add    $0x8,%eax
f0103c7f:	8b 00                	mov    (%eax),%eax
f0103c81:	83 ec 04             	sub    $0x4,%esp
f0103c84:	6a 0a                	push   $0xa
f0103c86:	6a 00                	push   $0x0
f0103c88:	50                   	push   %eax
f0103c89:	e8 fe 71 01 00       	call   f011ae8c <strtol>
f0103c8e:	83 c4 10             	add    $0x10,%esp
f0103c91:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103c94:	eb 62                	jmp    f0103cf8 <CreateEnv+0x1ef>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103c96:	83 ec 0c             	sub    $0xc,%esp
f0103c99:	6a 02                	push   $0x2
f0103c9b:	e8 85 bb 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f0103ca0:	83 c4 10             	add    $0x10,%esp
f0103ca3:	85 c0                	test   %eax,%eax
f0103ca5:	74 1a                	je     f0103cc1 <CreateEnv+0x1b8>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f0103ca7:	83 ec 0c             	sub    $0xc,%esp
f0103caa:	68 4c ce 12 f0       	push   $0xf012ce4c
f0103caf:	e8 a8 de ff ff       	call   f0101b5c <cprintf>
f0103cb4:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103cb7:	b8 00 00 00 00       	mov    $0x0,%eax
f0103cbc:	e9 36 01 00 00       	jmp    f0103df7 <CreateEnv+0x2ee>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103cc1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103cc4:	83 c0 08             	add    $0x8,%eax
f0103cc7:	8b 00                	mov    (%eax),%eax
f0103cc9:	83 ec 04             	sub    $0x4,%esp
f0103ccc:	6a 0a                	push   $0xa
f0103cce:	6a 00                	push   $0x0
f0103cd0:	50                   	push   %eax
f0103cd1:	e8 b6 71 01 00       	call   f011ae8c <strtol>
f0103cd6:	83 c4 10             	add    $0x10,%esp
f0103cd9:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103cdc:	eb 1a                	jmp    f0103cf8 <CreateEnv+0x1ef>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103cde:	83 ec 0c             	sub    $0xc,%esp
f0103ce1:	68 dc ce 12 f0       	push   $0xf012cedc
f0103ce6:	e8 71 de ff ff       	call   f0101b5c <cprintf>
f0103ceb:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103cee:	b8 00 00 00 00       	mov    $0x0,%eax
f0103cf3:	e9 ff 00 00 00       	jmp    f0103df7 <CreateEnv+0x2ee>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103cf8:	83 ec 0c             	sub    $0xc,%esp
f0103cfb:	6a 02                	push   $0x2
f0103cfd:	e8 23 bb 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f0103d02:	83 c4 10             	add    $0x10,%esp
f0103d05:	85 c0                	test   %eax,%eax
f0103d07:	74 23                	je     f0103d2c <CreateEnv+0x223>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f0103d09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103d0c:	48                   	dec    %eax
f0103d0d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103d10:	73 1a                	jae    f0103d2c <CreateEnv+0x223>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103d12:	83 ec 0c             	sub    $0xc,%esp
f0103d15:	68 74 cf 12 f0       	push   $0xf012cf74
f0103d1a:	e8 3d de ff ff       	call   f0101b5c <cprintf>
f0103d1f:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103d22:	b8 00 00 00 00       	mov    $0x0,%eax
f0103d27:	e9 cb 00 00 00       	jmp    f0103df7 <CreateEnv+0x2ee>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103d2c:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0103d30:	76 19                	jbe    f0103d4b <CreateEnv+0x242>
f0103d32:	68 cc cf 12 f0       	push   $0xf012cfcc
f0103d37:	68 11 d0 12 f0       	push   $0xf012d011
f0103d3c:	68 a5 02 00 00       	push   $0x2a5
f0103d41:	68 0d cb 12 f0       	push   $0xf012cb0d
f0103d46:	e8 64 d1 ff ff       	call   f0100eaf <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103d4b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0103d4f:	76 19                	jbe    f0103d6a <CreateEnv+0x261>
f0103d51:	68 cc cf 12 f0       	push   $0xf012cfcc
f0103d56:	68 11 d0 12 f0       	push   $0xf012d011
f0103d5b:	68 c3 02 00 00       	push   $0x2c3
f0103d60:	68 0d cb 12 f0       	push   $0xf012cb0d
f0103d65:	e8 45 d1 ff ff       	call   f0100eaf <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0103d6a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103d6d:	83 c0 04             	add    $0x4,%eax
f0103d70:	8b 00                	mov    (%eax),%eax
f0103d72:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103d75:	ff 75 f0             	pushl  -0x10(%ebp)
f0103d78:	ff 75 f4             	pushl  -0xc(%ebp)
f0103d7b:	50                   	push   %eax
f0103d7c:	e8 e3 70 00 00       	call   f010ae64 <env_create>
f0103d81:	83 c4 10             	add    $0x10,%esp
f0103d84:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (BSDSchedNiceVal != -100)
f0103d87:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f0103d8b:	74 49                	je     f0103dd6 <CreateEnv+0x2cd>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f0103d8d:	83 ec 08             	sub    $0x8,%esp
f0103d90:	ff 75 ec             	pushl  -0x14(%ebp)
f0103d93:	68 26 d0 12 f0       	push   $0xf012d026
f0103d98:	e8 bf dd ff ff       	call   f0101b5c <cprintf>
f0103d9d:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103da0:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f0103da4:	7c 06                	jl     f0103dac <CreateEnv+0x2a3>
f0103da6:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103daa:	7e 19                	jle    f0103dc5 <CreateEnv+0x2bc>
f0103dac:	68 38 d0 12 f0       	push   $0xf012d038
f0103db1:	68 11 d0 12 f0       	push   $0xf012d011
f0103db6:	68 c8 02 00 00       	push   $0x2c8
f0103dbb:	68 0d cb 12 f0       	push   $0xf012cb0d
f0103dc0:	e8 ea d0 ff ff       	call   f0100eaf <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f0103dc5:	83 ec 08             	sub    $0x8,%esp
f0103dc8:	ff 75 ec             	pushl  -0x14(%ebp)
f0103dcb:	ff 75 e0             	pushl  -0x20(%ebp)
f0103dce:	e8 34 38 00 00       	call   f0107607 <env_set_nice>
f0103dd3:	83 c4 10             	add    $0x10,%esp
	}
	if (isSchedMethodPRIRR())
f0103dd6:	e8 f5 38 00 00       	call   f01076d0 <isSchedMethodPRIRR>
f0103ddb:	85 c0                	test   %eax,%eax
f0103ddd:	74 15                	je     f0103df4 <CreateEnv+0x2eb>
		env_set_priority(env->env_id, PRIRRSchedPriority);
f0103ddf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103de2:	8b 40 10             	mov    0x10(%eax),%eax
f0103de5:	83 ec 08             	sub    $0x8,%esp
f0103de8:	ff 75 e8             	pushl  -0x18(%ebp)
f0103deb:	50                   	push   %eax
f0103dec:	e8 6d 38 00 00       	call   f010765e <env_set_priority>
f0103df1:	83 c4 10             	add    $0x10,%esp

	return env;
f0103df4:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0103df7:	c9                   	leave  
f0103df8:	c3                   	ret    

f0103df9 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103df9:	55                   	push   %ebp
f0103dfa:	89 e5                	mov    %esp,%ebp
f0103dfc:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103dff:	83 ec 08             	sub    $0x8,%esp
f0103e02:	ff 75 0c             	pushl  0xc(%ebp)
f0103e05:	ff 75 08             	pushl  0x8(%ebp)
f0103e08:	e8 fc fc ff ff       	call   f0103b09 <CreateEnv>
f0103e0d:	83 c4 10             	add    $0x10,%esp
f0103e10:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f0103e13:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103e17:	75 07                	jne    f0103e20 <command_run_program+0x27>
f0103e19:	b8 00 00 00 00       	mov    $0x0,%eax
f0103e1e:	eb 46                	jmp    f0103e66 <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103e20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103e23:	8b 40 10             	mov    0x10(%eax),%eax
f0103e26:	83 ec 08             	sub    $0x8,%esp
f0103e29:	50                   	push   %eax
f0103e2a:	68 68 d0 12 f0       	push   $0xf012d068
f0103e2f:	e8 28 dd ff ff       	call   f0101b5c <cprintf>
f0103e34:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f0103e37:	83 ec 0c             	sub    $0xc,%esp
f0103e3a:	ff 75 f4             	pushl  -0xc(%ebp)
f0103e3d:	e8 47 28 00 00       	call   f0106689 <sched_new_env>
f0103e42:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f0103e45:	c7 05 90 62 85 f0 00 	movl   $0x0,0xf0856290
f0103e4c:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103e4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103e52:	8b 40 10             	mov    0x10(%eax),%eax
f0103e55:	83 ec 0c             	sub    $0xc,%esp
f0103e58:	50                   	push   %eax
f0103e59:	e8 81 28 00 00       	call   f01066df <sched_run_env>
f0103e5e:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103e61:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103e66:	c9                   	leave  
f0103e67:	c3                   	ret    

f0103e68 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f0103e68:	55                   	push   %ebp
f0103e69:	89 e5                	mov    %esp,%ebp
f0103e6b:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103e6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103e71:	83 c0 04             	add    $0x4,%eax
f0103e74:	8b 00                	mov    (%eax),%eax
f0103e76:	83 ec 04             	sub    $0x4,%esp
f0103e79:	6a 0a                	push   $0xa
f0103e7b:	6a 00                	push   $0x0
f0103e7d:	50                   	push   %eax
f0103e7e:	e8 09 70 01 00       	call   f011ae8c <strtol>
f0103e83:	83 c4 10             	add    $0x10,%esp
f0103e86:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0103e89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103e8c:	83 ec 0c             	sub    $0xc,%esp
f0103e8f:	50                   	push   %eax
f0103e90:	e8 90 2b 00 00       	call   f0106a25 <sched_kill_env>
f0103e95:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103e98:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103e9d:	c9                   	leave  
f0103e9e:	c3                   	ret    

f0103e9f <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f0103e9f:	55                   	push   %ebp
f0103ea0:	89 e5                	mov    %esp,%ebp
f0103ea2:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103ea5:	83 ec 08             	sub    $0x8,%esp
f0103ea8:	ff 75 0c             	pushl  0xc(%ebp)
f0103eab:	ff 75 08             	pushl  0x8(%ebp)
f0103eae:	e8 56 fc ff ff       	call   f0103b09 <CreateEnv>
f0103eb3:	83 c4 10             	add    $0x10,%esp
f0103eb6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103eb9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103ebd:	75 07                	jne    f0103ec6 <commnad_load_env+0x27>
		return 0 ;
f0103ebf:	b8 00 00 00 00       	mov    $0x0,%eax
f0103ec4:	eb 2a                	jmp    f0103ef0 <commnad_load_env+0x51>

	sched_new_env(env) ;
f0103ec6:	83 ec 0c             	sub    $0xc,%esp
f0103ec9:	ff 75 f4             	pushl  -0xc(%ebp)
f0103ecc:	e8 b8 27 00 00       	call   f0106689 <sched_new_env>
f0103ed1:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103ed4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103ed7:	8b 40 10             	mov    0x10(%eax),%eax
f0103eda:	83 ec 08             	sub    $0x8,%esp
f0103edd:	50                   	push   %eax
f0103ede:	68 68 d0 12 f0       	push   $0xf012d068
f0103ee3:	e8 74 dc ff ff       	call   f0101b5c <cprintf>
f0103ee8:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103eeb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ef0:	c9                   	leave  
f0103ef1:	c3                   	ret    

f0103ef2 <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f0103ef2:	55                   	push   %ebp
f0103ef3:	89 e5                	mov    %esp,%ebp
f0103ef5:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103ef8:	c7 05 90 62 85 f0 00 	movl   $0x0,0xf0856290
f0103eff:	00 00 00 
	sched_run_all();
f0103f02:	e8 ef 30 00 00       	call   f0106ff6 <sched_run_all>

	return 0 ;
f0103f07:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103f0c:	c9                   	leave  
f0103f0d:	c3                   	ret    

f0103f0e <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0103f0e:	55                   	push   %ebp
f0103f0f:	89 e5                	mov    %esp,%ebp
f0103f11:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f0103f14:	e8 bc 2e 00 00       	call   f0106dd5 <sched_print_all>

	return 0 ;
f0103f19:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103f1e:	c9                   	leave  
f0103f1f:	c3                   	ret    

f0103f20 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0103f20:	55                   	push   %ebp
f0103f21:	89 e5                	mov    %esp,%ebp
f0103f23:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f0103f26:	e8 60 31 00 00       	call   f010708b <sched_kill_all>

	return 0 ;
f0103f2b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103f30:	c9                   	leave  
f0103f31:	c3                   	ret    

f0103f32 <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f0103f32:	55                   	push   %ebp
f0103f33:	89 e5                	mov    %esp,%ebp
f0103f35:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103f38:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103f3c:	7f 1a                	jg     f0103f58 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103f3e:	83 ec 0c             	sub    $0xc,%esp
f0103f41:	68 80 d0 12 f0       	push   $0xf012d080
f0103f46:	e8 11 dc ff ff       	call   f0101b5c <cprintf>
f0103f4b:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103f4e:	b8 00 00 00 00       	mov    $0x0,%eax
f0103f53:	e9 83 00 00 00       	jmp    f0103fdb <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f0103f58:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103f5b:	83 c0 04             	add    $0x4,%eax
f0103f5e:	8b 00                	mov    (%eax),%eax
f0103f60:	83 ec 04             	sub    $0x4,%esp
f0103f63:	6a 0a                	push   $0xa
f0103f65:	6a 00                	push   $0x0
f0103f67:	50                   	push   %eax
f0103f68:	e8 1f 6f 01 00       	call   f011ae8c <strtol>
f0103f6d:	83 c4 10             	add    $0x10,%esp
f0103f70:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f0103f73:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103f77:	75 20                	jne    f0103f99 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103f79:	83 ec 0c             	sub    $0xc,%esp
f0103f7c:	ff 75 f4             	pushl  -0xc(%ebp)
f0103f7f:	e8 f8 b7 00 00       	call   f010f77c <setPageReplacmentAlgorithmLRU>
f0103f84:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f0103f87:	83 ec 0c             	sub    $0xc,%esp
f0103f8a:	68 e0 d0 12 f0       	push   $0xf012d0e0
f0103f8f:	e8 c8 db ff ff       	call   f0101b5c <cprintf>
f0103f94:	83 c4 10             	add    $0x10,%esp
f0103f97:	eb 3d                	jmp    f0103fd6 <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f0103f99:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0103f9d:	75 20                	jne    f0103fbf <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103f9f:	83 ec 0c             	sub    $0xc,%esp
f0103fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0103fa5:	e8 d2 b7 00 00       	call   f010f77c <setPageReplacmentAlgorithmLRU>
f0103faa:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f0103fad:	83 ec 0c             	sub    $0xc,%esp
f0103fb0:	68 24 d1 12 f0       	push   $0xf012d124
f0103fb5:	e8 a2 db ff ff       	call   f0101b5c <cprintf>
f0103fba:	83 c4 10             	add    $0x10,%esp
f0103fbd:	eb 17                	jmp    f0103fd6 <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103fbf:	83 ec 0c             	sub    $0xc,%esp
f0103fc2:	68 64 d1 12 f0       	push   $0xf012d164
f0103fc7:	e8 90 db ff ff       	call   f0101b5c <cprintf>
f0103fcc:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103fcf:	b8 00 00 00 00       	mov    $0x0,%eax
f0103fd4:	eb 05                	jmp    f0103fdb <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f0103fd6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103fdb:	c9                   	leave  
f0103fdc:	c3                   	ret    

f0103fdd <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103fdd:	55                   	push   %ebp
f0103fde:	89 e5                	mov    %esp,%ebp
f0103fe0:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f0103fe3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fe6:	83 c0 04             	add    $0x4,%eax
f0103fe9:	8b 00                	mov    (%eax),%eax
f0103feb:	83 ec 04             	sub    $0x4,%esp
f0103fee:	6a 0a                	push   $0xa
f0103ff0:	6a 00                	push   $0x0
f0103ff2:	50                   	push   %eax
f0103ff3:	e8 94 6e 01 00       	call   f011ae8c <strtol>
f0103ff8:	83 c4 10             	add    $0x10,%esp
f0103ffb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint8 type = strtol(arguments[2], NULL, 10);
f0103ffe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104001:	83 c0 08             	add    $0x8,%eax
f0104004:	8b 00                	mov    (%eax),%eax
f0104006:	83 ec 04             	sub    $0x4,%esp
f0104009:	6a 0a                	push   $0xa
f010400b:	6a 00                	push   $0x0
f010400d:	50                   	push   %eax
f010400e:	e8 79 6e 01 00       	call   f011ae8c <strtol>
f0104013:	83 c4 10             	add    $0x10,%esp
f0104016:	88 45 f3             	mov    %al,-0xd(%ebp)
	if (PageWSMaxSweeps <= 0)
f0104019:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010401d:	75 17                	jne    f0104036 <command_set_page_rep_nthCLOCK+0x59>
	{
		cprintf("Invalid number of sweeps! it should be +ve.\n");
f010401f:	83 ec 0c             	sub    $0xc,%esp
f0104022:	68 b8 d1 12 f0       	push   $0xf012d1b8
f0104027:	e8 30 db ff ff       	call   f0101b5c <cprintf>
f010402c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010402f:	b8 00 00 00 00       	mov    $0x0,%eax
f0104034:	eb 4b                	jmp    f0104081 <command_set_page_rep_nthCLOCK+0xa4>
	}
	if (type == 1)		PageWSMaxSweeps = PageWSMaxSweeps * 1;
f0104036:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
f010403a:	74 22                	je     f010405e <command_set_page_rep_nthCLOCK+0x81>
	else if (type == 2)	PageWSMaxSweeps = PageWSMaxSweeps * -1;
f010403c:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
f0104040:	75 05                	jne    f0104047 <command_set_page_rep_nthCLOCK+0x6a>
f0104042:	f7 5d f4             	negl   -0xc(%ebp)
f0104045:	eb 17                	jmp    f010405e <command_set_page_rep_nthCLOCK+0x81>
	else
	{
		cprintf("Invalid type!\n	type=1: NORMAL Ver. type=2: MODIFIED Ver.\n");
f0104047:	83 ec 0c             	sub    $0xc,%esp
f010404a:	68 e8 d1 12 f0       	push   $0xf012d1e8
f010404f:	e8 08 db ff ff       	call   f0101b5c <cprintf>
f0104054:	83 c4 10             	add    $0x10,%esp
		return 0;
f0104057:	b8 00 00 00 00       	mov    $0x0,%eax
f010405c:	eb 23                	jmp    f0104081 <command_set_page_rep_nthCLOCK+0xa4>
	}
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f010405e:	83 ec 0c             	sub    $0xc,%esp
f0104061:	ff 75 f4             	pushl  -0xc(%ebp)
f0104064:	e8 86 b7 00 00       	call   f010f7ef <setPageReplacmentAlgorithmNchanceCLOCK>
f0104069:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f010406c:	83 ec 0c             	sub    $0xc,%esp
f010406f:	68 24 d2 12 f0       	push   $0xf012d224
f0104074:	e8 e3 da ff ff       	call   f0101b5c <cprintf>
f0104079:	83 c4 10             	add    $0x10,%esp
	return 0;
f010407c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104081:	c9                   	leave  
f0104082:	c3                   	ret    

f0104083 <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f0104083:	55                   	push   %ebp
f0104084:	89 e5                	mov    %esp,%ebp
f0104086:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0104089:	e8 21 b7 00 00       	call   f010f7af <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f010408e:	83 ec 0c             	sub    $0xc,%esp
f0104091:	68 58 d2 12 f0       	push   $0xf012d258
f0104096:	e8 c1 da ff ff       	call   f0101b5c <cprintf>
f010409b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010409e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040a3:	c9                   	leave  
f01040a4:	c3                   	ret    

f01040a5 <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f01040a5:	55                   	push   %ebp
f01040a6:	89 e5                	mov    %esp,%ebp
f01040a8:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f01040ab:	e8 0f b7 00 00       	call   f010f7bf <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f01040b0:	83 ec 0c             	sub    $0xc,%esp
f01040b3:	68 84 d2 12 f0       	push   $0xf012d284
f01040b8:	e8 9f da ff ff       	call   f0101b5c <cprintf>
f01040bd:	83 c4 10             	add    $0x10,%esp
	return 0;
f01040c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040c5:	c9                   	leave  
f01040c6:	c3                   	ret    

f01040c7 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01040c7:	55                   	push   %ebp
f01040c8:	89 e5                	mov    %esp,%ebp
f01040ca:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01040cd:	e8 fd b6 00 00       	call   f010f7cf <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01040d2:	83 ec 0c             	sub    $0xc,%esp
f01040d5:	68 ac d2 12 f0       	push   $0xf012d2ac
f01040da:	e8 7d da ff ff       	call   f0101b5c <cprintf>
f01040df:	83 c4 10             	add    $0x10,%esp
	return 0;
f01040e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040e7:	c9                   	leave  
f01040e8:	c3                   	ret    

f01040e9 <command_set_page_rep_OPTIMAL>:

int command_set_page_rep_OPTIMAL(int number_of_arguments, char **arguments)
{
f01040e9:	55                   	push   %ebp
f01040ea:	89 e5                	mov    %esp,%ebp
f01040ec:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmOPTIMAL();
f01040ef:	e8 21 b7 00 00       	call   f010f815 <setPageReplacmentAlgorithmOPTIMAL>
	cprintf("Page replacement algorithm is now OPTIMAL\n");
f01040f4:	83 ec 0c             	sub    $0xc,%esp
f01040f7:	68 e0 d2 12 f0       	push   $0xf012d2e0
f01040fc:	e8 5b da ff ff       	call   f0101b5c <cprintf>
f0104101:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104104:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104109:	c9                   	leave  
f010410a:	c3                   	ret    

f010410b <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f010410b:	55                   	push   %ebp
f010410c:	89 e5                	mov    %esp,%ebp
f010410e:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f0104111:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104114:	83 c0 04             	add    $0x4,%eax
f0104117:	8b 00                	mov    (%eax),%eax
f0104119:	83 ec 04             	sub    $0x4,%esp
f010411c:	6a 0a                	push   $0xa
f010411e:	6a 00                	push   $0x0
f0104120:	50                   	push   %eax
f0104121:	e8 66 6d 01 00       	call   f011ae8c <strtol>
f0104126:	83 c4 10             	add    $0x10,%esp
f0104129:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f010412c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104130:	83 ec 0c             	sub    $0xc,%esp
f0104133:	50                   	push   %eax
f0104134:	e8 09 38 00 00       	call   f0107942 <sched_init_RR>
f0104139:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f010413c:	a1 44 61 85 f0       	mov    0xf0856144,%eax
f0104141:	8a 00                	mov    (%eax),%al
f0104143:	0f b6 c0             	movzbl %al,%eax
f0104146:	83 ec 08             	sub    $0x8,%esp
f0104149:	50                   	push   %eax
f010414a:	68 0c d3 12 f0       	push   $0xf012d30c
f010414f:	e8 08 da ff ff       	call   f0101b5c <cprintf>
f0104154:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104157:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010415c:	c9                   	leave  
f010415d:	c3                   	ret    

f010415e <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f010415e:	55                   	push   %ebp
f010415f:	89 e5                	mov    %esp,%ebp
f0104161:	53                   	push   %ebx
f0104162:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0104165:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104168:	83 c0 04             	add    $0x4,%eax
f010416b:	8b 00                	mov    (%eax),%eax
f010416d:	83 ec 04             	sub    $0x4,%esp
f0104170:	6a 0a                	push   $0xa
f0104172:	6a 00                	push   $0x0
f0104174:	50                   	push   %eax
f0104175:	e8 12 6d 01 00       	call   f011ae8c <strtol>
f010417a:	83 c4 10             	add    $0x10,%esp
f010417d:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0104180:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0104187:	eb 2e                	jmp    f01041b7 <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f0104189:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010418c:	8d 58 fe             	lea    -0x2(%eax),%ebx
f010418f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104192:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104199:	8b 45 0c             	mov    0xc(%ebp),%eax
f010419c:	01 d0                	add    %edx,%eax
f010419e:	8b 00                	mov    (%eax),%eax
f01041a0:	83 ec 04             	sub    $0x4,%esp
f01041a3:	6a 0a                	push   $0xa
f01041a5:	6a 00                	push   $0x0
f01041a7:	50                   	push   %eax
f01041a8:	e8 df 6c 01 00       	call   f011ae8c <strtol>
f01041ad:	83 c4 10             	add    $0x10,%esp
f01041b0:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f01041b4:	ff 45 f4             	incl   -0xc(%ebp)
f01041b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01041ba:	3b 45 08             	cmp    0x8(%ebp),%eax
f01041bd:	7c ca                	jl     f0104189 <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f01041bf:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f01041c3:	83 ec 08             	sub    $0x8,%esp
f01041c6:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f01041c9:	52                   	push   %edx
f01041ca:	50                   	push   %eax
f01041cb:	e8 20 38 00 00       	call   f01079f0 <sched_init_MLFQ>
f01041d0:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f01041d3:	83 ec 0c             	sub    $0xc,%esp
f01041d6:	68 44 d3 12 f0       	push   $0xf012d344
f01041db:	e8 7c d9 ff ff       	call   f0101b5c <cprintf>
f01041e0:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01041e3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01041ea:	eb 24                	jmp    f0104210 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01041ec:	8b 15 44 61 85 f0    	mov    0xf0856144,%edx
f01041f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041f5:	01 d0                	add    %edx,%eax
f01041f7:	8a 00                	mov    (%eax),%al
f01041f9:	0f b6 c0             	movzbl %al,%eax
f01041fc:	83 ec 08             	sub    $0x8,%esp
f01041ff:	50                   	push   %eax
f0104200:	68 71 d3 12 f0       	push   $0xf012d371
f0104205:	e8 52 d9 ff ff       	call   f0101b5c <cprintf>
f010420a:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f010420d:	ff 45 f0             	incl   -0x10(%ebp)
f0104210:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f0104215:	0f b6 c0             	movzbl %al,%eax
f0104218:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010421b:	7f cf                	jg     f01041ec <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f010421d:	83 ec 0c             	sub    $0xc,%esp
f0104220:	68 77 d3 12 f0       	push   $0xf012d377
f0104225:	e8 32 d9 ff ff       	call   f0101b5c <cprintf>
f010422a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010422d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104232:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104235:	c9                   	leave  
f0104236:	c3                   	ret    

f0104237 <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f0104237:	55                   	push   %ebp
f0104238:	89 e5                	mov    %esp,%ebp
f010423a:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010423d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104240:	83 c0 04             	add    $0x4,%eax
f0104243:	8b 00                	mov    (%eax),%eax
f0104245:	83 ec 04             	sub    $0x4,%esp
f0104248:	6a 0a                	push   $0xa
f010424a:	6a 00                	push   $0x0
f010424c:	50                   	push   %eax
f010424d:	e8 3a 6c 01 00       	call   f011ae8c <strtol>
f0104252:	83 c4 10             	add    $0x10,%esp
f0104255:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f0104258:	8b 45 0c             	mov    0xc(%ebp),%eax
f010425b:	83 c0 08             	add    $0x8,%eax
f010425e:	8b 00                	mov    (%eax),%eax
f0104260:	83 ec 04             	sub    $0x4,%esp
f0104263:	6a 0a                	push   $0xa
f0104265:	6a 00                	push   $0x0
f0104267:	50                   	push   %eax
f0104268:	e8 1f 6c 01 00       	call   f011ae8c <strtol>
f010426d:	83 c4 10             	add    $0x10,%esp
f0104270:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0104273:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0104277:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f010427b:	83 ec 08             	sub    $0x8,%esp
f010427e:	52                   	push   %edx
f010427f:	50                   	push   %eax
f0104280:	e8 8e 37 00 00       	call   f0107a13 <sched_init_BSD>
f0104285:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f0104288:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010428c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104290:	83 ec 04             	sub    $0x4,%esp
f0104293:	52                   	push   %edx
f0104294:	50                   	push   %eax
f0104295:	68 7c d3 12 f0       	push   $0xf012d37c
f010429a:	e8 bd d8 ff ff       	call   f0101b5c <cprintf>
f010429f:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01042a2:	83 ec 0c             	sub    $0xc,%esp
f01042a5:	68 77 d3 12 f0       	push   $0xf012d377
f01042aa:	e8 ad d8 ff ff       	call   f0101b5c <cprintf>
f01042af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01042b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01042b7:	c9                   	leave  
f01042b8:	c3                   	ret    

f01042b9 <command_sch_PRIRR>:

int command_sch_PRIRR(int number_of_arguments, char **arguments)
{
f01042b9:	55                   	push   %ebp
f01042ba:	89 e5                	mov    %esp,%ebp
f01042bc:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f01042bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01042c2:	83 c0 04             	add    $0x4,%eax
f01042c5:	8b 00                	mov    (%eax),%eax
f01042c7:	83 ec 04             	sub    $0x4,%esp
f01042ca:	6a 0a                	push   $0xa
f01042cc:	6a 00                	push   $0x0
f01042ce:	50                   	push   %eax
f01042cf:	e8 b8 6b 01 00       	call   f011ae8c <strtol>
f01042d4:	83 c4 10             	add    $0x10,%esp
f01042d7:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f01042da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01042dd:	83 c0 08             	add    $0x8,%eax
f01042e0:	8b 00                	mov    (%eax),%eax
f01042e2:	83 ec 04             	sub    $0x4,%esp
f01042e5:	6a 0a                	push   $0xa
f01042e7:	6a 00                	push   $0x0
f01042e9:	50                   	push   %eax
f01042ea:	e8 9d 6b 01 00       	call   f011ae8c <strtol>
f01042ef:	83 c4 10             	add    $0x10,%esp
f01042f2:	88 45 f6             	mov    %al,-0xa(%ebp)
	uint32 starvThresh = strtol(arguments[3], NULL, 10);
f01042f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01042f8:	83 c0 0c             	add    $0xc,%eax
f01042fb:	8b 00                	mov    (%eax),%eax
f01042fd:	83 ec 04             	sub    $0x4,%esp
f0104300:	6a 0a                	push   $0xa
f0104302:	6a 00                	push   $0x0
f0104304:	50                   	push   %eax
f0104305:	e8 82 6b 01 00       	call   f011ae8c <strtol>
f010430a:	83 c4 10             	add    $0x10,%esp
f010430d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	sched_init_PRIRR(numOfLevels, quantum, starvThresh);
f0104310:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0104314:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104318:	83 ec 04             	sub    $0x4,%esp
f010431b:	ff 75 f0             	pushl  -0x10(%ebp)
f010431e:	52                   	push   %edx
f010431f:	50                   	push   %eax
f0104320:	e8 17 37 00 00       	call   f0107a3c <sched_init_PRIRR>
f0104325:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to PRIORITY RR with %d priorities, quantum = %d and starvation thresh %d\n", numOfLevels, quantum, starvThresh);
f0104328:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010432c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104330:	ff 75 f0             	pushl  -0x10(%ebp)
f0104333:	52                   	push   %edx
f0104334:	50                   	push   %eax
f0104335:	68 b8 d3 12 f0       	push   $0xf012d3b8
f010433a:	e8 1d d8 ff ff       	call   f0101b5c <cprintf>
f010433f:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0104342:	83 ec 0c             	sub    $0xc,%esp
f0104345:	68 77 d3 12 f0       	push   $0xf012d377
f010434a:	e8 0d d8 ff ff       	call   f0101b5c <cprintf>
f010434f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104352:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104357:	c9                   	leave  
f0104358:	c3                   	ret    

f0104359 <command_set_starve_thresh>:
int command_set_starve_thresh(int number_of_arguments, char **arguments)
{
f0104359:	55                   	push   %ebp
f010435a:	89 e5                	mov    %esp,%ebp
f010435c:	83 ec 18             	sub    $0x18,%esp
	uint32 starvationThresh = strtol(arguments[1], NULL, 10);
f010435f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104362:	83 c0 04             	add    $0x4,%eax
f0104365:	8b 00                	mov    (%eax),%eax
f0104367:	83 ec 04             	sub    $0x4,%esp
f010436a:	6a 0a                	push   $0xa
f010436c:	6a 00                	push   $0x0
f010436e:	50                   	push   %eax
f010436f:	e8 18 6b 01 00       	call   f011ae8c <strtol>
f0104374:	83 c4 10             	add    $0x10,%esp
f0104377:	89 45 f4             	mov    %eax,-0xc(%ebp)
	sched_set_starv_thresh(starvationThresh);
f010437a:	83 ec 0c             	sub    $0xc,%esp
f010437d:	ff 75 f4             	pushl  -0xc(%ebp)
f0104380:	e8 f6 32 00 00       	call   f010767b <sched_set_starv_thresh>
f0104385:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104388:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010438d:	c9                   	leave  
f010438e:	c3                   	ret    

f010438f <command_set_priority>:
//*********************************************************************************//

int command_set_priority(int number_of_arguments, char **arguments)
{
f010438f:	55                   	push   %ebp
f0104390:	89 e5                	mov    %esp,%ebp
f0104392:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0104395:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104398:	83 c0 04             	add    $0x4,%eax
f010439b:	8b 00                	mov    (%eax),%eax
f010439d:	83 ec 04             	sub    $0x4,%esp
f01043a0:	6a 0a                	push   $0xa
f01043a2:	6a 00                	push   $0x0
f01043a4:	50                   	push   %eax
f01043a5:	e8 e2 6a 01 00       	call   f011ae8c <strtol>
f01043aa:	83 c4 10             	add    $0x10,%esp
f01043ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int32 priority = strtol(arguments[2],NULL, 10);
f01043b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01043b3:	83 c0 08             	add    $0x8,%eax
f01043b6:	8b 00                	mov    (%eax),%eax
f01043b8:	83 ec 04             	sub    $0x4,%esp
f01043bb:	6a 0a                	push   $0xa
f01043bd:	6a 00                	push   $0x0
f01043bf:	50                   	push   %eax
f01043c0:	e8 c7 6a 01 00       	call   f011ae8c <strtol>
f01043c5:	83 c4 10             	add    $0x10,%esp
f01043c8:	89 45 f0             	mov    %eax,-0x10(%ebp)

	env_set_priority(envId, priority);
f01043cb:	83 ec 08             	sub    $0x8,%esp
f01043ce:	ff 75 f0             	pushl  -0x10(%ebp)
f01043d1:	ff 75 f4             	pushl  -0xc(%ebp)
f01043d4:	e8 85 32 00 00       	call   f010765e <env_set_priority>
f01043d9:	83 c4 10             	add    $0x10,%esp

	return 0;
f01043dc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01043e1:	c9                   	leave  
f01043e2:	c3                   	ret    

f01043e3 <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f01043e3:	55                   	push   %ebp
f01043e4:	89 e5                	mov    %esp,%ebp
f01043e6:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f01043e9:	e8 bc 32 00 00       	call   f01076aa <isSchedMethodMLFQ>
f01043ee:	85 c0                	test   %eax,%eax
f01043f0:	74 5f                	je     f0104451 <command_print_sch_method+0x6e>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f01043f2:	83 ec 0c             	sub    $0xc,%esp
f01043f5:	68 18 d4 12 f0       	push   $0xf012d418
f01043fa:	e8 5d d7 ff ff       	call   f0101b5c <cprintf>
f01043ff:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0104402:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104409:	eb 24                	jmp    f010442f <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f010440b:	8b 15 44 61 85 f0    	mov    0xf0856144,%edx
f0104411:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104414:	01 d0                	add    %edx,%eax
f0104416:	8a 00                	mov    (%eax),%al
f0104418:	0f b6 c0             	movzbl %al,%eax
f010441b:	83 ec 08             	sub    $0x8,%esp
f010441e:	50                   	push   %eax
f010441f:	68 71 d3 12 f0       	push   $0xf012d371
f0104424:	e8 33 d7 ff ff       	call   f0101b5c <cprintf>
f0104429:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010442c:	ff 45 f4             	incl   -0xc(%ebp)
f010442f:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f0104434:	0f b6 c0             	movzbl %al,%eax
f0104437:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010443a:	7f cf                	jg     f010440b <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f010443c:	83 ec 0c             	sub    $0xc,%esp
f010443f:	68 77 d3 12 f0       	push   $0xf012d377
f0104444:	e8 13 d7 ff ff       	call   f0101b5c <cprintf>
f0104449:	83 c4 10             	add    $0x10,%esp
f010444c:	e9 94 00 00 00       	jmp    f01044e5 <command_print_sch_method+0x102>
	}
	else if (isSchedMethodRR())
f0104451:	e8 42 32 00 00       	call   f0107698 <isSchedMethodRR>
f0104456:	85 c0                	test   %eax,%eax
f0104458:	74 1d                	je     f0104477 <command_print_sch_method+0x94>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f010445a:	a1 44 61 85 f0       	mov    0xf0856144,%eax
f010445f:	8a 00                	mov    (%eax),%al
f0104461:	0f b6 c0             	movzbl %al,%eax
f0104464:	83 ec 08             	sub    $0x8,%esp
f0104467:	50                   	push   %eax
f0104468:	68 4c d4 12 f0       	push   $0xf012d44c
f010446d:	e8 ea d6 ff ff       	call   f0101b5c <cprintf>
f0104472:	83 c4 10             	add    $0x10,%esp
f0104475:	eb 6e                	jmp    f01044e5 <command_print_sch_method+0x102>
	}
	else if (isSchedMethodBSD())
f0104477:	e8 41 32 00 00       	call   f01076bd <isSchedMethodBSD>
f010447c:	85 c0                	test   %eax,%eax
f010447e:	74 26                	je     f01044a6 <command_print_sch_method+0xc3>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0104480:	a1 44 61 85 f0       	mov    0xf0856144,%eax
f0104485:	8a 00                	mov    (%eax),%al
f0104487:	0f b6 d0             	movzbl %al,%edx
f010448a:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f010448f:	0f b6 c0             	movzbl %al,%eax
f0104492:	83 ec 04             	sub    $0x4,%esp
f0104495:	52                   	push   %edx
f0104496:	50                   	push   %eax
f0104497:	68 7c d3 12 f0       	push   $0xf012d37c
f010449c:	e8 bb d6 ff ff       	call   f0101b5c <cprintf>
f01044a1:	83 c4 10             	add    $0x10,%esp
f01044a4:	eb 3f                	jmp    f01044e5 <command_print_sch_method+0x102>
	}
	else if (isSchedMethodPRIRR())
f01044a6:	e8 25 32 00 00       	call   f01076d0 <isSchedMethodPRIRR>
f01044ab:	85 c0                	test   %eax,%eax
f01044ad:	74 26                	je     f01044d5 <command_print_sch_method+0xf2>
	{
		cprintf("Scheduler is now set to PRIORITY RR with %d priorities & quantum = %d\n", num_of_ready_queues, quantums[0]);
f01044af:	a1 44 61 85 f0       	mov    0xf0856144,%eax
f01044b4:	8a 00                	mov    (%eax),%al
f01044b6:	0f b6 d0             	movzbl %al,%edx
f01044b9:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f01044be:	0f b6 c0             	movzbl %al,%eax
f01044c1:	83 ec 04             	sub    $0x4,%esp
f01044c4:	52                   	push   %edx
f01044c5:	50                   	push   %eax
f01044c6:	68 88 d4 12 f0       	push   $0xf012d488
f01044cb:	e8 8c d6 ff ff       	call   f0101b5c <cprintf>
f01044d0:	83 c4 10             	add    $0x10,%esp
f01044d3:	eb 10                	jmp    f01044e5 <command_print_sch_method+0x102>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f01044d5:	83 ec 0c             	sub    $0xc,%esp
f01044d8:	68 d0 d4 12 f0       	push   $0xf012d4d0
f01044dd:	e8 7a d6 ff ff       	call   f0101b5c <cprintf>
f01044e2:	83 c4 10             	add    $0x10,%esp

	return 0;
f01044e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01044ea:	c9                   	leave  
f01044eb:	c3                   	ret    

f01044ec <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f01044ec:	55                   	push   %ebp
f01044ed:	89 e5                	mov    %esp,%ebp
f01044ef:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f01044f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044f5:	83 c0 04             	add    $0x4,%eax
f01044f8:	8b 00                	mov    (%eax),%eax
f01044fa:	83 ec 04             	sub    $0x4,%esp
f01044fd:	6a 0a                	push   $0xa
f01044ff:	6a 00                	push   $0x0
f0104501:	50                   	push   %eax
f0104502:	e8 85 69 01 00       	call   f011ae8c <strtol>
f0104507:	83 c4 10             	add    $0x10,%esp
f010450a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f010450d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104510:	0f b6 c0             	movzbl %al,%eax
f0104513:	83 ec 0c             	sub    $0xc,%esp
f0104516:	50                   	push   %eax
f0104517:	e8 0d 56 01 00       	call   f0119b29 <chksch>
f010451c:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f010451f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104523:	75 12                	jne    f0104537 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f0104525:	83 ec 0c             	sub    $0xc,%esp
f0104528:	68 f8 d4 12 f0       	push   $0xf012d4f8
f010452d:	e8 2a d6 ff ff       	call   f0101b5c <cprintf>
f0104532:	83 c4 10             	add    $0x10,%esp
f0104535:	eb 16                	jmp    f010454d <command_sch_test+0x61>
	else if (status == 1)
f0104537:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010453b:	75 10                	jne    f010454d <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f010453d:	83 ec 0c             	sub    $0xc,%esp
f0104540:	68 20 d5 12 f0       	push   $0xf012d520
f0104545:	e8 12 d6 ff ff       	call   f0101b5c <cprintf>
f010454a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010454d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104552:	c9                   	leave  
f0104553:	c3                   	ret    

f0104554 <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f0104554:	55                   	push   %ebp
f0104555:	89 e5                	mov    %esp,%ebp
f0104557:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f010455a:	e8 dc b2 00 00       	call   f010f83b <isPageReplacmentAlgorithmCLOCK>
f010455f:	85 c0                	test   %eax,%eax
f0104561:	74 15                	je     f0104578 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f0104563:	83 ec 0c             	sub    $0xc,%esp
f0104566:	68 44 d5 12 f0       	push   $0xf012d544
f010456b:	e8 ec d5 ff ff       	call   f0101b5c <cprintf>
f0104570:	83 c4 10             	add    $0x10,%esp
f0104573:	e9 ff 00 00 00       	jmp    f0104677 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0104578:	83 ec 0c             	sub    $0xc,%esp
f010457b:	6a 01                	push   $0x1
f010457d:	e8 a3 b2 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f0104582:	83 c4 10             	add    $0x10,%esp
f0104585:	85 c0                	test   %eax,%eax
f0104587:	74 15                	je     f010459e <command_print_page_rep+0x4a>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f0104589:	83 ec 0c             	sub    $0xc,%esp
f010458c:	68 6c d5 12 f0       	push   $0xf012d56c
f0104591:	e8 c6 d5 ff ff       	call   f0101b5c <cprintf>
f0104596:	83 c4 10             	add    $0x10,%esp
f0104599:	e9 d9 00 00 00       	jmp    f0104677 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010459e:	83 ec 0c             	sub    $0xc,%esp
f01045a1:	6a 02                	push   $0x2
f01045a3:	e8 7d b2 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f01045a8:	83 c4 10             	add    $0x10,%esp
f01045ab:	85 c0                	test   %eax,%eax
f01045ad:	74 15                	je     f01045c4 <command_print_page_rep+0x70>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f01045af:	83 ec 0c             	sub    $0xc,%esp
f01045b2:	68 ac d5 12 f0       	push   $0xf012d5ac
f01045b7:	e8 a0 d5 ff ff       	call   f0101b5c <cprintf>
f01045bc:	83 c4 10             	add    $0x10,%esp
f01045bf:	e9 b3 00 00 00       	jmp    f0104677 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmFIFO())
f01045c4:	e8 8d b2 00 00       	call   f010f856 <isPageReplacmentAlgorithmFIFO>
f01045c9:	85 c0                	test   %eax,%eax
f01045cb:	74 15                	je     f01045e2 <command_print_page_rep+0x8e>
		cprintf("Page replacement algorithm is FIFO\n");
f01045cd:	83 ec 0c             	sub    $0xc,%esp
f01045d0:	68 e8 d5 12 f0       	push   $0xf012d5e8
f01045d5:	e8 82 d5 ff ff       	call   f0101b5c <cprintf>
f01045da:	83 c4 10             	add    $0x10,%esp
f01045dd:	e9 95 00 00 00       	jmp    f0104677 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f01045e2:	e8 8a b2 00 00       	call   f010f871 <isPageReplacmentAlgorithmModifiedCLOCK>
f01045e7:	85 c0                	test   %eax,%eax
f01045e9:	74 12                	je     f01045fd <command_print_page_rep+0xa9>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f01045eb:	83 ec 0c             	sub    $0xc,%esp
f01045ee:	68 0c d6 12 f0       	push   $0xf012d60c
f01045f3:	e8 64 d5 ff ff       	call   f0101b5c <cprintf>
f01045f8:	83 c4 10             	add    $0x10,%esp
f01045fb:	eb 7a                	jmp    f0104677 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmOPTIMAL())
f01045fd:	e8 c0 b2 00 00       	call   f010f8c2 <isPageReplacmentAlgorithmOPTIMAL>
f0104602:	85 c0                	test   %eax,%eax
f0104604:	74 12                	je     f0104618 <command_print_page_rep+0xc4>
		cprintf("Page replacement algorithm is OPTIMAL\n");
f0104606:	83 ec 0c             	sub    $0xc,%esp
f0104609:	68 3c d6 12 f0       	push   $0xf012d63c
f010460e:	e8 49 d5 ff ff       	call   f0101b5c <cprintf>
f0104613:	83 c4 10             	add    $0x10,%esp
f0104616:	eb 5f                	jmp    f0104677 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmNchanceCLOCK())
f0104618:	e8 8a b2 00 00       	call   f010f8a7 <isPageReplacmentAlgorithmNchanceCLOCK>
f010461d:	85 c0                	test   %eax,%eax
f010461f:	74 46                	je     f0104667 <command_print_page_rep+0x113>
	{
		cprintf("Page replacement algorithm is Nth Chance CLOCK ");
f0104621:	83 ec 0c             	sub    $0xc,%esp
f0104624:	68 64 d6 12 f0       	push   $0xf012d664
f0104629:	e8 2e d5 ff ff       	call   f0101b5c <cprintf>
f010462e:	83 c4 10             	add    $0x10,%esp
		if (page_WS_max_sweeps > 0)			cprintf("[NORMAL ver]\n");
f0104631:	a1 14 de 83 f0       	mov    0xf083de14,%eax
f0104636:	85 c0                	test   %eax,%eax
f0104638:	7e 12                	jle    f010464c <command_print_page_rep+0xf8>
f010463a:	83 ec 0c             	sub    $0xc,%esp
f010463d:	68 94 d6 12 f0       	push   $0xf012d694
f0104642:	e8 15 d5 ff ff       	call   f0101b5c <cprintf>
f0104647:	83 c4 10             	add    $0x10,%esp
f010464a:	eb 2b                	jmp    f0104677 <command_print_page_rep+0x123>
		else if (page_WS_max_sweeps < 0)	cprintf("[MODIFIED ver]\n");
f010464c:	a1 14 de 83 f0       	mov    0xf083de14,%eax
f0104651:	85 c0                	test   %eax,%eax
f0104653:	79 22                	jns    f0104677 <command_print_page_rep+0x123>
f0104655:	83 ec 0c             	sub    $0xc,%esp
f0104658:	68 a2 d6 12 f0       	push   $0xf012d6a2
f010465d:	e8 fa d4 ff ff       	call   f0101b5c <cprintf>
f0104662:	83 c4 10             	add    $0x10,%esp
f0104665:	eb 10                	jmp    f0104677 <command_print_page_rep+0x123>
	}
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f0104667:	83 ec 0c             	sub    $0xc,%esp
f010466a:	68 b4 d6 12 f0       	push   $0xf012d6b4
f010466f:	e8 e8 d4 ff ff       	call   f0101b5c <cprintf>
f0104674:	83 c4 10             	add    $0x10,%esp

	return 0;
f0104677:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010467c:	c9                   	leave  
f010467d:	c3                   	ret    

f010467e <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f010467e:	55                   	push   %ebp
f010467f:	89 e5                	mov    %esp,%ebp
f0104681:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_FIRSTFIT);
f0104684:	6a 01                	push   $0x1
f0104686:	e8 c9 e7 ff ff       	call   f0102e54 <set_uheap_strategy>
f010468b:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f010468e:	83 ec 0c             	sub    $0xc,%esp
f0104691:	68 e0 d6 12 f0       	push   $0xf012d6e0
f0104696:	e8 c1 d4 ff ff       	call   f0101b5c <cprintf>
f010469b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010469e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01046a3:	c9                   	leave  
f01046a4:	c3                   	ret    

f01046a5 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01046a5:	55                   	push   %ebp
f01046a6:	89 e5                	mov    %esp,%ebp
f01046a8:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_BESTFIT);
f01046ab:	6a 02                	push   $0x2
f01046ad:	e8 a2 e7 ff ff       	call   f0102e54 <set_uheap_strategy>
f01046b2:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01046b5:	83 ec 0c             	sub    $0xc,%esp
f01046b8:	68 10 d7 12 f0       	push   $0xf012d710
f01046bd:	e8 9a d4 ff ff       	call   f0101b5c <cprintf>
f01046c2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01046c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01046ca:	c9                   	leave  
f01046cb:	c3                   	ret    

f01046cc <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01046cc:	55                   	push   %ebp
f01046cd:	89 e5                	mov    %esp,%ebp
f01046cf:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_NEXTFIT);
f01046d2:	6a 03                	push   $0x3
f01046d4:	e8 7b e7 ff ff       	call   f0102e54 <set_uheap_strategy>
f01046d9:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01046dc:	83 ec 0c             	sub    $0xc,%esp
f01046df:	68 40 d7 12 f0       	push   $0xf012d740
f01046e4:	e8 73 d4 ff ff       	call   f0101b5c <cprintf>
f01046e9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01046ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01046f1:	c9                   	leave  
f01046f2:	c3                   	ret    

f01046f3 <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01046f3:	55                   	push   %ebp
f01046f4:	89 e5                	mov    %esp,%ebp
f01046f6:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_WORSTFIT);
f01046f9:	6a 04                	push   $0x4
f01046fb:	e8 54 e7 ff ff       	call   f0102e54 <set_uheap_strategy>
f0104700:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now WORST FIT\n");
f0104703:	83 ec 0c             	sub    $0xc,%esp
f0104706:	68 70 d7 12 f0       	push   $0xf012d770
f010470b:	e8 4c d4 ff ff       	call   f0101b5c <cprintf>
f0104710:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104713:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104718:	c9                   	leave  
f0104719:	c3                   	ret    

f010471a <command_set_uheap_plac_CUSTOMFIT>:
int command_set_uheap_plac_CUSTOMFIT(int number_of_arguments, char **arguments)
{
f010471a:	55                   	push   %ebp
f010471b:	89 e5                	mov    %esp,%ebp
f010471d:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_CUSTOMFIT);
f0104720:	6a 05                	push   $0x5
f0104722:	e8 2d e7 ff ff       	call   f0102e54 <set_uheap_strategy>
f0104727:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now CUSTOM FIT\n");
f010472a:	83 ec 0c             	sub    $0xc,%esp
f010472d:	68 a0 d7 12 f0       	push   $0xf012d7a0
f0104732:	e8 25 d4 ff ff       	call   f0101b5c <cprintf>
f0104737:	83 c4 10             	add    $0x10,%esp
	return 0;
f010473a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010473f:	c9                   	leave  
f0104740:	c3                   	ret    

f0104741 <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f0104741:	55                   	push   %ebp
f0104742:	89 e5                	mov    %esp,%ebp
f0104744:	83 ec 18             	sub    $0x18,%esp
	uint32 strategy = get_uheap_strategy();
f0104747:	e8 16 e7 ff ff       	call   f0102e62 <get_uheap_strategy>
f010474c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (strategy)
f010474f:	83 7d f4 05          	cmpl   $0x5,-0xc(%ebp)
f0104753:	77 69                	ja     f01047be <command_print_uheap_plac+0x7d>
f0104755:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104758:	c1 e0 02             	shl    $0x2,%eax
f010475b:	05 d8 d8 12 f0       	add    $0xf012d8d8,%eax
f0104760:	8b 00                	mov    (%eax),%eax
f0104762:	ff e0                	jmp    *%eax
	{
	case UHP_PLACE_FIRSTFIT:
		cprintf("User Heap placement strategy is FIRST FIT\n");
f0104764:	83 ec 0c             	sub    $0xc,%esp
f0104767:	68 d0 d7 12 f0       	push   $0xf012d7d0
f010476c:	e8 eb d3 ff ff       	call   f0101b5c <cprintf>
f0104771:	83 c4 10             	add    $0x10,%esp
		break;
f0104774:	eb 58                	jmp    f01047ce <command_print_uheap_plac+0x8d>
	case UHP_PLACE_NEXTFIT:
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0104776:	83 ec 0c             	sub    $0xc,%esp
f0104779:	68 fc d7 12 f0       	push   $0xf012d7fc
f010477e:	e8 d9 d3 ff ff       	call   f0101b5c <cprintf>
f0104783:	83 c4 10             	add    $0x10,%esp
		break;
f0104786:	eb 46                	jmp    f01047ce <command_print_uheap_plac+0x8d>
	case UHP_PLACE_BESTFIT:
		cprintf("User Heap placement strategy is BEST FIT\n");
f0104788:	83 ec 0c             	sub    $0xc,%esp
f010478b:	68 28 d8 12 f0       	push   $0xf012d828
f0104790:	e8 c7 d3 ff ff       	call   f0101b5c <cprintf>
f0104795:	83 c4 10             	add    $0x10,%esp
		break;
f0104798:	eb 34                	jmp    f01047ce <command_print_uheap_plac+0x8d>
	case UHP_PLACE_WORSTFIT:
		cprintf("User Heap placement strategy is WORST FIT\n");
f010479a:	83 ec 0c             	sub    $0xc,%esp
f010479d:	68 54 d8 12 f0       	push   $0xf012d854
f01047a2:	e8 b5 d3 ff ff       	call   f0101b5c <cprintf>
f01047a7:	83 c4 10             	add    $0x10,%esp
		break;
f01047aa:	eb 22                	jmp    f01047ce <command_print_uheap_plac+0x8d>
	case UHP_PLACE_CUSTOMFIT:
		cprintf("User Heap placement strategy is CUSTOM FIT\n");
f01047ac:	83 ec 0c             	sub    $0xc,%esp
f01047af:	68 80 d8 12 f0       	push   $0xf012d880
f01047b4:	e8 a3 d3 ff ff       	call   f0101b5c <cprintf>
f01047b9:	83 c4 10             	add    $0x10,%esp
		break;
f01047bc:	eb 10                	jmp    f01047ce <command_print_uheap_plac+0x8d>
	default:
		cprintf("User Heap placement strategy is UNDEFINED\n");
f01047be:	83 ec 0c             	sub    $0xc,%esp
f01047c1:	68 ac d8 12 f0       	push   $0xf012d8ac
f01047c6:	e8 91 d3 ff ff       	call   f0101b5c <cprintf>
f01047cb:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01047ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047d3:	c9                   	leave  
f01047d4:	c3                   	ret    

f01047d5 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f01047d5:	55                   	push   %ebp
f01047d6:	89 e5                	mov    %esp,%ebp
f01047d8:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_CONTALLOC);
f01047db:	6a 00                	push   $0x0
f01047dd:	e8 5a e6 ff ff       	call   f0102e3c <set_kheap_strategy>
f01047e2:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01047e5:	83 ec 0c             	sub    $0xc,%esp
f01047e8:	68 f0 d8 12 f0       	push   $0xf012d8f0
f01047ed:	e8 6a d3 ff ff       	call   f0101b5c <cprintf>
f01047f2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01047f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047fa:	c9                   	leave  
f01047fb:	c3                   	ret    

f01047fc <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01047fc:	55                   	push   %ebp
f01047fd:	89 e5                	mov    %esp,%ebp
f01047ff:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_FIRSTFIT);
f0104802:	6a 01                	push   $0x1
f0104804:	e8 33 e6 ff ff       	call   f0102e3c <set_kheap_strategy>
f0104809:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f010480c:	83 ec 0c             	sub    $0xc,%esp
f010480f:	68 f0 d8 12 f0       	push   $0xf012d8f0
f0104814:	e8 43 d3 ff ff       	call   f0101b5c <cprintf>
f0104819:	83 c4 10             	add    $0x10,%esp
	return 0;
f010481c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104821:	c9                   	leave  
f0104822:	c3                   	ret    

f0104823 <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0104823:	55                   	push   %ebp
f0104824:	89 e5                	mov    %esp,%ebp
f0104826:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_BESTFIT);
f0104829:	6a 02                	push   $0x2
f010482b:	e8 0c e6 ff ff       	call   f0102e3c <set_kheap_strategy>
f0104830:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f0104833:	83 ec 0c             	sub    $0xc,%esp
f0104836:	68 24 d9 12 f0       	push   $0xf012d924
f010483b:	e8 1c d3 ff ff       	call   f0101b5c <cprintf>
f0104840:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104843:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104848:	c9                   	leave  
f0104849:	c3                   	ret    

f010484a <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f010484a:	55                   	push   %ebp
f010484b:	89 e5                	mov    %esp,%ebp
f010484d:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_NEXTFIT);
f0104850:	6a 03                	push   $0x3
f0104852:	e8 e5 e5 ff ff       	call   f0102e3c <set_kheap_strategy>
f0104857:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f010485a:	83 ec 0c             	sub    $0xc,%esp
f010485d:	68 54 d9 12 f0       	push   $0xf012d954
f0104862:	e8 f5 d2 ff ff       	call   f0101b5c <cprintf>
f0104867:	83 c4 10             	add    $0x10,%esp
	return 0;
f010486a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010486f:	c9                   	leave  
f0104870:	c3                   	ret    

f0104871 <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0104871:	55                   	push   %ebp
f0104872:	89 e5                	mov    %esp,%ebp
f0104874:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_WORSTFIT);
f0104877:	6a 04                	push   $0x4
f0104879:	e8 be e5 ff ff       	call   f0102e3c <set_kheap_strategy>
f010487e:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0104881:	83 ec 0c             	sub    $0xc,%esp
f0104884:	68 84 d9 12 f0       	push   $0xf012d984
f0104889:	e8 ce d2 ff ff       	call   f0101b5c <cprintf>
f010488e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104891:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104896:	c9                   	leave  
f0104897:	c3                   	ret    

f0104898 <command_set_kheap_plac_CUSTOMFIT>:
int command_set_kheap_plac_CUSTOMFIT(int number_of_arguments, char **arguments)
{
f0104898:	55                   	push   %ebp
f0104899:	89 e5                	mov    %esp,%ebp
f010489b:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_CUSTOMFIT);
f010489e:	6a 05                	push   $0x5
f01048a0:	e8 97 e5 ff ff       	call   f0102e3c <set_kheap_strategy>
f01048a5:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now CUSTOM FIT\n");
f01048a8:	83 ec 0c             	sub    $0xc,%esp
f01048ab:	68 b8 d9 12 f0       	push   $0xf012d9b8
f01048b0:	e8 a7 d2 ff ff       	call   f0101b5c <cprintf>
f01048b5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01048b8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01048bd:	c9                   	leave  
f01048be:	c3                   	ret    

f01048bf <command_print_kheap_plac>:
int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f01048bf:	55                   	push   %ebp
f01048c0:	89 e5                	mov    %esp,%ebp
f01048c2:	83 ec 18             	sub    $0x18,%esp
	uint32 strategy = get_kheap_strategy();
f01048c5:	e8 80 e5 ff ff       	call   f0102e4a <get_kheap_strategy>
f01048ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (strategy)
f01048cd:	83 7d f4 05          	cmpl   $0x5,-0xc(%ebp)
f01048d1:	77 7b                	ja     f010494e <command_print_kheap_plac+0x8f>
f01048d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01048d6:	c1 e0 02             	shl    $0x2,%eax
f01048d9:	05 40 db 12 f0       	add    $0xf012db40,%eax
f01048de:	8b 00                	mov    (%eax),%eax
f01048e0:	ff e0                	jmp    *%eax
	{
	case KHP_PLACE_CONTALLOC:
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f01048e2:	83 ec 0c             	sub    $0xc,%esp
f01048e5:	68 ec d9 12 f0       	push   $0xf012d9ec
f01048ea:	e8 6d d2 ff ff       	call   f0101b5c <cprintf>
f01048ef:	83 c4 10             	add    $0x10,%esp
		break;
f01048f2:	eb 6a                	jmp    f010495e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_FIRSTFIT:
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f01048f4:	83 ec 0c             	sub    $0xc,%esp
f01048f7:	68 28 da 12 f0       	push   $0xf012da28
f01048fc:	e8 5b d2 ff ff       	call   f0101b5c <cprintf>
f0104901:	83 c4 10             	add    $0x10,%esp
		break;
f0104904:	eb 58                	jmp    f010495e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_NEXTFIT:
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0104906:	83 ec 0c             	sub    $0xc,%esp
f0104909:	68 58 da 12 f0       	push   $0xf012da58
f010490e:	e8 49 d2 ff ff       	call   f0101b5c <cprintf>
f0104913:	83 c4 10             	add    $0x10,%esp
		break;
f0104916:	eb 46                	jmp    f010495e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_BESTFIT:
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0104918:	83 ec 0c             	sub    $0xc,%esp
f010491b:	68 84 da 12 f0       	push   $0xf012da84
f0104920:	e8 37 d2 ff ff       	call   f0101b5c <cprintf>
f0104925:	83 c4 10             	add    $0x10,%esp
		break;
f0104928:	eb 34                	jmp    f010495e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_WORSTFIT:
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f010492a:	83 ec 0c             	sub    $0xc,%esp
f010492d:	68 b0 da 12 f0       	push   $0xf012dab0
f0104932:	e8 25 d2 ff ff       	call   f0101b5c <cprintf>
f0104937:	83 c4 10             	add    $0x10,%esp
		break;
f010493a:	eb 22                	jmp    f010495e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_CUSTOMFIT:
		cprintf("Kernel Heap placement strategy is CUSTOM FIT\n");
f010493c:	83 ec 0c             	sub    $0xc,%esp
f010493f:	68 e0 da 12 f0       	push   $0xf012dae0
f0104944:	e8 13 d2 ff ff       	call   f0101b5c <cprintf>
f0104949:	83 c4 10             	add    $0x10,%esp
		break;
f010494c:	eb 10                	jmp    f010495e <command_print_kheap_plac+0x9f>
	default:
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f010494e:	83 ec 0c             	sub    $0xc,%esp
f0104951:	68 10 db 12 f0       	push   $0xf012db10
f0104956:	e8 01 d2 ff ff       	call   f0101b5c <cprintf>
f010495b:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f010495e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104963:	c9                   	leave  
f0104964:	c3                   	ret    

f0104965 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0104965:	55                   	push   %ebp
f0104966:	89 e5                	mov    %esp,%ebp
f0104968:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f010496b:	e8 93 af 00 00       	call   f010f903 <isBufferingEnabled>
f0104970:	84 c0                	test   %al,%al
f0104972:	75 12                	jne    f0104986 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0104974:	83 ec 0c             	sub    $0xc,%esp
f0104977:	68 58 db 12 f0       	push   $0xf012db58
f010497c:	e8 db d1 ff ff       	call   f0101b5c <cprintf>
f0104981:	83 c4 10             	add    $0x10,%esp
f0104984:	eb 1d                	jmp    f01049a3 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0104986:	83 ec 0c             	sub    $0xc,%esp
f0104989:	6a 00                	push   $0x0
f010498b:	e8 4d af 00 00       	call   f010f8dd <enableModifiedBuffer>
f0104990:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0104993:	83 ec 0c             	sub    $0xc,%esp
f0104996:	68 94 db 12 f0       	push   $0xf012db94
f010499b:	e8 bc d1 ff ff       	call   f0101b5c <cprintf>
f01049a0:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01049a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01049a8:	c9                   	leave  
f01049a9:	c3                   	ret    

f01049aa <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f01049aa:	55                   	push   %ebp
f01049ab:	89 e5                	mov    %esp,%ebp
f01049ad:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01049b0:	e8 4e af 00 00       	call   f010f903 <isBufferingEnabled>
f01049b5:	84 c0                	test   %al,%al
f01049b7:	75 12                	jne    f01049cb <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01049b9:	83 ec 0c             	sub    $0xc,%esp
f01049bc:	68 58 db 12 f0       	push   $0xf012db58
f01049c1:	e8 96 d1 ff ff       	call   f0101b5c <cprintf>
f01049c6:	83 c4 10             	add    $0x10,%esp
f01049c9:	eb 1d                	jmp    f01049e8 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f01049cb:	83 ec 0c             	sub    $0xc,%esp
f01049ce:	6a 01                	push   $0x1
f01049d0:	e8 08 af 00 00       	call   f010f8dd <enableModifiedBuffer>
f01049d5:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f01049d8:	83 ec 0c             	sub    $0xc,%esp
f01049db:	68 b8 db 12 f0       	push   $0xf012dbb8
f01049e0:	e8 77 d1 ff ff       	call   f0101b5c <cprintf>
f01049e5:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01049e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01049ed:	c9                   	leave  
f01049ee:	c3                   	ret    

f01049ef <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f01049ef:	55                   	push   %ebp
f01049f0:	89 e5                	mov    %esp,%ebp
f01049f2:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f01049f5:	83 ec 0c             	sub    $0xc,%esp
f01049f8:	6a 00                	push   $0x0
f01049fa:	e8 f6 ae 00 00       	call   f010f8f5 <enableBuffering>
f01049ff:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0104a02:	83 ec 0c             	sub    $0xc,%esp
f0104a05:	6a 00                	push   $0x0
f0104a07:	e8 d1 ae 00 00       	call   f010f8dd <enableModifiedBuffer>
f0104a0c:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0104a0f:	83 ec 0c             	sub    $0xc,%esp
f0104a12:	68 d8 db 12 f0       	push   $0xf012dbd8
f0104a17:	e8 40 d1 ff ff       	call   f0101b5c <cprintf>
f0104a1c:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104a1f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104a24:	c9                   	leave  
f0104a25:	c3                   	ret    

f0104a26 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0104a26:	55                   	push   %ebp
f0104a27:	89 e5                	mov    %esp,%ebp
f0104a29:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0104a2c:	83 ec 0c             	sub    $0xc,%esp
f0104a2f:	6a 01                	push   $0x1
f0104a31:	e8 bf ae 00 00       	call   f010f8f5 <enableBuffering>
f0104a36:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0104a39:	83 ec 0c             	sub    $0xc,%esp
f0104a3c:	6a 01                	push   $0x1
f0104a3e:	e8 9a ae 00 00       	call   f010f8dd <enableModifiedBuffer>
f0104a43:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0104a46:	e8 d0 ae 00 00       	call   f010f91b <getModifiedBufferLength>
f0104a4b:	85 c0                	test   %eax,%eax
f0104a4d:	75 59                	jne    f0104aa8 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0104a4f:	83 ec 0c             	sub    $0xc,%esp
f0104a52:	68 f4 db 12 f0       	push   $0xf012dbf4
f0104a57:	e8 00 d1 ff ff       	call   f0101b5c <cprintf>
f0104a5c:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0104a5f:	83 ec 08             	sub    $0x8,%esp
f0104a62:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0104a65:	50                   	push   %eax
f0104a66:	68 24 dc 12 f0       	push   $0xf012dc24
f0104a6b:	e8 05 5e 01 00       	call   f011a875 <readline>
f0104a70:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0104a73:	83 ec 04             	sub    $0x4,%esp
f0104a76:	6a 0a                	push   $0xa
f0104a78:	6a 00                	push   $0x0
f0104a7a:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0104a7d:	50                   	push   %eax
f0104a7e:	e8 09 64 01 00       	call   f011ae8c <strtol>
f0104a83:	83 c4 10             	add    $0x10,%esp
f0104a86:	83 ec 0c             	sub    $0xc,%esp
f0104a89:	50                   	push   %eax
f0104a8a:	e8 7e ae 00 00       	call   f010f90d <setModifiedBufferLength>
f0104a8f:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0104a92:	e8 84 ae 00 00       	call   f010f91b <getModifiedBufferLength>
f0104a97:	83 ec 08             	sub    $0x8,%esp
f0104a9a:	50                   	push   %eax
f0104a9b:	68 50 dc 12 f0       	push   $0xf012dc50
f0104aa0:	e8 b7 d0 ff ff       	call   f0101b5c <cprintf>
f0104aa5:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0104aa8:	83 ec 0c             	sub    $0xc,%esp
f0104aab:	68 75 dc 12 f0       	push   $0xf012dc75
f0104ab0:	e8 a7 d0 ff ff       	call   f0101b5c <cprintf>
f0104ab5:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104ab8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104abd:	c9                   	leave  
f0104abe:	c3                   	ret    

f0104abf <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0104abf:	55                   	push   %ebp
f0104ac0:	89 e5                	mov    %esp,%ebp
f0104ac2:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0104ac5:	e8 39 ae 00 00       	call   f010f903 <isBufferingEnabled>
f0104aca:	84 c0                	test   %al,%al
f0104acc:	75 12                	jne    f0104ae0 <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0104ace:	83 ec 0c             	sub    $0xc,%esp
f0104ad1:	68 90 dc 12 f0       	push   $0xf012dc90
f0104ad6:	e8 81 d0 ff ff       	call   f0101b5c <cprintf>
f0104adb:	83 c4 10             	add    $0x10,%esp
f0104ade:	eb 19                	jmp    f0104af9 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0104ae0:	e8 06 ae 00 00       	call   f010f8eb <isModifiedBufferEnabled>
f0104ae5:	84 c0                	test   %al,%al
f0104ae7:	75 10                	jne    f0104af9 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0104ae9:	83 ec 0c             	sub    $0xc,%esp
f0104aec:	68 e0 dc 12 f0       	push   $0xf012dce0
f0104af1:	e8 66 d0 ff ff       	call   f0101b5c <cprintf>
f0104af6:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0104af9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104afc:	83 c0 04             	add    $0x4,%eax
f0104aff:	8b 00                	mov    (%eax),%eax
f0104b01:	83 ec 04             	sub    $0x4,%esp
f0104b04:	6a 0a                	push   $0xa
f0104b06:	6a 00                	push   $0x0
f0104b08:	50                   	push   %eax
f0104b09:	e8 7e 63 01 00       	call   f011ae8c <strtol>
f0104b0e:	83 c4 10             	add    $0x10,%esp
f0104b11:	83 ec 0c             	sub    $0xc,%esp
f0104b14:	50                   	push   %eax
f0104b15:	e8 f3 ad 00 00       	call   f010f90d <setModifiedBufferLength>
f0104b1a:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0104b1d:	e8 f9 ad 00 00       	call   f010f91b <getModifiedBufferLength>
f0104b22:	83 ec 08             	sub    $0x8,%esp
f0104b25:	50                   	push   %eax
f0104b26:	68 50 dc 12 f0       	push   $0xf012dc50
f0104b2b:	e8 2c d0 ff ff       	call   f0101b5c <cprintf>
f0104b30:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104b33:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104b38:	c9                   	leave  
f0104b39:	c3                   	ret    

f0104b3a <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0104b3a:	55                   	push   %ebp
f0104b3b:	89 e5                	mov    %esp,%ebp
f0104b3d:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0104b40:	e8 be ad 00 00       	call   f010f903 <isBufferingEnabled>
f0104b45:	84 c0                	test   %al,%al
f0104b47:	75 12                	jne    f0104b5b <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0104b49:	83 ec 0c             	sub    $0xc,%esp
f0104b4c:	68 90 dc 12 f0       	push   $0xf012dc90
f0104b51:	e8 06 d0 ff ff       	call   f0101b5c <cprintf>
f0104b56:	83 c4 10             	add    $0x10,%esp
f0104b59:	eb 19                	jmp    f0104b74 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0104b5b:	e8 8b ad 00 00       	call   f010f8eb <isModifiedBufferEnabled>
f0104b60:	84 c0                	test   %al,%al
f0104b62:	75 10                	jne    f0104b74 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0104b64:	83 ec 0c             	sub    $0xc,%esp
f0104b67:	68 e0 dc 12 f0       	push   $0xf012dce0
f0104b6c:	e8 eb cf ff ff       	call   f0101b5c <cprintf>
f0104b71:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0104b74:	e8 a2 ad 00 00       	call   f010f91b <getModifiedBufferLength>
f0104b79:	83 ec 08             	sub    $0x8,%esp
f0104b7c:	50                   	push   %eax
f0104b7d:	68 26 dd 12 f0       	push   $0xf012dd26
f0104b82:	e8 d5 cf ff ff       	call   f0101b5c <cprintf>
f0104b87:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104b8a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104b8f:	c9                   	leave  
f0104b90:	c3                   	ret    

f0104b91 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0104b91:	55                   	push   %ebp
f0104b92:	89 e5                	mov    %esp,%ebp
f0104b94:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0104b97:	83 ec 08             	sub    $0x8,%esp
f0104b9a:	ff 75 0c             	pushl  0xc(%ebp)
f0104b9d:	ff 75 08             	pushl  0x8(%ebp)
f0104ba0:	e8 c3 b6 00 00       	call   f0110268 <tst_handler>
f0104ba5:	83 c4 10             	add    $0x10,%esp
}
f0104ba8:	c9                   	leave  
f0104ba9:	c3                   	ret    

f0104baa <command_cls>:

// *************** This clear screen feature is implemented by *************
// ********* Abd-Alrahman Zedan From Team Frozen-Bytes - FCIS'24-25 ********
int command_cls(int number_of_arguments, char **arguments)
{
f0104baa:	55                   	push   %ebp
f0104bab:	89 e5                	mov    %esp,%ebp
f0104bad:	83 ec 08             	sub    $0x8,%esp
	clear_screen_buffer();
f0104bb0:	e8 7b ce ff ff       	call   f0101a30 <clear_screen_buffer>
	return 0;
f0104bb5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104bba:	c9                   	leave  
f0104bbb:	c3                   	ret    

f0104bbc <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0104bbc:	55                   	push   %ebp
f0104bbd:	89 e5                	mov    %esp,%ebp
f0104bbf:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0104bc2:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bc5:	05 00 14 00 00       	add    $0x1400,%eax
f0104bca:	c1 e0 03             	shl    $0x3,%eax
f0104bcd:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0104bd0:	83 ec 04             	sub    $0x4,%esp
f0104bd3:	6a 08                	push   $0x8
f0104bd5:	ff 75 0c             	pushl  0xc(%ebp)
f0104bd8:	ff 75 f4             	pushl  -0xc(%ebp)
f0104bdb:	e8 3f 67 01 00       	call   f011b31f <ide_read>
f0104be0:	83 c4 10             	add    $0x10,%esp
f0104be3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0104be6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104be9:	c9                   	leave  
f0104bea:	c3                   	ret    

f0104beb <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0104beb:	55                   	push   %ebp
f0104bec:	89 e5                	mov    %esp,%ebp
f0104bee:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0104bf1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bf4:	05 00 14 00 00       	add    $0x1400,%eax
f0104bf9:	c1 e0 03             	shl    $0x3,%eax
f0104bfc:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0104bff:	83 ec 04             	sub    $0x4,%esp
f0104c02:	6a 08                	push   $0x8
f0104c04:	ff 75 0c             	pushl  0xc(%ebp)
f0104c07:	ff 75 f4             	pushl  -0xc(%ebp)
f0104c0a:	e8 67 68 01 00       	call   f011b476 <ide_write>
f0104c0f:	83 c4 10             	add    $0x10,%esp
f0104c12:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0104c15:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104c19:	74 14                	je     f0104c2f <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0104c1b:	83 ec 04             	sub    $0x4,%esp
f0104c1e:	68 44 dd 12 f0       	push   $0xf012dd44
f0104c23:	6a 2f                	push   $0x2f
f0104c25:	68 5b dd 12 f0       	push   $0xf012dd5b
f0104c2a:	e8 80 c2 ff ff       	call   f0100eaf <_panic>
	return success;
f0104c2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104c32:	c9                   	leave  
f0104c33:	c3                   	ret    

f0104c34 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0104c34:	55                   	push   %ebp
f0104c35:	89 e5                	mov    %esp,%ebp
f0104c37:	53                   	push   %ebx
f0104c38:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0104c3b:	c7 05 40 63 85 f0 00 	movl   $0x0,0xf0856340
f0104c42:	00 00 00 
f0104c45:	c7 05 44 63 85 f0 00 	movl   $0x0,0xf0856344
f0104c4c:	00 00 00 
f0104c4f:	c7 05 4c 63 85 f0 00 	movl   $0x0,0xf085634c
f0104c56:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0104c59:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0104c60:	e9 ef 00 00 00       	jmp    f0104d54 <initialize_disk_page_file+0x120>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0104c65:	8b 0d a4 db 83 f0    	mov    0xf083dba4,%ecx
f0104c6b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c6e:	89 d0                	mov    %edx,%eax
f0104c70:	c1 e0 02             	shl    $0x2,%eax
f0104c73:	01 d0                	add    %edx,%eax
f0104c75:	c1 e0 02             	shl    $0x2,%eax
f0104c78:	01 c8                	add    %ecx,%eax
f0104c7a:	83 ec 0c             	sub    $0xc,%esp
f0104c7d:	50                   	push   %eax
f0104c7e:	e8 a7 43 00 00       	call   f010902a <initialize_frame_info>
f0104c83:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0104c86:	8b 0d a4 db 83 f0    	mov    0xf083dba4,%ecx
f0104c8c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c8f:	89 d0                	mov    %edx,%eax
f0104c91:	c1 e0 02             	shl    $0x2,%eax
f0104c94:	01 d0                	add    %edx,%eax
f0104c96:	c1 e0 02             	shl    $0x2,%eax
f0104c99:	01 c8                	add    %ecx,%eax
f0104c9b:	85 c0                	test   %eax,%eax
f0104c9d:	75 14                	jne    f0104cb3 <initialize_disk_page_file+0x7f>
f0104c9f:	83 ec 04             	sub    $0x4,%esp
f0104ca2:	68 78 dd 12 f0       	push   $0xf012dd78
f0104ca7:	6a 56                	push   $0x56
f0104ca9:	68 5b dd 12 f0       	push   $0xf012dd5b
f0104cae:	e8 fc c1 ff ff       	call   f0100eaf <_panic>
f0104cb3:	8b 0d a4 db 83 f0    	mov    0xf083dba4,%ecx
f0104cb9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cbc:	89 d0                	mov    %edx,%eax
f0104cbe:	c1 e0 02             	shl    $0x2,%eax
f0104cc1:	01 d0                	add    %edx,%eax
f0104cc3:	c1 e0 02             	shl    $0x2,%eax
f0104cc6:	01 c8                	add    %ecx,%eax
f0104cc8:	8b 15 40 63 85 f0    	mov    0xf0856340,%edx
f0104cce:	89 10                	mov    %edx,(%eax)
f0104cd0:	8b 00                	mov    (%eax),%eax
f0104cd2:	85 c0                	test   %eax,%eax
f0104cd4:	74 20                	je     f0104cf6 <initialize_disk_page_file+0xc2>
f0104cd6:	8b 15 40 63 85 f0    	mov    0xf0856340,%edx
f0104cdc:	8b 1d a4 db 83 f0    	mov    0xf083dba4,%ebx
f0104ce2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0104ce5:	89 c8                	mov    %ecx,%eax
f0104ce7:	c1 e0 02             	shl    $0x2,%eax
f0104cea:	01 c8                	add    %ecx,%eax
f0104cec:	c1 e0 02             	shl    $0x2,%eax
f0104cef:	01 d8                	add    %ebx,%eax
f0104cf1:	89 42 04             	mov    %eax,0x4(%edx)
f0104cf4:	eb 1a                	jmp    f0104d10 <initialize_disk_page_file+0xdc>
f0104cf6:	8b 0d a4 db 83 f0    	mov    0xf083dba4,%ecx
f0104cfc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cff:	89 d0                	mov    %edx,%eax
f0104d01:	c1 e0 02             	shl    $0x2,%eax
f0104d04:	01 d0                	add    %edx,%eax
f0104d06:	c1 e0 02             	shl    $0x2,%eax
f0104d09:	01 c8                	add    %ecx,%eax
f0104d0b:	a3 44 63 85 f0       	mov    %eax,0xf0856344
f0104d10:	8b 0d a4 db 83 f0    	mov    0xf083dba4,%ecx
f0104d16:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d19:	89 d0                	mov    %edx,%eax
f0104d1b:	c1 e0 02             	shl    $0x2,%eax
f0104d1e:	01 d0                	add    %edx,%eax
f0104d20:	c1 e0 02             	shl    $0x2,%eax
f0104d23:	01 c8                	add    %ecx,%eax
f0104d25:	a3 40 63 85 f0       	mov    %eax,0xf0856340
f0104d2a:	8b 0d a4 db 83 f0    	mov    0xf083dba4,%ecx
f0104d30:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d33:	89 d0                	mov    %edx,%eax
f0104d35:	c1 e0 02             	shl    $0x2,%eax
f0104d38:	01 d0                	add    %edx,%eax
f0104d3a:	c1 e0 02             	shl    $0x2,%eax
f0104d3d:	01 c8                	add    %ecx,%eax
f0104d3f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104d46:	a1 4c 63 85 f0       	mov    0xf085634c,%eax
f0104d4b:	40                   	inc    %eax
f0104d4c:	a3 4c 63 85 f0       	mov    %eax,0xf085634c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0104d51:	ff 45 f4             	incl   -0xc(%ebp)
f0104d54:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0104d5b:	0f 8e 04 ff ff ff    	jle    f0104c65 <initialize_disk_page_file+0x31>

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}

	init_kspinlock(&DiskFrameLists.dfllock, "Disk FrameList Lock");
f0104d61:	83 ec 08             	sub    $0x8,%esp
f0104d64:	68 9b dd 12 f0       	push   $0xf012dd9b
f0104d69:	68 50 63 85 f0       	push   $0xf0856350
f0104d6e:	e8 d9 af 00 00       	call   f010fd4c <init_kspinlock>
f0104d73:	83 c4 10             	add    $0x10,%esp
}
f0104d76:	90                   	nop
f0104d77:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104d7a:	c9                   	leave  
f0104d7b:	c3                   	ret    

f0104d7c <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0104d7c:	55                   	push   %ebp
f0104d7d:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0104d7f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d82:	8b 15 a4 db 83 f0    	mov    0xf083dba4,%edx
f0104d88:	29 d0                	sub    %edx,%eax
f0104d8a:	c1 f8 02             	sar    $0x2,%eax
f0104d8d:	89 c2                	mov    %eax,%edx
f0104d8f:	89 d0                	mov    %edx,%eax
f0104d91:	c1 e0 02             	shl    $0x2,%eax
f0104d94:	01 d0                	add    %edx,%eax
f0104d96:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0104d9d:	01 c8                	add    %ecx,%eax
f0104d9f:	01 c0                	add    %eax,%eax
f0104da1:	01 d0                	add    %edx,%eax
f0104da3:	89 c1                	mov    %eax,%ecx
f0104da5:	c1 e1 08             	shl    $0x8,%ecx
f0104da8:	01 c8                	add    %ecx,%eax
f0104daa:	89 c1                	mov    %eax,%ecx
f0104dac:	c1 e1 10             	shl    $0x10,%ecx
f0104daf:	01 c8                	add    %ecx,%eax
f0104db1:	c1 e0 02             	shl    $0x2,%eax
f0104db4:	01 d0                	add    %edx,%eax
}
f0104db6:	5d                   	pop    %ebp
f0104db7:	c3                   	ret    

f0104db8 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0104db8:	55                   	push   %ebp
f0104db9:	89 e5                	mov    %esp,%ebp
f0104dbb:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0104dbe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_kspinlock(&DiskFrameLists.dfllock);
f0104dc5:	83 ec 0c             	sub    $0xc,%esp
f0104dc8:	68 50 63 85 f0       	push   $0xf0856350
f0104dcd:	e8 ab af 00 00       	call   f010fd7d <acquire_kspinlock>
f0104dd2:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0104dd5:	a1 40 63 85 f0       	mov    0xf0856340,%eax
f0104dda:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0104ddd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104de1:	75 0c                	jne    f0104def <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0104de3:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0104dea:	e9 a2 00 00 00       	jmp    f0104e91 <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0104def:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104df3:	75 14                	jne    f0104e09 <allocate_disk_frame+0x51>
f0104df5:	83 ec 04             	sub    $0x4,%esp
f0104df8:	68 af dd 12 f0       	push   $0xf012ddaf
f0104dfd:	6a 7d                	push   $0x7d
f0104dff:	68 5b dd 12 f0       	push   $0xf012dd5b
f0104e04:	e8 a6 c0 ff ff       	call   f0100eaf <_panic>
f0104e09:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e0c:	8b 00                	mov    (%eax),%eax
f0104e0e:	85 c0                	test   %eax,%eax
f0104e10:	74 10                	je     f0104e22 <allocate_disk_frame+0x6a>
f0104e12:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e15:	8b 00                	mov    (%eax),%eax
f0104e17:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e1a:	8b 52 04             	mov    0x4(%edx),%edx
f0104e1d:	89 50 04             	mov    %edx,0x4(%eax)
f0104e20:	eb 0b                	jmp    f0104e2d <allocate_disk_frame+0x75>
f0104e22:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e25:	8b 40 04             	mov    0x4(%eax),%eax
f0104e28:	a3 44 63 85 f0       	mov    %eax,0xf0856344
f0104e2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e30:	8b 40 04             	mov    0x4(%eax),%eax
f0104e33:	85 c0                	test   %eax,%eax
f0104e35:	74 0f                	je     f0104e46 <allocate_disk_frame+0x8e>
f0104e37:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e3a:	8b 40 04             	mov    0x4(%eax),%eax
f0104e3d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e40:	8b 12                	mov    (%edx),%edx
f0104e42:	89 10                	mov    %edx,(%eax)
f0104e44:	eb 0a                	jmp    f0104e50 <allocate_disk_frame+0x98>
f0104e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e49:	8b 00                	mov    (%eax),%eax
f0104e4b:	a3 40 63 85 f0       	mov    %eax,0xf0856340
f0104e50:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e53:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104e59:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e5c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104e63:	a1 4c 63 85 f0       	mov    0xf085634c,%eax
f0104e68:	48                   	dec    %eax
f0104e69:	a3 4c 63 85 f0       	mov    %eax,0xf085634c
			initialize_frame_info(ptr_frame_info);
f0104e6e:	83 ec 0c             	sub    $0xc,%esp
f0104e71:	ff 75 f0             	pushl  -0x10(%ebp)
f0104e74:	e8 b1 41 00 00       	call   f010902a <initialize_frame_info>
f0104e79:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0104e7c:	83 ec 0c             	sub    $0xc,%esp
f0104e7f:	ff 75 f0             	pushl  -0x10(%ebp)
f0104e82:	e8 f5 fe ff ff       	call   f0104d7c <to_disk_frame_number>
f0104e87:	83 c4 10             	add    $0x10,%esp
f0104e8a:	89 c2                	mov    %eax,%edx
f0104e8c:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e8f:	89 10                	mov    %edx,(%eax)
		}
	}
	release_kspinlock(&DiskFrameLists.dfllock);
f0104e91:	83 ec 0c             	sub    $0xc,%esp
f0104e94:	68 50 63 85 f0       	push   $0xf0856350
f0104e99:	e8 84 af 00 00       	call   f010fe22 <release_kspinlock>
f0104e9e:	83 c4 10             	add    $0x10,%esp

	return ret;
f0104ea1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104ea4:	c9                   	leave  
f0104ea5:	c3                   	ret    

f0104ea6 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0104ea6:	55                   	push   %ebp
f0104ea7:	89 e5                	mov    %esp,%ebp
f0104ea9:	53                   	push   %ebx
f0104eaa:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0104ead:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104eb1:	0f 84 f0 00 00 00    	je     f0104fa7 <free_disk_frame+0x101>
	acquire_kspinlock(&DiskFrameLists.dfllock);
f0104eb7:	83 ec 0c             	sub    $0xc,%esp
f0104eba:	68 50 63 85 f0       	push   $0xf0856350
f0104ebf:	e8 b9 ae 00 00       	call   f010fd7d <acquire_kspinlock>
f0104ec4:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0104ec7:	8b 0d a4 db 83 f0    	mov    0xf083dba4,%ecx
f0104ecd:	8b 55 08             	mov    0x8(%ebp),%edx
f0104ed0:	89 d0                	mov    %edx,%eax
f0104ed2:	c1 e0 02             	shl    $0x2,%eax
f0104ed5:	01 d0                	add    %edx,%eax
f0104ed7:	c1 e0 02             	shl    $0x2,%eax
f0104eda:	01 c8                	add    %ecx,%eax
f0104edc:	85 c0                	test   %eax,%eax
f0104ede:	75 17                	jne    f0104ef7 <free_disk_frame+0x51>
f0104ee0:	83 ec 04             	sub    $0x4,%esp
f0104ee3:	68 78 dd 12 f0       	push   $0xf012dd78
f0104ee8:	68 90 00 00 00       	push   $0x90
f0104eed:	68 5b dd 12 f0       	push   $0xf012dd5b
f0104ef2:	e8 b8 bf ff ff       	call   f0100eaf <_panic>
f0104ef7:	8b 0d a4 db 83 f0    	mov    0xf083dba4,%ecx
f0104efd:	8b 55 08             	mov    0x8(%ebp),%edx
f0104f00:	89 d0                	mov    %edx,%eax
f0104f02:	c1 e0 02             	shl    $0x2,%eax
f0104f05:	01 d0                	add    %edx,%eax
f0104f07:	c1 e0 02             	shl    $0x2,%eax
f0104f0a:	01 c8                	add    %ecx,%eax
f0104f0c:	8b 15 40 63 85 f0    	mov    0xf0856340,%edx
f0104f12:	89 10                	mov    %edx,(%eax)
f0104f14:	8b 00                	mov    (%eax),%eax
f0104f16:	85 c0                	test   %eax,%eax
f0104f18:	74 20                	je     f0104f3a <free_disk_frame+0x94>
f0104f1a:	8b 15 40 63 85 f0    	mov    0xf0856340,%edx
f0104f20:	8b 1d a4 db 83 f0    	mov    0xf083dba4,%ebx
f0104f26:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0104f29:	89 c8                	mov    %ecx,%eax
f0104f2b:	c1 e0 02             	shl    $0x2,%eax
f0104f2e:	01 c8                	add    %ecx,%eax
f0104f30:	c1 e0 02             	shl    $0x2,%eax
f0104f33:	01 d8                	add    %ebx,%eax
f0104f35:	89 42 04             	mov    %eax,0x4(%edx)
f0104f38:	eb 1a                	jmp    f0104f54 <free_disk_frame+0xae>
f0104f3a:	8b 0d a4 db 83 f0    	mov    0xf083dba4,%ecx
f0104f40:	8b 55 08             	mov    0x8(%ebp),%edx
f0104f43:	89 d0                	mov    %edx,%eax
f0104f45:	c1 e0 02             	shl    $0x2,%eax
f0104f48:	01 d0                	add    %edx,%eax
f0104f4a:	c1 e0 02             	shl    $0x2,%eax
f0104f4d:	01 c8                	add    %ecx,%eax
f0104f4f:	a3 44 63 85 f0       	mov    %eax,0xf0856344
f0104f54:	8b 0d a4 db 83 f0    	mov    0xf083dba4,%ecx
f0104f5a:	8b 55 08             	mov    0x8(%ebp),%edx
f0104f5d:	89 d0                	mov    %edx,%eax
f0104f5f:	c1 e0 02             	shl    $0x2,%eax
f0104f62:	01 d0                	add    %edx,%eax
f0104f64:	c1 e0 02             	shl    $0x2,%eax
f0104f67:	01 c8                	add    %ecx,%eax
f0104f69:	a3 40 63 85 f0       	mov    %eax,0xf0856340
f0104f6e:	8b 0d a4 db 83 f0    	mov    0xf083dba4,%ecx
f0104f74:	8b 55 08             	mov    0x8(%ebp),%edx
f0104f77:	89 d0                	mov    %edx,%eax
f0104f79:	c1 e0 02             	shl    $0x2,%eax
f0104f7c:	01 d0                	add    %edx,%eax
f0104f7e:	c1 e0 02             	shl    $0x2,%eax
f0104f81:	01 c8                	add    %ecx,%eax
f0104f83:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f8a:	a1 4c 63 85 f0       	mov    0xf085634c,%eax
f0104f8f:	40                   	inc    %eax
f0104f90:	a3 4c 63 85 f0       	mov    %eax,0xf085634c
	}
	release_kspinlock(&DiskFrameLists.dfllock);
f0104f95:	83 ec 0c             	sub    $0xc,%esp
f0104f98:	68 50 63 85 f0       	push   $0xf0856350
f0104f9d:	e8 80 ae 00 00       	call   f010fe22 <release_kspinlock>
f0104fa2:	83 c4 10             	add    $0x10,%esp
f0104fa5:	eb 01                	jmp    f0104fa8 <free_disk_frame+0x102>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0104fa7:	90                   	nop
	acquire_kspinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_kspinlock(&DiskFrameLists.dfllock);
}
f0104fa8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104fab:	c9                   	leave  
f0104fac:	c3                   	ret    

f0104fad <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0104fad:	55                   	push   %ebp
f0104fae:	89 e5                	mov    %esp,%ebp
f0104fb0:	53                   	push   %ebx
f0104fb1:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0104fb4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104fb7:	c1 e8 16             	shr    $0x16,%eax
f0104fba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104fc1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fc4:	01 d0                	add    %edx,%eax
f0104fc6:	8b 00                	mov    (%eax),%eax
f0104fc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0104fcb:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104fd2:	77 1d                	ja     f0104ff1 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f0104fd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104fd7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104fdc:	83 ec 0c             	sub    $0xc,%esp
f0104fdf:	50                   	push   %eax
f0104fe0:	e8 88 4b 00 00       	call   f0109b6d <kheap_virtual_address>
f0104fe5:	83 c4 10             	add    $0x10,%esp
f0104fe8:	89 c2                	mov    %eax,%edx
f0104fea:	8b 45 14             	mov    0x14(%ebp),%eax
f0104fed:	89 10                	mov    %edx,(%eax)
f0104fef:	eb 44                	jmp    f0105035 <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0104ff1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104ff4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104ff9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104ffc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104fff:	c1 e8 0c             	shr    $0xc,%eax
f0105002:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0105005:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f010500a:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f010500d:	72 17                	jb     f0105026 <get_disk_page_table+0x79>
f010500f:	ff 75 f0             	pushl  -0x10(%ebp)
f0105012:	68 d0 dd 12 f0       	push   $0xf012ddd0
f0105017:	68 9f 00 00 00       	push   $0x9f
f010501c:	68 5b dd 12 f0       	push   $0xf012dd5b
f0105021:	e8 89 be ff ff       	call   f0100eaf <_panic>
f0105026:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105029:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010502e:	89 c2                	mov    %eax,%edx
f0105030:	8b 45 14             	mov    0x14(%ebp),%eax
f0105033:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f0105035:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105039:	0f 85 80 00 00 00    	jne    f01050bf <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f010503f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0105043:	74 6a                	je     f01050af <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f0105045:	83 ec 0c             	sub    $0xc,%esp
f0105048:	68 00 10 00 00       	push   $0x1000
f010504d:	e8 e7 4a 00 00       	call   f0109b39 <kmalloc>
f0105052:	83 c4 10             	add    $0x10,%esp
f0105055:	89 c2                	mov    %eax,%edx
f0105057:	8b 45 14             	mov    0x14(%ebp),%eax
f010505a:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f010505c:	8b 45 14             	mov    0x14(%ebp),%eax
f010505f:	8b 00                	mov    (%eax),%eax
f0105061:	85 c0                	test   %eax,%eax
f0105063:	75 07                	jne    f010506c <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f0105065:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010506a:	eb 58                	jmp    f01050c4 <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f010506c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010506f:	c1 e8 16             	shr    $0x16,%eax
f0105072:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105079:	8b 45 08             	mov    0x8(%ebp),%eax
f010507c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f010507f:	8b 45 14             	mov    0x14(%ebp),%eax
f0105082:	8b 00                	mov    (%eax),%eax
f0105084:	83 ec 0c             	sub    $0xc,%esp
f0105087:	50                   	push   %eax
f0105088:	e8 fa 4a 00 00       	call   f0109b87 <kheap_physical_address>
f010508d:	83 c4 10             	add    $0x10,%esp
f0105090:	83 c8 01             	or     $0x1,%eax
f0105093:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f0105095:	8b 45 14             	mov    0x14(%ebp),%eax
f0105098:	8b 00                	mov    (%eax),%eax
f010509a:	83 ec 04             	sub    $0x4,%esp
f010509d:	68 00 10 00 00       	push   $0x1000
f01050a2:	6a 00                	push   $0x0
f01050a4:	50                   	push   %eax
f01050a5:	e8 c1 5b 01 00       	call   f011ac6b <memset>
f01050aa:	83 c4 10             	add    $0x10,%esp
f01050ad:	eb 10                	jmp    f01050bf <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01050af:	8b 45 14             	mov    0x14(%ebp),%eax
f01050b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01050b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01050bd:	eb 05                	jmp    f01050c4 <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01050bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01050c4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01050c7:	c9                   	leave  
f01050c8:	c3                   	ret    

f01050c9 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f01050c9:	55                   	push   %ebp
f01050ca:	89 e5                	mov    %esp,%ebp
f01050cc:	83 ec 28             	sub    $0x28,%esp
f01050cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01050d2:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f01050d5:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f01050d9:	74 72                	je     f010514d <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f01050db:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f01050e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050e5:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01050ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01050ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01050f0:	ba 00 00 00 00       	mov    $0x0,%edx
f01050f5:	f7 75 f4             	divl   -0xc(%ebp)
f01050f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01050fb:	29 d0                	sub    %edx,%eax
f01050fd:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0105100:	73 2f                	jae    f0105131 <pf_add_empty_env_page+0x68>
f0105102:	8b 45 08             	mov    0x8(%ebp),%eax
f0105105:	8b 50 6c             	mov    0x6c(%eax),%edx
f0105108:	b8 00 00 00 00       	mov    $0x0,%eax
f010510d:	29 d0                	sub    %edx,%eax
f010510f:	c1 e0 0c             	shl    $0xc,%eax
f0105112:	2d 00 20 40 11       	sub    $0x11402000,%eax
f0105117:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010511a:	76 15                	jbe    f0105131 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f010511c:	8b 45 08             	mov    0x8(%ebp),%eax
f010511f:	8b 80 bc 05 00 00    	mov    0x5bc(%eax),%eax
f0105125:	8d 50 01             	lea    0x1(%eax),%edx
f0105128:	8b 45 08             	mov    0x8(%ebp),%eax
f010512b:	89 90 bc 05 00 00    	mov    %edx,0x5bc(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0105131:	a1 78 61 85 f0       	mov    0xf0856178,%eax
f0105136:	83 ec 04             	sub    $0x4,%esp
f0105139:	50                   	push   %eax
f010513a:	ff 75 0c             	pushl  0xc(%ebp)
f010513d:	ff 75 08             	pushl  0x8(%ebp)
f0105140:	e8 b2 00 00 00       	call   f01051f7 <pf_add_env_page>
f0105145:	83 c4 10             	add    $0x10,%esp
f0105148:	e9 a8 00 00 00       	jmp    f01051f5 <pf_add_empty_env_page+0x12c>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f010514d:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0105154:	76 19                	jbe    f010516f <pf_add_empty_env_page+0xa6>
f0105156:	68 00 de 12 f0       	push   $0xf012de00
f010515b:	68 26 de 12 f0       	push   $0xf012de26
f0105160:	68 de 00 00 00       	push   $0xde
f0105165:	68 5b dd 12 f0       	push   $0xf012dd5b
f010516a:	e8 40 bd ff ff       	call   f0100eaf <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010516f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105172:	83 c0 74             	add    $0x74,%eax
f0105175:	83 ec 08             	sub    $0x8,%esp
f0105178:	50                   	push   %eax
f0105179:	ff 75 08             	pushl  0x8(%ebp)
f010517c:	e8 8f 05 00 00       	call   f0105710 <get_disk_page_directory>
f0105181:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0105184:	8b 45 08             	mov    0x8(%ebp),%eax
f0105187:	8b 40 74             	mov    0x74(%eax),%eax
f010518a:	8d 55 ec             	lea    -0x14(%ebp),%edx
f010518d:	52                   	push   %edx
f010518e:	6a 01                	push   $0x1
f0105190:	ff 75 0c             	pushl  0xc(%ebp)
f0105193:	50                   	push   %eax
f0105194:	e8 14 fe ff ff       	call   f0104fad <get_disk_page_table>
f0105199:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010519c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010519f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01051a2:	c1 ea 0c             	shr    $0xc,%edx
f01051a5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01051ab:	c1 e2 02             	shl    $0x2,%edx
f01051ae:	01 d0                	add    %edx,%eax
f01051b0:	8b 00                	mov    (%eax),%eax
f01051b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01051b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01051b8:	85 c0                	test   %eax,%eax
f01051ba:	75 34                	jne    f01051f0 <pf_add_empty_env_page+0x127>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01051bc:	83 ec 0c             	sub    $0xc,%esp
f01051bf:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01051c2:	50                   	push   %eax
f01051c3:	e8 f0 fb ff ff       	call   f0104db8 <allocate_disk_frame>
f01051c8:	83 c4 10             	add    $0x10,%esp
f01051cb:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01051ce:	75 07                	jne    f01051d7 <pf_add_empty_env_page+0x10e>
f01051d0:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01051d5:	eb 1e                	jmp    f01051f5 <pf_add_empty_env_page+0x12c>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01051d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01051da:	8b 55 0c             	mov    0xc(%ebp),%edx
f01051dd:	c1 ea 0c             	shr    $0xc,%edx
f01051e0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01051e6:	c1 e2 02             	shl    $0x2,%edx
f01051e9:	01 c2                	add    %eax,%edx
f01051eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01051ee:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f01051f0:	b8 00 00 00 00       	mov    $0x0,%eax

}
f01051f5:	c9                   	leave  
f01051f6:	c3                   	ret    

f01051f7 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f01051f7:	55                   	push   %ebp
f01051f8:	89 e5                	mov    %esp,%ebp
f01051fa:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f01051fd:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0105204:	76 19                	jbe    f010521f <pf_add_env_page+0x28>
f0105206:	68 00 de 12 f0       	push   $0xf012de00
f010520b:	68 26 de 12 f0       	push   $0xf012de26
f0105210:	68 f3 00 00 00       	push   $0xf3
f0105215:	68 5b dd 12 f0       	push   $0xf012dd5b
f010521a:	e8 90 bc ff ff       	call   f0100eaf <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010521f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105222:	83 c0 74             	add    $0x74,%eax
f0105225:	83 ec 08             	sub    $0x8,%esp
f0105228:	50                   	push   %eax
f0105229:	ff 75 08             	pushl  0x8(%ebp)
f010522c:	e8 df 04 00 00       	call   f0105710 <get_disk_page_directory>
f0105231:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0105234:	8b 45 08             	mov    0x8(%ebp),%eax
f0105237:	8b 40 74             	mov    0x74(%eax),%eax
f010523a:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010523d:	52                   	push   %edx
f010523e:	6a 01                	push   $0x1
f0105240:	ff 75 0c             	pushl  0xc(%ebp)
f0105243:	50                   	push   %eax
f0105244:	e8 64 fd ff ff       	call   f0104fad <get_disk_page_table>
f0105249:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010524c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010524f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105252:	c1 ea 0c             	shr    $0xc,%edx
f0105255:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010525b:	c1 e2 02             	shl    $0x2,%edx
f010525e:	01 d0                	add    %edx,%eax
f0105260:	8b 00                	mov    (%eax),%eax
f0105262:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f0105265:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105268:	85 c0                	test   %eax,%eax
f010526a:	75 34                	jne    f01052a0 <pf_add_env_page+0xa9>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010526c:	83 ec 0c             	sub    $0xc,%esp
f010526f:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0105272:	50                   	push   %eax
f0105273:	e8 40 fb ff ff       	call   f0104db8 <allocate_disk_frame>
f0105278:	83 c4 10             	add    $0x10,%esp
f010527b:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010527e:	75 07                	jne    f0105287 <pf_add_env_page+0x90>
f0105280:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0105285:	eb 31                	jmp    f01052b8 <pf_add_env_page+0xc1>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0105287:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010528a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010528d:	c1 ea 0c             	shr    $0xc,%edx
f0105290:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105296:	c1 e2 02             	shl    $0x2,%edx
f0105299:	01 c2                	add    %eax,%edx
f010529b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010529e:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01052a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01052a3:	83 ec 08             	sub    $0x8,%esp
f01052a6:	ff 75 10             	pushl  0x10(%ebp)
f01052a9:	50                   	push   %eax
f01052aa:	e8 3c f9 ff ff       	call   f0104beb <write_disk_page>
f01052af:	83 c4 10             	add    $0x10,%esp
f01052b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01052b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01052b8:	c9                   	leave  
f01052b9:	c3                   	ret    

f01052ba <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01052ba:	55                   	push   %ebp
f01052bb:	89 e5                	mov    %esp,%ebp
f01052bd:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01052c0:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01052c7:	76 19                	jbe    f01052e2 <pf_update_env_page+0x28>
f01052c9:	68 00 de 12 f0       	push   $0xf012de00
f01052ce:	68 26 de 12 f0       	push   $0xf012de26
f01052d3:	68 15 01 00 00       	push   $0x115
f01052d8:	68 5b dd 12 f0       	push   $0xf012dd5b
f01052dd:	e8 cd bb ff ff       	call   f0100eaf <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01052e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01052e5:	83 c0 74             	add    $0x74,%eax
f01052e8:	83 ec 08             	sub    $0x8,%esp
f01052eb:	50                   	push   %eax
f01052ec:	ff 75 08             	pushl  0x8(%ebp)
f01052ef:	e8 1c 04 00 00       	call   f0105710 <get_disk_page_directory>
f01052f4:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01052f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01052fa:	8b 40 74             	mov    0x74(%eax),%eax
f01052fd:	8d 55 e0             	lea    -0x20(%ebp),%edx
f0105300:	52                   	push   %edx
f0105301:	6a 00                	push   $0x0
f0105303:	ff 75 0c             	pushl  0xc(%ebp)
f0105306:	50                   	push   %eax
f0105307:	e8 a1 fc ff ff       	call   f0104fad <get_disk_page_table>
f010530c:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f010530f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105312:	85 c0                	test   %eax,%eax
f0105314:	74 29                	je     f010533f <pf_update_env_page+0x85>
f0105316:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105319:	85 c0                	test   %eax,%eax
f010531b:	0f 84 bf 00 00 00    	je     f01053e0 <pf_update_env_page+0x126>
f0105321:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105324:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105327:	c1 ea 0c             	shr    $0xc,%edx
f010532a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105330:	c1 e2 02             	shl    $0x2,%edx
f0105333:	01 d0                	add    %edx,%eax
f0105335:	8b 00                	mov    (%eax),%eax
f0105337:	85 c0                	test   %eax,%eax
f0105339:	0f 85 a1 00 00 00    	jne    f01053e0 <pf_update_env_page+0x126>
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f010533f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105342:	85 c0                	test   %eax,%eax
f0105344:	79 09                	jns    f010534f <pf_update_env_page+0x95>
f0105346:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010534d:	76 30                	jbe    f010537f <pf_update_env_page+0xc5>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f010534f:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0105356:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105359:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010535e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0105361:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105364:	ba 00 00 00 00       	mov    $0x0,%edx
f0105369:	f7 75 f4             	divl   -0xc(%ebp)
f010536c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010536f:	29 d0                	sub    %edx,%eax

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f0105371:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0105374:	77 53                	ja     f01053c9 <pf_update_env_page+0x10f>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f0105376:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010537d:	77 4a                	ja     f01053c9 <pf_update_env_page+0x10f>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, virtual_address, 0);
f010537f:	83 ec 04             	sub    $0x4,%esp
f0105382:	6a 00                	push   $0x0
f0105384:	ff 75 0c             	pushl  0xc(%ebp)
f0105387:	ff 75 08             	pushl  0x8(%ebp)
f010538a:	e8 3a fd ff ff       	call   f01050c9 <pf_add_empty_env_page>
f010538f:	83 c4 10             	add    $0x10,%esp
f0105392:	89 45 ec             	mov    %eax,-0x14(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f0105395:	83 7d ec f8          	cmpl   $0xfffffff8,-0x14(%ebp)
f0105399:	75 17                	jne    f01053b2 <pf_update_env_page+0xf8>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f010539b:	83 ec 04             	sub    $0x4,%esp
f010539e:	68 3c de 12 f0       	push   $0xf012de3c
f01053a3:	68 45 01 00 00       	push   $0x145
f01053a8:	68 5b dd 12 f0       	push   $0xf012dd5b
f01053ad:	e8 fd ba ff ff       	call   f0100eaf <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01053b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01053b5:	8b 80 bc 05 00 00    	mov    0x5bc(%eax),%eax
f01053bb:	8d 50 01             	lea    0x1(%eax),%edx
f01053be:	8b 45 08             	mov    0x8(%ebp),%eax
f01053c1:	89 90 bc 05 00 00    	mov    %edx,0x5bc(%eax)
f01053c7:	eb 17                	jmp    f01053e0 <pf_update_env_page+0x126>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f01053c9:	83 ec 04             	sub    $0x4,%esp
f01053cc:	68 88 de 12 f0       	push   $0xf012de88
f01053d1:	68 4e 01 00 00       	push   $0x14e
f01053d6:	68 5b dd 12 f0       	push   $0xf012dd5b
f01053db:	e8 cf ba ff ff       	call   f0100eaf <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01053e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01053e3:	8b 40 74             	mov    0x74(%eax),%eax
f01053e6:	8d 55 e0             	lea    -0x20(%ebp),%edx
f01053e9:	52                   	push   %edx
f01053ea:	6a 00                	push   $0x0
f01053ec:	ff 75 0c             	pushl  0xc(%ebp)
f01053ef:	50                   	push   %eax
f01053f0:	e8 b8 fb ff ff       	call   f0104fad <get_disk_page_table>
f01053f5:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01053f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01053fb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01053fe:	c1 ea 0c             	shr    $0xc,%edx
f0105401:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105407:	c1 e2 02             	shl    $0x2,%edx
f010540a:	01 d0                	add    %edx,%eax
f010540c:	8b 00                	mov    (%eax),%eax
f010540e:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//FIX'24 (el7): due to concurrency issues in 1-1 thread model, using the USER_LIMIT as a temp loc
		//				will lead to concurrency problems since it's shared among processes.
		//				Instead, use PGFLTEMP as a local temporarily page at user space for this mapping
		//				to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, (uint32)PGFLTEMP, 0);
f0105411:	8b 45 08             	mov    0x8(%ebp),%eax
f0105414:	8b 40 64             	mov    0x64(%eax),%eax
f0105417:	6a 00                	push   $0x0
f0105419:	68 00 f0 3f 00       	push   $0x3ff000
f010541e:	ff 75 10             	pushl  0x10(%ebp)
f0105421:	50                   	push   %eax
f0105422:	e8 bf 40 00 00       	call   f01094e6 <map_frame>
f0105427:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN((uint32)PGFLTEMP, PAGE_SIZE));
f010542a:	c7 45 e4 00 f0 3f 00 	movl   $0x3ff000,-0x1c(%ebp)
f0105431:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105434:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0105439:	83 ec 08             	sub    $0x8,%esp
f010543c:	50                   	push   %eax
f010543d:	ff 75 e8             	pushl  -0x18(%ebp)
f0105440:	e8 a6 f7 ff ff       	call   f0104beb <write_disk_page>
f0105445:	83 c4 10             	add    $0x10,%esp
f0105448:	89 45 ec             	mov    %eax,-0x14(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f010544b:	8b 45 10             	mov    0x10(%ebp),%eax
f010544e:	8b 40 08             	mov    0x8(%eax),%eax
f0105451:	40                   	inc    %eax
f0105452:	8b 55 10             	mov    0x10(%ebp),%edx
f0105455:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, (uint32)PGFLTEMP);
f0105459:	8b 45 08             	mov    0x8(%ebp),%eax
f010545c:	8b 40 64             	mov    0x64(%eax),%eax
f010545f:	83 ec 08             	sub    $0x8,%esp
f0105462:	68 00 f0 3f 00       	push   $0x3ff000
f0105467:	50                   	push   %eax
f0105468:	e8 e5 41 00 00       	call   f0109652 <unmap_frame>
f010546d:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f0105470:	8b 45 10             	mov    0x10(%ebp),%eax
f0105473:	8b 40 08             	mov    0x8(%eax),%eax
f0105476:	48                   	dec    %eax
f0105477:	8b 55 10             	mov    0x10(%ebp),%edx
f010547a:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f010547e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105481:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0105487:	8d 50 01             	lea    0x1(%eax),%edx
f010548a:	8b 45 08             	mov    0x8(%ebp),%eax
f010548d:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
	//======================

	return ret;
f0105493:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0105496:	c9                   	leave  
f0105497:	c3                   	ret    

f0105498 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f0105498:	55                   	push   %ebp
f0105499:	89 e5                	mov    %esp,%ebp
f010549b:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f010549e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01054a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01054a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01054a7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01054ac:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01054af:	8b 45 08             	mov    0x8(%ebp),%eax
f01054b2:	8b 40 74             	mov    0x74(%eax),%eax
f01054b5:	85 c0                	test   %eax,%eax
f01054b7:	75 0a                	jne    f01054c3 <pf_read_env_page+0x2b>
f01054b9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01054be:	e9 90 00 00 00       	jmp    f0105553 <pf_read_env_page+0xbb>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f01054c3:	8b 55 0c             	mov    0xc(%ebp),%edx
f01054c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01054c9:	8b 40 74             	mov    0x74(%eax),%eax
f01054cc:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f01054cf:	51                   	push   %ecx
f01054d0:	6a 00                	push   $0x0
f01054d2:	52                   	push   %edx
f01054d3:	50                   	push   %eax
f01054d4:	e8 d4 fa ff ff       	call   f0104fad <get_disk_page_table>
f01054d9:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01054dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01054df:	85 c0                	test   %eax,%eax
f01054e1:	75 07                	jne    f01054ea <pf_read_env_page+0x52>
f01054e3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01054e8:	eb 69                	jmp    f0105553 <pf_read_env_page+0xbb>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01054ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01054ed:	8b 55 0c             	mov    0xc(%ebp),%edx
f01054f0:	c1 ea 0c             	shr    $0xc,%edx
f01054f3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01054f9:	c1 e2 02             	shl    $0x2,%edx
f01054fc:	01 d0                	add    %edx,%eax
f01054fe:	8b 00                	mov    (%eax),%eax
f0105500:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0105503:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105507:	75 07                	jne    f0105510 <pf_read_env_page+0x78>
f0105509:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010550e:	eb 43                	jmp    f0105553 <pf_read_env_page+0xbb>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f0105510:	83 ec 08             	sub    $0x8,%esp
f0105513:	ff 75 0c             	pushl  0xc(%ebp)
f0105516:	ff 75 f0             	pushl  -0x10(%ebp)
f0105519:	e8 9e f6 ff ff       	call   f0104bbc <read_disk_page>
f010551e:	83 c4 10             	add    $0x10,%esp
f0105521:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0105524:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105527:	8b 45 08             	mov    0x8(%ebp),%eax
f010552a:	8b 40 64             	mov    0x64(%eax),%eax
f010552d:	6a 40                	push   $0x40
f010552f:	6a 00                	push   $0x0
f0105531:	52                   	push   %edx
f0105532:	50                   	push   %eax
f0105533:	e8 ca 46 00 00       	call   f0109c02 <pt_set_page_permissions>
f0105538:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010553b:	8b 45 08             	mov    0x8(%ebp),%eax
f010553e:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0105544:	8d 50 01             	lea    0x1(%eax),%edx
f0105547:	8b 45 08             	mov    0x8(%ebp),%eax
f010554a:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
	//======================

	return disk_read_error;
f0105550:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0105553:	c9                   	leave  
f0105554:	c3                   	ret    

f0105555 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f0105555:	55                   	push   %ebp
f0105556:	89 e5                	mov    %esp,%ebp
f0105558:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010555b:	8b 45 08             	mov    0x8(%ebp),%eax
f010555e:	8b 40 74             	mov    0x74(%eax),%eax
f0105561:	85 c0                	test   %eax,%eax
f0105563:	74 62                	je     f01055c7 <pf_remove_env_page+0x72>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0105565:	8b 45 08             	mov    0x8(%ebp),%eax
f0105568:	8b 40 74             	mov    0x74(%eax),%eax
f010556b:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010556e:	52                   	push   %edx
f010556f:	6a 00                	push   $0x0
f0105571:	ff 75 0c             	pushl  0xc(%ebp)
f0105574:	50                   	push   %eax
f0105575:	e8 33 fa ff ff       	call   f0104fad <get_disk_page_table>
f010557a:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f010557d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105580:	85 c0                	test   %eax,%eax
f0105582:	74 46                	je     f01055ca <pf_remove_env_page+0x75>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0105584:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105587:	8b 55 0c             	mov    0xc(%ebp),%edx
f010558a:	c1 ea 0c             	shr    $0xc,%edx
f010558d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105593:	c1 e2 02             	shl    $0x2,%edx
f0105596:	01 d0                	add    %edx,%eax
f0105598:	8b 00                	mov    (%eax),%eax
f010559a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f010559d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01055a0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01055a3:	c1 ea 0c             	shr    $0xc,%edx
f01055a6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01055ac:	c1 e2 02             	shl    $0x2,%edx
f01055af:	01 d0                	add    %edx,%eax
f01055b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01055b7:	83 ec 0c             	sub    $0xc,%esp
f01055ba:	ff 75 f4             	pushl  -0xc(%ebp)
f01055bd:	e8 e4 f8 ff ff       	call   f0104ea6 <free_disk_frame>
f01055c2:	83 c4 10             	add    $0x10,%esp
f01055c5:	eb 04                	jmp    f01055cb <pf_remove_env_page+0x76>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01055c7:	90                   	nop
f01055c8:	eb 01                	jmp    f01055cb <pf_remove_env_page+0x76>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f01055ca:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f01055cb:	c9                   	leave  
f01055cc:	c3                   	ret    

f01055cd <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f01055cd:	55                   	push   %ebp
f01055ce:	89 e5                	mov    %esp,%ebp
f01055d0:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01055d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01055da:	e9 b8 00 00 00       	jmp    f0105697 <pf_free_env+0xca>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f01055df:	8b 45 08             	mov    0x8(%ebp),%eax
f01055e2:	8b 40 74             	mov    0x74(%eax),%eax
f01055e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01055e8:	c1 e2 02             	shl    $0x2,%edx
f01055eb:	01 d0                	add    %edx,%eax
f01055ed:	8b 00                	mov    (%eax),%eax
f01055ef:	83 e0 01             	and    $0x1,%eax
f01055f2:	85 c0                	test   %eax,%eax
f01055f4:	0f 84 99 00 00 00    	je     f0105693 <pf_free_env+0xc6>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f01055fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01055fd:	8b 40 74             	mov    0x74(%eax),%eax
f0105600:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105603:	c1 e2 02             	shl    $0x2,%edx
f0105606:	01 d0                	add    %edx,%eax
f0105608:	8b 00                	mov    (%eax),%eax
f010560a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010560f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f0105612:	83 ec 0c             	sub    $0xc,%esp
f0105615:	ff 75 ec             	pushl  -0x14(%ebp)
f0105618:	e8 50 45 00 00       	call   f0109b6d <kheap_virtual_address>
f010561d:	83 c4 10             	add    $0x10,%esp
f0105620:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f0105623:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010562a:	eb 3a                	jmp    f0105666 <pf_free_env+0x99>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f010562c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010562f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105636:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105639:	01 d0                	add    %edx,%eax
f010563b:	8b 00                	mov    (%eax),%eax
f010563d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f0105640:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105643:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010564a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010564d:	01 d0                	add    %edx,%eax
f010564f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f0105655:	83 ec 0c             	sub    $0xc,%esp
f0105658:	ff 75 e4             	pushl  -0x1c(%ebp)
f010565b:	e8 46 f8 ff ff       	call   f0104ea6 <free_disk_frame>
f0105660:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f0105663:	ff 45 f0             	incl   -0x10(%ebp)
f0105666:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f010566d:	76 bd                	jbe    f010562c <pf_free_env+0x5f>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f010566f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105672:	8b 40 74             	mov    0x74(%eax),%eax
f0105675:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105678:	c1 e2 02             	shl    $0x2,%edx
f010567b:	01 d0                	add    %edx,%eax
f010567d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f0105683:	83 ec 0c             	sub    $0xc,%esp
f0105686:	ff 75 e8             	pushl  -0x18(%ebp)
f0105689:	e8 c5 44 00 00       	call   f0109b53 <kfree>
f010568e:	83 c4 10             	add    $0x10,%esp
f0105691:	eb 01                	jmp    f0105694 <pf_free_env+0xc7>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f0105693:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0105694:	ff 45 f4             	incl   -0xc(%ebp)
f0105697:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010569e:	0f 86 3b ff ff ff    	jbe    f01055df <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f01056a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056a7:	8b 40 74             	mov    0x74(%eax),%eax
f01056aa:	83 ec 0c             	sub    $0xc,%esp
f01056ad:	50                   	push   %eax
f01056ae:	e8 a0 44 00 00       	call   f0109b53 <kfree>
f01056b3:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f01056b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b9:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	ptr_env->disk_env_pgdir_PA = 0;
f01056c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01056c3:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f01056ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01056cd:	8b 40 7c             	mov    0x7c(%eax),%eax
f01056d0:	85 c0                	test   %eax,%eax
f01056d2:	74 39                	je     f010570d <pf_free_env+0x140>
		return;
	__pf_remove_env_all_tables(ptr_env);
f01056d4:	83 ec 0c             	sub    $0xc,%esp
f01056d7:	ff 75 08             	pushl  0x8(%ebp)
f01056da:	e8 f1 02 00 00       	call   f01059d0 <__pf_remove_env_all_tables>
f01056df:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f01056e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01056e5:	8b 40 7c             	mov    0x7c(%eax),%eax
f01056e8:	83 ec 0c             	sub    $0xc,%esp
f01056eb:	50                   	push   %eax
f01056ec:	e8 62 44 00 00       	call   f0109b53 <kfree>
f01056f1:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f01056f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056f7:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	ptr_env->disk_env_tabledir_PA = 0;
f01056fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0105701:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0105708:	00 00 00 
f010570b:	eb 01                	jmp    f010570e <pf_free_env+0x141>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010570d:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010570e:	c9                   	leave  
f010570f:	c3                   	ret    

f0105710 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f0105710:	55                   	push   %ebp
f0105711:	89 e5                	mov    %esp,%ebp
f0105713:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0105716:	8b 45 08             	mov    0x8(%ebp),%eax
f0105719:	8b 50 74             	mov    0x74(%eax),%edx
f010571c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010571f:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0105721:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105724:	8b 00                	mov    (%eax),%eax
f0105726:	85 c0                	test   %eax,%eax
f0105728:	75 58                	jne    f0105782 <get_disk_page_directory+0x72>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010572a:	83 ec 0c             	sub    $0xc,%esp
f010572d:	68 00 10 00 00       	push   $0x1000
f0105732:	e8 02 44 00 00       	call   f0109b39 <kmalloc>
f0105737:	83 c4 10             	add    $0x10,%esp
f010573a:	89 c2                	mov    %eax,%edx
f010573c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010573f:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f0105741:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105744:	8b 00                	mov    (%eax),%eax
f0105746:	85 c0                	test   %eax,%eax
f0105748:	75 07                	jne    f0105751 <get_disk_page_directory+0x41>
			{
				return E_NO_VM;
f010574a:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010574f:	eb 36                	jmp    f0105787 <get_disk_page_directory+0x77>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f0105751:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105754:	8b 00                	mov    (%eax),%eax
f0105756:	83 ec 0c             	sub    $0xc,%esp
f0105759:	50                   	push   %eax
f010575a:	e8 28 44 00 00       	call   f0109b87 <kheap_physical_address>
f010575f:	83 c4 10             	add    $0x10,%esp
f0105762:	89 c2                	mov    %eax,%edx
f0105764:	8b 45 08             	mov    0x8(%ebp),%eax
f0105767:	89 50 78             	mov    %edx,0x78(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f010576a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010576d:	8b 00                	mov    (%eax),%eax
f010576f:	83 ec 04             	sub    $0x4,%esp
f0105772:	68 00 10 00 00       	push   $0x1000
f0105777:	6a 00                	push   $0x0
f0105779:	50                   	push   %eax
f010577a:	e8 ec 54 01 00       	call   f011ac6b <memset>
f010577f:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0105782:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105787:	c9                   	leave  
f0105788:	c3                   	ret    

f0105789 <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f0105789:	55                   	push   %ebp
f010578a:	89 e5                	mov    %esp,%ebp
f010578c:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f010578f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0105796:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010579d:	eb 78                	jmp    f0105817 <pf_calculate_allocated_pages+0x8e>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f010579f:	8b 45 08             	mov    0x8(%ebp),%eax
f01057a2:	8b 40 74             	mov    0x74(%eax),%eax
f01057a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01057a8:	c1 e2 02             	shl    $0x2,%edx
f01057ab:	01 d0                	add    %edx,%eax
f01057ad:	8b 00                	mov    (%eax),%eax
f01057af:	83 e0 01             	and    $0x1,%eax
f01057b2:	85 c0                	test   %eax,%eax
f01057b4:	74 5d                	je     f0105813 <pf_calculate_allocated_pages+0x8a>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f01057b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01057b9:	8b 40 74             	mov    0x74(%eax),%eax
f01057bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01057bf:	c1 e2 02             	shl    $0x2,%edx
f01057c2:	01 d0                	add    %edx,%eax
f01057c4:	8b 00                	mov    (%eax),%eax
f01057c6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01057cb:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f01057ce:	83 ec 0c             	sub    $0xc,%esp
f01057d1:	ff 75 e8             	pushl  -0x18(%ebp)
f01057d4:	e8 94 43 00 00       	call   f0109b6d <kheap_virtual_address>
f01057d9:	83 c4 10             	add    $0x10,%esp
f01057dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f01057df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01057e6:	eb 20                	jmp    f0105808 <pf_calculate_allocated_pages+0x7f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f01057e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01057eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01057f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01057f5:	01 d0                	add    %edx,%eax
f01057f7:	8b 00                	mov    (%eax),%eax
f01057f9:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f01057fc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0105800:	74 03                	je     f0105805 <pf_calculate_allocated_pages+0x7c>
				counter ++;
f0105802:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0105805:	ff 45 ec             	incl   -0x14(%ebp)
f0105808:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010580f:	76 d7                	jbe    f01057e8 <pf_calculate_allocated_pages+0x5f>
f0105811:	eb 01                	jmp    f0105814 <pf_calculate_allocated_pages+0x8b>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f0105813:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0105814:	ff 45 f4             	incl   -0xc(%ebp)
f0105817:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010581e:	0f 86 7b ff ff ff    	jbe    f010579f <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f0105824:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0105827:	c9                   	leave  
f0105828:	c3                   	ret    

f0105829 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0105829:	55                   	push   %ebp
f010582a:	89 e5                	mov    %esp,%ebp
f010582c:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_kspinlock(&DiskFrameLists.dfllock);
f010582f:	83 ec 0c             	sub    $0xc,%esp
f0105832:	68 50 63 85 f0       	push   $0xf0856350
f0105837:	e8 41 a5 00 00       	call   f010fd7d <acquire_kspinlock>
f010583c:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f010583f:	a1 4c 63 85 f0       	mov    0xf085634c,%eax
f0105844:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_kspinlock(&DiskFrameLists.dfllock);
f0105847:	83 ec 0c             	sub    $0xc,%esp
f010584a:	68 50 63 85 f0       	push   $0xf0856350
f010584f:	e8 ce a5 00 00       	call   f010fe22 <release_kspinlock>
f0105854:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f0105857:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f010585a:	c9                   	leave  
f010585b:	c3                   	ret    

f010585c <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f010585c:	55                   	push   %ebp
f010585d:	89 e5                	mov    %esp,%ebp
f010585f:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f0105862:	8b 45 08             	mov    0x8(%ebp),%eax
f0105865:	8b 50 7c             	mov    0x7c(%eax),%edx
f0105868:	8b 45 0c             	mov    0xc(%ebp),%eax
f010586b:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f010586d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105870:	8b 00                	mov    (%eax),%eax
f0105872:	85 c0                	test   %eax,%eax
f0105874:	75 5b                	jne    f01058d1 <get_disk_table_directory+0x75>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f0105876:	83 ec 0c             	sub    $0xc,%esp
f0105879:	68 00 10 00 00       	push   $0x1000
f010587e:	e8 b6 42 00 00       	call   f0109b39 <kmalloc>
f0105883:	83 c4 10             	add    $0x10,%esp
f0105886:	89 c2                	mov    %eax,%edx
f0105888:	8b 45 0c             	mov    0xc(%ebp),%eax
f010588b:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f010588d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105890:	8b 00                	mov    (%eax),%eax
f0105892:	85 c0                	test   %eax,%eax
f0105894:	75 07                	jne    f010589d <get_disk_table_directory+0x41>
			{
				return E_NO_VM;
f0105896:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010589b:	eb 39                	jmp    f01058d6 <get_disk_table_directory+0x7a>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f010589d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01058a0:	8b 00                	mov    (%eax),%eax
f01058a2:	83 ec 0c             	sub    $0xc,%esp
f01058a5:	50                   	push   %eax
f01058a6:	e8 dc 42 00 00       	call   f0109b87 <kheap_physical_address>
f01058ab:	83 c4 10             	add    $0x10,%esp
f01058ae:	89 c2                	mov    %eax,%edx
f01058b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01058b3:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f01058b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01058bc:	8b 00                	mov    (%eax),%eax
f01058be:	83 ec 04             	sub    $0x4,%esp
f01058c1:	68 00 10 00 00       	push   $0x1000
f01058c6:	6a 00                	push   $0x0
f01058c8:	50                   	push   %eax
f01058c9:	e8 9d 53 01 00       	call   f011ac6b <memset>
f01058ce:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01058d1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01058d6:	c9                   	leave  
f01058d7:	c3                   	ret    

f01058d8 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f01058d8:	55                   	push   %ebp
f01058d9:	89 e5                	mov    %esp,%ebp
f01058db:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f01058de:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01058e5:	76 19                	jbe    f0105900 <__pf_write_env_table+0x28>
f01058e7:	68 00 de 12 f0       	push   $0xf012de00
f01058ec:	68 26 de 12 f0       	push   $0xf012de26
f01058f1:	68 98 02 00 00       	push   $0x298
f01058f6:	68 5b dd 12 f0       	push   $0xf012dd5b
f01058fb:	e8 af b5 ff ff       	call   f0100eaf <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f0105900:	8b 45 08             	mov    0x8(%ebp),%eax
f0105903:	83 c0 7c             	add    $0x7c,%eax
f0105906:	83 ec 08             	sub    $0x8,%esp
f0105909:	50                   	push   %eax
f010590a:	ff 75 08             	pushl  0x8(%ebp)
f010590d:	e8 4a ff ff ff       	call   f010585c <get_disk_table_directory>
f0105912:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0105915:	8b 45 08             	mov    0x8(%ebp),%eax
f0105918:	8b 40 7c             	mov    0x7c(%eax),%eax
f010591b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010591e:	c1 ea 16             	shr    $0x16,%edx
f0105921:	c1 e2 02             	shl    $0x2,%edx
f0105924:	01 d0                	add    %edx,%eax
f0105926:	8b 00                	mov    (%eax),%eax
f0105928:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f010592b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010592e:	85 c0                	test   %eax,%eax
f0105930:	75 31                	jne    f0105963 <__pf_write_env_table+0x8b>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0105932:	83 ec 0c             	sub    $0xc,%esp
f0105935:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0105938:	50                   	push   %eax
f0105939:	e8 7a f4 ff ff       	call   f0104db8 <allocate_disk_frame>
f010593e:	83 c4 10             	add    $0x10,%esp
f0105941:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0105944:	75 07                	jne    f010594d <__pf_write_env_table+0x75>
f0105946:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010594b:	eb 2e                	jmp    f010597b <__pf_write_env_table+0xa3>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f010594d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105950:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105953:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105956:	c1 ea 16             	shr    $0x16,%edx
f0105959:	c1 e2 02             	shl    $0x2,%edx
f010595c:	01 c2                	add    %eax,%edx
f010595e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105961:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f0105963:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105966:	83 ec 08             	sub    $0x8,%esp
f0105969:	ff 75 10             	pushl  0x10(%ebp)
f010596c:	50                   	push   %eax
f010596d:	e8 79 f2 ff ff       	call   f0104beb <write_disk_page>
f0105972:	83 c4 10             	add    $0x10,%esp
f0105975:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f0105978:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010597b:	c9                   	leave  
f010597c:	c3                   	ret    

f010597d <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f010597d:	55                   	push   %ebp
f010597e:	89 e5                	mov    %esp,%ebp
f0105980:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0105983:	8b 45 08             	mov    0x8(%ebp),%eax
f0105986:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105989:	85 c0                	test   %eax,%eax
f010598b:	75 07                	jne    f0105994 <__pf_read_env_table+0x17>
f010598d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0105992:	eb 3a                	jmp    f01059ce <__pf_read_env_table+0x51>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0105994:	8b 45 08             	mov    0x8(%ebp),%eax
f0105997:	8b 40 7c             	mov    0x7c(%eax),%eax
f010599a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010599d:	c1 ea 16             	shr    $0x16,%edx
f01059a0:	c1 e2 02             	shl    $0x2,%edx
f01059a3:	01 d0                	add    %edx,%eax
f01059a5:	8b 00                	mov    (%eax),%eax
f01059a7:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f01059aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059ae:	75 07                	jne    f01059b7 <__pf_read_env_table+0x3a>
f01059b0:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f01059b5:	eb 17                	jmp    f01059ce <__pf_read_env_table+0x51>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f01059b7:	83 ec 08             	sub    $0x8,%esp
f01059ba:	ff 75 10             	pushl  0x10(%ebp)
f01059bd:	ff 75 f4             	pushl  -0xc(%ebp)
f01059c0:	e8 f7 f1 ff ff       	call   f0104bbc <read_disk_page>
f01059c5:	83 c4 10             	add    $0x10,%esp
f01059c8:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f01059cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f01059ce:	c9                   	leave  
f01059cf:	c3                   	ret    

f01059d0 <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f01059d0:	55                   	push   %ebp
f01059d1:	89 e5                	mov    %esp,%ebp
f01059d3:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f01059d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01059d9:	8b 40 7c             	mov    0x7c(%eax),%eax
f01059dc:	85 c0                	test   %eax,%eax
f01059de:	74 4c                	je     f0105a2c <__pf_remove_env_all_tables+0x5c>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01059e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01059e7:	eb 38                	jmp    f0105a21 <__pf_remove_env_all_tables+0x51>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f01059e9:	8b 45 08             	mov    0x8(%ebp),%eax
f01059ec:	8b 40 7c             	mov    0x7c(%eax),%eax
f01059ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01059f2:	c1 e2 02             	shl    $0x2,%edx
f01059f5:	01 d0                	add    %edx,%eax
f01059f7:	8b 00                	mov    (%eax),%eax
f01059f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f01059fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01059ff:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a02:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105a05:	c1 e2 02             	shl    $0x2,%edx
f0105a08:	01 d0                	add    %edx,%eax
f0105a0a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0105a10:	83 ec 0c             	sub    $0xc,%esp
f0105a13:	ff 75 f0             	pushl  -0x10(%ebp)
f0105a16:	e8 8b f4 ff ff       	call   f0104ea6 <free_disk_frame>
f0105a1b:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0105a1e:	ff 45 f4             	incl   -0xc(%ebp)
f0105a21:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0105a28:	76 bf                	jbe    f01059e9 <__pf_remove_env_all_tables+0x19>
f0105a2a:	eb 01                	jmp    f0105a2d <__pf_remove_env_all_tables+0x5d>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0105a2c:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0105a2d:	c9                   	leave  
f0105a2e:	c3                   	ret    

f0105a2f <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0105a2f:	55                   	push   %ebp
f0105a30:	89 e5                	mov    %esp,%ebp
f0105a32:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0105a35:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105a39:	75 10                	jne    f0105a4b <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0105a3b:	83 ec 0c             	sub    $0xc,%esp
f0105a3e:	68 04 df 12 f0       	push   $0xf012df04
f0105a43:	e8 14 c1 ff ff       	call   f0101b5c <cprintf>
f0105a48:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0105a4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a4e:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a51:	85 c0                	test   %eax,%eax
f0105a53:	74 3d                	je     f0105a92 <__pf_remove_env_table+0x63>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0105a55:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a58:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a5b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105a5e:	c1 ea 16             	shr    $0x16,%edx
f0105a61:	c1 e2 02             	shl    $0x2,%edx
f0105a64:	01 d0                	add    %edx,%eax
f0105a66:	8b 00                	mov    (%eax),%eax
f0105a68:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0105a6b:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a6e:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a71:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105a74:	c1 ea 16             	shr    $0x16,%edx
f0105a77:	c1 e2 02             	shl    $0x2,%edx
f0105a7a:	01 d0                	add    %edx,%eax
f0105a7c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0105a82:	83 ec 0c             	sub    $0xc,%esp
f0105a85:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a88:	e8 19 f4 ff ff       	call   f0104ea6 <free_disk_frame>
f0105a8d:	83 c4 10             	add    $0x10,%esp
f0105a90:	eb 01                	jmp    f0105a93 <__pf_remove_env_table+0x64>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0105a92:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0105a93:	c9                   	leave  
f0105a94:	c3                   	ret    

f0105a95 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0105a95:	55                   	push   %ebp
f0105a96:	89 e5                	mov    %esp,%ebp
f0105a98:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0105a9b:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0105aa2:	eb 1f                	jmp    f0105ac3 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0105aa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105aa7:	83 ec 04             	sub    $0x4,%esp
f0105aaa:	6a 08                	push   $0x8
f0105aac:	ff 75 08             	pushl  0x8(%ebp)
f0105aaf:	50                   	push   %eax
f0105ab0:	e8 c1 59 01 00       	call   f011b476 <ide_write>
f0105ab5:	83 c4 10             	add    $0x10,%esp
f0105ab8:	85 c0                	test   %eax,%eax
f0105aba:	75 12                	jne    f0105ace <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0105abc:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0105ac3:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0105aca:	7e d8                	jle    f0105aa4 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0105acc:	eb 01                	jmp    f0105acf <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0105ace:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0105acf:	90                   	nop
f0105ad0:	c9                   	leave  
f0105ad1:	c3                   	ret    

f0105ad2 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0105ad2:	55                   	push   %ebp
  pushl %eax
f0105ad3:	50                   	push   %eax
  pushl %ebx
f0105ad4:	53                   	push   %ebx
  pushl %ecx
f0105ad5:	51                   	push   %ecx
  pushl %edx
f0105ad6:	52                   	push   %edx
  pushl %esi
f0105ad7:	56                   	push   %esi
  pushl %edi
f0105ad8:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0105ad9:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0105add:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0105ae1:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0105ae3:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0105ae5:	5f                   	pop    %edi
  popl %esi
f0105ae6:	5e                   	pop    %esi
  popl %edx
f0105ae7:	5a                   	pop    %edx
  popl %ecx
f0105ae8:	59                   	pop    %ecx
  popl %ebx
f0105ae9:	5b                   	pop    %ebx
  popl %eax
f0105aea:	58                   	pop    %eax
  popl %ebp
f0105aeb:	5d                   	pop    %ebp
  ret
f0105aec:	c3                   	ret    

f0105aed <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0105aed:	55                   	push   %ebp
f0105aee:	89 e5                	mov    %esp,%ebp
f0105af0:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0105af3:	8b 45 08             	mov    0x8(%ebp),%eax
f0105af6:	0f b6 c0             	movzbl %al,%eax
f0105af9:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0105b00:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105b03:	8a 45 f6             	mov    -0xa(%ebp),%al
f0105b06:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0105b09:	ee                   	out    %al,(%dx)
f0105b0a:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105b11:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0105b14:	89 c2                	mov    %eax,%edx
f0105b16:	ec                   	in     (%dx),%al
f0105b17:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0105b1a:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0105b1d:	0f b6 c0             	movzbl %al,%eax
}
f0105b20:	c9                   	leave  
f0105b21:	c3                   	ret    

f0105b22 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0105b22:	55                   	push   %ebp
f0105b23:	89 e5                	mov    %esp,%ebp
f0105b25:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0105b28:	8b 45 08             	mov    0x8(%ebp),%eax
f0105b2b:	0f b6 c0             	movzbl %al,%eax
f0105b2e:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0105b35:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105b38:	8a 45 f6             	mov    -0xa(%ebp),%al
f0105b3b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0105b3e:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0105b3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105b42:	0f b6 c0             	movzbl %al,%eax
f0105b45:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0105b4c:	88 45 f7             	mov    %al,-0x9(%ebp)
f0105b4f:	8a 45 f7             	mov    -0x9(%ebp),%al
f0105b52:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0105b55:	ee                   	out    %al,(%dx)
}
f0105b56:	90                   	nop
f0105b57:	c9                   	leave  
f0105b58:	c3                   	ret    

f0105b59 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0105b59:	55                   	push   %ebp
f0105b5a:	89 e5                	mov    %esp,%ebp
f0105b5c:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0105b5f:	c7 05 88 62 85 f0 00 	movl   $0x0,0xf0856288
f0105b66:	00 00 00 
f0105b69:	c7 05 8c 62 85 f0 00 	movl   $0x0,0xf085628c
f0105b70:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0105b73:	83 ec 08             	sub    $0x8,%esp
f0105b76:	68 c6 7b 10 f0       	push   $0xf0107bc6
f0105b7b:	6a 00                	push   $0x0
f0105b7d:	e8 41 86 00 00       	call   f010e1c3 <irq_install_handler>
f0105b82:	83 c4 10             	add    $0x10,%esp
}
f0105b85:	90                   	nop
f0105b86:	c9                   	leave  
f0105b87:	c3                   	ret    

f0105b88 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0105b88:	55                   	push   %ebp
f0105b89:	89 e5                	mov    %esp,%ebp
f0105b8b:	53                   	push   %ebx
f0105b8c:	83 ec 24             	sub    $0x24,%esp
f0105b8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105b92:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0105b95:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105b9c:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105ba0:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105ba3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105ba6:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0105ba7:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0105bab:	77 48                	ja     f0105bf5 <kclock_start+0x6d>
f0105bad:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105bb4:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0105bb8:	8a 45 ee             	mov    -0x12(%ebp),%al
f0105bbb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105bbe:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0105bbf:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0105bc3:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0105bc8:	99                   	cltd   
f0105bc9:	f7 fb                	idiv   %ebx
f0105bcb:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0105bd1:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0105bd5:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0105bda:	99                   	cltd   
f0105bdb:	f7 fb                	idiv   %ebx
f0105bdd:	89 c3                	mov    %eax,%ebx
f0105bdf:	89 c8                	mov    %ecx,%eax
f0105be1:	99                   	cltd   
f0105be2:	f7 fb                	idiv   %ebx
f0105be4:	0f b7 c0             	movzwl %ax,%eax
f0105be7:	83 ec 0c             	sub    $0xc,%esp
f0105bea:	50                   	push   %eax
f0105beb:	e8 b3 01 00 00       	call   f0105da3 <kclock_write_cnt0_LSB_first>
f0105bf0:	83 c4 10             	add    $0x10,%esp
f0105bf3:	eb 13                	jmp    f0105c08 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0105bf5:	6a 35                	push   $0x35
f0105bf7:	68 28 df 12 f0       	push   $0xf012df28
f0105bfc:	6a 41                	push   $0x41
f0105bfe:	68 84 df 12 f0       	push   $0xf012df84
f0105c03:	e8 a7 b2 ff ff       	call   f0100eaf <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0105c08:	83 ec 0c             	sub    $0xc,%esp
f0105c0b:	6a 00                	push   $0x0
f0105c0d:	e8 46 22 00 00       	call   f0107e58 <irq_clear_mask>
f0105c12:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0105c15:	90                   	nop
f0105c16:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105c19:	c9                   	leave  
f0105c1a:	c3                   	ret    

f0105c1b <kclock_stop>:

void
kclock_stop(void)
{
f0105c1b:	55                   	push   %ebp
f0105c1c:	89 e5                	mov    %esp,%ebp
f0105c1e:	83 ec 18             	sub    $0x18,%esp
f0105c21:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105c28:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0105c2c:	8a 45 f3             	mov    -0xd(%ebp),%al
f0105c2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c32:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0105c33:	83 ec 0c             	sub    $0xc,%esp
f0105c36:	6a 00                	push   $0x0
f0105c38:	e8 a6 21 00 00       	call   f0107de3 <irq_set_mask>
f0105c3d:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0105c40:	90                   	nop
f0105c41:	c9                   	leave  
f0105c42:	c3                   	ret    

f0105c43 <kclock_resume>:

void
kclock_resume(void)
{
f0105c43:	55                   	push   %ebp
f0105c44:	89 e5                	mov    %esp,%ebp
f0105c46:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0105c49:	e8 f5 01 00 00       	call   f0105e43 <kclock_read_cnt0_latch>
f0105c4e:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0105c52:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0105c57:	77 06                	ja     f0105c5f <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0105c59:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0105c5f:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0105c63:	83 e0 01             	and    $0x1,%eax
f0105c66:	66 85 c0             	test   %ax,%ax
f0105c69:	74 09                	je     f0105c74 <kclock_resume+0x31>
		cnt0++;
f0105c6b:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0105c6f:	40                   	inc    %eax
f0105c70:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0105c74:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105c7b:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105c7f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105c82:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105c85:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0105c86:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0105c8a:	83 ec 0c             	sub    $0xc,%esp
f0105c8d:	50                   	push   %eax
f0105c8e:	e8 10 01 00 00       	call   f0105da3 <kclock_write_cnt0_LSB_first>
f0105c93:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0105c96:	83 ec 0c             	sub    $0xc,%esp
f0105c99:	6a 00                	push   $0x0
f0105c9b:	e8 b8 21 00 00       	call   f0107e58 <irq_clear_mask>
f0105ca0:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0105ca3:	90                   	nop
f0105ca4:	c9                   	leave  
f0105ca5:	c3                   	ret    

f0105ca6 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0105ca6:	55                   	push   %ebp
f0105ca7:	89 e5                	mov    %esp,%ebp
f0105ca9:	83 ec 28             	sub    $0x28,%esp
f0105cac:	8b 45 08             	mov    0x8(%ebp),%eax
f0105caf:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0105cb2:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105cb9:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0105cbd:	8a 45 f3             	mov    -0xd(%ebp),%al
f0105cc0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105cc3:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0105cc4:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0105cc8:	83 ec 0c             	sub    $0xc,%esp
f0105ccb:	50                   	push   %eax
f0105ccc:	e8 d2 00 00 00       	call   f0105da3 <kclock_write_cnt0_LSB_first>
f0105cd1:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0105cd4:	83 ec 0c             	sub    $0xc,%esp
f0105cd7:	6a 00                	push   $0x0
f0105cd9:	e8 7a 21 00 00       	call   f0107e58 <irq_clear_mask>
f0105cde:	83 c4 10             	add    $0x10,%esp
}
f0105ce1:	90                   	nop
f0105ce2:	c9                   	leave  
f0105ce3:	c3                   	ret    

f0105ce4 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0105ce4:	55                   	push   %ebp
f0105ce5:	89 e5                	mov    %esp,%ebp
f0105ce7:	56                   	push   %esi
f0105ce8:	53                   	push   %ebx
f0105ce9:	83 ec 20             	sub    $0x20,%esp
f0105cec:	8b 45 08             	mov    0x8(%ebp),%eax
f0105cef:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0105cf2:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0105cf6:	0f 87 8a 00 00 00    	ja     f0105d86 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0105cfc:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0105d00:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0105d05:	99                   	cltd   
f0105d06:	f7 fe                	idiv   %esi
f0105d08:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0105d0e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0105d12:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0105d17:	99                   	cltd   
f0105d18:	f7 fb                	idiv   %ebx
f0105d1a:	89 c6                	mov    %eax,%esi
f0105d1c:	89 c8                	mov    %ecx,%eax
f0105d1e:	99                   	cltd   
f0105d1f:	f7 fe                	idiv   %esi
f0105d21:	89 c3                	mov    %eax,%ebx
f0105d23:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0105d27:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0105d2c:	99                   	cltd   
f0105d2d:	f7 f9                	idiv   %ecx
f0105d2f:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0105d35:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0105d39:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0105d3e:	99                   	cltd   
f0105d3f:	f7 fe                	idiv   %esi
f0105d41:	89 c6                	mov    %eax,%esi
f0105d43:	89 c8                	mov    %ecx,%eax
f0105d45:	99                   	cltd   
f0105d46:	f7 fe                	idiv   %esi
f0105d48:	25 01 00 00 80       	and    $0x80000001,%eax
f0105d4d:	85 c0                	test   %eax,%eax
f0105d4f:	79 05                	jns    f0105d56 <kclock_set_quantum+0x72>
f0105d51:	48                   	dec    %eax
f0105d52:	83 c8 fe             	or     $0xfffffffe,%eax
f0105d55:	40                   	inc    %eax
f0105d56:	01 d8                	add    %ebx,%eax
f0105d58:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d5b:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105d62:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105d66:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105d69:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105d6c:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0105d6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d70:	0f b7 c0             	movzwl %ax,%eax
f0105d73:	83 ec 0c             	sub    $0xc,%esp
f0105d76:	50                   	push   %eax
f0105d77:	e8 27 00 00 00       	call   f0105da3 <kclock_write_cnt0_LSB_first>
f0105d7c:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0105d7f:	e8 97 fe ff ff       	call   f0105c1b <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0105d84:	eb 16                	jmp    f0105d9c <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0105d86:	6a 35                	push   $0x35
f0105d88:	68 28 df 12 f0       	push   $0xf012df28
f0105d8d:	68 ea 00 00 00       	push   $0xea
f0105d92:	68 84 df 12 f0       	push   $0xf012df84
f0105d97:	e8 13 b1 ff ff       	call   f0100eaf <_panic>
	}
}
f0105d9c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0105d9f:	5b                   	pop    %ebx
f0105da0:	5e                   	pop    %esi
f0105da1:	5d                   	pop    %ebp
f0105da2:	c3                   	ret    

f0105da3 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0105da3:	55                   	push   %ebp
f0105da4:	89 e5                	mov    %esp,%ebp
f0105da6:	83 ec 28             	sub    $0x28,%esp
f0105da9:	8b 45 08             	mov    0x8(%ebp),%eax
f0105dac:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0105db0:	e8 7e 22 00 00       	call   f0108033 <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0105db5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105db8:	0f b6 c0             	movzbl %al,%eax
f0105dbb:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0105dc2:	88 45 ee             	mov    %al,-0x12(%ebp)
f0105dc5:	8a 45 ee             	mov    -0x12(%ebp),%al
f0105dc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105dcb:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0105dcc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105dcf:	66 c1 e8 08          	shr    $0x8,%ax
f0105dd3:	0f b6 c0             	movzbl %al,%eax
f0105dd6:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0105ddd:	88 45 ef             	mov    %al,-0x11(%ebp)
f0105de0:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105de3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105de6:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0105de7:	e8 99 22 00 00       	call   f0108085 <popcli>

}
f0105dec:	90                   	nop
f0105ded:	c9                   	leave  
f0105dee:	c3                   	ret    

f0105def <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0105def:	55                   	push   %ebp
f0105df0:	89 e5                	mov    %esp,%ebp
f0105df2:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0105df5:	e8 39 22 00 00       	call   f0108033 <pushcli>
f0105dfa:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105e04:	89 c2                	mov    %eax,%edx
f0105e06:	ec                   	in     (%dx),%al
f0105e07:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0105e0a:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105e0d:	88 45 f7             	mov    %al,-0x9(%ebp)
f0105e10:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e17:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105e1a:	89 c2                	mov    %eax,%edx
f0105e1c:	ec                   	in     (%dx),%al
f0105e1d:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0105e20:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105e23:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0105e26:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0105e2a:	c1 e0 08             	shl    $0x8,%eax
f0105e2d:	89 c2                	mov    %eax,%edx
f0105e2f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0105e33:	09 d0                	or     %edx,%eax
f0105e35:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0105e39:	e8 47 22 00 00       	call   f0108085 <popcli>
	return cnt0 ;
f0105e3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0105e41:	c9                   	leave  
f0105e42:	c3                   	ret    

f0105e43 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0105e43:	55                   	push   %ebp
f0105e44:	89 e5                	mov    %esp,%ebp
f0105e46:	83 ec 30             	sub    $0x30,%esp
f0105e49:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e50:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0105e53:	89 c2                	mov    %eax,%edx
f0105e55:	ec                   	in     (%dx),%al
f0105e56:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0105e59:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0105e5c:	88 45 ff             	mov    %al,-0x1(%ebp)
f0105e5f:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105e66:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105e6a:	8a 45 dc             	mov    -0x24(%ebp),%al
f0105e6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105e70:	ee                   	out    %al,(%dx)
f0105e71:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105e7b:	89 c2                	mov    %eax,%edx
f0105e7d:	ec                   	in     (%dx),%al
f0105e7e:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0105e81:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105e84:	88 45 f3             	mov    %al,-0xd(%ebp)
f0105e87:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105e91:	89 c2                	mov    %eax,%edx
f0105e93:	ec                   	in     (%dx),%al
f0105e94:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0105e97:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105e9a:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0105e9d:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0105ea1:	c1 e0 08             	shl    $0x8,%eax
f0105ea4:	89 c2                	mov    %eax,%edx
f0105ea6:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0105eaa:	09 d0                	or     %edx,%eax
f0105eac:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0105eb0:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0105eb4:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0105ebb:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105ebe:	8a 45 df             	mov    -0x21(%ebp),%al
f0105ec1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105ec4:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0105ec5:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0105ec8:	c9                   	leave  
f0105ec9:	c3                   	ret    

f0105eca <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0105eca:	55                   	push   %ebp
f0105ecb:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0105ecd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105ed1:	74 1d                	je     f0105ef0 <init_queue+0x26>
	{
		LIST_INIT(queue);
f0105ed3:	8b 45 08             	mov    0x8(%ebp),%eax
f0105ed6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0105edc:	8b 45 08             	mov    0x8(%ebp),%eax
f0105edf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105ee6:	8b 45 08             	mov    0x8(%ebp),%eax
f0105ee9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0105ef0:	90                   	nop
f0105ef1:	5d                   	pop    %ebp
f0105ef2:	c3                   	ret    

f0105ef3 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0105ef3:	55                   	push   %ebp
f0105ef4:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0105ef6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105efa:	74 08                	je     f0105f04 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0105efc:	8b 45 08             	mov    0x8(%ebp),%eax
f0105eff:	8b 40 0c             	mov    0xc(%eax),%eax
f0105f02:	eb 05                	jmp    f0105f09 <queue_size+0x16>
	}
	else
	{
		return 0;
f0105f04:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0105f09:	5d                   	pop    %ebp
f0105f0a:	c3                   	ret    

f0105f0b <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0105f0b:	55                   	push   %ebp
f0105f0c:	89 e5                	mov    %esp,%ebp
f0105f0e:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0105f11:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105f15:	75 16                	jne    f0105f2d <enqueue+0x22>
f0105f17:	68 98 df 12 f0       	push   $0xf012df98
f0105f1c:	68 a6 df 12 f0       	push   $0xf012dfa6
f0105f21:	6a 34                	push   $0x34
f0105f23:	68 bb df 12 f0       	push   $0xf012dfbb
f0105f28:	e8 82 af ff ff       	call   f0100eaf <_panic>
	if(env != NULL)
f0105f2d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105f31:	74 66                	je     f0105f99 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0105f33:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105f37:	75 14                	jne    f0105f4d <enqueue+0x42>
f0105f39:	83 ec 04             	sub    $0x4,%esp
f0105f3c:	68 d4 df 12 f0       	push   $0xf012dfd4
f0105f41:	6a 37                	push   $0x37
f0105f43:	68 bb df 12 f0       	push   $0xf012dfbb
f0105f48:	e8 62 af ff ff       	call   f0100eaf <_panic>
f0105f4d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105f50:	8b 10                	mov    (%eax),%edx
f0105f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105f55:	89 50 08             	mov    %edx,0x8(%eax)
f0105f58:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105f5b:	8b 40 08             	mov    0x8(%eax),%eax
f0105f5e:	85 c0                	test   %eax,%eax
f0105f60:	74 0d                	je     f0105f6f <enqueue+0x64>
f0105f62:	8b 45 08             	mov    0x8(%ebp),%eax
f0105f65:	8b 00                	mov    (%eax),%eax
f0105f67:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105f6a:	89 50 0c             	mov    %edx,0xc(%eax)
f0105f6d:	eb 09                	jmp    f0105f78 <enqueue+0x6d>
f0105f6f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105f72:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105f75:	89 50 04             	mov    %edx,0x4(%eax)
f0105f78:	8b 45 08             	mov    0x8(%ebp),%eax
f0105f7b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105f7e:	89 10                	mov    %edx,(%eax)
f0105f80:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105f83:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105f8a:	8b 45 08             	mov    0x8(%ebp),%eax
f0105f8d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105f90:	8d 50 01             	lea    0x1(%eax),%edx
f0105f93:	8b 45 08             	mov    0x8(%ebp),%eax
f0105f96:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105f99:	90                   	nop
f0105f9a:	c9                   	leave  
f0105f9b:	c3                   	ret    

f0105f9c <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f0105f9c:	55                   	push   %ebp
f0105f9d:	89 e5                	mov    %esp,%ebp
f0105f9f:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0105fa2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105fa6:	75 0a                	jne    f0105fb2 <dequeue+0x16>
f0105fa8:	b8 00 00 00 00       	mov    $0x0,%eax
f0105fad:	e9 a0 00 00 00       	jmp    f0106052 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0105fb2:	8b 45 08             	mov    0x8(%ebp),%eax
f0105fb5:	8b 40 04             	mov    0x4(%eax),%eax
f0105fb8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f0105fbb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fbf:	0f 84 8a 00 00 00    	je     f010604f <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105fc5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fc9:	75 14                	jne    f0105fdf <dequeue+0x43>
f0105fcb:	83 ec 04             	sub    $0x4,%esp
f0105fce:	68 f7 df 12 f0       	push   $0xf012dff7
f0105fd3:	6a 44                	push   $0x44
f0105fd5:	68 bb df 12 f0       	push   $0xf012dfbb
f0105fda:	e8 d0 ae ff ff       	call   f0100eaf <_panic>
f0105fdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fe2:	8b 40 08             	mov    0x8(%eax),%eax
f0105fe5:	85 c0                	test   %eax,%eax
f0105fe7:	74 11                	je     f0105ffa <dequeue+0x5e>
f0105fe9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fec:	8b 40 08             	mov    0x8(%eax),%eax
f0105fef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105ff2:	8b 52 0c             	mov    0xc(%edx),%edx
f0105ff5:	89 50 0c             	mov    %edx,0xc(%eax)
f0105ff8:	eb 0c                	jmp    f0106006 <dequeue+0x6a>
f0105ffa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ffd:	8b 50 0c             	mov    0xc(%eax),%edx
f0106000:	8b 45 08             	mov    0x8(%ebp),%eax
f0106003:	89 50 04             	mov    %edx,0x4(%eax)
f0106006:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106009:	8b 40 0c             	mov    0xc(%eax),%eax
f010600c:	85 c0                	test   %eax,%eax
f010600e:	74 11                	je     f0106021 <dequeue+0x85>
f0106010:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106013:	8b 40 0c             	mov    0xc(%eax),%eax
f0106016:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106019:	8b 52 08             	mov    0x8(%edx),%edx
f010601c:	89 50 08             	mov    %edx,0x8(%eax)
f010601f:	eb 0b                	jmp    f010602c <dequeue+0x90>
f0106021:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106024:	8b 50 08             	mov    0x8(%eax),%edx
f0106027:	8b 45 08             	mov    0x8(%ebp),%eax
f010602a:	89 10                	mov    %edx,(%eax)
f010602c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010602f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106036:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106039:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106040:	8b 45 08             	mov    0x8(%ebp),%eax
f0106043:	8b 40 0c             	mov    0xc(%eax),%eax
f0106046:	8d 50 ff             	lea    -0x1(%eax),%edx
f0106049:	8b 45 08             	mov    0x8(%ebp),%eax
f010604c:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f010604f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106052:	c9                   	leave  
f0106053:	c3                   	ret    

f0106054 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f0106054:	55                   	push   %ebp
f0106055:	89 e5                	mov    %esp,%ebp
f0106057:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f010605a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010605e:	75 16                	jne    f0106076 <remove_from_queue+0x22>
f0106060:	68 98 df 12 f0       	push   $0xf012df98
f0106065:	68 a6 df 12 f0       	push   $0xf012dfa6
f010606a:	6a 4e                	push   $0x4e
f010606c:	68 bb df 12 f0       	push   $0xf012dfbb
f0106071:	e8 39 ae ff ff       	call   f0100eaf <_panic>

	if (e != NULL)
f0106076:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010607a:	0f 84 8a 00 00 00    	je     f010610a <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f0106080:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0106084:	75 14                	jne    f010609a <remove_from_queue+0x46>
f0106086:	83 ec 04             	sub    $0x4,%esp
f0106089:	68 f7 df 12 f0       	push   $0xf012dff7
f010608e:	6a 52                	push   $0x52
f0106090:	68 bb df 12 f0       	push   $0xf012dfbb
f0106095:	e8 15 ae ff ff       	call   f0100eaf <_panic>
f010609a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010609d:	8b 40 08             	mov    0x8(%eax),%eax
f01060a0:	85 c0                	test   %eax,%eax
f01060a2:	74 11                	je     f01060b5 <remove_from_queue+0x61>
f01060a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060a7:	8b 40 08             	mov    0x8(%eax),%eax
f01060aa:	8b 55 0c             	mov    0xc(%ebp),%edx
f01060ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01060b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01060b3:	eb 0c                	jmp    f01060c1 <remove_from_queue+0x6d>
f01060b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060b8:	8b 50 0c             	mov    0xc(%eax),%edx
f01060bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01060be:	89 50 04             	mov    %edx,0x4(%eax)
f01060c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060c4:	8b 40 0c             	mov    0xc(%eax),%eax
f01060c7:	85 c0                	test   %eax,%eax
f01060c9:	74 11                	je     f01060dc <remove_from_queue+0x88>
f01060cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060ce:	8b 40 0c             	mov    0xc(%eax),%eax
f01060d1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01060d4:	8b 52 08             	mov    0x8(%edx),%edx
f01060d7:	89 50 08             	mov    %edx,0x8(%eax)
f01060da:	eb 0b                	jmp    f01060e7 <remove_from_queue+0x93>
f01060dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060df:	8b 50 08             	mov    0x8(%eax),%edx
f01060e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01060e5:	89 10                	mov    %edx,(%eax)
f01060e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060ea:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01060f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060f4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01060fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01060fe:	8b 40 0c             	mov    0xc(%eax),%eax
f0106101:	8d 50 ff             	lea    -0x1(%eax),%edx
f0106104:	8b 45 08             	mov    0x8(%ebp),%eax
f0106107:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f010610a:	90                   	nop
f010610b:	c9                   	leave  
f010610c:	c3                   	ret    

f010610d <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f010610d:	55                   	push   %ebp
f010610e:	89 e5                	mov    %esp,%ebp
f0106110:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f0106113:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106117:	75 07                	jne    f0106120 <find_env_in_queue+0x13>
f0106119:	b8 00 00 00 00       	mov    $0x0,%eax
f010611e:	eb 58                	jmp    f0106178 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f0106120:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f0106127:	8b 45 08             	mov    0x8(%ebp),%eax
f010612a:	8b 00                	mov    (%eax),%eax
f010612c:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010612f:	eb 19                	jmp    f010614a <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f0106131:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0106134:	8b 40 10             	mov    0x10(%eax),%eax
f0106137:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010613a:	75 05                	jne    f0106141 <find_env_in_queue+0x34>
		{
			return ptr_env;
f010613c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010613f:	eb 37                	jmp    f0106178 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f0106141:	8b 45 08             	mov    0x8(%ebp),%eax
f0106144:	8b 40 08             	mov    0x8(%eax),%eax
f0106147:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010614a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f010614e:	74 08                	je     f0106158 <find_env_in_queue+0x4b>
f0106150:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0106153:	8b 40 08             	mov    0x8(%eax),%eax
f0106156:	eb 05                	jmp    f010615d <find_env_in_queue+0x50>
f0106158:	b8 00 00 00 00       	mov    $0x0,%eax
f010615d:	8b 55 08             	mov    0x8(%ebp),%edx
f0106160:	89 42 08             	mov    %eax,0x8(%edx)
f0106163:	8b 45 08             	mov    0x8(%ebp),%eax
f0106166:	8b 40 08             	mov    0x8(%eax),%eax
f0106169:	85 c0                	test   %eax,%eax
f010616b:	75 c4                	jne    f0106131 <find_env_in_queue+0x24>
f010616d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0106171:	75 be                	jne    f0106131 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0106173:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0106178:	c9                   	leave  
f0106179:	c3                   	ret    

f010617a <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f010617a:	55                   	push   %ebp
f010617b:	89 e5                	mov    %esp,%ebp
f010617d:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_kspinlock(&ProcessQueues.qlock);
f0106180:	83 ec 0c             	sub    $0xc,%esp
f0106183:	68 80 dd 83 f0       	push   $0xf083dd80
f0106188:	e8 f0 9b 00 00       	call   f010fd7d <acquire_kspinlock>
f010618d:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f0106190:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106195:	85 c0                	test   %eax,%eax
f0106197:	74 11                	je     f01061aa <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0106199:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f010619e:	83 ec 0c             	sub    $0xc,%esp
f01061a1:	50                   	push   %eax
f01061a2:	e8 ac 39 00 00       	call   f0109b53 <kfree>
f01061a7:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f01061aa:	a1 44 61 85 f0       	mov    0xf0856144,%eax
f01061af:	85 c0                	test   %eax,%eax
f01061b1:	74 11                	je     f01061c4 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f01061b3:	a1 44 61 85 f0       	mov    0xf0856144,%eax
f01061b8:	83 ec 0c             	sub    $0xc,%esp
f01061bb:	50                   	push   %eax
f01061bc:	e8 92 39 00 00       	call   f0109b53 <kfree>
f01061c1:	83 c4 10             	add    $0x10,%esp
	}
	release_kspinlock(&ProcessQueues.qlock);
f01061c4:	83 ec 0c             	sub    $0xc,%esp
f01061c7:	68 80 dd 83 f0       	push   $0xf083dd80
f01061cc:	e8 51 9c 00 00       	call   f010fe22 <release_kspinlock>
f01061d1:	83 c4 10             	add    $0x10,%esp

#endif
}
f01061d4:	90                   	nop
f01061d5:	c9                   	leave  
f01061d6:	c3                   	ret    

f01061d7 <sched_insert_ready>:

//============================================================
// [2] Insert the given Env in the priority-based Ready Queue:
//============================================================
void sched_insert_ready(struct Env* env)
{
f01061d7:	55                   	push   %ebp
f01061d8:	89 e5                	mov    %esp,%ebp
f01061da:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f01061dd:	83 ec 0c             	sub    $0xc,%esp
f01061e0:	68 80 dd 83 f0       	push   $0xf083dd80
f01061e5:	e8 e8 9d 00 00       	call   f010ffd2 <holding_kspinlock>
f01061ea:	83 c4 10             	add    $0x10,%esp
f01061ed:	85 c0                	test   %eax,%eax
f01061ef:	75 17                	jne    f0106208 <sched_insert_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01061f1:	83 ec 04             	sub    $0x4,%esp
f01061f4:	68 18 e0 12 f0       	push   $0xf012e018
f01061f9:	68 97 00 00 00       	push   $0x97
f01061fe:	68 bb df 12 f0       	push   $0xf012dfbb
f0106203:	e8 a7 ac ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0106208:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010620c:	75 19                	jne    f0106227 <sched_insert_ready+0x50>
f010620e:	68 59 e0 12 f0       	push   $0xf012e059
f0106213:	68 a6 df 12 f0       	push   $0xf012dfa6
f0106218:	68 9a 00 00 00       	push   $0x9a
f010621d:	68 bb df 12 f0       	push   $0xf012dfbb
f0106222:	e8 88 ac ff ff       	call   f0100eaf <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0106227:	8b 45 08             	mov    0x8(%ebp),%eax
f010622a:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[env->priority]), env);
f0106231:	8b 15 10 de 83 f0    	mov    0xf083de10,%edx
f0106237:	8b 45 08             	mov    0x8(%ebp),%eax
f010623a:	8b 40 1c             	mov    0x1c(%eax),%eax
f010623d:	c1 e0 04             	shl    $0x4,%eax
f0106240:	01 d0                	add    %edx,%eax
f0106242:	83 ec 08             	sub    $0x8,%esp
f0106245:	ff 75 08             	pushl  0x8(%ebp)
f0106248:	50                   	push   %eax
f0106249:	e8 bd fc ff ff       	call   f0105f0b <enqueue>
f010624e:	83 c4 10             	add    $0x10,%esp
	}
}
f0106251:	90                   	nop
f0106252:	c9                   	leave  
f0106253:	c3                   	ret    

f0106254 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0106254:	55                   	push   %ebp
f0106255:	89 e5                	mov    %esp,%ebp
f0106257:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f010625a:	83 ec 0c             	sub    $0xc,%esp
f010625d:	68 80 dd 83 f0       	push   $0xf083dd80
f0106262:	e8 6b 9d 00 00       	call   f010ffd2 <holding_kspinlock>
f0106267:	83 c4 10             	add    $0x10,%esp
f010626a:	85 c0                	test   %eax,%eax
f010626c:	75 17                	jne    f0106285 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010626e:	83 ec 04             	sub    $0x4,%esp
f0106271:	68 18 e0 12 f0       	push   $0xf012e018
f0106276:	68 a9 00 00 00       	push   $0xa9
f010627b:	68 bb df 12 f0       	push   $0xf012dfbb
f0106280:	e8 2a ac ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0106285:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106289:	74 0b                	je     f0106296 <sched_remove_ready+0x42>
f010628b:	8b 45 08             	mov    0x8(%ebp),%eax
f010628e:	8b 40 18             	mov    0x18(%eax),%eax
f0106291:	83 f8 01             	cmp    $0x1,%eax
f0106294:	74 19                	je     f01062af <sched_remove_ready+0x5b>
f0106296:	68 68 e0 12 f0       	push   $0xf012e068
f010629b:	68 a6 df 12 f0       	push   $0xf012dfa6
f01062a0:	68 ac 00 00 00       	push   $0xac
f01062a5:	68 bb df 12 f0       	push   $0xf012dfbb
f01062aa:	e8 00 ac ff ff       	call   f0100eaf <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01062af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01062b6:	e9 e4 00 00 00       	jmp    f010639f <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f01062bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01062be:	8b 40 10             	mov    0x10(%eax),%eax
f01062c1:	89 c2                	mov    %eax,%edx
f01062c3:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f01062c8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01062cb:	c1 e1 04             	shl    $0x4,%ecx
f01062ce:	01 c8                	add    %ecx,%eax
f01062d0:	83 ec 08             	sub    $0x8,%esp
f01062d3:	52                   	push   %edx
f01062d4:	50                   	push   %eax
f01062d5:	e8 33 fe ff ff       	call   f010610d <find_env_in_queue>
f01062da:	83 c4 10             	add    $0x10,%esp
f01062dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f01062e0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01062e4:	0f 84 b2 00 00 00    	je     f010639c <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f01062ea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01062ee:	75 17                	jne    f0106307 <sched_remove_ready+0xb3>
f01062f0:	83 ec 04             	sub    $0x4,%esp
f01062f3:	68 f7 df 12 f0       	push   $0xf012dff7
f01062f8:	68 b3 00 00 00       	push   $0xb3
f01062fd:	68 bb df 12 f0       	push   $0xf012dfbb
f0106302:	e8 a8 ab ff ff       	call   f0100eaf <_panic>
f0106307:	8b 45 08             	mov    0x8(%ebp),%eax
f010630a:	8b 40 08             	mov    0x8(%eax),%eax
f010630d:	85 c0                	test   %eax,%eax
f010630f:	74 11                	je     f0106322 <sched_remove_ready+0xce>
f0106311:	8b 45 08             	mov    0x8(%ebp),%eax
f0106314:	8b 40 08             	mov    0x8(%eax),%eax
f0106317:	8b 55 08             	mov    0x8(%ebp),%edx
f010631a:	8b 52 0c             	mov    0xc(%edx),%edx
f010631d:	89 50 0c             	mov    %edx,0xc(%eax)
f0106320:	eb 16                	jmp    f0106338 <sched_remove_ready+0xe4>
f0106322:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106327:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010632a:	c1 e2 04             	shl    $0x4,%edx
f010632d:	01 c2                	add    %eax,%edx
f010632f:	8b 45 08             	mov    0x8(%ebp),%eax
f0106332:	8b 40 0c             	mov    0xc(%eax),%eax
f0106335:	89 42 04             	mov    %eax,0x4(%edx)
f0106338:	8b 45 08             	mov    0x8(%ebp),%eax
f010633b:	8b 40 0c             	mov    0xc(%eax),%eax
f010633e:	85 c0                	test   %eax,%eax
f0106340:	74 11                	je     f0106353 <sched_remove_ready+0xff>
f0106342:	8b 45 08             	mov    0x8(%ebp),%eax
f0106345:	8b 40 0c             	mov    0xc(%eax),%eax
f0106348:	8b 55 08             	mov    0x8(%ebp),%edx
f010634b:	8b 52 08             	mov    0x8(%edx),%edx
f010634e:	89 50 08             	mov    %edx,0x8(%eax)
f0106351:	eb 15                	jmp    f0106368 <sched_remove_ready+0x114>
f0106353:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106358:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010635b:	c1 e2 04             	shl    $0x4,%edx
f010635e:	01 c2                	add    %eax,%edx
f0106360:	8b 45 08             	mov    0x8(%ebp),%eax
f0106363:	8b 40 08             	mov    0x8(%eax),%eax
f0106366:	89 02                	mov    %eax,(%edx)
f0106368:	8b 45 08             	mov    0x8(%ebp),%eax
f010636b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106372:	8b 45 08             	mov    0x8(%ebp),%eax
f0106375:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010637c:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106381:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106384:	c1 e2 04             	shl    $0x4,%edx
f0106387:	01 d0                	add    %edx,%eax
f0106389:	8b 50 0c             	mov    0xc(%eax),%edx
f010638c:	4a                   	dec    %edx
f010638d:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f0106390:	8b 45 08             	mov    0x8(%ebp),%eax
f0106393:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
				return ;
f010639a:	eb 14                	jmp    f01063b0 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010639c:	ff 45 f4             	incl   -0xc(%ebp)
f010639f:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f01063a4:	0f b6 c0             	movzbl %al,%eax
f01063a7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01063aa:	0f 8f 0b ff ff ff    	jg     f01062bb <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01063b0:	c9                   	leave  
f01063b1:	c3                   	ret    

f01063b2 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01063b2:	55                   	push   %ebp
f01063b3:	89 e5                	mov    %esp,%ebp
f01063b5:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f01063b8:	83 ec 0c             	sub    $0xc,%esp
f01063bb:	68 80 dd 83 f0       	push   $0xf083dd80
f01063c0:	e8 0d 9c 00 00       	call   f010ffd2 <holding_kspinlock>
f01063c5:	83 c4 10             	add    $0x10,%esp
f01063c8:	85 c0                	test   %eax,%eax
f01063ca:	75 17                	jne    f01063e3 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01063cc:	83 ec 04             	sub    $0x4,%esp
f01063cf:	68 18 e0 12 f0       	push   $0xf012e018
f01063d4:	68 c2 00 00 00       	push   $0xc2
f01063d9:	68 bb df 12 f0       	push   $0xf012dfbb
f01063de:	e8 cc aa ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01063e3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01063e7:	75 19                	jne    f0106402 <sched_insert_new+0x50>
f01063e9:	68 59 e0 12 f0       	push   $0xf012e059
f01063ee:	68 a6 df 12 f0       	push   $0xf012dfa6
f01063f3:	68 c5 00 00 00       	push   $0xc5
f01063f8:	68 bb df 12 f0       	push   $0xf012dfbb
f01063fd:	e8 ad aa ff ff       	call   f0100eaf <_panic>
	{
		env->env_status = ENV_NEW ;
f0106402:	8b 45 08             	mov    0x8(%ebp),%eax
f0106405:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010640c:	83 ec 08             	sub    $0x8,%esp
f010640f:	ff 75 08             	pushl  0x8(%ebp)
f0106412:	68 f0 dd 83 f0       	push   $0xf083ddf0
f0106417:	e8 ef fa ff ff       	call   f0105f0b <enqueue>
f010641c:	83 c4 10             	add    $0x10,%esp
	}
}
f010641f:	90                   	nop
f0106420:	c9                   	leave  
f0106421:	c3                   	ret    

f0106422 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f0106422:	55                   	push   %ebp
f0106423:	89 e5                	mov    %esp,%ebp
f0106425:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0106428:	83 ec 0c             	sub    $0xc,%esp
f010642b:	68 80 dd 83 f0       	push   $0xf083dd80
f0106430:	e8 9d 9b 00 00       	call   f010ffd2 <holding_kspinlock>
f0106435:	83 c4 10             	add    $0x10,%esp
f0106438:	85 c0                	test   %eax,%eax
f010643a:	75 17                	jne    f0106453 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010643c:	83 ec 04             	sub    $0x4,%esp
f010643f:	68 18 e0 12 f0       	push   $0xf012e018
f0106444:	68 d3 00 00 00       	push   $0xd3
f0106449:	68 bb df 12 f0       	push   $0xf012dfbb
f010644e:	e8 5c aa ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f0106453:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106457:	74 0b                	je     f0106464 <sched_remove_new+0x42>
f0106459:	8b 45 08             	mov    0x8(%ebp),%eax
f010645c:	8b 40 18             	mov    0x18(%eax),%eax
f010645f:	83 f8 04             	cmp    $0x4,%eax
f0106462:	74 19                	je     f010647d <sched_remove_new+0x5b>
f0106464:	68 94 e0 12 f0       	push   $0xf012e094
f0106469:	68 a6 df 12 f0       	push   $0xf012dfa6
f010646e:	68 d6 00 00 00       	push   $0xd6
f0106473:	68 bb df 12 f0       	push   $0xf012dfbb
f0106478:	e8 32 aa ff ff       	call   f0100eaf <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f010647d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106481:	75 17                	jne    f010649a <sched_remove_new+0x78>
f0106483:	83 ec 04             	sub    $0x4,%esp
f0106486:	68 f7 df 12 f0       	push   $0xf012dff7
f010648b:	68 d8 00 00 00       	push   $0xd8
f0106490:	68 bb df 12 f0       	push   $0xf012dfbb
f0106495:	e8 15 aa ff ff       	call   f0100eaf <_panic>
f010649a:	8b 45 08             	mov    0x8(%ebp),%eax
f010649d:	8b 40 08             	mov    0x8(%eax),%eax
f01064a0:	85 c0                	test   %eax,%eax
f01064a2:	74 11                	je     f01064b5 <sched_remove_new+0x93>
f01064a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01064a7:	8b 40 08             	mov    0x8(%eax),%eax
f01064aa:	8b 55 08             	mov    0x8(%ebp),%edx
f01064ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01064b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01064b3:	eb 0b                	jmp    f01064c0 <sched_remove_new+0x9e>
f01064b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01064b8:	8b 40 0c             	mov    0xc(%eax),%eax
f01064bb:	a3 f4 dd 83 f0       	mov    %eax,0xf083ddf4
f01064c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01064c3:	8b 40 0c             	mov    0xc(%eax),%eax
f01064c6:	85 c0                	test   %eax,%eax
f01064c8:	74 11                	je     f01064db <sched_remove_new+0xb9>
f01064ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01064cd:	8b 40 0c             	mov    0xc(%eax),%eax
f01064d0:	8b 55 08             	mov    0x8(%ebp),%edx
f01064d3:	8b 52 08             	mov    0x8(%edx),%edx
f01064d6:	89 50 08             	mov    %edx,0x8(%eax)
f01064d9:	eb 0b                	jmp    f01064e6 <sched_remove_new+0xc4>
f01064db:	8b 45 08             	mov    0x8(%ebp),%eax
f01064de:	8b 40 08             	mov    0x8(%eax),%eax
f01064e1:	a3 f0 dd 83 f0       	mov    %eax,0xf083ddf0
f01064e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01064e9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01064f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01064f3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01064fa:	a1 fc dd 83 f0       	mov    0xf083ddfc,%eax
f01064ff:	48                   	dec    %eax
f0106500:	a3 fc dd 83 f0       	mov    %eax,0xf083ddfc
		env->env_status = ENV_UNKNOWN;
f0106505:	8b 45 08             	mov    0x8(%ebp),%eax
f0106508:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
	}
}
f010650f:	90                   	nop
f0106510:	c9                   	leave  
f0106511:	c3                   	ret    

f0106512 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f0106512:	55                   	push   %ebp
f0106513:	89 e5                	mov    %esp,%ebp
f0106515:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0106518:	83 ec 0c             	sub    $0xc,%esp
f010651b:	68 80 dd 83 f0       	push   $0xf083dd80
f0106520:	e8 ad 9a 00 00       	call   f010ffd2 <holding_kspinlock>
f0106525:	83 c4 10             	add    $0x10,%esp
f0106528:	85 c0                	test   %eax,%eax
f010652a:	75 17                	jne    f0106543 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010652c:	83 ec 04             	sub    $0x4,%esp
f010652f:	68 18 e0 12 f0       	push   $0xf012e018
f0106534:	68 e4 00 00 00       	push   $0xe4
f0106539:	68 bb df 12 f0       	push   $0xf012dfbb
f010653e:	e8 6c a9 ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0106543:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106547:	75 19                	jne    f0106562 <sched_insert_exit+0x50>
f0106549:	68 59 e0 12 f0       	push   $0xf012e059
f010654e:	68 a6 df 12 f0       	push   $0xf012dfa6
f0106553:	68 e7 00 00 00       	push   $0xe7
f0106558:	68 bb df 12 f0       	push   $0xf012dfbb
f010655d:	e8 4d a9 ff ff       	call   f0100eaf <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f0106562:	e8 9c 93 00 00       	call   f010f903 <isBufferingEnabled>
f0106567:	84 c0                	test   %al,%al
f0106569:	74 0e                	je     f0106579 <sched_insert_exit+0x67>
f010656b:	83 ec 0c             	sub    $0xc,%esp
f010656e:	ff 75 08             	pushl  0x8(%ebp)
f0106571:	e8 33 66 00 00       	call   f010cba9 <cleanup_buffers>
f0106576:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f0106579:	8b 45 08             	mov    0x8(%ebp),%eax
f010657c:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0106583:	83 ec 08             	sub    $0x8,%esp
f0106586:	ff 75 08             	pushl  0x8(%ebp)
f0106589:	68 00 de 83 f0       	push   $0xf083de00
f010658e:	e8 78 f9 ff ff       	call   f0105f0b <enqueue>
f0106593:	83 c4 10             	add    $0x10,%esp
	}
}
f0106596:	90                   	nop
f0106597:	c9                   	leave  
f0106598:	c3                   	ret    

f0106599 <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f0106599:	55                   	push   %ebp
f010659a:	89 e5                	mov    %esp,%ebp
f010659c:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f010659f:	83 ec 0c             	sub    $0xc,%esp
f01065a2:	68 80 dd 83 f0       	push   $0xf083dd80
f01065a7:	e8 26 9a 00 00       	call   f010ffd2 <holding_kspinlock>
f01065ac:	83 c4 10             	add    $0x10,%esp
f01065af:	85 c0                	test   %eax,%eax
f01065b1:	75 17                	jne    f01065ca <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01065b3:	83 ec 04             	sub    $0x4,%esp
f01065b6:	68 18 e0 12 f0       	push   $0xf012e018
f01065bb:	68 f5 00 00 00       	push   $0xf5
f01065c0:	68 bb df 12 f0       	push   $0xf012dfbb
f01065c5:	e8 e5 a8 ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01065ca:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01065ce:	74 0b                	je     f01065db <sched_remove_exit+0x42>
f01065d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01065d3:	8b 40 18             	mov    0x18(%eax),%eax
f01065d6:	83 f8 05             	cmp    $0x5,%eax
f01065d9:	74 19                	je     f01065f4 <sched_remove_exit+0x5b>
f01065db:	68 c0 e0 12 f0       	push   $0xf012e0c0
f01065e0:	68 a6 df 12 f0       	push   $0xf012dfa6
f01065e5:	68 f8 00 00 00       	push   $0xf8
f01065ea:	68 bb df 12 f0       	push   $0xf012dfbb
f01065ef:	e8 bb a8 ff ff       	call   f0100eaf <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f01065f4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01065f8:	75 17                	jne    f0106611 <sched_remove_exit+0x78>
f01065fa:	83 ec 04             	sub    $0x4,%esp
f01065fd:	68 f7 df 12 f0       	push   $0xf012dff7
f0106602:	68 fa 00 00 00       	push   $0xfa
f0106607:	68 bb df 12 f0       	push   $0xf012dfbb
f010660c:	e8 9e a8 ff ff       	call   f0100eaf <_panic>
f0106611:	8b 45 08             	mov    0x8(%ebp),%eax
f0106614:	8b 40 08             	mov    0x8(%eax),%eax
f0106617:	85 c0                	test   %eax,%eax
f0106619:	74 11                	je     f010662c <sched_remove_exit+0x93>
f010661b:	8b 45 08             	mov    0x8(%ebp),%eax
f010661e:	8b 40 08             	mov    0x8(%eax),%eax
f0106621:	8b 55 08             	mov    0x8(%ebp),%edx
f0106624:	8b 52 0c             	mov    0xc(%edx),%edx
f0106627:	89 50 0c             	mov    %edx,0xc(%eax)
f010662a:	eb 0b                	jmp    f0106637 <sched_remove_exit+0x9e>
f010662c:	8b 45 08             	mov    0x8(%ebp),%eax
f010662f:	8b 40 0c             	mov    0xc(%eax),%eax
f0106632:	a3 04 de 83 f0       	mov    %eax,0xf083de04
f0106637:	8b 45 08             	mov    0x8(%ebp),%eax
f010663a:	8b 40 0c             	mov    0xc(%eax),%eax
f010663d:	85 c0                	test   %eax,%eax
f010663f:	74 11                	je     f0106652 <sched_remove_exit+0xb9>
f0106641:	8b 45 08             	mov    0x8(%ebp),%eax
f0106644:	8b 40 0c             	mov    0xc(%eax),%eax
f0106647:	8b 55 08             	mov    0x8(%ebp),%edx
f010664a:	8b 52 08             	mov    0x8(%edx),%edx
f010664d:	89 50 08             	mov    %edx,0x8(%eax)
f0106650:	eb 0b                	jmp    f010665d <sched_remove_exit+0xc4>
f0106652:	8b 45 08             	mov    0x8(%ebp),%eax
f0106655:	8b 40 08             	mov    0x8(%eax),%eax
f0106658:	a3 00 de 83 f0       	mov    %eax,0xf083de00
f010665d:	8b 45 08             	mov    0x8(%ebp),%eax
f0106660:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106667:	8b 45 08             	mov    0x8(%ebp),%eax
f010666a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106671:	a1 0c de 83 f0       	mov    0xf083de0c,%eax
f0106676:	48                   	dec    %eax
f0106677:	a3 0c de 83 f0       	mov    %eax,0xf083de0c
		env->env_status = ENV_UNKNOWN;
f010667c:	8b 45 08             	mov    0x8(%ebp),%eax
f010667f:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
	}
}
f0106686:	90                   	nop
f0106687:	c9                   	leave  
f0106688:	c3                   	ret    

f0106689 <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f0106689:	55                   	push   %ebp
f010668a:	89 e5                	mov    %esp,%ebp
f010668c:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010668f:	83 ec 0c             	sub    $0xc,%esp
f0106692:	68 80 dd 83 f0       	push   $0xf083dd80
f0106697:	e8 e1 96 00 00       	call   f010fd7d <acquire_kspinlock>
f010669c:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f010669f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01066a3:	75 19                	jne    f01066be <sched_new_env+0x35>
f01066a5:	68 eb e0 12 f0       	push   $0xf012e0eb
f01066aa:	68 a6 df 12 f0       	push   $0xf012dfa6
f01066af:	68 08 01 00 00       	push   $0x108
f01066b4:	68 bb df 12 f0       	push   $0xf012dfbb
f01066b9:	e8 f1 a7 ff ff       	call   f0100eaf <_panic>
	{
		sched_insert_new(e);
f01066be:	83 ec 0c             	sub    $0xc,%esp
f01066c1:	ff 75 08             	pushl  0x8(%ebp)
f01066c4:	e8 e9 fc ff ff       	call   f01063b2 <sched_insert_new>
f01066c9:	83 c4 10             	add    $0x10,%esp
	}

	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01066cc:	83 ec 0c             	sub    $0xc,%esp
f01066cf:	68 80 dd 83 f0       	push   $0xf083dd80
f01066d4:	e8 49 97 00 00       	call   f010fe22 <release_kspinlock>
f01066d9:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f01066dc:	90                   	nop
f01066dd:	c9                   	leave  
f01066de:	c3                   	ret    

f01066df <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f01066df:	55                   	push   %ebp
f01066e0:	89 e5                	mov    %esp,%ebp
f01066e2:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01066e5:	83 ec 0c             	sub    $0xc,%esp
f01066e8:	68 80 dd 83 f0       	push   $0xf083dd80
f01066ed:	e8 8b 96 00 00       	call   f010fd7d <acquire_kspinlock>
f01066f2:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01066f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01066fc:	a1 f0 dd 83 f0       	mov    0xf083ddf0,%eax
f0106701:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106704:	eb 53                	jmp    f0106759 <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0106706:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106709:	8b 40 10             	mov    0x10(%eax),%eax
f010670c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010670f:	75 40                	jne    f0106751 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f0106711:	83 ec 0c             	sub    $0xc,%esp
f0106714:	ff 75 f4             	pushl  -0xc(%ebp)
f0106717:	e8 06 fd ff ff       	call   f0106422 <sched_remove_new>
f010671c:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready(ptr_env);
f010671f:	83 ec 0c             	sub    $0xc,%esp
f0106722:	ff 75 f4             	pushl  -0xc(%ebp)
f0106725:	e8 ad fa ff ff       	call   f01061d7 <sched_insert_ready>
f010672a:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f010672d:	e8 3e 18 00 00       	call   f0107f70 <mycpu>
f0106732:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0106738:	85 c0                	test   %eax,%eax
f010673a:	75 46                	jne    f0106782 <sched_run_env+0xa3>
			{
				release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010673c:	83 ec 0c             	sub    $0xc,%esp
f010673f:	68 80 dd 83 f0       	push   $0xf083dd80
f0106744:	e8 d9 96 00 00       	call   f010fe22 <release_kspinlock>
f0106749:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f010674c:	e8 f6 0f 00 00       	call   f0107747 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106751:	a1 f8 dd 83 f0       	mov    0xf083ddf8,%eax
f0106756:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106759:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010675d:	74 08                	je     f0106767 <sched_run_env+0x88>
f010675f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106762:	8b 40 08             	mov    0x8(%eax),%eax
f0106765:	eb 05                	jmp    f010676c <sched_run_env+0x8d>
f0106767:	b8 00 00 00 00       	mov    $0x0,%eax
f010676c:	a3 f8 dd 83 f0       	mov    %eax,0xf083ddf8
f0106771:	a1 f8 dd 83 f0       	mov    0xf083ddf8,%eax
f0106776:	85 c0                	test   %eax,%eax
f0106778:	75 8c                	jne    f0106706 <sched_run_env+0x27>
f010677a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010677e:	75 86                	jne    f0106706 <sched_run_env+0x27>
f0106780:	eb 01                	jmp    f0106783 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0106782:	90                   	nop
		}
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106783:	83 ec 0c             	sub    $0xc,%esp
f0106786:	68 80 dd 83 f0       	push   $0xf083dd80
f010678b:	e8 92 96 00 00       	call   f010fe22 <release_kspinlock>
f0106790:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0106793:	90                   	nop
f0106794:	c9                   	leave  
f0106795:	c3                   	ret    

f0106796 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0106796:	55                   	push   %ebp
f0106797:	89 e5                	mov    %esp,%ebp
f0106799:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_kspinlock(&ProcessQueues.qlock);
f010679c:	83 ec 0c             	sub    $0xc,%esp
f010679f:	68 80 dd 83 f0       	push   $0xf083dd80
f01067a4:	e8 29 98 00 00       	call   f010ffd2 <holding_kspinlock>
f01067a9:	83 c4 10             	add    $0x10,%esp
f01067ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f01067af:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01067b3:	75 10                	jne    f01067c5 <sched_exit_env+0x2f>
	{
		acquire_kspinlock(&ProcessQueues.qlock);
f01067b5:	83 ec 0c             	sub    $0xc,%esp
f01067b8:	68 80 dd 83 f0       	push   $0xf083dd80
f01067bd:	e8 bb 95 00 00       	call   f010fd7d <acquire_kspinlock>
f01067c2:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f01067c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f01067cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f01067d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01067d7:	75 59                	jne    f0106832 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01067d9:	a1 f0 dd 83 f0       	mov    0xf083ddf0,%eax
f01067de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01067e1:	eb 28                	jmp    f010680b <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f01067e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067e6:	8b 40 10             	mov    0x10(%eax),%eax
f01067e9:	3b 45 08             	cmp    0x8(%ebp),%eax
f01067ec:	75 15                	jne    f0106803 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f01067ee:	83 ec 0c             	sub    $0xc,%esp
f01067f1:	ff 75 f4             	pushl  -0xc(%ebp)
f01067f4:	e8 29 fc ff ff       	call   f0106422 <sched_remove_new>
f01067f9:	83 c4 10             	add    $0x10,%esp
				found = 1;
f01067fc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106803:	a1 f8 dd 83 f0       	mov    0xf083ddf8,%eax
f0106808:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010680b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010680f:	74 08                	je     f0106819 <sched_exit_env+0x83>
f0106811:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106814:	8b 40 08             	mov    0x8(%eax),%eax
f0106817:	eb 05                	jmp    f010681e <sched_exit_env+0x88>
f0106819:	b8 00 00 00 00       	mov    $0x0,%eax
f010681e:	a3 f8 dd 83 f0       	mov    %eax,0xf083ddf8
f0106823:	a1 f8 dd 83 f0       	mov    0xf083ddf8,%eax
f0106828:	85 c0                	test   %eax,%eax
f010682a:	75 b7                	jne    f01067e3 <sched_exit_env+0x4d>
f010682c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106830:	75 b1                	jne    f01067e3 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f0106832:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106836:	0f 85 67 01 00 00    	jne    f01069a3 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010683c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0106843:	e9 47 01 00 00       	jmp    f010698f <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106848:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f010684d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106850:	c1 e2 04             	shl    $0x4,%edx
f0106853:	01 d0                	add    %edx,%eax
f0106855:	8b 00                	mov    (%eax),%eax
f0106857:	85 c0                	test   %eax,%eax
f0106859:	0f 84 27 01 00 00    	je     f0106986 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f010685f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106866:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f010686b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010686e:	c1 e2 04             	shl    $0x4,%edx
f0106871:	01 d0                	add    %edx,%eax
f0106873:	8b 00                	mov    (%eax),%eax
f0106875:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106878:	e9 d1 00 00 00       	jmp    f010694e <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f010687d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106880:	8b 40 10             	mov    0x10(%eax),%eax
f0106883:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106886:	0f 85 af 00 00 00    	jne    f010693b <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010688c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106890:	75 17                	jne    f01068a9 <sched_exit_env+0x113>
f0106892:	83 ec 04             	sub    $0x4,%esp
f0106895:	68 f7 df 12 f0       	push   $0xf012dff7
f010689a:	68 56 01 00 00       	push   $0x156
f010689f:	68 bb df 12 f0       	push   $0xf012dfbb
f01068a4:	e8 06 a6 ff ff       	call   f0100eaf <_panic>
f01068a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01068ac:	8b 40 08             	mov    0x8(%eax),%eax
f01068af:	85 c0                	test   %eax,%eax
f01068b1:	74 11                	je     f01068c4 <sched_exit_env+0x12e>
f01068b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01068b6:	8b 40 08             	mov    0x8(%eax),%eax
f01068b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01068bc:	8b 52 0c             	mov    0xc(%edx),%edx
f01068bf:	89 50 0c             	mov    %edx,0xc(%eax)
f01068c2:	eb 16                	jmp    f01068da <sched_exit_env+0x144>
f01068c4:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f01068c9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01068cc:	c1 e2 04             	shl    $0x4,%edx
f01068cf:	01 c2                	add    %eax,%edx
f01068d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01068d4:	8b 40 0c             	mov    0xc(%eax),%eax
f01068d7:	89 42 04             	mov    %eax,0x4(%edx)
f01068da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01068dd:	8b 40 0c             	mov    0xc(%eax),%eax
f01068e0:	85 c0                	test   %eax,%eax
f01068e2:	74 11                	je     f01068f5 <sched_exit_env+0x15f>
f01068e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01068e7:	8b 40 0c             	mov    0xc(%eax),%eax
f01068ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01068ed:	8b 52 08             	mov    0x8(%edx),%edx
f01068f0:	89 50 08             	mov    %edx,0x8(%eax)
f01068f3:	eb 15                	jmp    f010690a <sched_exit_env+0x174>
f01068f5:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f01068fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01068fd:	c1 e2 04             	shl    $0x4,%edx
f0106900:	01 c2                	add    %eax,%edx
f0106902:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106905:	8b 40 08             	mov    0x8(%eax),%eax
f0106908:	89 02                	mov    %eax,(%edx)
f010690a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010690d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106914:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106917:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010691e:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106923:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106926:	c1 e2 04             	shl    $0x4,%edx
f0106929:	01 d0                	add    %edx,%eax
f010692b:	8b 50 0c             	mov    0xc(%eax),%edx
f010692e:	4a                   	dec    %edx
f010692f:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0106932:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0106939:	eb 4b                	jmp    f0106986 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010693b:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106940:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106943:	c1 e2 04             	shl    $0x4,%edx
f0106946:	01 d0                	add    %edx,%eax
f0106948:	8b 40 08             	mov    0x8(%eax),%eax
f010694b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010694e:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106953:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106956:	c1 e2 04             	shl    $0x4,%edx
f0106959:	01 d0                	add    %edx,%eax
f010695b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010695f:	74 08                	je     f0106969 <sched_exit_env+0x1d3>
f0106961:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106964:	8b 52 08             	mov    0x8(%edx),%edx
f0106967:	eb 05                	jmp    f010696e <sched_exit_env+0x1d8>
f0106969:	ba 00 00 00 00       	mov    $0x0,%edx
f010696e:	89 50 08             	mov    %edx,0x8(%eax)
f0106971:	8b 40 08             	mov    0x8(%eax),%eax
f0106974:	85 c0                	test   %eax,%eax
f0106976:	0f 85 01 ff ff ff    	jne    f010687d <sched_exit_env+0xe7>
f010697c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106980:	0f 85 f7 fe ff ff    	jne    f010687d <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0106986:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010698a:	75 16                	jne    f01069a2 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010698c:	ff 45 ec             	incl   -0x14(%ebp)
f010698f:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f0106994:	0f b6 c0             	movzbl %al,%eax
f0106997:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010699a:	0f 8f a8 fe ff ff    	jg     f0106848 <sched_exit_env+0xb2>
f01069a0:	eb 01                	jmp    f01069a3 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01069a2:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f01069a3:	e8 73 50 00 00       	call   f010ba1b <get_cpu_proc>
f01069a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f01069ab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01069af:	75 19                	jne    f01069ca <sched_exit_env+0x234>
f01069b1:	68 f3 e0 12 f0       	push   $0xf012e0f3
f01069b6:	68 a6 df 12 f0       	push   $0xf012dfa6
f01069bb:	68 60 01 00 00       	push   $0x160
f01069c0:	68 bb df 12 f0       	push   $0xf012dfbb
f01069c5:	e8 e5 a4 ff ff       	call   f0100eaf <_panic>
	if (!found)
f01069ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01069ce:	75 18                	jne    f01069e8 <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f01069d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01069d3:	8b 40 10             	mov    0x10(%eax),%eax
f01069d6:	3b 45 08             	cmp    0x8(%ebp),%eax
f01069d9:	75 0d                	jne    f01069e8 <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f01069db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01069de:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f01069e1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f01069e8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01069ec:	74 1e                	je     f0106a0c <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f01069ee:	83 ec 0c             	sub    $0xc,%esp
f01069f1:	ff 75 f4             	pushl  -0xc(%ebp)
f01069f4:	e8 19 fb ff ff       	call   f0106512 <sched_insert_exit>
f01069f9:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f01069fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01069ff:	8b 40 10             	mov    0x10(%eax),%eax
f0106a02:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106a05:	75 05                	jne    f0106a0c <sched_exit_env+0x276>
		{
//			cprintf("\n[%d:%s] LAST WS BEFORE EXIT\n", cur_env->env_id,  cur_env->prog_name);
//			env_page_ws_print(cur_env);
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0106a07:	e8 89 51 00 00       	call   f010bb95 <sched>
		}
	}
	if (!lock_already_held)
f0106a0c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106a10:	75 10                	jne    f0106a22 <sched_exit_env+0x28c>
	{
		release_kspinlock(&ProcessQueues.qlock);
f0106a12:	83 ec 0c             	sub    $0xc,%esp
f0106a15:	68 80 dd 83 f0       	push   $0xf083dd80
f0106a1a:	e8 03 94 00 00       	call   f010fe22 <release_kspinlock>
f0106a1f:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0106a22:	90                   	nop
f0106a23:	c9                   	leave  
f0106a24:	c3                   	ret    

f0106a25 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0106a25:	55                   	push   %ebp
f0106a26:	89 e5                	mov    %esp,%ebp
f0106a28:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106a2b:	83 ec 0c             	sub    $0xc,%esp
f0106a2e:	68 80 dd 83 f0       	push   $0xf083dd80
f0106a33:	e8 45 93 00 00       	call   f010fd7d <acquire_kspinlock>
f0106a38:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106a3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0106a42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0106a49:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106a4d:	75 79                	jne    f0106ac8 <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106a4f:	a1 f0 dd 83 f0       	mov    0xf083ddf0,%eax
f0106a54:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106a57:	eb 48                	jmp    f0106aa1 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0106a59:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a5c:	8b 40 10             	mov    0x10(%eax),%eax
f0106a5f:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106a62:	75 35                	jne    f0106a99 <sched_kill_env+0x74>
			{
				cprintf("[BEGIN] killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0106a64:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a67:	8d 50 20             	lea    0x20(%eax),%edx
f0106a6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a6d:	8b 40 10             	mov    0x10(%eax),%eax
f0106a70:	83 ec 04             	sub    $0x4,%esp
f0106a73:	52                   	push   %edx
f0106a74:	50                   	push   %eax
f0106a75:	68 04 e1 12 f0       	push   $0xf012e104
f0106a7a:	e8 dd b0 ff ff       	call   f0101b5c <cprintf>
f0106a7f:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0106a82:	83 ec 0c             	sub    $0xc,%esp
f0106a85:	ff 75 f4             	pushl  -0xc(%ebp)
f0106a88:	e8 95 f9 ff ff       	call   f0106422 <sched_remove_new>
f0106a8d:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0106a90:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0106a97:	eb 2f                	jmp    f0106ac8 <sched_kill_env+0xa3>
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106a99:	a1 f8 dd 83 f0       	mov    0xf083ddf8,%eax
f0106a9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106aa1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106aa5:	74 08                	je     f0106aaf <sched_kill_env+0x8a>
f0106aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106aaa:	8b 40 08             	mov    0x8(%eax),%eax
f0106aad:	eb 05                	jmp    f0106ab4 <sched_kill_env+0x8f>
f0106aaf:	b8 00 00 00 00       	mov    $0x0,%eax
f0106ab4:	a3 f8 dd 83 f0       	mov    %eax,0xf083ddf8
f0106ab9:	a1 f8 dd 83 f0       	mov    0xf083ddf8,%eax
f0106abe:	85 c0                	test   %eax,%eax
f0106ac0:	75 97                	jne    f0106a59 <sched_kill_env+0x34>
f0106ac2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ac6:	75 91                	jne    f0106a59 <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0106ac8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106acc:	0f 85 85 01 00 00    	jne    f0106c57 <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106ad2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0106ad9:	e9 65 01 00 00       	jmp    f0106c43 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106ade:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106ae3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106ae6:	c1 e2 04             	shl    $0x4,%edx
f0106ae9:	01 d0                	add    %edx,%eax
f0106aeb:	8b 00                	mov    (%eax),%eax
f0106aed:	85 c0                	test   %eax,%eax
f0106aef:	0f 84 45 01 00 00    	je     f0106c3a <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0106af5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106afc:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106b01:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106b04:	c1 e2 04             	shl    $0x4,%edx
f0106b07:	01 d0                	add    %edx,%eax
f0106b09:	8b 00                	mov    (%eax),%eax
f0106b0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106b0e:	e9 ef 00 00 00       	jmp    f0106c02 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0106b13:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b16:	8b 40 10             	mov    0x10(%eax),%eax
f0106b19:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106b1c:	0f 85 cd 00 00 00    	jne    f0106bef <sched_kill_env+0x1ca>
					{
						cprintf("[BEGIN] killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0106b22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b25:	8d 50 20             	lea    0x20(%eax),%edx
f0106b28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b2b:	8b 40 10             	mov    0x10(%eax),%eax
f0106b2e:	ff 75 ec             	pushl  -0x14(%ebp)
f0106b31:	52                   	push   %edx
f0106b32:	50                   	push   %eax
f0106b33:	68 34 e1 12 f0       	push   $0xf012e134
f0106b38:	e8 1f b0 ff ff       	call   f0101b5c <cprintf>
f0106b3d:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106b40:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106b44:	75 17                	jne    f0106b5d <sched_kill_env+0x138>
f0106b46:	83 ec 04             	sub    $0x4,%esp
f0106b49:	68 f7 df 12 f0       	push   $0xf012dff7
f0106b4e:	68 a5 01 00 00       	push   $0x1a5
f0106b53:	68 bb df 12 f0       	push   $0xf012dfbb
f0106b58:	e8 52 a3 ff ff       	call   f0100eaf <_panic>
f0106b5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b60:	8b 40 08             	mov    0x8(%eax),%eax
f0106b63:	85 c0                	test   %eax,%eax
f0106b65:	74 11                	je     f0106b78 <sched_kill_env+0x153>
f0106b67:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b6a:	8b 40 08             	mov    0x8(%eax),%eax
f0106b6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106b70:	8b 52 0c             	mov    0xc(%edx),%edx
f0106b73:	89 50 0c             	mov    %edx,0xc(%eax)
f0106b76:	eb 16                	jmp    f0106b8e <sched_kill_env+0x169>
f0106b78:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106b7d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106b80:	c1 e2 04             	shl    $0x4,%edx
f0106b83:	01 c2                	add    %eax,%edx
f0106b85:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b88:	8b 40 0c             	mov    0xc(%eax),%eax
f0106b8b:	89 42 04             	mov    %eax,0x4(%edx)
f0106b8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b91:	8b 40 0c             	mov    0xc(%eax),%eax
f0106b94:	85 c0                	test   %eax,%eax
f0106b96:	74 11                	je     f0106ba9 <sched_kill_env+0x184>
f0106b98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b9b:	8b 40 0c             	mov    0xc(%eax),%eax
f0106b9e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106ba1:	8b 52 08             	mov    0x8(%edx),%edx
f0106ba4:	89 50 08             	mov    %edx,0x8(%eax)
f0106ba7:	eb 15                	jmp    f0106bbe <sched_kill_env+0x199>
f0106ba9:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106bae:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106bb1:	c1 e2 04             	shl    $0x4,%edx
f0106bb4:	01 c2                	add    %eax,%edx
f0106bb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106bb9:	8b 40 08             	mov    0x8(%eax),%eax
f0106bbc:	89 02                	mov    %eax,(%edx)
f0106bbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106bc1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106bc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106bcb:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106bd2:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106bd7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106bda:	c1 e2 04             	shl    $0x4,%edx
f0106bdd:	01 d0                	add    %edx,%eax
f0106bdf:	8b 50 0c             	mov    0xc(%eax),%edx
f0106be2:	4a                   	dec    %edx
f0106be3:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0106be6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0106bed:	eb 4b                	jmp    f0106c3a <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106bef:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106bf4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106bf7:	c1 e2 04             	shl    $0x4,%edx
f0106bfa:	01 d0                	add    %edx,%eax
f0106bfc:	8b 40 08             	mov    0x8(%eax),%eax
f0106bff:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c02:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106c07:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106c0a:	c1 e2 04             	shl    $0x4,%edx
f0106c0d:	01 d0                	add    %edx,%eax
f0106c0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c13:	74 08                	je     f0106c1d <sched_kill_env+0x1f8>
f0106c15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106c18:	8b 52 08             	mov    0x8(%edx),%edx
f0106c1b:	eb 05                	jmp    f0106c22 <sched_kill_env+0x1fd>
f0106c1d:	ba 00 00 00 00       	mov    $0x0,%edx
f0106c22:	89 50 08             	mov    %edx,0x8(%eax)
f0106c25:	8b 40 08             	mov    0x8(%eax),%eax
f0106c28:	85 c0                	test   %eax,%eax
f0106c2a:	0f 85 e3 fe ff ff    	jne    f0106b13 <sched_kill_env+0xee>
f0106c30:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c34:	0f 85 d9 fe ff ff    	jne    f0106b13 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0106c3a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106c3e:	75 16                	jne    f0106c56 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106c40:	ff 45 ec             	incl   -0x14(%ebp)
f0106c43:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f0106c48:	0f b6 c0             	movzbl %al,%eax
f0106c4b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0106c4e:	0f 8f 8a fe ff ff    	jg     f0106ade <sched_kill_env+0xb9>
f0106c54:	eb 01                	jmp    f0106c57 <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0106c56:	90                   	nop
		}
	}
	if (!found)
f0106c57:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106c5b:	0f 85 80 00 00 00    	jne    f0106ce1 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0106c61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106c68:	a1 00 de 83 f0       	mov    0xf083de00,%eax
f0106c6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c70:	eb 48                	jmp    f0106cba <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0106c72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c75:	8b 40 10             	mov    0x10(%eax),%eax
f0106c78:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106c7b:	75 35                	jne    f0106cb2 <sched_kill_env+0x28d>
			{
				cprintf("[BEGIN] killing[%d] %s from the EXIT queue...\n", ptr_env->env_id, ptr_env->prog_name);
f0106c7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c80:	8d 50 20             	lea    0x20(%eax),%edx
f0106c83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c86:	8b 40 10             	mov    0x10(%eax),%eax
f0106c89:	83 ec 04             	sub    $0x4,%esp
f0106c8c:	52                   	push   %edx
f0106c8d:	50                   	push   %eax
f0106c8e:	68 68 e1 12 f0       	push   $0xf012e168
f0106c93:	e8 c4 ae ff ff       	call   f0101b5c <cprintf>
f0106c98:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0106c9b:	83 ec 0c             	sub    $0xc,%esp
f0106c9e:	ff 75 f4             	pushl  -0xc(%ebp)
f0106ca1:	e8 f3 f8 ff ff       	call   f0106599 <sched_remove_exit>
f0106ca6:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0106ca9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0106cb0:	eb 2f                	jmp    f0106ce1 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106cb2:	a1 08 de 83 f0       	mov    0xf083de08,%eax
f0106cb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106cba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106cbe:	74 08                	je     f0106cc8 <sched_kill_env+0x2a3>
f0106cc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cc3:	8b 40 08             	mov    0x8(%eax),%eax
f0106cc6:	eb 05                	jmp    f0106ccd <sched_kill_env+0x2a8>
f0106cc8:	b8 00 00 00 00       	mov    $0x0,%eax
f0106ccd:	a3 08 de 83 f0       	mov    %eax,0xf083de08
f0106cd2:	a1 08 de 83 f0       	mov    0xf083de08,%eax
f0106cd7:	85 c0                	test   %eax,%eax
f0106cd9:	75 97                	jne    f0106c72 <sched_kill_env+0x24d>
f0106cdb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106cdf:	75 91                	jne    f0106c72 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106ce1:	83 ec 0c             	sub    $0xc,%esp
f0106ce4:	68 80 dd 83 f0       	push   $0xf083dd80
f0106ce9:	e8 34 91 00 00       	call   f010fe22 <release_kspinlock>
f0106cee:	83 c4 10             	add    $0x10,%esp

	if (found)
f0106cf1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106cf5:	74 23                	je     f0106d1a <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0106cf7:	83 ec 0c             	sub    $0xc,%esp
f0106cfa:	ff 75 f4             	pushl  -0xc(%ebp)
f0106cfd:	e8 ba 4c 00 00       	call   f010b9bc <env_free>
f0106d02:	83 c4 10             	add    $0x10,%esp
		cprintf("[END] DONE\n");
f0106d05:	83 ec 0c             	sub    $0xc,%esp
f0106d08:	68 97 e1 12 f0       	push   $0xf012e197
f0106d0d:	e8 4a ae ff ff       	call   f0101b5c <cprintf>
f0106d12:	83 c4 10             	add    $0x10,%esp
			acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
			sched();
		}
	}

}
f0106d15:	e9 b8 00 00 00       	jmp    f0106dd2 <sched_kill_env+0x3ad>
		env_free(ptr_env);
		cprintf("[END] DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0106d1a:	e8 fc 4c 00 00       	call   f010ba1b <get_cpu_proc>
f0106d1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0106d22:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106d26:	75 19                	jne    f0106d41 <sched_kill_env+0x31c>
f0106d28:	68 f3 e0 12 f0       	push   $0xf012e0f3
f0106d2d:	68 a6 df 12 f0       	push   $0xf012dfa6
f0106d32:	68 c7 01 00 00       	push   $0x1c7
f0106d37:	68 bb df 12 f0       	push   $0xf012dfbb
f0106d3c:	e8 6e a1 ff ff       	call   f0100eaf <_panic>

		if (cur_env->env_id == envId)
f0106d41:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106d44:	8b 40 10             	mov    0x10(%eax),%eax
f0106d47:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106d4a:	0f 85 82 00 00 00    	jne    f0106dd2 <sched_kill_env+0x3ad>
		{
			ptr_env = cur_env;
f0106d50:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106d53:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0106d56:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d59:	8b 40 18             	mov    0x18(%eax),%eax
f0106d5c:	83 f8 02             	cmp    $0x2,%eax
f0106d5f:	74 19                	je     f0106d7a <sched_kill_env+0x355>
f0106d61:	68 a4 e1 12 f0       	push   $0xf012e1a4
f0106d66:	68 a6 df 12 f0       	push   $0xf012dfa6
f0106d6b:	68 cc 01 00 00       	push   $0x1cc
f0106d70:	68 bb df 12 f0       	push   $0xf012dfbb
f0106d75:	e8 35 a1 ff ff       	call   f0100eaf <_panic>
			cprintf("[BEGIN] killing a RUNNABLE environment [%d] %s...\n", ptr_env->env_id, ptr_env->prog_name);
f0106d7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d7d:	8d 50 20             	lea    0x20(%eax),%edx
f0106d80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d83:	8b 40 10             	mov    0x10(%eax),%eax
f0106d86:	83 ec 04             	sub    $0x4,%esp
f0106d89:	52                   	push   %edx
f0106d8a:	50                   	push   %eax
f0106d8b:	68 c8 e1 12 f0       	push   $0xf012e1c8
f0106d90:	e8 c7 ad ff ff       	call   f0101b5c <cprintf>
f0106d95:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106d98:	83 ec 0c             	sub    $0xc,%esp
f0106d9b:	ff 75 f4             	pushl  -0xc(%ebp)
f0106d9e:	e8 19 4c 00 00       	call   f010b9bc <env_free>
f0106da3:	83 c4 10             	add    $0x10,%esp
			cprintf("[END] DONE\n");
f0106da6:	83 ec 0c             	sub    $0xc,%esp
f0106da9:	68 97 e1 12 f0       	push   $0xf012e197
f0106dae:	e8 a9 ad ff ff       	call   f0101b5c <cprintf>
f0106db3:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0106db6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106dbd:	83 ec 0c             	sub    $0xc,%esp
f0106dc0:	68 80 dd 83 f0       	push   $0xf083dd80
f0106dc5:	e8 b3 8f 00 00       	call   f010fd7d <acquire_kspinlock>
f0106dca:	83 c4 10             	add    $0x10,%esp
			sched();
f0106dcd:	e8 c3 4d 00 00       	call   f010bb95 <sched>
		}
	}

}
f0106dd2:	90                   	nop
f0106dd3:	c9                   	leave  
f0106dd4:	c3                   	ret    

f0106dd5 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0106dd5:	55                   	push   %ebp
f0106dd6:	89 e5                	mov    %esp,%ebp
f0106dd8:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106ddb:	83 ec 0c             	sub    $0xc,%esp
f0106dde:	68 80 dd 83 f0       	push   $0xf083dd80
f0106de3:	e8 95 8f 00 00       	call   f010fd7d <acquire_kspinlock>
f0106de8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0106deb:	a1 f0 dd 83 f0       	mov    0xf083ddf0,%eax
f0106df0:	85 c0                	test   %eax,%eax
f0106df2:	74 69                	je     f0106e5d <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0106df4:	83 ec 0c             	sub    $0xc,%esp
f0106df7:	68 fc e1 12 f0       	push   $0xf012e1fc
f0106dfc:	e8 5b ad ff ff       	call   f0101b5c <cprintf>
f0106e01:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106e04:	a1 f0 dd 83 f0       	mov    0xf083ddf0,%eax
f0106e09:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106e0c:	eb 26                	jmp    f0106e34 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106e0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e11:	8d 50 20             	lea    0x20(%eax),%edx
f0106e14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e17:	8b 40 10             	mov    0x10(%eax),%eax
f0106e1a:	83 ec 04             	sub    $0x4,%esp
f0106e1d:	52                   	push   %edx
f0106e1e:	50                   	push   %eax
f0106e1f:	68 1e e2 12 f0       	push   $0xf012e21e
f0106e24:	e8 33 ad ff ff       	call   f0101b5c <cprintf>
f0106e29:	83 c4 10             	add    $0x10,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106e2c:	a1 f8 dd 83 f0       	mov    0xf083ddf8,%eax
f0106e31:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106e34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106e38:	74 08                	je     f0106e42 <sched_print_all+0x6d>
f0106e3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e3d:	8b 40 08             	mov    0x8(%eax),%eax
f0106e40:	eb 05                	jmp    f0106e47 <sched_print_all+0x72>
f0106e42:	b8 00 00 00 00       	mov    $0x0,%eax
f0106e47:	a3 f8 dd 83 f0       	mov    %eax,0xf083ddf8
f0106e4c:	a1 f8 dd 83 f0       	mov    0xf083ddf8,%eax
f0106e51:	85 c0                	test   %eax,%eax
f0106e53:	75 b9                	jne    f0106e0e <sched_print_all+0x39>
f0106e55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106e59:	75 b3                	jne    f0106e0e <sched_print_all+0x39>
f0106e5b:	eb 10                	jmp    f0106e6d <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0106e5d:	83 ec 0c             	sub    $0xc,%esp
f0106e60:	68 28 e2 12 f0       	push   $0xf012e228
f0106e65:	e8 f2 ac ff ff       	call   f0101b5c <cprintf>
f0106e6a:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0106e6d:	83 ec 0c             	sub    $0xc,%esp
f0106e70:	68 44 e2 12 f0       	push   $0xf012e244
f0106e75:	e8 e2 ac ff ff       	call   f0101b5c <cprintf>
f0106e7a:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106e7d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106e84:	e9 c7 00 00 00       	jmp    f0106f50 <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106e89:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106e8e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106e91:	c1 e2 04             	shl    $0x4,%edx
f0106e94:	01 d0                	add    %edx,%eax
f0106e96:	8b 00                	mov    (%eax),%eax
f0106e98:	85 c0                	test   %eax,%eax
f0106e9a:	0f 84 8a 00 00 00    	je     f0106f2a <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0106ea0:	83 ec 08             	sub    $0x8,%esp
f0106ea3:	ff 75 f0             	pushl  -0x10(%ebp)
f0106ea6:	68 78 e2 12 f0       	push   $0xf012e278
f0106eab:	e8 ac ac ff ff       	call   f0101b5c <cprintf>
f0106eb0:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106eb3:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106eb8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ebb:	c1 e2 04             	shl    $0x4,%edx
f0106ebe:	01 d0                	add    %edx,%eax
f0106ec0:	8b 00                	mov    (%eax),%eax
f0106ec2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ec5:	eb 31                	jmp    f0106ef8 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106ec7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106eca:	8d 50 20             	lea    0x20(%eax),%edx
f0106ecd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ed0:	8b 40 10             	mov    0x10(%eax),%eax
f0106ed3:	83 ec 04             	sub    $0x4,%esp
f0106ed6:	52                   	push   %edx
f0106ed7:	50                   	push   %eax
f0106ed8:	68 1e e2 12 f0       	push   $0xf012e21e
f0106edd:	e8 7a ac ff ff       	call   f0101b5c <cprintf>
f0106ee2:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106ee5:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106eea:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106eed:	c1 e2 04             	shl    $0x4,%edx
f0106ef0:	01 d0                	add    %edx,%eax
f0106ef2:	8b 40 08             	mov    0x8(%eax),%eax
f0106ef5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ef8:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0106efd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106f00:	c1 e2 04             	shl    $0x4,%edx
f0106f03:	01 d0                	add    %edx,%eax
f0106f05:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106f09:	74 08                	je     f0106f13 <sched_print_all+0x13e>
f0106f0b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106f0e:	8b 52 08             	mov    0x8(%edx),%edx
f0106f11:	eb 05                	jmp    f0106f18 <sched_print_all+0x143>
f0106f13:	ba 00 00 00 00       	mov    $0x0,%edx
f0106f18:	89 50 08             	mov    %edx,0x8(%eax)
f0106f1b:	8b 40 08             	mov    0x8(%eax),%eax
f0106f1e:	85 c0                	test   %eax,%eax
f0106f20:	75 a5                	jne    f0106ec7 <sched_print_all+0xf2>
f0106f22:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106f26:	75 9f                	jne    f0106ec7 <sched_print_all+0xf2>
f0106f28:	eb 13                	jmp    f0106f3d <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0106f2a:	83 ec 08             	sub    $0x8,%esp
f0106f2d:	ff 75 f0             	pushl  -0x10(%ebp)
f0106f30:	68 a0 e2 12 f0       	push   $0xf012e2a0
f0106f35:	e8 22 ac ff ff       	call   f0101b5c <cprintf>
f0106f3a:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106f3d:	83 ec 0c             	sub    $0xc,%esp
f0106f40:	68 44 e2 12 f0       	push   $0xf012e244
f0106f45:	e8 12 ac ff ff       	call   f0101b5c <cprintf>
f0106f4a:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106f4d:	ff 45 f0             	incl   -0x10(%ebp)
f0106f50:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f0106f55:	0f b6 c0             	movzbl %al,%eax
f0106f58:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106f5b:	0f 8f 28 ff ff ff    	jg     f0106e89 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106f61:	a1 00 de 83 f0       	mov    0xf083de00,%eax
f0106f66:	85 c0                	test   %eax,%eax
f0106f68:	74 69                	je     f0106fd3 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0106f6a:	83 ec 0c             	sub    $0xc,%esp
f0106f6d:	68 c4 e2 12 f0       	push   $0xf012e2c4
f0106f72:	e8 e5 ab ff ff       	call   f0101b5c <cprintf>
f0106f77:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106f7a:	a1 00 de 83 f0       	mov    0xf083de00,%eax
f0106f7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106f82:	eb 26                	jmp    f0106faa <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106f84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f87:	8d 50 20             	lea    0x20(%eax),%edx
f0106f8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f8d:	8b 40 10             	mov    0x10(%eax),%eax
f0106f90:	83 ec 04             	sub    $0x4,%esp
f0106f93:	52                   	push   %edx
f0106f94:	50                   	push   %eax
f0106f95:	68 1e e2 12 f0       	push   $0xf012e21e
f0106f9a:	e8 bd ab ff ff       	call   f0101b5c <cprintf>
f0106f9f:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106fa2:	a1 08 de 83 f0       	mov    0xf083de08,%eax
f0106fa7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106faa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106fae:	74 08                	je     f0106fb8 <sched_print_all+0x1e3>
f0106fb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb3:	8b 40 08             	mov    0x8(%eax),%eax
f0106fb6:	eb 05                	jmp    f0106fbd <sched_print_all+0x1e8>
f0106fb8:	b8 00 00 00 00       	mov    $0x0,%eax
f0106fbd:	a3 08 de 83 f0       	mov    %eax,0xf083de08
f0106fc2:	a1 08 de 83 f0       	mov    0xf083de08,%eax
f0106fc7:	85 c0                	test   %eax,%eax
f0106fc9:	75 b9                	jne    f0106f84 <sched_print_all+0x1af>
f0106fcb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106fcf:	75 b3                	jne    f0106f84 <sched_print_all+0x1af>
f0106fd1:	eb 10                	jmp    f0106fe3 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106fd3:	83 ec 0c             	sub    $0xc,%esp
f0106fd6:	68 e6 e2 12 f0       	push   $0xf012e2e6
f0106fdb:	e8 7c ab ff ff       	call   f0101b5c <cprintf>
f0106fe0:	83 c4 10             	add    $0x10,%esp
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106fe3:	83 ec 0c             	sub    $0xc,%esp
f0106fe6:	68 80 dd 83 f0       	push   $0xf083dd80
f0106feb:	e8 32 8e 00 00       	call   f010fe22 <release_kspinlock>
f0106ff0:	83 c4 10             	add    $0x10,%esp
}
f0106ff3:	90                   	nop
f0106ff4:	c9                   	leave  
f0106ff5:	c3                   	ret    

f0106ff6 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106ff6:	55                   	push   %ebp
f0106ff7:	89 e5                	mov    %esp,%ebp
f0106ff9:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106ffc:	83 ec 0c             	sub    $0xc,%esp
f0106fff:	68 80 dd 83 f0       	push   $0xf083dd80
f0107004:	e8 74 8d 00 00       	call   f010fd7d <acquire_kspinlock>
f0107009:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010700c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0107013:	a1 fc dd 83 f0       	mov    0xf083ddfc,%eax
f0107018:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f010701b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107022:	eb 24                	jmp    f0107048 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f0107024:	83 ec 0c             	sub    $0xc,%esp
f0107027:	68 f0 dd 83 f0       	push   $0xf083ddf0
f010702c:	e8 6b ef ff ff       	call   f0105f9c <dequeue>
f0107031:	83 c4 10             	add    $0x10,%esp
f0107034:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready(ptr_env);
f0107037:	83 ec 0c             	sub    $0xc,%esp
f010703a:	ff 75 f0             	pushl  -0x10(%ebp)
f010703d:	e8 95 f1 ff ff       	call   f01061d7 <sched_insert_ready>
f0107042:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f0107045:	ff 45 f4             	incl   -0xc(%ebp)
f0107048:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010704b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010704e:	7c d4                	jl     f0107024 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready(ptr_env);
	}

	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0107050:	83 ec 0c             	sub    $0xc,%esp
f0107053:	68 80 dd 83 f0       	push   $0xf083dd80
f0107058:	e8 c5 8d 00 00       	call   f010fe22 <release_kspinlock>
f010705d:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f0107060:	e8 0b 0f 00 00       	call   f0107f70 <mycpu>
f0107065:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010706b:	85 c0                	test   %eax,%eax
f010706d:	75 05                	jne    f0107074 <sched_run_all+0x7e>
		fos_scheduler();
f010706f:	e8 d3 06 00 00       	call   f0107747 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f0107074:	83 ec 04             	sub    $0x4,%esp
f0107077:	68 04 e3 12 f0       	push   $0xf012e304
f010707c:	68 2a 02 00 00       	push   $0x22a
f0107081:	68 bb df 12 f0       	push   $0xf012dfbb
f0107086:	e8 24 9e ff ff       	call   f0100eaf <_panic>

f010708b <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f010708b:	55                   	push   %ebp
f010708c:	89 e5                	mov    %esp,%ebp
f010708e:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0107091:	83 ec 0c             	sub    $0xc,%esp
f0107094:	68 80 dd 83 f0       	push   $0xf083dd80
f0107099:	e8 df 8c 00 00       	call   f010fd7d <acquire_kspinlock>
f010709e:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01070a1:	a1 f0 dd 83 f0       	mov    0xf083ddf0,%eax
f01070a6:	85 c0                	test   %eax,%eax
f01070a8:	0f 84 95 00 00 00    	je     f0107143 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f01070ae:	83 ec 0c             	sub    $0xc,%esp
f01070b1:	68 40 e3 12 f0       	push   $0xf012e340
f01070b6:	e8 a1 aa ff ff       	call   f0101b5c <cprintf>
f01070bb:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01070be:	a1 f0 dd 83 f0       	mov    0xf083ddf0,%eax
f01070c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01070c6:	eb 52                	jmp    f010711a <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01070c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070cb:	8d 50 20             	lea    0x20(%eax),%edx
f01070ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070d1:	8b 40 10             	mov    0x10(%eax),%eax
f01070d4:	83 ec 04             	sub    $0x4,%esp
f01070d7:	52                   	push   %edx
f01070d8:	50                   	push   %eax
f01070d9:	68 6c e3 12 f0       	push   $0xf012e36c
f01070de:	e8 79 aa ff ff       	call   f0101b5c <cprintf>
f01070e3:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f01070e6:	83 ec 0c             	sub    $0xc,%esp
f01070e9:	ff 75 f4             	pushl  -0xc(%ebp)
f01070ec:	e8 31 f3 ff ff       	call   f0106422 <sched_remove_new>
f01070f1:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01070f4:	83 ec 0c             	sub    $0xc,%esp
f01070f7:	ff 75 f4             	pushl  -0xc(%ebp)
f01070fa:	e8 bd 48 00 00       	call   f010b9bc <env_free>
f01070ff:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0107102:	83 ec 0c             	sub    $0xc,%esp
f0107105:	68 7f e3 12 f0       	push   $0xf012e37f
f010710a:	e8 4d aa ff ff       	call   f0101b5c <cprintf>
f010710f:	83 c4 10             	add    $0x10,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0107112:	a1 f8 dd 83 f0       	mov    0xf083ddf8,%eax
f0107117:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010711a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010711e:	74 08                	je     f0107128 <sched_kill_all+0x9d>
f0107120:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107123:	8b 40 08             	mov    0x8(%eax),%eax
f0107126:	eb 05                	jmp    f010712d <sched_kill_all+0xa2>
f0107128:	b8 00 00 00 00       	mov    $0x0,%eax
f010712d:	a3 f8 dd 83 f0       	mov    %eax,0xf083ddf8
f0107132:	a1 f8 dd 83 f0       	mov    0xf083ddf8,%eax
f0107137:	85 c0                	test   %eax,%eax
f0107139:	75 8d                	jne    f01070c8 <sched_kill_all+0x3d>
f010713b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010713f:	75 87                	jne    f01070c8 <sched_kill_all+0x3d>
f0107141:	eb 10                	jmp    f0107153 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f0107143:	83 ec 0c             	sub    $0xc,%esp
f0107146:	68 85 e3 12 f0       	push   $0xf012e385
f010714b:	e8 0c aa ff ff       	call   f0101b5c <cprintf>
f0107150:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0107153:	83 ec 0c             	sub    $0xc,%esp
f0107156:	68 44 e2 12 f0       	push   $0xf012e244
f010715b:	e8 fc a9 ff ff       	call   f0101b5c <cprintf>
f0107160:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0107163:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010716a:	e9 96 01 00 00       	jmp    f0107305 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010716f:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0107174:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107177:	c1 e2 04             	shl    $0x4,%edx
f010717a:	01 d0                	add    %edx,%eax
f010717c:	8b 00                	mov    (%eax),%eax
f010717e:	85 c0                	test   %eax,%eax
f0107180:	0f 84 59 01 00 00    	je     f01072df <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0107186:	83 ec 08             	sub    $0x8,%esp
f0107189:	ff 75 f0             	pushl  -0x10(%ebp)
f010718c:	68 a0 e3 12 f0       	push   $0xf012e3a0
f0107191:	e8 c6 a9 ff ff       	call   f0101b5c <cprintf>
f0107196:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0107199:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f010719e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01071a1:	c1 e2 04             	shl    $0x4,%edx
f01071a4:	01 d0                	add    %edx,%eax
f01071a6:	8b 00                	mov    (%eax),%eax
f01071a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01071ab:	e9 f5 00 00 00       	jmp    f01072a5 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01071b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071b3:	8d 50 20             	lea    0x20(%eax),%edx
f01071b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071b9:	8b 40 10             	mov    0x10(%eax),%eax
f01071bc:	83 ec 04             	sub    $0x4,%esp
f01071bf:	52                   	push   %edx
f01071c0:	50                   	push   %eax
f01071c1:	68 6c e3 12 f0       	push   $0xf012e36c
f01071c6:	e8 91 a9 ff ff       	call   f0101b5c <cprintf>
f01071cb:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01071ce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01071d2:	75 17                	jne    f01071eb <sched_kill_all+0x160>
f01071d4:	83 ec 04             	sub    $0x4,%esp
f01071d7:	68 f7 df 12 f0       	push   $0xf012dff7
f01071dc:	68 4c 02 00 00       	push   $0x24c
f01071e1:	68 bb df 12 f0       	push   $0xf012dfbb
f01071e6:	e8 c4 9c ff ff       	call   f0100eaf <_panic>
f01071eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ee:	8b 40 08             	mov    0x8(%eax),%eax
f01071f1:	85 c0                	test   %eax,%eax
f01071f3:	74 11                	je     f0107206 <sched_kill_all+0x17b>
f01071f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071f8:	8b 40 08             	mov    0x8(%eax),%eax
f01071fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01071fe:	8b 52 0c             	mov    0xc(%edx),%edx
f0107201:	89 50 0c             	mov    %edx,0xc(%eax)
f0107204:	eb 16                	jmp    f010721c <sched_kill_all+0x191>
f0107206:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f010720b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010720e:	c1 e2 04             	shl    $0x4,%edx
f0107211:	01 c2                	add    %eax,%edx
f0107213:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107216:	8b 40 0c             	mov    0xc(%eax),%eax
f0107219:	89 42 04             	mov    %eax,0x4(%edx)
f010721c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010721f:	8b 40 0c             	mov    0xc(%eax),%eax
f0107222:	85 c0                	test   %eax,%eax
f0107224:	74 11                	je     f0107237 <sched_kill_all+0x1ac>
f0107226:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107229:	8b 40 0c             	mov    0xc(%eax),%eax
f010722c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010722f:	8b 52 08             	mov    0x8(%edx),%edx
f0107232:	89 50 08             	mov    %edx,0x8(%eax)
f0107235:	eb 15                	jmp    f010724c <sched_kill_all+0x1c1>
f0107237:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f010723c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010723f:	c1 e2 04             	shl    $0x4,%edx
f0107242:	01 c2                	add    %eax,%edx
f0107244:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107247:	8b 40 08             	mov    0x8(%eax),%eax
f010724a:	89 02                	mov    %eax,(%edx)
f010724c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010724f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0107256:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107259:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0107260:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0107265:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107268:	c1 e2 04             	shl    $0x4,%edx
f010726b:	01 d0                	add    %edx,%eax
f010726d:	8b 50 0c             	mov    0xc(%eax),%edx
f0107270:	4a                   	dec    %edx
f0107271:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f0107274:	83 ec 0c             	sub    $0xc,%esp
f0107277:	ff 75 f4             	pushl  -0xc(%ebp)
f010727a:	e8 3d 47 00 00       	call   f010b9bc <env_free>
f010727f:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0107282:	83 ec 0c             	sub    $0xc,%esp
f0107285:	68 7f e3 12 f0       	push   $0xf012e37f
f010728a:	e8 cd a8 ff ff       	call   f0101b5c <cprintf>
f010728f:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0107292:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0107297:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010729a:	c1 e2 04             	shl    $0x4,%edx
f010729d:	01 d0                	add    %edx,%eax
f010729f:	8b 40 08             	mov    0x8(%eax),%eax
f01072a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01072a5:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f01072aa:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01072ad:	c1 e2 04             	shl    $0x4,%edx
f01072b0:	01 d0                	add    %edx,%eax
f01072b2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01072b6:	74 08                	je     f01072c0 <sched_kill_all+0x235>
f01072b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01072bb:	8b 52 08             	mov    0x8(%edx),%edx
f01072be:	eb 05                	jmp    f01072c5 <sched_kill_all+0x23a>
f01072c0:	ba 00 00 00 00       	mov    $0x0,%edx
f01072c5:	89 50 08             	mov    %edx,0x8(%eax)
f01072c8:	8b 40 08             	mov    0x8(%eax),%eax
f01072cb:	85 c0                	test   %eax,%eax
f01072cd:	0f 85 dd fe ff ff    	jne    f01071b0 <sched_kill_all+0x125>
f01072d3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01072d7:	0f 85 d3 fe ff ff    	jne    f01071b0 <sched_kill_all+0x125>
f01072dd:	eb 13                	jmp    f01072f2 <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f01072df:	83 ec 08             	sub    $0x8,%esp
f01072e2:	ff 75 f0             	pushl  -0x10(%ebp)
f01072e5:	68 a0 e2 12 f0       	push   $0xf012e2a0
f01072ea:	e8 6d a8 ff ff       	call   f0101b5c <cprintf>
f01072ef:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f01072f2:	83 ec 0c             	sub    $0xc,%esp
f01072f5:	68 44 e2 12 f0       	push   $0xf012e244
f01072fa:	e8 5d a8 ff ff       	call   f0101b5c <cprintf>
f01072ff:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0107302:	ff 45 f0             	incl   -0x10(%ebp)
f0107305:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f010730a:	0f b6 c0             	movzbl %al,%eax
f010730d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0107310:	0f 8f 59 fe ff ff    	jg     f010716f <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0107316:	a1 00 de 83 f0       	mov    0xf083de00,%eax
f010731b:	85 c0                	test   %eax,%eax
f010731d:	0f 84 95 00 00 00    	je     f01073b8 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f0107323:	83 ec 0c             	sub    $0xc,%esp
f0107326:	68 d4 e3 12 f0       	push   $0xf012e3d4
f010732b:	e8 2c a8 ff ff       	call   f0101b5c <cprintf>
f0107330:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0107333:	a1 00 de 83 f0       	mov    0xf083de00,%eax
f0107338:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010733b:	eb 52                	jmp    f010738f <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010733d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107340:	8d 50 20             	lea    0x20(%eax),%edx
f0107343:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107346:	8b 40 10             	mov    0x10(%eax),%eax
f0107349:	83 ec 04             	sub    $0x4,%esp
f010734c:	52                   	push   %edx
f010734d:	50                   	push   %eax
f010734e:	68 6c e3 12 f0       	push   $0xf012e36c
f0107353:	e8 04 a8 ff ff       	call   f0101b5c <cprintf>
f0107358:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f010735b:	83 ec 0c             	sub    $0xc,%esp
f010735e:	ff 75 f4             	pushl  -0xc(%ebp)
f0107361:	e8 33 f2 ff ff       	call   f0106599 <sched_remove_exit>
f0107366:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0107369:	83 ec 0c             	sub    $0xc,%esp
f010736c:	ff 75 f4             	pushl  -0xc(%ebp)
f010736f:	e8 48 46 00 00       	call   f010b9bc <env_free>
f0107374:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0107377:	83 ec 0c             	sub    $0xc,%esp
f010737a:	68 7f e3 12 f0       	push   $0xf012e37f
f010737f:	e8 d8 a7 ff ff       	call   f0101b5c <cprintf>
f0107384:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0107387:	a1 08 de 83 f0       	mov    0xf083de08,%eax
f010738c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010738f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107393:	74 08                	je     f010739d <sched_kill_all+0x312>
f0107395:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107398:	8b 40 08             	mov    0x8(%eax),%eax
f010739b:	eb 05                	jmp    f01073a2 <sched_kill_all+0x317>
f010739d:	b8 00 00 00 00       	mov    $0x0,%eax
f01073a2:	a3 08 de 83 f0       	mov    %eax,0xf083de08
f01073a7:	a1 08 de 83 f0       	mov    0xf083de08,%eax
f01073ac:	85 c0                	test   %eax,%eax
f01073ae:	75 8d                	jne    f010733d <sched_kill_all+0x2b2>
f01073b0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01073b4:	75 87                	jne    f010733d <sched_kill_all+0x2b2>
f01073b6:	eb 10                	jmp    f01073c8 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01073b8:	83 ec 0c             	sub    $0xc,%esp
f01073bb:	68 e6 e2 12 f0       	push   $0xf012e2e6
f01073c0:	e8 97 a7 ff ff       	call   f0101b5c <cprintf>
f01073c5:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f01073c8:	e8 4e 46 00 00       	call   f010ba1b <get_cpu_proc>
f01073cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f01073d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01073d4:	74 6b                	je     f0107441 <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f01073d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01073d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f01073dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073df:	8b 40 18             	mov    0x18(%eax),%eax
f01073e2:	83 f8 02             	cmp    $0x2,%eax
f01073e5:	74 19                	je     f0107400 <sched_kill_all+0x375>
f01073e7:	68 a4 e1 12 f0       	push   $0xf012e1a4
f01073ec:	68 a6 df 12 f0       	push   $0xf012dfa6
f01073f1:	68 6c 02 00 00       	push   $0x26c
f01073f6:	68 bb df 12 f0       	push   $0xf012dfbb
f01073fb:	e8 af 9a ff ff       	call   f0100eaf <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0107400:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107403:	8d 50 20             	lea    0x20(%eax),%edx
f0107406:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107409:	8b 40 10             	mov    0x10(%eax),%eax
f010740c:	83 ec 04             	sub    $0x4,%esp
f010740f:	52                   	push   %edx
f0107410:	50                   	push   %eax
f0107411:	68 00 e4 12 f0       	push   $0xf012e400
f0107416:	e8 41 a7 ff ff       	call   f0101b5c <cprintf>
f010741b:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010741e:	83 ec 0c             	sub    $0xc,%esp
f0107421:	ff 75 f4             	pushl  -0xc(%ebp)
f0107424:	e8 93 45 00 00       	call   f010b9bc <env_free>
f0107429:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f010742c:	83 ec 0c             	sub    $0xc,%esp
f010742f:	68 7f e3 12 f0       	push   $0xf012e37f
f0107434:	e8 23 a7 ff ff       	call   f0101b5c <cprintf>
f0107439:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f010743c:	e8 54 47 00 00       	call   f010bb95 <sched>
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0107441:	83 ec 0c             	sub    $0xc,%esp
f0107444:	68 80 dd 83 f0       	push   $0xf083dd80
f0107449:	e8 d4 89 00 00       	call   f010fe22 <release_kspinlock>
f010744e:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f0107451:	e8 8c a8 ff ff       	call   f0101ce2 <get_into_prompt>

f0107456 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f0107456:	55                   	push   %ebp
f0107457:	89 e5                	mov    %esp,%ebp
f0107459:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010745c:	83 ec 0c             	sub    $0xc,%esp
f010745f:	68 80 dd 83 f0       	push   $0xf083dd80
f0107464:	e8 14 89 00 00       	call   f010fd7d <acquire_kspinlock>
f0107469:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010746c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0107473:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010747a:	e9 37 01 00 00       	jmp    f01075b6 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010747f:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0107484:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107487:	c1 e2 04             	shl    $0x4,%edx
f010748a:	01 d0                	add    %edx,%eax
f010748c:	8b 00                	mov    (%eax),%eax
f010748e:	85 c0                	test   %eax,%eax
f0107490:	0f 84 1d 01 00 00    	je     f01075b3 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0107496:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010749d:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f01074a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01074a5:	c1 e2 04             	shl    $0x4,%edx
f01074a8:	01 d0                	add    %edx,%eax
f01074aa:	8b 00                	mov    (%eax),%eax
f01074ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01074af:	e9 c7 00 00 00       	jmp    f010757b <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01074b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01074b8:	75 17                	jne    f01074d1 <sched_exit_all_ready_envs+0x7b>
f01074ba:	83 ec 04             	sub    $0x4,%esp
f01074bd:	68 f7 df 12 f0       	push   $0xf012dff7
f01074c2:	68 8e 02 00 00       	push   $0x28e
f01074c7:	68 bb df 12 f0       	push   $0xf012dfbb
f01074cc:	e8 de 99 ff ff       	call   f0100eaf <_panic>
f01074d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d4:	8b 40 08             	mov    0x8(%eax),%eax
f01074d7:	85 c0                	test   %eax,%eax
f01074d9:	74 11                	je     f01074ec <sched_exit_all_ready_envs+0x96>
f01074db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074de:	8b 40 08             	mov    0x8(%eax),%eax
f01074e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01074e4:	8b 52 0c             	mov    0xc(%edx),%edx
f01074e7:	89 50 0c             	mov    %edx,0xc(%eax)
f01074ea:	eb 16                	jmp    f0107502 <sched_exit_all_ready_envs+0xac>
f01074ec:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f01074f1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01074f4:	c1 e2 04             	shl    $0x4,%edx
f01074f7:	01 c2                	add    %eax,%edx
f01074f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074fc:	8b 40 0c             	mov    0xc(%eax),%eax
f01074ff:	89 42 04             	mov    %eax,0x4(%edx)
f0107502:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107505:	8b 40 0c             	mov    0xc(%eax),%eax
f0107508:	85 c0                	test   %eax,%eax
f010750a:	74 11                	je     f010751d <sched_exit_all_ready_envs+0xc7>
f010750c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010750f:	8b 40 0c             	mov    0xc(%eax),%eax
f0107512:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107515:	8b 52 08             	mov    0x8(%edx),%edx
f0107518:	89 50 08             	mov    %edx,0x8(%eax)
f010751b:	eb 15                	jmp    f0107532 <sched_exit_all_ready_envs+0xdc>
f010751d:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0107522:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107525:	c1 e2 04             	shl    $0x4,%edx
f0107528:	01 c2                	add    %eax,%edx
f010752a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010752d:	8b 40 08             	mov    0x8(%eax),%eax
f0107530:	89 02                	mov    %eax,(%edx)
f0107532:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107535:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010753c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010753f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0107546:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f010754b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010754e:	c1 e2 04             	shl    $0x4,%edx
f0107551:	01 d0                	add    %edx,%eax
f0107553:	8b 50 0c             	mov    0xc(%eax),%edx
f0107556:	4a                   	dec    %edx
f0107557:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f010755a:	83 ec 0c             	sub    $0xc,%esp
f010755d:	ff 75 f4             	pushl  -0xc(%ebp)
f0107560:	e8 ad ef ff ff       	call   f0106512 <sched_insert_exit>
f0107565:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0107568:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f010756d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107570:	c1 e2 04             	shl    $0x4,%edx
f0107573:	01 d0                	add    %edx,%eax
f0107575:	8b 40 08             	mov    0x8(%eax),%eax
f0107578:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010757b:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0107580:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107583:	c1 e2 04             	shl    $0x4,%edx
f0107586:	01 d0                	add    %edx,%eax
f0107588:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010758c:	74 08                	je     f0107596 <sched_exit_all_ready_envs+0x140>
f010758e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107591:	8b 52 08             	mov    0x8(%edx),%edx
f0107594:	eb 05                	jmp    f010759b <sched_exit_all_ready_envs+0x145>
f0107596:	ba 00 00 00 00       	mov    $0x0,%edx
f010759b:	89 50 08             	mov    %edx,0x8(%eax)
f010759e:	8b 40 08             	mov    0x8(%eax),%eax
f01075a1:	85 c0                	test   %eax,%eax
f01075a3:	0f 85 0b ff ff ff    	jne    f01074b4 <sched_exit_all_ready_envs+0x5e>
f01075a9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01075ad:	0f 85 01 ff ff ff    	jne    f01074b4 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01075b3:	ff 45 f0             	incl   -0x10(%ebp)
f01075b6:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f01075bb:	0f b6 c0             	movzbl %al,%eax
f01075be:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01075c1:	0f 8f b8 fe ff ff    	jg     f010747f <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01075c7:	83 ec 0c             	sub    $0xc,%esp
f01075ca:	68 80 dd 83 f0       	push   $0xf083dd80
f01075cf:	e8 4e 88 00 00       	call   f010fe22 <release_kspinlock>
f01075d4:	83 c4 10             	add    $0x10,%esp
}
f01075d7:	90                   	nop
f01075d8:	c9                   	leave  
f01075d9:	c3                   	ret    

f01075da <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f01075da:	55                   	push   %ebp
f01075db:	89 e5                	mov    %esp,%ebp
	return ticks;
f01075dd:	a1 88 62 85 f0       	mov    0xf0856288,%eax
f01075e2:	8b 15 8c 62 85 f0    	mov    0xf085628c,%edx
}
f01075e8:	5d                   	pop    %ebp
f01075e9:	c3                   	ret    

f01075ea <env_get_nice>:
int env_get_nice(struct Env* e)
{
f01075ea:	55                   	push   %ebp
f01075eb:	89 e5                	mov    %esp,%ebp
f01075ed:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f01075f0:	83 ec 04             	sub    $0x4,%esp
f01075f3:	68 2a e4 12 f0       	push   $0xf012e42a
f01075f8:	68 9e 02 00 00       	push   $0x29e
f01075fd:	68 bb df 12 f0       	push   $0xf012dfbb
f0107602:	e8 a8 98 ff ff       	call   f0100eaf <_panic>

f0107607 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0107607:	55                   	push   %ebp
f0107608:	89 e5                	mov    %esp,%ebp
f010760a:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f010760d:	83 ec 04             	sub    $0x4,%esp
f0107610:	68 2a e4 12 f0       	push   $0xf012e42a
f0107615:	68 a3 02 00 00       	push   $0x2a3
f010761a:	68 bb df 12 f0       	push   $0xf012dfbb
f010761f:	e8 8b 98 ff ff       	call   f0100eaf <_panic>

f0107624 <env_get_recent_cpu>:
}
int env_get_recent_cpu(struct Env* e)
{
f0107624:	55                   	push   %ebp
f0107625:	89 e5                	mov    %esp,%ebp
f0107627:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f010762a:	83 ec 04             	sub    $0x4,%esp
f010762d:	68 2a e4 12 f0       	push   $0xf012e42a
f0107632:	68 a7 02 00 00       	push   $0x2a7
f0107637:	68 bb df 12 f0       	push   $0xf012dfbb
f010763c:	e8 6e 98 ff ff       	call   f0100eaf <_panic>

f0107641 <get_load_average>:
}
int get_load_average()
{
f0107641:	55                   	push   %ebp
f0107642:	89 e5                	mov    %esp,%ebp
f0107644:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f0107647:	83 ec 04             	sub    $0x4,%esp
f010764a:	68 2a e4 12 f0       	push   $0xf012e42a
f010764f:	68 ab 02 00 00       	push   $0x2ab
f0107654:	68 bb df 12 f0       	push   $0xf012dfbb
f0107659:	e8 51 98 ff ff       	call   f0100eaf <_panic>

f010765e <env_set_priority>:
//==================================================================================//

/*2024*/
/********* for Priority RR Scheduler *************/
void env_set_priority(int envID, int priority)
{
f010765e:	55                   	push   %ebp
f010765f:	89 e5                	mov    %esp,%ebp
f0107661:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 env_set_priority
	//Your code is here
	//Comment the following line
	panic("env_set_priority() is not implemented yet...!!");
f0107664:	83 ec 04             	sub    $0x4,%esp
f0107667:	68 44 e4 12 f0       	push   $0xf012e444
f010766c:	68 b8 02 00 00       	push   $0x2b8
f0107671:	68 bb df 12 f0       	push   $0xf012dfbb
f0107676:	e8 34 98 ff ff       	call   f0100eaf <_panic>

f010767b <sched_set_starv_thresh>:
}
void sched_set_starv_thresh(uint32 starvThresh)
{
f010767b:	55                   	push   %ebp
f010767c:	89 e5                	mov    %esp,%ebp
f010767e:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 sched_set_starv_thresh
	//Your code is here
	//Comment the following line
	panic("sched_set_starv_thresh() is not implemented yet...!!");
f0107681:	83 ec 04             	sub    $0x4,%esp
f0107684:	68 74 e4 12 f0       	push   $0xf012e474
f0107689:	68 bf 02 00 00       	push   $0x2bf
f010768e:	68 bb df 12 f0       	push   $0xf012dfbb
f0107693:	e8 17 98 ff ff       	call   f0100eaf <_panic>

f0107698 <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){return (scheduler_method == SCH_RR);}
f0107698:	55                   	push   %ebp
f0107699:	89 e5                	mov    %esp,%ebp
f010769b:	a1 5c 61 85 f0       	mov    0xf085615c,%eax
f01076a0:	85 c0                	test   %eax,%eax
f01076a2:	0f 94 c0             	sete   %al
f01076a5:	0f b6 c0             	movzbl %al,%eax
f01076a8:	5d                   	pop    %ebp
f01076a9:	c3                   	ret    

f01076aa <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){return (scheduler_method == SCH_MLFQ); }
f01076aa:	55                   	push   %ebp
f01076ab:	89 e5                	mov    %esp,%ebp
f01076ad:	a1 5c 61 85 f0       	mov    0xf085615c,%eax
f01076b2:	83 f8 01             	cmp    $0x1,%eax
f01076b5:	0f 94 c0             	sete   %al
f01076b8:	0f b6 c0             	movzbl %al,%eax
f01076bb:	5d                   	pop    %ebp
f01076bc:	c3                   	ret    

f01076bd <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){return(scheduler_method == SCH_BSD); }
f01076bd:	55                   	push   %ebp
f01076be:	89 e5                	mov    %esp,%ebp
f01076c0:	a1 5c 61 85 f0       	mov    0xf085615c,%eax
f01076c5:	83 f8 02             	cmp    $0x2,%eax
f01076c8:	0f 94 c0             	sete   %al
f01076cb:	0f b6 c0             	movzbl %al,%eax
f01076ce:	5d                   	pop    %ebp
f01076cf:	c3                   	ret    

f01076d0 <isSchedMethodPRIRR>:
uint32 isSchedMethodPRIRR(){return(scheduler_method == SCH_PRIRR); }
f01076d0:	55                   	push   %ebp
f01076d1:	89 e5                	mov    %esp,%ebp
f01076d3:	a1 5c 61 85 f0       	mov    0xf085615c,%eax
f01076d8:	83 f8 03             	cmp    $0x3,%eax
f01076db:	0f 94 c0             	sete   %al
f01076de:	0f b6 c0             	movzbl %al,%eax
f01076e1:	5d                   	pop    %ebp
f01076e2:	c3                   	ret    

f01076e3 <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f01076e3:	55                   	push   %ebp
f01076e4:	89 e5                	mov    %esp,%ebp
f01076e6:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f01076e9:	c7 05 58 df 83 f0 00 	movl   $0x0,0xf083df58
f01076f0:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f01076f3:	83 ec 0c             	sub    $0xc,%esp
f01076f6:	6a 0a                	push   $0xa
f01076f8:	e8 45 02 00 00       	call   f0107942 <sched_init_RR>
f01076fd:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f0107700:	83 ec 0c             	sub    $0xc,%esp
f0107703:	68 f0 dd 83 f0       	push   $0xf083ddf0
f0107708:	e8 bd e7 ff ff       	call   f0105eca <init_queue>
f010770d:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f0107710:	83 ec 0c             	sub    $0xc,%esp
f0107713:	68 00 de 83 f0       	push   $0xf083de00
f0107718:	e8 ad e7 ff ff       	call   f0105eca <init_queue>
f010771d:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f0107720:	e8 4b 08 00 00       	call   f0107f70 <mycpu>
f0107725:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f010772c:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_kspinlock(&ProcessQueues.qlock, "process queues lock");
f010772f:	83 ec 08             	sub    $0x8,%esp
f0107732:	68 ac e4 12 f0       	push   $0xf012e4ac
f0107737:	68 80 dd 83 f0       	push   $0xf083dd80
f010773c:	e8 0b 86 00 00       	call   f010fd4c <init_kspinlock>
f0107741:	83 c4 10             	add    $0x10,%esp
}
f0107744:	90                   	nop
f0107745:	c9                   	leave  
f0107746:	c3                   	ret    

f0107747 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0107747:	55                   	push   %ebp
f0107748:	89 e5                	mov    %esp,%ebp
f010774a:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010774d:	9c                   	pushf  
f010774e:	58                   	pop    %eax
f010774f:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return eflags;
f0107752:	8b 45 dc             	mov    -0x24(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f0107755:	25 00 02 00 00       	and    $0x200,%eax
f010775a:	85 c0                	test   %eax,%eax
f010775c:	74 14                	je     f0107772 <fos_scheduler+0x2b>
		panic("fos_scheduler: called while the interrupt is enabled!");
f010775e:	83 ec 04             	sub    $0x4,%esp
f0107761:	68 c0 e4 12 f0       	push   $0xf012e4c0
f0107766:	6a 3a                	push   $0x3a
f0107768:	68 f6 e4 12 f0       	push   $0xf012e4f6
f010776d:	e8 3d 97 ff ff       	call   f0100eaf <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f0107772:	e8 f9 07 00 00       	call   f0107f70 <mycpu>
f0107777:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f010777a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010777d:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0107784:	00 00 00 

	chk1();
f0107787:	e8 05 24 01 00       	call   f0119b91 <chk1>
	c->scheduler_status = SCH_STARTED;
f010778c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010778f:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f0107796:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0107799:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f01077a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01077a7:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_kspinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f01077a8:	83 ec 0c             	sub    $0xc,%esp
f01077ab:	68 80 dd 83 f0       	push   $0xf083dd80
f01077b0:	e8 c8 85 00 00       	call   f010fd7d <acquire_kspinlock>
f01077b5:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f01077b8:	a1 5c 61 85 f0       	mov    0xf085615c,%eax
f01077bd:	8b 04 85 ac fb 17 f0 	mov    -0xfe80454(,%eax,4),%eax
f01077c4:	ff d0                	call   *%eax
f01077c6:	89 45 e8             	mov    %eax,-0x18(%ebp)

			if(next_env != NULL)
f01077c9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01077cd:	0f 84 f5 00 00 00    	je     f01078c8 <fos_scheduler+0x181>
			{
				//cprintf("\nScheduler select program '%s' [%d]... clock counter = %d\n", next_env->prog_name, next_env->env_id, kclock_read_cnt0());
				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f01077d3:	83 ec 0c             	sub    $0xc,%esp
f01077d6:	ff 75 e8             	pushl  -0x18(%ebp)
f01077d9:	e8 66 42 00 00       	call   f010ba44 <set_cpu_proc>
f01077de:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f01077e1:	83 ec 0c             	sub    $0xc,%esp
f01077e4:	ff 75 e8             	pushl  -0x18(%ebp)
f01077e7:	e8 cc 44 00 00       	call   f010bcb8 <switchuvm>
f01077ec:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f01077ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01077f2:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f01077f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01077fc:	8b 40 04             	mov    0x4(%eax),%eax
f01077ff:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107802:	83 c2 04             	add    $0x4,%edx
f0107805:	83 ec 08             	sub    $0x8,%esp
f0107808:	50                   	push   %eax
f0107809:	52                   	push   %edx
f010780a:	e8 c3 e2 ff ff       	call   f0105ad2 <context_switch>
f010780f:	83 c4 10             	add    $0x10,%esp

				//ensure that the qlock is still held after returning from the process
				if(!holding_kspinlock(&ProcessQueues.qlock))
f0107812:	83 ec 0c             	sub    $0xc,%esp
f0107815:	68 80 dd 83 f0       	push   $0xf083dd80
f010781a:	e8 b3 87 00 00       	call   f010ffd2 <holding_kspinlock>
f010781f:	83 c4 10             	add    $0x10,%esp
f0107822:	85 c0                	test   %eax,%eax
f0107824:	75 24                	jne    f010784a <fos_scheduler+0x103>
				{
					printcallstack(&ProcessQueues.qlock);
f0107826:	83 ec 0c             	sub    $0xc,%esp
f0107829:	68 80 dd 83 f0       	push   $0xf083dd80
f010782e:	e8 38 87 00 00       	call   f010ff6b <printcallstack>
f0107833:	83 c4 10             	add    $0x10,%esp
					panic("fos_scheduler(): qlock is either not held or held by another CPU!");
f0107836:	83 ec 04             	sub    $0x4,%esp
f0107839:	68 08 e5 12 f0       	push   $0xf012e508
f010783e:	6a 6c                	push   $0x6c
f0107840:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107845:	e8 65 96 ff ff       	call   f0100eaf <_panic>
				}

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f010784a:	e8 cc e3 ff ff       	call   f0105c1b <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, c->proc == NULL? 0 : c->proc->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f010784f:	e8 c7 41 00 00       	call   f010ba1b <get_cpu_proc>
f0107854:	89 c2                	mov    %eax,%edx
f0107856:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107859:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010785f:	39 c2                	cmp    %eax,%edx
f0107861:	74 16                	je     f0107879 <fos_scheduler+0x132>
f0107863:	68 4a e5 12 f0       	push   $0xf012e54a
f0107868:	68 64 e5 12 f0       	push   $0xf012e564
f010786d:	6a 76                	push   $0x76
f010786f:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107874:	e8 36 96 ff ff       	call   f0100eaf <_panic>
				int status = c->proc->env_status ;
f0107879:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010787c:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0107882:	8b 40 18             	mov    0x18(%eax),%eax
f0107885:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				assert(status != ENV_RUNNING);
f0107888:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
f010788c:	75 16                	jne    f01078a4 <fos_scheduler+0x15d>
f010788e:	68 79 e5 12 f0       	push   $0xf012e579
f0107893:	68 64 e5 12 f0       	push   $0xf012e564
f0107898:	6a 78                	push   $0x78
f010789a:	68 f6 e4 12 f0       	push   $0xf012e4f6
f010789f:	e8 0b 96 ff ff       	call   f0100eaf <_panic>
				if (status == ENV_READY)
f01078a4:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f01078a8:	74 1e                	je     f01078c8 <fos_scheduler+0x181>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f01078aa:	e8 f2 43 00 00       	call   f010bca1 <switchkvm>
					struct Env* __e__ = c->proc;
f01078af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01078b2:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01078b8:	89 45 e0             	mov    %eax,-0x20(%ebp)
					set_cpu_proc(NULL);
f01078bb:	83 ec 0c             	sub    $0xc,%esp
f01078be:	6a 00                	push   $0x0
f01078c0:	e8 7f 41 00 00       	call   f010ba44 <set_cpu_proc>
f01078c5:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f01078c8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01078cc:	0f 85 e6 fe ff ff    	jne    f01077b8 <fos_scheduler+0x71>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f01078d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f01078d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01078e0:	eb 37                	jmp    f0107919 <fos_scheduler+0x1d2>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f01078e2:	8b 0d f0 51 81 f0    	mov    0xf08151f0,%ecx
f01078e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01078eb:	89 d0                	mov    %edx,%eax
f01078ed:	c1 e0 02             	shl    $0x2,%eax
f01078f0:	01 d0                	add    %edx,%eax
f01078f2:	c1 e0 03             	shl    $0x3,%eax
f01078f5:	01 d0                	add    %edx,%eax
f01078f7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01078fe:	01 d0                	add    %edx,%eax
f0107900:	c1 e0 02             	shl    $0x2,%eax
f0107903:	01 c8                	add    %ecx,%eax
f0107905:	8b 40 18             	mov    0x18(%eax),%eax
f0107908:	83 f8 03             	cmp    $0x3,%eax
f010790b:	75 09                	jne    f0107916 <fos_scheduler+0x1cf>
			{
				is_any_blocked = 1;
f010790d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0107914:	eb 0d                	jmp    f0107923 <fos_scheduler+0x1dc>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f0107916:	ff 45 f0             	incl   -0x10(%ebp)
f0107919:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010791c:	3d c5 02 00 00       	cmp    $0x2c5,%eax
f0107921:	76 bf                	jbe    f01078e2 <fos_scheduler+0x19b>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0107923:	83 ec 0c             	sub    $0xc,%esp
f0107926:	68 80 dd 83 f0       	push   $0xf083dd80
f010792b:	e8 f2 84 00 00       	call   f010fe22 <release_kspinlock>
f0107930:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);
	} while (is_any_blocked > 0);
f0107933:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107937:	0f 8f 6a fe ff ff    	jg     f01077a7 <fos_scheduler+0x60>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f010793d:	e8 a0 a3 ff ff       	call   f0101ce2 <get_into_prompt>

f0107942 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f0107942:	55                   	push   %ebp
f0107943:	89 e5                	mov    %esp,%ebp
f0107945:	83 ec 28             	sub    $0x28,%esp
f0107948:	8b 45 08             	mov    0x8(%ebp),%eax
f010794b:	88 45 e4             	mov    %al,-0x1c(%ebp)
	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f010794e:	c6 05 c0 63 85 f0 01 	movb   $0x1,0xf08563c0
#if USE_KHEAP
	sched_delete_ready_queues();
f0107955:	e8 20 e8 ff ff       	call   f010617a <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f010795a:	83 ec 0c             	sub    $0xc,%esp
f010795d:	6a 10                	push   $0x10
f010795f:	e8 d5 21 00 00       	call   f0109b39 <kmalloc>
f0107964:	83 c4 10             	add    $0x10,%esp
f0107967:	a3 10 de 83 f0       	mov    %eax,0xf083de10
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f010796c:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f0107971:	0f b6 c0             	movzbl %al,%eax
f0107974:	83 ec 0c             	sub    $0xc,%esp
f0107977:	50                   	push   %eax
f0107978:	e8 bc 21 00 00       	call   f0109b39 <kmalloc>
f010797d:	83 c4 10             	add    $0x10,%esp
f0107980:	a3 44 61 85 f0       	mov    %eax,0xf0856144
#endif
	quantums[0] = quantum;
f0107985:	a1 44 61 85 f0       	mov    0xf0856144,%eax
f010798a:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f010798d:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f010798f:	a1 44 61 85 f0       	mov    0xf0856144,%eax
f0107994:	8a 00                	mov    (%eax),%al
f0107996:	0f b6 c0             	movzbl %al,%eax
f0107999:	83 ec 0c             	sub    $0xc,%esp
f010799c:	50                   	push   %eax
f010799d:	e8 42 e3 ff ff       	call   f0105ce4 <kclock_set_quantum>
f01079a2:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f01079a5:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f01079aa:	83 ec 0c             	sub    $0xc,%esp
f01079ad:	50                   	push   %eax
f01079ae:	e8 17 e5 ff ff       	call   f0105eca <init_queue>
f01079b3:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f01079b6:	e8 88 e4 ff ff       	call   f0105e43 <kclock_read_cnt0_latch>
f01079bb:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f01079bf:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f01079c3:	83 ec 08             	sub    $0x8,%esp
f01079c6:	50                   	push   %eax
f01079c7:	68 90 e5 12 f0       	push   $0xf012e590
f01079cc:	e8 8b a1 ff ff       	call   f0101b5c <cprintf>
f01079d1:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f01079d4:	e8 97 05 00 00       	call   f0107f70 <mycpu>
f01079d9:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f01079e0:	00 00 00 
	scheduler_method = SCH_RR;
f01079e3:	c7 05 5c 61 85 f0 00 	movl   $0x0,0xf085615c
f01079ea:	00 00 00 
	//=========================================
	//=========================================
}
f01079ed:	90                   	nop
f01079ee:	c9                   	leave  
f01079ef:	c3                   	ret    

f01079f0 <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f01079f0:	55                   	push   %ebp
f01079f1:	89 e5                	mov    %esp,%ebp
f01079f3:	83 ec 18             	sub    $0x18,%esp
f01079f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01079f9:	88 45 f4             	mov    %al,-0xc(%ebp)
	panic("Not implemented yet");
f01079fc:	83 ec 04             	sub    $0x4,%esp
f01079ff:	68 b8 e5 12 f0       	push   $0xf012e5b8
f0107a04:	68 bb 00 00 00       	push   $0xbb
f0107a09:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107a0e:	e8 9c 94 ff ff       	call   f0100eaf <_panic>

f0107a13 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0107a13:	55                   	push   %ebp
f0107a14:	89 e5                	mov    %esp,%ebp
f0107a16:	83 ec 18             	sub    $0x18,%esp
f0107a19:	8b 55 08             	mov    0x8(%ebp),%edx
f0107a1c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107a1f:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0107a22:	88 45 f0             	mov    %al,-0x10(%ebp)
	panic("Not implemented yet");
f0107a25:	83 ec 04             	sub    $0x4,%esp
f0107a28:	68 b8 e5 12 f0       	push   $0xf012e5b8
f0107a2d:	68 ce 00 00 00       	push   $0xce
f0107a32:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107a37:	e8 73 94 ff ff       	call   f0100eaf <_panic>

f0107a3c <sched_init_PRIRR>:

//======================================
// [6] Initialize PRIORITY RR Scheduler:
//======================================
void sched_init_PRIRR(uint8 numOfPriorities, uint8 quantum, uint32 starvThresh)
{
f0107a3c:	55                   	push   %ebp
f0107a3d:	89 e5                	mov    %esp,%ebp
f0107a3f:	83 ec 18             	sub    $0x18,%esp
f0107a42:	8b 55 08             	mov    0x8(%ebp),%edx
f0107a45:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107a48:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0107a4b:	88 45 f0             	mov    %al,-0x10(%ebp)
	{
		//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #2 sched_init_PRIRR
		//Your code is here
		//Comment the following line
		panic("sched_init_PRIRR() is not implemented yet...!!");
f0107a4e:	83 ec 04             	sub    $0x4,%esp
f0107a51:	68 cc e5 12 f0       	push   $0xf012e5cc
f0107a56:	68 e4 00 00 00       	push   $0xe4
f0107a5b:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107a60:	e8 4a 94 ff ff       	call   f0100eaf <_panic>

f0107a65 <fos_scheduler_RR>:

//=========================
// [7] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0107a65:	55                   	push   %ebp
f0107a66:	89 e5                	mov    %esp,%ebp
f0107a68:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107a6b:	83 ec 0c             	sub    $0xc,%esp
f0107a6e:	68 80 dd 83 f0       	push   $0xf083dd80
f0107a73:	e8 5a 85 00 00       	call   f010ffd2 <holding_kspinlock>
f0107a78:	83 c4 10             	add    $0x10,%esp
f0107a7b:	85 c0                	test   %eax,%eax
f0107a7d:	75 17                	jne    f0107a96 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0107a7f:	83 ec 04             	sub    $0x4,%esp
f0107a82:	68 fc e5 12 f0       	push   $0xf012e5fc
f0107a87:	68 ff 00 00 00       	push   $0xff
f0107a8c:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107a91:	e8 19 94 ff ff       	call   f0100eaf <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0107a96:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0107a9d:	e8 79 3f 00 00       	call   f010ba1b <get_cpu_proc>
f0107aa2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0107aa5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107aa9:	74 14                	je     f0107abf <fos_scheduler_RR+0x5a>
	{
		//cprintf("RR: [%d] with status %d will be added to ready Q", cur_env->env_id, cur_env->env_status);
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0107aab:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0107ab0:	83 ec 08             	sub    $0x8,%esp
f0107ab3:	ff 75 f0             	pushl  -0x10(%ebp)
f0107ab6:	50                   	push   %eax
f0107ab7:	e8 4f e4 ff ff       	call   f0105f0b <enqueue>
f0107abc:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0107abf:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0107ac4:	83 ec 0c             	sub    $0xc,%esp
f0107ac7:	50                   	push   %eax
f0107ac8:	e8 cf e4 ff ff       	call   f0105f9c <dequeue>
f0107acd:	83 c4 10             	add    $0x10,%esp
f0107ad0:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0107ad3:	a1 44 61 85 f0       	mov    0xf0856144,%eax
f0107ad8:	8a 00                	mov    (%eax),%al
f0107ada:	0f b6 c0             	movzbl %al,%eax
f0107add:	83 ec 0c             	sub    $0xc,%esp
f0107ae0:	50                   	push   %eax
f0107ae1:	e8 fe e1 ff ff       	call   f0105ce4 <kclock_set_quantum>
f0107ae6:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0107ae9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0107aec:	c9                   	leave  
f0107aed:	c3                   	ret    

f0107aee <fos_scheduler_MLFQ>:

//=========================
// [8] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0107aee:	55                   	push   %ebp
f0107aef:	89 e5                	mov    %esp,%ebp
f0107af1:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107af4:	83 ec 0c             	sub    $0xc,%esp
f0107af7:	68 80 dd 83 f0       	push   $0xf083dd80
f0107afc:	e8 d1 84 00 00       	call   f010ffd2 <holding_kspinlock>
f0107b01:	83 c4 10             	add    $0x10,%esp
f0107b04:	85 c0                	test   %eax,%eax
f0107b06:	75 17                	jne    f0107b1f <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0107b08:	83 ec 04             	sub    $0x4,%esp
f0107b0b:	68 48 e6 12 f0       	push   $0xf012e648
f0107b10:	68 1f 01 00 00       	push   $0x11f
f0107b15:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107b1a:	e8 90 93 ff ff       	call   f0100eaf <_panic>
	/****************************************************************************************/
	panic("Not implemented yet");
f0107b1f:	83 ec 04             	sub    $0x4,%esp
f0107b22:	68 b8 e5 12 f0       	push   $0xf012e5b8
f0107b27:	68 21 01 00 00       	push   $0x121
f0107b2c:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107b31:	e8 79 93 ff ff       	call   f0100eaf <_panic>

f0107b36 <fos_scheduler_BSD>:

//=========================
// [9] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0107b36:	55                   	push   %ebp
f0107b37:	89 e5                	mov    %esp,%ebp
f0107b39:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107b3c:	83 ec 0c             	sub    $0xc,%esp
f0107b3f:	68 80 dd 83 f0       	push   $0xf083dd80
f0107b44:	e8 89 84 00 00       	call   f010ffd2 <holding_kspinlock>
f0107b49:	83 c4 10             	add    $0x10,%esp
f0107b4c:	85 c0                	test   %eax,%eax
f0107b4e:	75 17                	jne    f0107b67 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0107b50:	83 ec 04             	sub    $0x4,%esp
f0107b53:	68 98 e6 12 f0       	push   $0xf012e698
f0107b58:	68 2b 01 00 00       	push   $0x12b
f0107b5d:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107b62:	e8 48 93 ff ff       	call   f0100eaf <_panic>
	/****************************************************************************************/
	panic("Not implemented yet");
f0107b67:	83 ec 04             	sub    $0x4,%esp
f0107b6a:	68 b8 e5 12 f0       	push   $0xf012e5b8
f0107b6f:	68 2d 01 00 00       	push   $0x12d
f0107b74:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107b79:	e8 31 93 ff ff       	call   f0100eaf <_panic>

f0107b7e <fos_scheduler_PRIRR>:

//=============================
// [10] PRIORITY RR Scheduler:
//=============================
struct Env* fos_scheduler_PRIRR()
{
f0107b7e:	55                   	push   %ebp
f0107b7f:	89 e5                	mov    %esp,%ebp
f0107b81:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107b84:	83 ec 0c             	sub    $0xc,%esp
f0107b87:	68 80 dd 83 f0       	push   $0xf083dd80
f0107b8c:	e8 41 84 00 00       	call   f010ffd2 <holding_kspinlock>
f0107b91:	83 c4 10             	add    $0x10,%esp
f0107b94:	85 c0                	test   %eax,%eax
f0107b96:	75 17                	jne    f0107baf <fos_scheduler_PRIRR+0x31>
		panic("fos_scheduler_PRIRR: q.lock is not held by this CPU while it's expected to be.");
f0107b98:	83 ec 04             	sub    $0x4,%esp
f0107b9b:	68 e8 e6 12 f0       	push   $0xf012e6e8
f0107ba0:	68 37 01 00 00       	push   $0x137
f0107ba5:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107baa:	e8 00 93 ff ff       	call   f0100eaf <_panic>
	/****************************************************************************************/
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #3 fos_scheduler_PRIRR
	//Your code is here
	//Comment the following line
	panic("fos_scheduler_PRIRR() is not implemented yet...!!");
f0107baf:	83 ec 04             	sub    $0x4,%esp
f0107bb2:	68 38 e7 12 f0       	push   $0xf012e738
f0107bb7:	68 3c 01 00 00       	push   $0x13c
f0107bbc:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107bc1:	e8 e9 92 ff ff       	call   f0100eaf <_panic>

f0107bc6 <clock_interrupt_handler>:
//========================================
// [11] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0107bc6:	55                   	push   %ebp
f0107bc7:	89 e5                	mov    %esp,%ebp
f0107bc9:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodPRIRR())
f0107bcc:	e8 ff fa ff ff       	call   f01076d0 <isSchedMethodPRIRR>
f0107bd1:	85 c0                	test   %eax,%eax
f0107bd3:	74 17                	je     f0107bec <clock_interrupt_handler+0x26>
	{
		//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #4 clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("clock_interrupt_handler() is not implemented yet...!!");
f0107bd5:	83 ec 04             	sub    $0x4,%esp
f0107bd8:	68 6c e7 12 f0       	push   $0xf012e76c
f0107bdd:	68 4a 01 00 00       	push   $0x14a
f0107be2:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107be7:	e8 c3 92 ff ff       	call   f0100eaf <_panic>


	}

	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0107bec:	a1 88 62 85 f0       	mov    0xf0856288,%eax
f0107bf1:	8b 15 8c 62 85 f0    	mov    0xf085628c,%edx
f0107bf7:	83 c0 01             	add    $0x1,%eax
f0107bfa:	83 d2 00             	adc    $0x0,%edx
f0107bfd:	a3 88 62 85 f0       	mov    %eax,0xf0856288
f0107c02:	89 15 8c 62 85 f0    	mov    %edx,0xf085628c
	struct Env* p = get_cpu_proc();
f0107c08:	e8 0e 3e 00 00       	call   f010ba1b <get_cpu_proc>
f0107c0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0107c10:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107c14:	74 30                	je     f0107c46 <clock_interrupt_handler+0x80>
//		cprintf("scheduler status = %d\n", mycpu()->scheduler_status) ;
		//panic("clock_interrupt_handler: no running process at the cpu! unexpected clock interrupt in the kernel!");
	}
	else
	{
		p->nClocks++ ;
f0107c16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c19:	8b 80 c0 05 00 00    	mov    0x5c0(%eax),%eax
f0107c1f:	8d 50 01             	lea    0x1(%eax),%edx
f0107c22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c25:	89 90 c0 05 00 00    	mov    %edx,0x5c0(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0107c2b:	83 ec 0c             	sub    $0xc,%esp
f0107c2e:	6a 01                	push   $0x1
f0107c30:	e8 f0 7b 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f0107c35:	83 c4 10             	add    $0x10,%esp
f0107c38:	85 c0                	test   %eax,%eax
f0107c3a:	74 05                	je     f0107c41 <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0107c3c:	e8 08 00 00 00       	call   f0107c49 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0107c41:	e8 f0 3e 00 00       	call   f010bb36 <yield>
	}
	/*****************************************/
}
f0107c46:	90                   	nop
f0107c47:	c9                   	leave  
f0107c48:	c3                   	ret    

f0107c49 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0107c49:	55                   	push   %ebp
f0107c4a:	89 e5                	mov    %esp,%ebp
f0107c4c:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #1 update_WS_time_stamps
	//Your code is here
	//Comment the following line
	panic("update_WS_time_stamps is not implemented yet...!!");
f0107c4f:	83 ec 04             	sub    $0x4,%esp
f0107c52:	68 a4 e7 12 f0       	push   $0xf012e7a4
f0107c57:	68 72 01 00 00       	push   $0x172
f0107c5c:	68 f6 e4 12 f0       	push   $0xf012e4f6
f0107c61:	e8 49 92 ff ff       	call   f0100eaf <_panic>

f0107c66 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0107c66:	55                   	push   %ebp
f0107c67:	89 e5                	mov    %esp,%ebp
f0107c69:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0107c6c:	c7 05 ec 51 81 f0 01 	movl   $0x1,0xf08151ec
f0107c73:	00 00 00 
f0107c76:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0107c7d:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107c81:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0107c84:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107c87:	ee                   	out    %al,(%dx)
f0107c88:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0107c8f:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0107c93:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0107c96:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107c99:	ee                   	out    %al,(%dx)
f0107c9a:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0107ca1:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0107ca5:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0107ca8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107cab:	ee                   	out    %al,(%dx)
f0107cac:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0107cb3:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0107cb7:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0107cba:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107cbd:	ee                   	out    %al,(%dx)
f0107cbe:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0107cc5:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0107cc9:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0107ccc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107ccf:	ee                   	out    %al,(%dx)
f0107cd0:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0107cd7:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0107cdb:	8a 45 b7             	mov    -0x49(%ebp),%al
f0107cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107ce1:	ee                   	out    %al,(%dx)
f0107ce2:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0107ce9:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0107ced:	8a 45 b8             	mov    -0x48(%ebp),%al
f0107cf0:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0107cf3:	ee                   	out    %al,(%dx)
f0107cf4:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0107cfb:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0107cff:	8a 45 b9             	mov    -0x47(%ebp),%al
f0107d02:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0107d05:	ee                   	out    %al,(%dx)
f0107d06:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0107d0d:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0107d11:	8a 45 ba             	mov    -0x46(%ebp),%al
f0107d14:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0107d17:	ee                   	out    %al,(%dx)
f0107d18:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0107d1f:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0107d23:	8a 45 bb             	mov    -0x45(%ebp),%al
f0107d26:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0107d29:	ee                   	out    %al,(%dx)
f0107d2a:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0107d31:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0107d35:	8a 45 bc             	mov    -0x44(%ebp),%al
f0107d38:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0107d3b:	ee                   	out    %al,(%dx)
f0107d3c:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0107d43:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0107d47:	8a 45 bd             	mov    -0x43(%ebp),%al
f0107d4a:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0107d4d:	ee                   	out    %al,(%dx)
f0107d4e:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0107d55:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0107d59:	8a 45 be             	mov    -0x42(%ebp),%al
f0107d5c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0107d5f:	ee                   	out    %al,(%dx)
f0107d60:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0107d67:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0107d6b:	8a 45 bf             	mov    -0x41(%ebp),%al
f0107d6e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0107d71:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0107d72:	66 a1 bc fb 17 f0    	mov    0xf017fbbc,%ax
f0107d78:	66 83 f8 ff          	cmp    $0xffff,%ax
f0107d7c:	74 15                	je     f0107d93 <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0107d7e:	66 a1 bc fb 17 f0    	mov    0xf017fbbc,%ax
f0107d84:	0f b7 c0             	movzwl %ax,%eax
f0107d87:	83 ec 0c             	sub    $0xc,%esp
f0107d8a:	50                   	push   %eax
f0107d8b:	e8 06 00 00 00       	call   f0107d96 <irq_setmask_8259A>
f0107d90:	83 c4 10             	add    $0x10,%esp
}
f0107d93:	90                   	nop
f0107d94:	c9                   	leave  
f0107d95:	c3                   	ret    

f0107d96 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0107d96:	55                   	push   %ebp
f0107d97:	89 e5                	mov    %esp,%ebp
f0107d99:	83 ec 14             	sub    $0x14,%esp
f0107d9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d9f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0107da3:	a1 ec 51 81 f0       	mov    0xf08151ec,%eax
f0107da8:	85 c0                	test   %eax,%eax
f0107daa:	74 34                	je     f0107de0 <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0107dac:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107daf:	0f b6 c0             	movzbl %al,%eax
f0107db2:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0107db9:	88 45 f6             	mov    %al,-0xa(%ebp)
f0107dbc:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107dbf:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107dc2:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0107dc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107dc6:	66 c1 e8 08          	shr    $0x8,%ax
f0107dca:	0f b6 c0             	movzbl %al,%eax
f0107dcd:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0107dd4:	88 45 f7             	mov    %al,-0x9(%ebp)
f0107dd7:	8a 45 f7             	mov    -0x9(%ebp),%al
f0107dda:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0107ddd:	ee                   	out    %al,(%dx)
f0107dde:	eb 01                	jmp    f0107de1 <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0107de0:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0107de1:	c9                   	leave  
f0107de2:	c3                   	ret    

f0107de3 <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0107de3:	55                   	push   %ebp
f0107de4:	89 e5                	mov    %esp,%ebp
f0107de6:	53                   	push   %ebx
f0107de7:	83 ec 14             	sub    $0x14,%esp
f0107dea:	8b 45 08             	mov    0x8(%ebp),%eax
f0107ded:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107df0:	a1 ec 51 81 f0       	mov    0xf08151ec,%eax
f0107df5:	85 c0                	test   %eax,%eax
f0107df7:	74 58                	je     f0107e51 <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107df9:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107dfd:	77 08                	ja     f0107e07 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0107dff:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107e05:	eb 0a                	jmp    f0107e11 <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107e07:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107e0d:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0107e11:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107e15:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107e18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e1b:	89 c2                	mov    %eax,%edx
f0107e1d:	ec                   	in     (%dx),%al
f0107e1e:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107e21:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107e24:	88 c2                	mov    %al,%dl
f0107e26:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107e2a:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107e2f:	88 c1                	mov    %al,%cl
f0107e31:	d3 e3                	shl    %cl,%ebx
f0107e33:	89 d8                	mov    %ebx,%eax
f0107e35:	09 d0                	or     %edx,%eax
f0107e37:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107e3a:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107e3e:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107e42:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107e45:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107e48:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107e4b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107e4e:	ee                   	out    %al,(%dx)
f0107e4f:	eb 01                	jmp    f0107e52 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107e51:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0107e52:	83 c4 14             	add    $0x14,%esp
f0107e55:	5b                   	pop    %ebx
f0107e56:	5d                   	pop    %ebp
f0107e57:	c3                   	ret    

f0107e58 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0107e58:	55                   	push   %ebp
f0107e59:	89 e5                	mov    %esp,%ebp
f0107e5b:	53                   	push   %ebx
f0107e5c:	83 ec 14             	sub    $0x14,%esp
f0107e5f:	8b 45 08             	mov    0x8(%ebp),%eax
f0107e62:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107e65:	a1 ec 51 81 f0       	mov    0xf08151ec,%eax
f0107e6a:	85 c0                	test   %eax,%eax
f0107e6c:	74 5a                	je     f0107ec8 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107e6e:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107e72:	77 08                	ja     f0107e7c <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0107e74:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107e7a:	eb 0a                	jmp    f0107e86 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107e7c:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107e82:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0107e86:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e90:	89 c2                	mov    %eax,%edx
f0107e92:	ec                   	in     (%dx),%al
f0107e93:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107e96:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107e99:	88 c2                	mov    %al,%dl
f0107e9b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107e9f:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107ea4:	88 c1                	mov    %al,%cl
f0107ea6:	d3 e3                	shl    %cl,%ebx
f0107ea8:	89 d8                	mov    %ebx,%eax
f0107eaa:	f7 d0                	not    %eax
f0107eac:	21 d0                	and    %edx,%eax
f0107eae:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107eb1:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107eb5:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107eb9:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107ebc:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107ebf:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107ec2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107ec5:	ee                   	out    %al,(%dx)
f0107ec6:	eb 01                	jmp    f0107ec9 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107ec8:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107ec9:	83 c4 14             	add    $0x14,%esp
f0107ecc:	5b                   	pop    %ebx
f0107ecd:	5d                   	pop    %ebp
f0107ece:	c3                   	ret    

f0107ecf <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f0107ecf:	55                   	push   %ebp
f0107ed0:	89 e5                	mov    %esp,%ebp
f0107ed2:	53                   	push   %ebx
f0107ed3:	83 ec 14             	sub    $0x14,%esp
f0107ed6:	8b 45 08             	mov    0x8(%ebp),%eax
f0107ed9:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107edc:	a1 ec 51 81 f0       	mov    0xf08151ec,%eax
f0107ee1:	85 c0                	test   %eax,%eax
f0107ee3:	75 07                	jne    f0107eec <irq_get_mask+0x1d>
		return -1;
f0107ee5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107eea:	eb 45                	jmp    f0107f31 <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107eec:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107ef0:	77 08                	ja     f0107efa <irq_get_mask+0x2b>
		port = PIC1_DATA;
f0107ef2:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107ef8:	eb 0a                	jmp    f0107f04 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0107efa:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107f00:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f0107f04:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107f08:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107f0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107f0e:	89 c2                	mov    %eax,%edx
f0107f10:	ec                   	in     (%dx),%al
f0107f11:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f0107f14:	8a 45 f3             	mov    -0xd(%ebp),%al
f0107f17:	88 c2                	mov    %al,%dl
f0107f19:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107f1d:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107f22:	88 c1                	mov    %al,%cl
f0107f24:	d3 e3                	shl    %cl,%ebx
f0107f26:	89 d8                	mov    %ebx,%eax
f0107f28:	21 d0                	and    %edx,%eax
f0107f2a:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f0107f2d:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f0107f31:	83 c4 14             	add    $0x14,%esp
f0107f34:	5b                   	pop    %ebx
f0107f35:	5d                   	pop    %ebp
f0107f36:	c3                   	ret    

f0107f37 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f0107f37:	55                   	push   %ebp
f0107f38:	89 e5                	mov    %esp,%ebp
f0107f3a:	83 ec 14             	sub    $0x14,%esp
f0107f3d:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f40:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f0107f43:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f0107f47:	76 12                	jbe    f0107f5b <pic_sendEOI+0x24>
f0107f49:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f0107f50:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107f54:	8a 45 f7             	mov    -0x9(%ebp),%al
f0107f57:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0107f5a:	ee                   	out    %al,(%dx)
f0107f5b:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f0107f62:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0107f66:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107f69:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107f6c:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107f6d:	90                   	nop
f0107f6e:	c9                   	leave  
f0107f6f:	c3                   	ret    

f0107f70 <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f0107f70:	55                   	push   %ebp
f0107f71:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f0107f73:	b8 60 df 83 f0       	mov    $0xf083df60,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0107f78:	5d                   	pop    %ebp
f0107f79:	c3                   	ret    

f0107f7a <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107f7a:	55                   	push   %ebp
f0107f7b:	89 e5                	mov    %esp,%ebp
f0107f7d:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f0107f80:	e8 eb ff ff ff       	call   f0107f70 <mycpu>
f0107f85:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0107f88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107f8b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0107f92:	00 00 00 
  c->ncli = 0;
f0107f95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107f98:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0107f9f:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107fa2:	9c                   	pushf  
f0107fa3:	58                   	pop    %eax
f0107fa4:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107fa7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107faa:	25 00 02 00 00       	and    $0x200,%eax
f0107faf:	85 c0                	test   %eax,%eax
f0107fb1:	0f 95 c0             	setne  %al
f0107fb4:	0f b6 d0             	movzbl %al,%edx
f0107fb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107fba:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f0107fc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107fc3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107fca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107fcd:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107fd4:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107fd7:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fda:	40                   	inc    %eax
f0107fdb:	c1 e0 0f             	shl    $0xf,%eax
f0107fde:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0107fe3:	29 c2                	sub    %eax,%edx
f0107fe5:	89 d0                	mov    %edx,%eax
f0107fe7:	89 c2                	mov    %eax,%edx
f0107fe9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107fec:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f0107fef:	e8 18 01 00 00       	call   f010810c <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107ff4:	e8 01 50 00 00       	call   f010cffa <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0107ff9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ffc:	83 c0 0c             	add    $0xc,%eax
f0107fff:	83 ec 04             	sub    $0x4,%esp
f0108002:	6a 68                	push   $0x68
f0108004:	6a 00                	push   $0x0
f0108006:	50                   	push   %eax
f0108007:	e8 5f 2c 01 00       	call   f011ac6b <memset>
f010800c:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f010800f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108012:	05 a4 00 00 00       	add    $0xa4,%eax
f0108017:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010801a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f0108021:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108024:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108027:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010802a:	f0 87 02             	lock xchg %eax,(%edx)
f010802d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f0108030:	90                   	nop
f0108031:	c9                   	leave  
f0108032:	c3                   	ret    

f0108033 <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f0108033:	55                   	push   %ebp
f0108034:	89 e5                	mov    %esp,%ebp
f0108036:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0108039:	9c                   	pushf  
f010803a:	58                   	pop    %eax
f010803b:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f010803e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f0108041:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0108044:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f0108045:	e8 26 ff ff ff       	call   f0107f70 <mycpu>
f010804a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f010804d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108050:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0108056:	85 c0                	test   %eax,%eax
f0108058:	75 13                	jne    f010806d <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f010805a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010805d:	25 00 02 00 00       	and    $0x200,%eax
f0108062:	89 c2                	mov    %eax,%edx
f0108064:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108067:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f010806d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108070:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0108076:	8d 50 01             	lea    0x1(%eax),%edx
f0108079:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010807c:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f0108082:	90                   	nop
f0108083:	c9                   	leave  
f0108084:	c3                   	ret    

f0108085 <popcli>:

void popcli(void)
{
f0108085:	55                   	push   %ebp
f0108086:	89 e5                	mov    %esp,%ebp
f0108088:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010808b:	9c                   	pushf  
f010808c:	58                   	pop    %eax
f010808d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0108090:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f0108093:	25 00 02 00 00       	and    $0x200,%eax
f0108098:	85 c0                	test   %eax,%eax
f010809a:	74 14                	je     f01080b0 <popcli+0x2b>
    panic("popcli - interruptible");
f010809c:	83 ec 04             	sub    $0x4,%esp
f010809f:	68 d6 e7 12 f0       	push   $0xf012e7d6
f01080a4:	6a 5e                	push   $0x5e
f01080a6:	68 ed e7 12 f0       	push   $0xf012e7ed
f01080ab:	e8 ff 8d ff ff       	call   f0100eaf <_panic>
  struct cpu* c = mycpu();
f01080b0:	e8 bb fe ff ff       	call   f0107f70 <mycpu>
f01080b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f01080b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080bb:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01080c1:	8d 50 ff             	lea    -0x1(%eax),%edx
f01080c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080c7:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f01080cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080d0:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01080d6:	85 c0                	test   %eax,%eax
f01080d8:	79 14                	jns    f01080ee <popcli+0x69>
    panic("popcli");
f01080da:	83 ec 04             	sub    $0x4,%esp
f01080dd:	68 fc e7 12 f0       	push   $0xf012e7fc
f01080e2:	6a 61                	push   $0x61
f01080e4:	68 ed e7 12 f0       	push   $0xf012e7ed
f01080e9:	e8 c1 8d ff ff       	call   f0100eaf <_panic>
  if(c->ncli == 0 && c->intena)
f01080ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080f1:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01080f7:	85 c0                	test   %eax,%eax
f01080f9:	75 0e                	jne    f0108109 <popcli+0x84>
f01080fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080fe:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0108104:	85 c0                	test   %eax,%eax
f0108106:	74 01                	je     f0108109 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0108108:	fb                   	sti    
    sti();
}
f0108109:	90                   	nop
f010810a:	c9                   	leave  
f010810b:	c3                   	ret    

f010810c <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f010810c:	55                   	push   %ebp
f010810d:	89 e5                	mov    %esp,%ebp
f010810f:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f0108112:	e8 1c ff ff ff       	call   f0108033 <pushcli>

	c = mycpu();
f0108117:	e8 54 fe ff ff       	call   f0107f70 <mycpu>
f010811c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f010811f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108122:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f0108129:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f0108130:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108133:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f0108139:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010813c:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f0108142:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108145:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f010814c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010814f:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0108155:	83 e2 f0             	and    $0xfffffff0,%edx
f0108158:	83 ca 0a             	or     $0xa,%edx
f010815b:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108161:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108164:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010816a:	83 ca 10             	or     $0x10,%edx
f010816d:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108173:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108176:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010817c:	83 e2 9f             	and    $0xffffff9f,%edx
f010817f:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108188:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010818e:	83 ca 80             	or     $0xffffff80,%edx
f0108191:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108197:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010819a:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01081a0:	83 ca 0f             	or     $0xf,%edx
f01081a3:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01081a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081ac:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01081b2:	83 e2 ef             	and    $0xffffffef,%edx
f01081b5:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01081bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081be:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01081c4:	83 e2 df             	and    $0xffffffdf,%edx
f01081c7:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01081cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081d0:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01081d6:	83 ca 40             	or     $0x40,%edx
f01081d9:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01081df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081e2:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01081e8:	83 ca 80             	or     $0xffffff80,%edx
f01081eb:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01081f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081f4:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f01081fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081fe:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f0108205:	ff ff 
f0108207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010820a:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f0108211:	00 00 
f0108213:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108216:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f010821d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108220:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0108226:	83 e2 f0             	and    $0xfffffff0,%edx
f0108229:	83 ca 02             	or     $0x2,%edx
f010822c:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0108232:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108235:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010823b:	83 ca 10             	or     $0x10,%edx
f010823e:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0108244:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108247:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010824d:	83 e2 9f             	and    $0xffffff9f,%edx
f0108250:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0108256:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108259:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010825f:	83 ca 80             	or     $0xffffff80,%edx
f0108262:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0108268:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010826b:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0108271:	83 ca 0f             	or     $0xf,%edx
f0108274:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010827a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010827d:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0108283:	83 e2 ef             	and    $0xffffffef,%edx
f0108286:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010828c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010828f:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0108295:	83 e2 df             	and    $0xffffffdf,%edx
f0108298:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010829e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082a1:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01082a7:	83 ca 40             	or     $0x40,%edx
f01082aa:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01082b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082b3:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01082b9:	83 ca 80             	or     $0xffffff80,%edx
f01082bc:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01082c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082c5:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f01082cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082cf:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f01082d6:	ff ff 
f01082d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082db:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f01082e2:	00 00 
f01082e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082e7:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f01082ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082f1:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01082f7:	83 e2 f0             	and    $0xfffffff0,%edx
f01082fa:	83 ca 0a             	or     $0xa,%edx
f01082fd:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108303:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108306:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010830c:	83 ca 10             	or     $0x10,%edx
f010830f:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108315:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108318:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010831e:	83 ca 60             	or     $0x60,%edx
f0108321:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108327:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010832a:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0108330:	83 ca 80             	or     $0xffffff80,%edx
f0108333:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108339:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010833c:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108342:	83 ca 0f             	or     $0xf,%edx
f0108345:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010834b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010834e:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108354:	83 e2 ef             	and    $0xffffffef,%edx
f0108357:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010835d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108360:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108366:	83 e2 df             	and    $0xffffffdf,%edx
f0108369:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010836f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108372:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108378:	83 ca 40             	or     $0x40,%edx
f010837b:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0108381:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108384:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010838a:	83 ca 80             	or     $0xffffff80,%edx
f010838d:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0108393:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108396:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f010839d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083a0:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f01083a7:	ff ff 
f01083a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083ac:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f01083b3:	00 00 
f01083b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083b8:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f01083bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083c2:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01083c8:	83 e2 f0             	and    $0xfffffff0,%edx
f01083cb:	83 ca 02             	or     $0x2,%edx
f01083ce:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01083d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083d7:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01083dd:	83 ca 10             	or     $0x10,%edx
f01083e0:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01083e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083e9:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01083ef:	83 ca 60             	or     $0x60,%edx
f01083f2:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01083f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083fb:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0108401:	83 ca 80             	or     $0xffffff80,%edx
f0108404:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f010840a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010840d:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108413:	83 ca 0f             	or     $0xf,%edx
f0108416:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010841c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010841f:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108425:	83 e2 ef             	and    $0xffffffef,%edx
f0108428:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010842e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108431:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108437:	83 e2 df             	and    $0xffffffdf,%edx
f010843a:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0108440:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108443:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108449:	83 ca 40             	or     $0x40,%edx
f010844c:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0108452:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108455:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f010845b:	83 ca 80             	or     $0xffffff80,%edx
f010845e:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0108464:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108467:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f010846e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108471:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0108478:	00 00 00 
f010847b:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f0108482:	00 00 00 

	popcli();	//enable interrupt
f0108485:	e8 fb fb ff ff       	call   f0108085 <popcli>


}
f010848a:	90                   	nop
f010848b:	c9                   	leave  
f010848c:	c3                   	ret    

f010848d <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f010848d:	55                   	push   %ebp
f010848e:	89 e5                	mov    %esp,%ebp
f0108490:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f0108493:	83 ec 08             	sub    $0x8,%esp
f0108496:	68 00 10 00 00       	push   $0x1000
f010849b:	68 00 10 00 00       	push   $0x1000
f01084a0:	e8 43 02 00 00       	call   f01086e8 <boot_allocate_space>
f01084a5:	83 c4 10             	add    $0x10,%esp
f01084a8:	a3 38 63 85 f0       	mov    %eax,0xf0856338
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f01084ad:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01084b2:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01084b5:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f01084bc:	77 14                	ja     f01084d2 <initialize_kernel_VM+0x45>
f01084be:	ff 75 e0             	pushl  -0x20(%ebp)
f01084c1:	68 04 e8 12 f0       	push   $0xf012e804
f01084c6:	6a 57                	push   $0x57
f01084c8:	68 38 e8 12 f0       	push   $0xf012e838
f01084cd:	e8 dd 89 ff ff       	call   f0100eaf <_panic>
f01084d2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01084d5:	05 00 00 00 10       	add    $0x10000000,%eax
f01084da:	a3 40 64 85 f0       	mov    %eax,0xf0856440
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f01084df:	c7 45 dc 00 70 17 f0 	movl   $0xf0177000,-0x24(%ebp)
f01084e6:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f01084ed:	77 14                	ja     f0108503 <initialize_kernel_VM+0x76>
f01084ef:	ff 75 dc             	pushl  -0x24(%ebp)
f01084f2:	68 04 e8 12 f0       	push   $0xf012e804
f01084f7:	6a 63                	push   $0x63
f01084f9:	68 38 e8 12 f0       	push   $0xf012e838
f01084fe:	e8 ac 89 ff ff       	call   f0100eaf <_panic>
f0108503:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108506:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f010850c:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0108511:	83 ec 0c             	sub    $0xc,%esp
f0108514:	6a 02                	push   $0x2
f0108516:	52                   	push   %edx
f0108517:	68 00 80 00 00       	push   $0x8000
f010851c:	68 00 80 bf ef       	push   $0xefbf8000
f0108521:	50                   	push   %eax
f0108522:	e8 35 02 00 00       	call   f010875c <boot_map_range>
f0108527:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f010852a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108531:	eb 24                	jmp    f0108557 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f0108533:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108536:	40                   	inc    %eax
f0108537:	c1 e0 0f             	shl    $0xf,%eax
f010853a:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f010853f:	29 c2                	sub    %eax,%edx
f0108541:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0108546:	6a 01                	push   $0x1
f0108548:	6a 00                	push   $0x0
f010854a:	52                   	push   %edx
f010854b:	50                   	push   %eax
f010854c:	e8 b1 16 00 00       	call   f0109c02 <pt_set_page_permissions>
f0108551:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0108554:	ff 45 f4             	incl   -0xc(%ebp)
f0108557:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010855b:	7e d6                	jle    f0108533 <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f010855d:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0108564:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f010856b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0108572:	eb 25                	jmp    f0108599 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0108574:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0108577:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010857a:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f010857f:	83 ec 04             	sub    $0x4,%esp
f0108582:	6a 01                	push   $0x1
f0108584:	52                   	push   %edx
f0108585:	50                   	push   %eax
f0108586:	e8 45 02 00 00       	call   f01087d0 <boot_get_page_table>
f010858b:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010858e:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0108595:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0108599:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010859d:	72 d5                	jb     f0108574 <initialize_kernel_VM+0xe7>
f010859f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01085a3:	77 06                	ja     f01085ab <initialize_kernel_VM+0x11e>
f01085a5:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f01085a9:	76 c9                	jbe    f0108574 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f01085ab:	8b 15 18 e0 83 f0    	mov    0xf083e018,%edx
f01085b1:	89 d0                	mov    %edx,%eax
f01085b3:	c1 e0 02             	shl    $0x2,%eax
f01085b6:	01 d0                	add    %edx,%eax
f01085b8:	c1 e0 02             	shl    $0x2,%eax
f01085bb:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f01085be:	83 ec 08             	sub    $0x8,%esp
f01085c1:	68 00 10 00 00       	push   $0x1000
f01085c6:	ff 75 d8             	pushl  -0x28(%ebp)
f01085c9:	e8 1a 01 00 00       	call   f01086e8 <boot_allocate_space>
f01085ce:	83 c4 10             	add    $0x10,%esp
f01085d1:	a3 68 61 85 f0       	mov    %eax,0xf0856168
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f01085d6:	c7 45 d4 00 a0 28 00 	movl   $0x28a000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f01085dd:	83 ec 08             	sub    $0x8,%esp
f01085e0:	68 00 10 00 00       	push   $0x1000
f01085e5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01085e8:	e8 fb 00 00 00       	call   f01086e8 <boot_allocate_space>
f01085ed:	83 c4 10             	add    $0x10,%esp
f01085f0:	a3 a4 db 83 f0       	mov    %eax,0xf083dba4
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f01085f5:	e8 05 05 00 00       	call   f0108aff <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f01085fa:	83 ec 0c             	sub    $0xc,%esp
f01085fd:	68 c6 02 00 00       	push   $0x2c6
f0108602:	e8 16 05 01 00       	call   f0118b1d <nearest_pow2_ceil>
f0108607:	83 c4 10             	add    $0x10,%esp
f010860a:	83 ec 04             	sub    $0x4,%esp
f010860d:	50                   	push   %eax
f010860e:	68 c6 02 00 00       	push   $0x2c6
f0108613:	68 58 e8 12 f0       	push   $0xf012e858
f0108618:	e8 3f 95 ff ff       	call   f0101b5c <cprintf>
f010861d:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f0108620:	c7 45 d0 98 fd 0f 00 	movl   $0xffd98,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0108627:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010862a:	83 ec 08             	sub    $0x8,%esp
f010862d:	68 00 10 00 00       	push   $0x1000
f0108632:	50                   	push   %eax
f0108633:	e8 b0 00 00 00       	call   f01086e8 <boot_allocate_space>
f0108638:	83 c4 10             	add    $0x10,%esp
f010863b:	a3 f0 51 81 f0       	mov    %eax,0xf08151f0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f0108640:	a1 f0 51 81 f0       	mov    0xf08151f0,%eax
f0108645:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0108648:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f010864f:	77 17                	ja     f0108668 <initialize_kernel_VM+0x1db>
f0108651:	ff 75 cc             	pushl  -0x34(%ebp)
f0108654:	68 04 e8 12 f0       	push   $0xf012e804
f0108659:	68 b1 00 00 00       	push   $0xb1
f010865e:	68 38 e8 12 f0       	push   $0xf012e838
f0108663:	e8 47 88 ff ff       	call   f0100eaf <_panic>
f0108668:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010866b:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f0108671:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0108674:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0108679:	83 ec 0c             	sub    $0xc,%esp
f010867c:	6a 04                	push   $0x4
f010867e:	51                   	push   %ecx
f010867f:	52                   	push   %edx
f0108680:	68 00 00 c0 ee       	push   $0xeec00000
f0108685:	50                   	push   %eax
f0108686:	e8 d1 00 00 00       	call   f010875c <boot_map_range>
f010868b:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f010868e:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0108693:	05 ec 0e 00 00       	add    $0xeec,%eax
f0108698:	8b 15 38 63 85 f0    	mov    0xf0856338,%edx
f010869e:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f01086a4:	8b 12                	mov    (%edx),%edx
f01086a6:	83 ca 05             	or     $0x5,%edx
f01086a9:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f01086ab:	a1 30 63 85 f0       	mov    0xf0856330,%eax
f01086b0:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01086b6:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01086bb:	83 ec 0c             	sub    $0xc,%esp
f01086be:	6a 02                	push   $0x2
f01086c0:	6a 00                	push   $0x0
f01086c2:	52                   	push   %edx
f01086c3:	68 00 00 00 f0       	push   $0xf0000000
f01086c8:	50                   	push   %eax
f01086c9:	e8 8e 00 00 00       	call   f010875c <boot_map_range>
f01086ce:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f01086d1:	e8 30 18 01 00       	call   f0119f06 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f01086d6:	c7 05 50 df 83 f0 19 	movl   $0x19,0xf083df50
f01086dd:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f01086e0:	e8 e6 02 00 00       	call   f01089cb <turn_on_paging>
}
f01086e5:	90                   	nop
f01086e6:	c9                   	leave  
f01086e7:	c3                   	ret    

f01086e8 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f01086e8:	55                   	push   %ebp
f01086e9:	89 e5                	mov    %esp,%ebp
f01086eb:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f01086ee:	a1 30 63 85 f0       	mov    0xf0856330,%eax
f01086f3:	85 c0                	test   %eax,%eax
f01086f5:	75 0a                	jne    f0108701 <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f01086f7:	c7 05 30 63 85 f0 30 	movl   $0xf087cd30,0xf0856330
f01086fe:	cd 87 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f0108701:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108704:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108707:	a1 30 63 85 f0       	mov    0xf0856330,%eax
f010870c:	89 c2                	mov    %eax,%edx
f010870e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108711:	01 d0                	add    %edx,%eax
f0108713:	48                   	dec    %eax
f0108714:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108717:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010871a:	ba 00 00 00 00       	mov    $0x0,%edx
f010871f:	f7 75 f4             	divl   -0xc(%ebp)
f0108722:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108725:	29 d0                	sub    %edx,%eax
f0108727:	a3 30 63 85 f0       	mov    %eax,0xf0856330

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f010872c:	a1 30 63 85 f0       	mov    0xf0856330,%eax
f0108731:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f0108734:	8b 15 30 63 85 f0    	mov    0xf0856330,%edx
f010873a:	8b 45 08             	mov    0x8(%ebp),%eax
f010873d:	01 d0                	add    %edx,%eax
f010873f:	a3 30 63 85 f0       	mov    %eax,0xf0856330

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f0108744:	83 ec 04             	sub    $0x4,%esp
f0108747:	ff 75 08             	pushl  0x8(%ebp)
f010874a:	6a 00                	push   $0x0
f010874c:	ff 75 ec             	pushl  -0x14(%ebp)
f010874f:	e8 17 25 01 00       	call   f011ac6b <memset>
f0108754:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f0108757:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f010875a:	c9                   	leave  
f010875b:	c3                   	ret    

f010875c <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f010875c:	55                   	push   %ebp
f010875d:	89 e5                	mov    %esp,%ebp
f010875f:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f0108762:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0108769:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108770:	eb 53                	jmp    f01087c5 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f0108772:	83 ec 04             	sub    $0x4,%esp
f0108775:	6a 01                	push   $0x1
f0108777:	ff 75 0c             	pushl  0xc(%ebp)
f010877a:	ff 75 08             	pushl  0x8(%ebp)
f010877d:	e8 4e 00 00 00       	call   f01087d0 <boot_get_page_table>
f0108782:	83 c4 10             	add    $0x10,%esp
f0108785:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0108788:	8b 45 0c             	mov    0xc(%ebp),%eax
f010878b:	c1 e8 0c             	shr    $0xc,%eax
f010878e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108793:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0108796:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108799:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01087a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01087a3:	01 c2                	add    %eax,%edx
f01087a5:	8b 45 18             	mov    0x18(%ebp),%eax
f01087a8:	0b 45 14             	or     0x14(%ebp),%eax
f01087ab:	83 c8 01             	or     $0x1,%eax
f01087ae:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f01087b0:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f01087b7:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f01087be:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f01087c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087c8:	3b 45 10             	cmp    0x10(%ebp),%eax
f01087cb:	72 a5                	jb     f0108772 <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f01087cd:	90                   	nop
f01087ce:	c9                   	leave  
f01087cf:	c3                   	ret    

f01087d0 <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f01087d0:	55                   	push   %ebp
f01087d1:	89 e5                	mov    %esp,%ebp
f01087d3:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f01087d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01087d9:	c1 e8 16             	shr    $0x16,%eax
f01087dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f01087df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087e2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01087e9:	8b 45 08             	mov    0x8(%ebp),%eax
f01087ec:	01 d0                	add    %edx,%eax
f01087ee:	8b 00                	mov    (%eax),%eax
f01087f0:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f01087f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01087f6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f01087fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108801:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108804:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108807:	c1 e8 0c             	shr    $0xc,%eax
f010880a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010880d:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f0108812:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108815:	72 17                	jb     f010882e <boot_get_page_table+0x5e>
f0108817:	ff 75 e8             	pushl  -0x18(%ebp)
f010881a:	68 80 e8 12 f0       	push   $0xf012e880
f010881f:	68 33 01 00 00       	push   $0x133
f0108824:	68 38 e8 12 f0       	push   $0xf012e838
f0108829:	e8 81 86 ff ff       	call   f0100eaf <_panic>
f010882e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108831:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108836:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f0108839:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010883d:	75 72                	jne    f01088b1 <boot_get_page_table+0xe1>
	{
		if (create)
f010883f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0108843:	74 65                	je     f01088aa <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f0108845:	83 ec 08             	sub    $0x8,%esp
f0108848:	68 00 10 00 00       	push   $0x1000
f010884d:	68 00 10 00 00       	push   $0x1000
f0108852:	e8 91 fe ff ff       	call   f01086e8 <boot_allocate_space>
f0108857:	83 c4 10             	add    $0x10,%esp
f010885a:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f010885d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108860:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108863:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f010886a:	77 17                	ja     f0108883 <boot_get_page_table+0xb3>
f010886c:	ff 75 dc             	pushl  -0x24(%ebp)
f010886f:	68 04 e8 12 f0       	push   $0xf012e804
f0108874:	68 39 01 00 00       	push   $0x139
f0108879:	68 38 e8 12 f0       	push   $0xf012e838
f010887e:	e8 2c 86 ff ff       	call   f0100eaf <_panic>
f0108883:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108886:	05 00 00 00 10       	add    $0x10000000,%eax
f010888b:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f010888e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108891:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108898:	8b 45 08             	mov    0x8(%ebp),%eax
f010889b:	01 d0                	add    %edx,%eax
f010889d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01088a0:	83 ca 03             	or     $0x3,%edx
f01088a3:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f01088a5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01088a8:	eb 0a                	jmp    f01088b4 <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f01088aa:	b8 00 00 00 00       	mov    $0x0,%eax
f01088af:	eb 03                	jmp    f01088b4 <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f01088b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f01088b4:	c9                   	leave  
f01088b5:	c3                   	ret    

f01088b6 <nvram_read>:


int nvram_read(int r)
{
f01088b6:	55                   	push   %ebp
f01088b7:	89 e5                	mov    %esp,%ebp
f01088b9:	53                   	push   %ebx
f01088ba:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f01088bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01088c0:	83 ec 0c             	sub    $0xc,%esp
f01088c3:	50                   	push   %eax
f01088c4:	e8 24 d2 ff ff       	call   f0105aed <mc146818_read>
f01088c9:	83 c4 10             	add    $0x10,%esp
f01088cc:	89 c3                	mov    %eax,%ebx
f01088ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01088d1:	40                   	inc    %eax
f01088d2:	83 ec 0c             	sub    $0xc,%esp
f01088d5:	50                   	push   %eax
f01088d6:	e8 12 d2 ff ff       	call   f0105aed <mc146818_read>
f01088db:	83 c4 10             	add    $0x10,%esp
f01088de:	c1 e0 08             	shl    $0x8,%eax
f01088e1:	09 d8                	or     %ebx,%eax
}
f01088e3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01088e6:	c9                   	leave  
f01088e7:	c3                   	ret    

f01088e8 <detect_memory>:

void detect_memory()
{
f01088e8:	55                   	push   %ebp
f01088e9:	89 e5                	mov    %esp,%ebp
f01088eb:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f01088ee:	83 ec 0c             	sub    $0xc,%esp
f01088f1:	6a 15                	push   $0x15
f01088f3:	e8 be ff ff ff       	call   f01088b6 <nvram_read>
f01088f8:	83 c4 10             	add    $0x10,%esp
f01088fb:	c1 e0 0a             	shl    $0xa,%eax
f01088fe:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108901:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108904:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108909:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f010890c:	83 ec 0c             	sub    $0xc,%esp
f010890f:	6a 17                	push   $0x17
f0108911:	e8 a0 ff ff ff       	call   f01088b6 <nvram_read>
f0108916:	83 c4 10             	add    $0x10,%esp
f0108919:	c1 e0 0a             	shl    $0xa,%eax
f010891c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010891f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108922:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108927:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f010892a:	83 ec 0c             	sub    $0xc,%esp
f010892d:	6a 34                	push   $0x34
f010892f:	e8 82 ff ff ff       	call   f01088b6 <nvram_read>
f0108934:	83 c4 10             	add    $0x10,%esp
f0108937:	c1 e0 10             	shl    $0x10,%eax
f010893a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010893d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108940:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108945:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0108948:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010894c:	74 18                	je     f0108966 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f010894e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108951:	05 00 00 00 01       	add    $0x1000000,%eax
f0108956:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0108959:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010895c:	2d 00 00 10 00       	sub    $0x100000,%eax
f0108961:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108964:	eb 19                	jmp    f010897f <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0108966:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010896a:	74 0d                	je     f0108979 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f010896c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010896f:	05 00 00 10 00       	add    $0x100000,%eax
f0108974:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108977:	eb 06                	jmp    f010897f <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0108979:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010897c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f010897f:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0108986:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108989:	c1 e8 0c             	shr    $0xc,%eax
f010898c:	a3 18 e0 83 f0       	mov    %eax,0xf083e018

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0108991:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108994:	c1 e8 0a             	shr    $0xa,%eax
f0108997:	83 ec 08             	sub    $0x8,%esp
f010899a:	50                   	push   %eax
f010899b:	68 b0 e8 12 f0       	push   $0xf012e8b0
f01089a0:	e8 b7 91 ff ff       	call   f0101b5c <cprintf>
f01089a5:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f01089a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01089ab:	c1 e8 0a             	shr    $0xa,%eax
f01089ae:	89 c2                	mov    %eax,%edx
f01089b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01089b3:	c1 e8 0a             	shr    $0xa,%eax
f01089b6:	83 ec 04             	sub    $0x4,%esp
f01089b9:	52                   	push   %edx
f01089ba:	50                   	push   %eax
f01089bb:	68 d3 e8 12 f0       	push   $0xf012e8d3
f01089c0:	e8 97 91 ff ff       	call   f0101b5c <cprintf>
f01089c5:	83 c4 10             	add    $0x10,%esp
}
f01089c8:	90                   	nop
f01089c9:	c9                   	leave  
f01089ca:	c3                   	ret    

f01089cb <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f01089cb:	55                   	push   %ebp
f01089cc:	89 e5                	mov    %esp,%ebp
f01089ce:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f01089d1:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f01089d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f01089df:	eb 24                	jmp    f0108a05 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f01089e1:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01089e6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01089e9:	c1 e2 02             	shl    $0x2,%edx
f01089ec:	01 c2                	add    %eax,%edx
f01089ee:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01089f3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01089f6:	c1 e1 02             	shl    $0x2,%ecx
f01089f9:	01 c8                	add    %ecx,%eax
f01089fb:	8b 00                	mov    (%eax),%eax
f01089fd:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f01089ff:	ff 45 f4             	incl   -0xc(%ebp)
f0108a02:	ff 45 f0             	incl   -0x10(%ebp)
f0108a05:	a1 30 63 85 f0       	mov    0xf0856330,%eax
f0108a0a:	c1 e8 16             	shr    $0x16,%eax
f0108a0d:	89 c2                	mov    %eax,%edx
f0108a0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a12:	39 c2                	cmp    %eax,%edx
f0108a14:	77 cb                	ja     f01089e1 <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0108a16:	a1 40 64 85 f0       	mov    0xf0856440,%eax
f0108a1b:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0108a1e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108a21:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0108a24:	0f 20 c0             	mov    %cr0,%eax
f0108a27:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0108a2a:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0108a2d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0108a30:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0108a37:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0108a3b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108a3e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0108a41:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0108a44:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0108a47:	e8 e7 f5 ff ff       	call   f0108033 <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0108a4c:	e8 1f f5 ff ff       	call   f0107f70 <mycpu>
f0108a51:	83 c0 74             	add    $0x74,%eax
f0108a54:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0108a57:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0108a5e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0108a61:	48                   	dec    %eax
f0108a62:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0108a66:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0108a69:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0108a6d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0108a70:	c1 e8 10             	shr    $0x10,%eax
f0108a73:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0108a77:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0108a7a:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0108a7d:	e8 03 f6 ff ff       	call   f0108085 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0108a82:	b8 23 00 00 00       	mov    $0x23,%eax
f0108a87:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0108a89:	b8 23 00 00 00       	mov    $0x23,%eax
f0108a8e:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0108a90:	b8 10 00 00 00       	mov    $0x10,%eax
f0108a95:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0108a97:	b8 10 00 00 00       	mov    $0x10,%eax
f0108a9c:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0108a9e:	b8 10 00 00 00       	mov    $0x10,%eax
f0108aa3:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0108aa5:	ea ac 8a 10 f0 08 00 	ljmp   $0x8,$0xf0108aac
	asm volatile("lldt %%ax" :: "a" (0));
f0108aac:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ab1:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0108ab4:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0108abb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108ac2:	eb 19                	jmp    f0108add <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0108ac4:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0108ac9:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108acc:	c1 e2 02             	shl    $0x2,%edx
f0108acf:	01 d0                	add    %edx,%eax
f0108ad1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108ad7:	ff 45 ec             	incl   -0x14(%ebp)
f0108ada:	ff 45 e8             	incl   -0x18(%ebp)
f0108add:	a1 30 63 85 f0       	mov    0xf0856330,%eax
f0108ae2:	c1 e8 16             	shr    $0x16,%eax
f0108ae5:	89 c2                	mov    %eax,%edx
f0108ae7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108aea:	39 c2                	cmp    %eax,%edx
f0108aec:	77 d6                	ja     f0108ac4 <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0108aee:	a1 40 64 85 f0       	mov    0xf0856440,%eax
f0108af3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0108af6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108af9:	0f 22 d8             	mov    %eax,%cr3

}
f0108afc:	90                   	nop
f0108afd:	c9                   	leave  
f0108afe:	c3                   	ret    

f0108aff <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0108aff:	55                   	push   %ebp
f0108b00:	89 e5                	mov    %esp,%ebp
f0108b02:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0108b05:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0108b0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108b0d:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0108b14:	77 17                	ja     f0108b2d <setup_listing_to_all_page_tables_entries+0x2e>
f0108b16:	ff 75 f4             	pushl  -0xc(%ebp)
f0108b19:	68 04 e8 12 f0       	push   $0xf012e804
f0108b1e:	68 cf 01 00 00       	push   $0x1cf
f0108b23:	68 38 e8 12 f0       	push   $0xf012e838
f0108b28:	e8 82 83 ff ff       	call   f0100eaf <_panic>
f0108b2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b30:	05 00 00 00 10       	add    $0x10000000,%eax
f0108b35:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0108b38:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0108b3d:	05 fc 0e 00 00       	add    $0xefc,%eax
f0108b42:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108b45:	83 ca 03             	or     $0x3,%edx
f0108b48:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0108b4a:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0108b4f:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0108b55:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0108b5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108b5d:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0108b64:	77 17                	ja     f0108b7d <setup_listing_to_all_page_tables_entries+0x7e>
f0108b66:	ff 75 ec             	pushl  -0x14(%ebp)
f0108b69:	68 04 e8 12 f0       	push   $0xf012e804
f0108b6e:	68 d4 01 00 00       	push   $0x1d4
f0108b73:	68 38 e8 12 f0       	push   $0xf012e838
f0108b78:	e8 32 83 ff ff       	call   f0100eaf <_panic>
f0108b7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b80:	05 00 00 00 10       	add    $0x10000000,%eax
f0108b85:	83 c8 05             	or     $0x5,%eax
f0108b88:	89 02                	mov    %eax,(%edx)

}
f0108b8a:	90                   	nop
f0108b8b:	c9                   	leave  
f0108b8c:	c3                   	ret    

f0108b8d <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0108b8d:	55                   	push   %ebp
f0108b8e:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0108b90:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b93:	8b 15 68 61 85 f0    	mov    0xf0856168,%edx
f0108b99:	29 d0                	sub    %edx,%eax
f0108b9b:	c1 f8 02             	sar    $0x2,%eax
f0108b9e:	89 c2                	mov    %eax,%edx
f0108ba0:	89 d0                	mov    %edx,%eax
f0108ba2:	c1 e0 02             	shl    $0x2,%eax
f0108ba5:	01 d0                	add    %edx,%eax
f0108ba7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0108bae:	01 c8                	add    %ecx,%eax
f0108bb0:	01 c0                	add    %eax,%eax
f0108bb2:	01 d0                	add    %edx,%eax
f0108bb4:	89 c1                	mov    %eax,%ecx
f0108bb6:	c1 e1 08             	shl    $0x8,%ecx
f0108bb9:	01 c8                	add    %ecx,%eax
f0108bbb:	89 c1                	mov    %eax,%ecx
f0108bbd:	c1 e1 10             	shl    $0x10,%ecx
f0108bc0:	01 c8                	add    %ecx,%eax
f0108bc2:	c1 e0 02             	shl    $0x2,%eax
f0108bc5:	01 d0                	add    %edx,%eax
}
f0108bc7:	5d                   	pop    %ebp
f0108bc8:	c3                   	ret    

f0108bc9 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0108bc9:	55                   	push   %ebp
f0108bca:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0108bcc:	ff 75 08             	pushl  0x8(%ebp)
f0108bcf:	e8 b9 ff ff ff       	call   f0108b8d <to_frame_number>
f0108bd4:	83 c4 04             	add    $0x4,%esp
f0108bd7:	c1 e0 0c             	shl    $0xc,%eax
}
f0108bda:	c9                   	leave  
f0108bdb:	c3                   	ret    

f0108bdc <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0108bdc:	55                   	push   %ebp
f0108bdd:	89 e5                	mov    %esp,%ebp
f0108bdf:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0108be2:	8b 45 08             	mov    0x8(%ebp),%eax
f0108be5:	c1 e8 0c             	shr    $0xc,%eax
f0108be8:	89 c2                	mov    %eax,%edx
f0108bea:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f0108bef:	39 c2                	cmp    %eax,%edx
f0108bf1:	72 14                	jb     f0108c07 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0108bf3:	83 ec 04             	sub    $0x4,%esp
f0108bf6:	68 f0 e8 12 f0       	push   $0xf012e8f0
f0108bfb:	6a 4e                	push   $0x4e
f0108bfd:	68 15 e9 12 f0       	push   $0xf012e915
f0108c02:	e8 a8 82 ff ff       	call   f0100eaf <_panic>
	return &frames_info[PPN(physical_address)];
f0108c07:	8b 15 68 61 85 f0    	mov    0xf0856168,%edx
f0108c0d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108c10:	c1 e8 0c             	shr    $0xc,%eax
f0108c13:	89 c1                	mov    %eax,%ecx
f0108c15:	89 c8                	mov    %ecx,%eax
f0108c17:	c1 e0 02             	shl    $0x2,%eax
f0108c1a:	01 c8                	add    %ecx,%eax
f0108c1c:	c1 e0 02             	shl    $0x2,%eax
f0108c1f:	01 d0                	add    %edx,%eax
}
f0108c21:	c9                   	leave  
f0108c22:	c3                   	ret    

f0108c23 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0108c23:	55                   	push   %ebp
f0108c24:	89 e5                	mov    %esp,%ebp
f0108c26:	83 ec 18             	sub    $0x18,%esp
	// Flush the entry only if we're modifying the current address space.
	/*2025*/ //check is added
	struct Env* e = get_cpu_proc();
f0108c29:	e8 ed 2d 00 00       	call   f010ba1b <get_cpu_proc>
f0108c2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!e || e->env_page_directory == ptr_page_directory)
f0108c31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c35:	74 0b                	je     f0108c42 <tlb_invalidate+0x1f>
f0108c37:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c3a:	8b 40 64             	mov    0x64(%eax),%eax
f0108c3d:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108c40:	75 0c                	jne    f0108c4e <tlb_invalidate+0x2b>
f0108c42:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108c45:	89 45 f0             	mov    %eax,-0x10(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0108c48:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c4b:	0f 01 38             	invlpg (%eax)
		invlpg(virtual_address);
}
f0108c4e:	90                   	nop
f0108c4f:	c9                   	leave  
f0108c50:	c3                   	ret    

f0108c51 <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0108c51:	55                   	push   %ebp
f0108c52:	89 e5                	mov    %esp,%ebp
f0108c54:	53                   	push   %ebx
f0108c55:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0108c58:	c7 05 20 de 83 f0 00 	movl   $0x0,0xf083de20
f0108c5f:	00 00 00 
f0108c62:	c7 05 24 de 83 f0 00 	movl   $0x0,0xf083de24
f0108c69:	00 00 00 
f0108c6c:	c7 05 2c de 83 f0 00 	movl   $0x0,0xf083de2c
f0108c73:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0108c76:	c7 05 30 de 83 f0 00 	movl   $0x0,0xf083de30
f0108c7d:	00 00 00 
f0108c80:	c7 05 34 de 83 f0 00 	movl   $0x0,0xf083de34
f0108c87:	00 00 00 
f0108c8a:	c7 05 3c de 83 f0 00 	movl   $0x0,0xf083de3c
f0108c91:	00 00 00 

	//Initialize the corresponding lock
	init_kspinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0108c94:	83 ec 08             	sub    $0x8,%esp
f0108c97:	68 2f e9 12 f0       	push   $0xf012e92f
f0108c9c:	68 40 de 83 f0       	push   $0xf083de40
f0108ca1:	e8 a6 70 00 00       	call   f010fd4c <init_kspinlock>
f0108ca6:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0108ca9:	a1 68 61 85 f0       	mov    0xf0856168,%eax
f0108cae:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0108cb4:	a1 68 61 85 f0       	mov    0xf0856168,%eax
f0108cb9:	83 c0 14             	add    $0x14,%eax
f0108cbc:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0108cc2:	a1 68 61 85 f0       	mov    0xf0856168,%eax
f0108cc7:	83 c0 28             	add    $0x28,%eax
f0108cca:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0108cd0:	c7 05 78 61 85 f0 00 	movl   $0xf0001000,0xf0856178
f0108cd7:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0108cda:	c7 05 c4 63 85 f0 00 	movl   $0xf0002000,0xf08563c4
f0108ce1:	20 00 f0 
	i =0;
f0108ce4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0108ceb:	eb 1f                	jmp    f0108d0c <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0108ced:	8b 15 78 61 85 f0    	mov    0xf0856178,%edx
f0108cf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108cf6:	01 d0                	add    %edx,%eax
f0108cf8:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0108cfb:	8b 15 c4 63 85 f0    	mov    0xf08563c4,%edx
f0108d01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d04:	01 d0                	add    %edx,%eax
f0108d06:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0108d09:	ff 45 f4             	incl   -0xc(%ebp)
f0108d0c:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0108d13:	7e d8                	jle    f0108ced <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0108d15:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0108d1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d1f:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0108d24:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108d27:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108d2a:	ba 00 00 00 00       	mov    $0x0,%edx
f0108d2f:	f7 75 f0             	divl   -0x10(%ebp)
f0108d32:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108d35:	29 d0                	sub    %edx,%eax
f0108d37:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0108d3a:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0108d41:	e9 ef 00 00 00       	jmp    f0108e35 <initialize_paging+0x1e4>
	{

		initialize_frame_info(&(frames_info[i]));
f0108d46:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108d4c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d4f:	89 d0                	mov    %edx,%eax
f0108d51:	c1 e0 02             	shl    $0x2,%eax
f0108d54:	01 d0                	add    %edx,%eax
f0108d56:	c1 e0 02             	shl    $0x2,%eax
f0108d59:	01 c8                	add    %ecx,%eax
f0108d5b:	83 ec 0c             	sub    $0xc,%esp
f0108d5e:	50                   	push   %eax
f0108d5f:	e8 c6 02 00 00       	call   f010902a <initialize_frame_info>
f0108d64:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0108d67:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108d6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d70:	89 d0                	mov    %edx,%eax
f0108d72:	c1 e0 02             	shl    $0x2,%eax
f0108d75:	01 d0                	add    %edx,%eax
f0108d77:	c1 e0 02             	shl    $0x2,%eax
f0108d7a:	01 c8                	add    %ecx,%eax
f0108d7c:	85 c0                	test   %eax,%eax
f0108d7e:	75 14                	jne    f0108d94 <initialize_paging+0x143>
f0108d80:	83 ec 04             	sub    $0x4,%esp
f0108d83:	68 40 e9 12 f0       	push   $0xf012e940
f0108d88:	6a 62                	push   $0x62
f0108d8a:	68 63 e9 12 f0       	push   $0xf012e963
f0108d8f:	e8 1b 81 ff ff       	call   f0100eaf <_panic>
f0108d94:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108d9a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d9d:	89 d0                	mov    %edx,%eax
f0108d9f:	c1 e0 02             	shl    $0x2,%eax
f0108da2:	01 d0                	add    %edx,%eax
f0108da4:	c1 e0 02             	shl    $0x2,%eax
f0108da7:	01 c8                	add    %ecx,%eax
f0108da9:	8b 15 20 de 83 f0    	mov    0xf083de20,%edx
f0108daf:	89 10                	mov    %edx,(%eax)
f0108db1:	8b 00                	mov    (%eax),%eax
f0108db3:	85 c0                	test   %eax,%eax
f0108db5:	74 20                	je     f0108dd7 <initialize_paging+0x186>
f0108db7:	8b 15 20 de 83 f0    	mov    0xf083de20,%edx
f0108dbd:	8b 1d 68 61 85 f0    	mov    0xf0856168,%ebx
f0108dc3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108dc6:	89 c8                	mov    %ecx,%eax
f0108dc8:	c1 e0 02             	shl    $0x2,%eax
f0108dcb:	01 c8                	add    %ecx,%eax
f0108dcd:	c1 e0 02             	shl    $0x2,%eax
f0108dd0:	01 d8                	add    %ebx,%eax
f0108dd2:	89 42 04             	mov    %eax,0x4(%edx)
f0108dd5:	eb 1a                	jmp    f0108df1 <initialize_paging+0x1a0>
f0108dd7:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108ddd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108de0:	89 d0                	mov    %edx,%eax
f0108de2:	c1 e0 02             	shl    $0x2,%eax
f0108de5:	01 d0                	add    %edx,%eax
f0108de7:	c1 e0 02             	shl    $0x2,%eax
f0108dea:	01 c8                	add    %ecx,%eax
f0108dec:	a3 24 de 83 f0       	mov    %eax,0xf083de24
f0108df1:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108df7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108dfa:	89 d0                	mov    %edx,%eax
f0108dfc:	c1 e0 02             	shl    $0x2,%eax
f0108dff:	01 d0                	add    %edx,%eax
f0108e01:	c1 e0 02             	shl    $0x2,%eax
f0108e04:	01 c8                	add    %ecx,%eax
f0108e06:	a3 20 de 83 f0       	mov    %eax,0xf083de20
f0108e0b:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108e11:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108e14:	89 d0                	mov    %edx,%eax
f0108e16:	c1 e0 02             	shl    $0x2,%eax
f0108e19:	01 d0                	add    %edx,%eax
f0108e1b:	c1 e0 02             	shl    $0x2,%eax
f0108e1e:	01 c8                	add    %ecx,%eax
f0108e20:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108e27:	a1 2c de 83 f0       	mov    0xf083de2c,%eax
f0108e2c:	40                   	inc    %eax
f0108e2d:	a3 2c de 83 f0       	mov    %eax,0xf083de2c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0108e32:	ff 45 f4             	incl   -0xc(%ebp)
f0108e35:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e38:	85 c0                	test   %eax,%eax
f0108e3a:	79 05                	jns    f0108e41 <initialize_paging+0x1f0>
f0108e3c:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108e41:	c1 f8 0c             	sar    $0xc,%eax
f0108e44:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108e47:	0f 8f f9 fe ff ff    	jg     f0108d46 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0108e4d:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0108e54:	eb 1e                	jmp    f0108e74 <initialize_paging+0x223>
	{
		frames_info[i].references = 1;
f0108e56:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108e5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108e5f:	89 d0                	mov    %edx,%eax
f0108e61:	c1 e0 02             	shl    $0x2,%eax
f0108e64:	01 d0                	add    %edx,%eax
f0108e66:	c1 e0 02             	shl    $0x2,%eax
f0108e69:	01 c8                	add    %ecx,%eax
f0108e6b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0108e71:	ff 45 f4             	incl   -0xc(%ebp)
f0108e74:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0108e7b:	7e d9                	jle    f0108e56 <initialize_paging+0x205>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0108e7d:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108e84:	a1 30 63 85 f0       	mov    0xf0856330,%eax
f0108e89:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108e8c:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108e93:	77 14                	ja     f0108ea9 <initialize_paging+0x258>
f0108e95:	ff 75 e0             	pushl  -0x20(%ebp)
f0108e98:	68 80 e9 12 f0       	push   $0xf012e980
f0108e9d:	6a 6a                	push   $0x6a
f0108e9f:	68 63 e9 12 f0       	push   $0xf012e963
f0108ea4:	e8 06 80 ff ff       	call   f0100eaf <_panic>
f0108ea9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108eac:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108eb2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108eb5:	01 d0                	add    %edx,%eax
f0108eb7:	48                   	dec    %eax
f0108eb8:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108ebb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108ebe:	ba 00 00 00 00       	mov    $0x0,%edx
f0108ec3:	f7 75 e4             	divl   -0x1c(%ebp)
f0108ec6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108ec9:	29 d0                	sub    %edx,%eax
f0108ecb:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108ece:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0108ed5:	eb 1e                	jmp    f0108ef5 <initialize_paging+0x2a4>
	{
		frames_info[i].references = 1;
f0108ed7:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108edd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108ee0:	89 d0                	mov    %edx,%eax
f0108ee2:	c1 e0 02             	shl    $0x2,%eax
f0108ee5:	01 d0                	add    %edx,%eax
f0108ee7:	c1 e0 02             	shl    $0x2,%eax
f0108eea:	01 c8                	add    %ecx,%eax
f0108eec:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108ef2:	ff 45 f4             	incl   -0xc(%ebp)
f0108ef5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ef8:	85 c0                	test   %eax,%eax
f0108efa:	79 05                	jns    f0108f01 <initialize_paging+0x2b0>
f0108efc:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108f01:	c1 f8 0c             	sar    $0xc,%eax
f0108f04:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108f07:	7f ce                	jg     f0108ed7 <initialize_paging+0x286>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108f09:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108f0c:	85 c0                	test   %eax,%eax
f0108f0e:	79 05                	jns    f0108f15 <initialize_paging+0x2c4>
f0108f10:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108f15:	c1 f8 0c             	sar    $0xc,%eax
f0108f18:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108f1b:	e9 ef 00 00 00       	jmp    f010900f <initialize_paging+0x3be>
	{
		initialize_frame_info(&(frames_info[i]));
f0108f20:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108f26:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108f29:	89 d0                	mov    %edx,%eax
f0108f2b:	c1 e0 02             	shl    $0x2,%eax
f0108f2e:	01 d0                	add    %edx,%eax
f0108f30:	c1 e0 02             	shl    $0x2,%eax
f0108f33:	01 c8                	add    %ecx,%eax
f0108f35:	83 ec 0c             	sub    $0xc,%esp
f0108f38:	50                   	push   %eax
f0108f39:	e8 ec 00 00 00       	call   f010902a <initialize_frame_info>
f0108f3e:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0108f41:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108f47:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108f4a:	89 d0                	mov    %edx,%eax
f0108f4c:	c1 e0 02             	shl    $0x2,%eax
f0108f4f:	01 d0                	add    %edx,%eax
f0108f51:	c1 e0 02             	shl    $0x2,%eax
f0108f54:	01 c8                	add    %ecx,%eax
f0108f56:	85 c0                	test   %eax,%eax
f0108f58:	75 14                	jne    f0108f6e <initialize_paging+0x31d>
f0108f5a:	83 ec 04             	sub    $0x4,%esp
f0108f5d:	68 40 e9 12 f0       	push   $0xf012e940
f0108f62:	6a 76                	push   $0x76
f0108f64:	68 63 e9 12 f0       	push   $0xf012e963
f0108f69:	e8 41 7f ff ff       	call   f0100eaf <_panic>
f0108f6e:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108f74:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108f77:	89 d0                	mov    %edx,%eax
f0108f79:	c1 e0 02             	shl    $0x2,%eax
f0108f7c:	01 d0                	add    %edx,%eax
f0108f7e:	c1 e0 02             	shl    $0x2,%eax
f0108f81:	01 c8                	add    %ecx,%eax
f0108f83:	8b 15 20 de 83 f0    	mov    0xf083de20,%edx
f0108f89:	89 10                	mov    %edx,(%eax)
f0108f8b:	8b 00                	mov    (%eax),%eax
f0108f8d:	85 c0                	test   %eax,%eax
f0108f8f:	74 20                	je     f0108fb1 <initialize_paging+0x360>
f0108f91:	8b 15 20 de 83 f0    	mov    0xf083de20,%edx
f0108f97:	8b 1d 68 61 85 f0    	mov    0xf0856168,%ebx
f0108f9d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108fa0:	89 c8                	mov    %ecx,%eax
f0108fa2:	c1 e0 02             	shl    $0x2,%eax
f0108fa5:	01 c8                	add    %ecx,%eax
f0108fa7:	c1 e0 02             	shl    $0x2,%eax
f0108faa:	01 d8                	add    %ebx,%eax
f0108fac:	89 42 04             	mov    %eax,0x4(%edx)
f0108faf:	eb 1a                	jmp    f0108fcb <initialize_paging+0x37a>
f0108fb1:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108fb7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108fba:	89 d0                	mov    %edx,%eax
f0108fbc:	c1 e0 02             	shl    $0x2,%eax
f0108fbf:	01 d0                	add    %edx,%eax
f0108fc1:	c1 e0 02             	shl    $0x2,%eax
f0108fc4:	01 c8                	add    %ecx,%eax
f0108fc6:	a3 24 de 83 f0       	mov    %eax,0xf083de24
f0108fcb:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108fd1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108fd4:	89 d0                	mov    %edx,%eax
f0108fd6:	c1 e0 02             	shl    $0x2,%eax
f0108fd9:	01 d0                	add    %edx,%eax
f0108fdb:	c1 e0 02             	shl    $0x2,%eax
f0108fde:	01 c8                	add    %ecx,%eax
f0108fe0:	a3 20 de 83 f0       	mov    %eax,0xf083de20
f0108fe5:	8b 0d 68 61 85 f0    	mov    0xf0856168,%ecx
f0108feb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108fee:	89 d0                	mov    %edx,%eax
f0108ff0:	c1 e0 02             	shl    $0x2,%eax
f0108ff3:	01 d0                	add    %edx,%eax
f0108ff5:	c1 e0 02             	shl    $0x2,%eax
f0108ff8:	01 c8                	add    %ecx,%eax
f0108ffa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0109001:	a1 2c de 83 f0       	mov    0xf083de2c,%eax
f0109006:	40                   	inc    %eax
f0109007:	a3 2c de 83 f0       	mov    %eax,0xf083de2c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010900c:	ff 45 f4             	incl   -0xc(%ebp)
f010900f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109012:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f0109017:	39 c2                	cmp    %eax,%edx
f0109019:	0f 82 01 ff ff ff    	jb     f0108f20 <initialize_paging+0x2cf>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010901f:	e8 10 bc ff ff       	call   f0104c34 <initialize_disk_page_file>
}
f0109024:	90                   	nop
f0109025:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109028:	c9                   	leave  
f0109029:	c3                   	ret    

f010902a <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f010902a:	55                   	push   %ebp
f010902b:	89 e5                	mov    %esp,%ebp
f010902d:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f0109030:	83 ec 04             	sub    $0x4,%esp
f0109033:	6a 14                	push   $0x14
f0109035:	6a 00                	push   $0x0
f0109037:	ff 75 08             	pushl  0x8(%ebp)
f010903a:	e8 2c 1c 01 00       	call   f011ac6b <memset>
f010903f:	83 c4 10             	add    $0x10,%esp
}
f0109042:	90                   	nop
f0109043:	c9                   	leave  
f0109044:	c3                   	ret    

f0109045 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f0109045:	55                   	push   %ebp
f0109046:	89 e5                	mov    %esp,%ebp
f0109048:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_kspinlock(&MemFrameLists.mfllock);
f010904b:	83 ec 0c             	sub    $0xc,%esp
f010904e:	68 40 de 83 f0       	push   $0xf083de40
f0109053:	e8 7a 6f 00 00       	call   f010ffd2 <holding_kspinlock>
f0109058:	83 c4 10             	add    $0x10,%esp
f010905b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010905e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109062:	75 10                	jne    f0109074 <allocate_frame+0x2f>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f0109064:	83 ec 0c             	sub    $0xc,%esp
f0109067:	68 40 de 83 f0       	push   $0xf083de40
f010906c:	e8 0c 6d 00 00       	call   f010fd7d <acquire_kspinlock>
f0109071:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f0109074:	8b 15 20 de 83 f0    	mov    0xf083de20,%edx
f010907a:	8b 45 08             	mov    0x8(%ebp),%eax
f010907d:	89 10                	mov    %edx,(%eax)
	int c = 0;
f010907f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (*ptr_frame_info == NULL)
f0109086:	8b 45 08             	mov    0x8(%ebp),%eax
f0109089:	8b 00                	mov    (%eax),%eax
f010908b:	85 c0                	test   %eax,%eax
f010908d:	75 17                	jne    f01090a6 <allocate_frame+0x61>
	{
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f010908f:	83 ec 04             	sub    $0x4,%esp
f0109092:	68 b4 e9 12 f0       	push   $0xf012e9b4
f0109097:	68 a2 00 00 00       	push   $0xa2
f010909c:	68 63 e9 12 f0       	push   $0xf012e963
f01090a1:	e8 09 7e ff ff       	call   f0100eaf <_panic>
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f01090a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01090a9:	8b 00                	mov    (%eax),%eax
f01090ab:	85 c0                	test   %eax,%eax
f01090ad:	75 17                	jne    f01090c6 <allocate_frame+0x81>
f01090af:	83 ec 04             	sub    $0x4,%esp
f01090b2:	68 01 ea 12 f0       	push   $0xf012ea01
f01090b7:	68 a5 00 00 00       	push   $0xa5
f01090bc:	68 63 e9 12 f0       	push   $0xf012e963
f01090c1:	e8 e9 7d ff ff       	call   f0100eaf <_panic>
f01090c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01090c9:	8b 00                	mov    (%eax),%eax
f01090cb:	8b 00                	mov    (%eax),%eax
f01090cd:	85 c0                	test   %eax,%eax
f01090cf:	74 14                	je     f01090e5 <allocate_frame+0xa0>
f01090d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01090d4:	8b 00                	mov    (%eax),%eax
f01090d6:	8b 00                	mov    (%eax),%eax
f01090d8:	8b 55 08             	mov    0x8(%ebp),%edx
f01090db:	8b 12                	mov    (%edx),%edx
f01090dd:	8b 52 04             	mov    0x4(%edx),%edx
f01090e0:	89 50 04             	mov    %edx,0x4(%eax)
f01090e3:	eb 0d                	jmp    f01090f2 <allocate_frame+0xad>
f01090e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01090e8:	8b 00                	mov    (%eax),%eax
f01090ea:	8b 40 04             	mov    0x4(%eax),%eax
f01090ed:	a3 24 de 83 f0       	mov    %eax,0xf083de24
f01090f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01090f5:	8b 00                	mov    (%eax),%eax
f01090f7:	8b 40 04             	mov    0x4(%eax),%eax
f01090fa:	85 c0                	test   %eax,%eax
f01090fc:	74 13                	je     f0109111 <allocate_frame+0xcc>
f01090fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0109101:	8b 00                	mov    (%eax),%eax
f0109103:	8b 40 04             	mov    0x4(%eax),%eax
f0109106:	8b 55 08             	mov    0x8(%ebp),%edx
f0109109:	8b 12                	mov    (%edx),%edx
f010910b:	8b 12                	mov    (%edx),%edx
f010910d:	89 10                	mov    %edx,(%eax)
f010910f:	eb 0c                	jmp    f010911d <allocate_frame+0xd8>
f0109111:	8b 45 08             	mov    0x8(%ebp),%eax
f0109114:	8b 00                	mov    (%eax),%eax
f0109116:	8b 00                	mov    (%eax),%eax
f0109118:	a3 20 de 83 f0       	mov    %eax,0xf083de20
f010911d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109120:	8b 00                	mov    (%eax),%eax
f0109122:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109128:	8b 45 08             	mov    0x8(%ebp),%eax
f010912b:	8b 00                	mov    (%eax),%eax
f010912d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0109134:	a1 2c de 83 f0       	mov    0xf083de2c,%eax
f0109139:	48                   	dec    %eax
f010913a:	a3 2c de 83 f0       	mov    %eax,0xf083de2c
	}

	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f010913f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109142:	8b 00                	mov    (%eax),%eax
f0109144:	83 ec 0c             	sub    $0xc,%esp
f0109147:	50                   	push   %eax
f0109148:	e8 dd fe ff ff       	call   f010902a <initialize_frame_info>
f010914d:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f0109150:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109154:	75 10                	jne    f0109166 <allocate_frame+0x121>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f0109156:	83 ec 0c             	sub    $0xc,%esp
f0109159:	68 40 de 83 f0       	push   $0xf083de40
f010915e:	e8 bf 6c 00 00       	call   f010fe22 <release_kspinlock>
f0109163:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f0109166:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010916b:	c9                   	leave  
f010916c:	c3                   	ret    

f010916d <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f010916d:	55                   	push   %ebp
f010916e:	89 e5                	mov    %esp,%ebp
f0109170:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_kspinlock(&MemFrameLists.mfllock);
f0109173:	83 ec 0c             	sub    $0xc,%esp
f0109176:	68 40 de 83 f0       	push   $0xf083de40
f010917b:	e8 52 6e 00 00       	call   f010ffd2 <holding_kspinlock>
f0109180:	83 c4 10             	add    $0x10,%esp
f0109183:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f0109186:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010918a:	75 10                	jne    f010919c <free_frame+0x2f>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f010918c:	83 ec 0c             	sub    $0xc,%esp
f010918f:	68 40 de 83 f0       	push   $0xf083de40
f0109194:	e8 e4 6b 00 00       	call   f010fd7d <acquire_kspinlock>
f0109199:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f010919c:	83 ec 0c             	sub    $0xc,%esp
f010919f:	ff 75 08             	pushl  0x8(%ebp)
f01091a2:	e8 83 fe ff ff       	call   f010902a <initialize_frame_info>
f01091a7:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f01091aa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01091ae:	75 17                	jne    f01091c7 <free_frame+0x5a>
f01091b0:	83 ec 04             	sub    $0x4,%esp
f01091b3:	68 40 e9 12 f0       	push   $0xf012e940
f01091b8:	68 ce 00 00 00       	push   $0xce
f01091bd:	68 63 e9 12 f0       	push   $0xf012e963
f01091c2:	e8 e8 7c ff ff       	call   f0100eaf <_panic>
f01091c7:	8b 15 20 de 83 f0    	mov    0xf083de20,%edx
f01091cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01091d0:	89 10                	mov    %edx,(%eax)
f01091d2:	8b 45 08             	mov    0x8(%ebp),%eax
f01091d5:	8b 00                	mov    (%eax),%eax
f01091d7:	85 c0                	test   %eax,%eax
f01091d9:	74 0d                	je     f01091e8 <free_frame+0x7b>
f01091db:	a1 20 de 83 f0       	mov    0xf083de20,%eax
f01091e0:	8b 55 08             	mov    0x8(%ebp),%edx
f01091e3:	89 50 04             	mov    %edx,0x4(%eax)
f01091e6:	eb 08                	jmp    f01091f0 <free_frame+0x83>
f01091e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01091eb:	a3 24 de 83 f0       	mov    %eax,0xf083de24
f01091f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01091f3:	a3 20 de 83 f0       	mov    %eax,0xf083de20
f01091f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01091fb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0109202:	a1 2c de 83 f0       	mov    0xf083de2c,%eax
f0109207:	40                   	inc    %eax
f0109208:	a3 2c de 83 f0       	mov    %eax,0xf083de2c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f010920d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109211:	75 10                	jne    f0109223 <free_frame+0xb6>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f0109213:	83 ec 0c             	sub    $0xc,%esp
f0109216:	68 40 de 83 f0       	push   $0xf083de40
f010921b:	e8 02 6c 00 00       	call   f010fe22 <release_kspinlock>
f0109220:	83 c4 10             	add    $0x10,%esp
	}
}
f0109223:	90                   	nop
f0109224:	c9                   	leave  
f0109225:	c3                   	ret    

f0109226 <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f0109226:	55                   	push   %ebp
f0109227:	89 e5                	mov    %esp,%ebp
f0109229:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f010922c:	8b 45 08             	mov    0x8(%ebp),%eax
f010922f:	8b 40 08             	mov    0x8(%eax),%eax
f0109232:	48                   	dec    %eax
f0109233:	8b 55 08             	mov    0x8(%ebp),%edx
f0109236:	66 89 42 08          	mov    %ax,0x8(%edx)
f010923a:	8b 45 08             	mov    0x8(%ebp),%eax
f010923d:	8b 40 08             	mov    0x8(%eax),%eax
f0109240:	66 85 c0             	test   %ax,%ax
f0109243:	75 0e                	jne    f0109253 <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f0109245:	83 ec 0c             	sub    $0xc,%esp
f0109248:	ff 75 08             	pushl  0x8(%ebp)
f010924b:	e8 1d ff ff ff       	call   f010916d <free_frame>
f0109250:	83 c4 10             	add    $0x10,%esp
}
f0109253:	90                   	nop
f0109254:	c9                   	leave  
f0109255:	c3                   	ret    

f0109256 <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0109256:	55                   	push   %ebp
f0109257:	89 e5                	mov    %esp,%ebp
f0109259:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f010925c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010925f:	c1 e8 16             	shr    $0x16,%eax
f0109262:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109269:	8b 45 08             	mov    0x8(%ebp),%eax
f010926c:	01 d0                	add    %edx,%eax
f010926e:	8b 00                	mov    (%eax),%eax
f0109270:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f0109273:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109276:	83 e0 01             	and    $0x1,%eax
f0109279:	85 c0                	test   %eax,%eax
f010927b:	74 74                	je     f01092f1 <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010927d:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0109284:	77 1d                	ja     f01092a3 <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109286:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109289:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010928e:	83 ec 0c             	sub    $0xc,%esp
f0109291:	50                   	push   %eax
f0109292:	e8 d6 08 00 00       	call   f0109b6d <kheap_virtual_address>
f0109297:	83 c4 10             	add    $0x10,%esp
f010929a:	89 c2                	mov    %eax,%edx
f010929c:	8b 45 10             	mov    0x10(%ebp),%eax
f010929f:	89 10                	mov    %edx,(%eax)
f01092a1:	eb 44                	jmp    f01092e7 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01092a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01092a6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01092ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01092ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092b1:	c1 e8 0c             	shr    $0xc,%eax
f01092b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01092b7:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f01092bc:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01092bf:	72 17                	jb     f01092d8 <get_page_table+0x82>
f01092c1:	ff 75 f0             	pushl  -0x10(%ebp)
f01092c4:	68 20 ea 12 f0       	push   $0xf012ea20
f01092c9:	68 fa 00 00 00       	push   $0xfa
f01092ce:	68 63 e9 12 f0       	push   $0xf012e963
f01092d3:	e8 d7 7b ff ff       	call   f0100eaf <_panic>
f01092d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092db:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01092e0:	89 c2                	mov    %eax,%edx
f01092e2:	8b 45 10             	mov    0x10(%ebp),%eax
f01092e5:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f01092e7:	b8 00 00 00 00       	mov    $0x0,%eax
f01092ec:	e9 b9 00 00 00       	jmp    f01093aa <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f01092f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01092f5:	0f 84 a1 00 00 00    	je     f010939c <get_page_table+0x146>
f01092fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01092fe:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f0109301:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109304:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f0109307:	83 ec 0c             	sub    $0xc,%esp
f010930a:	6a 00                	push   $0x0
f010930c:	e8 40 66 00 00       	call   f010f951 <fault_handler>
f0109311:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0109314:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109317:	c1 e8 16             	shr    $0x16,%eax
f010931a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109321:	8b 45 08             	mov    0x8(%ebp),%eax
f0109324:	01 d0                	add    %edx,%eax
f0109326:	8b 00                	mov    (%eax),%eax
f0109328:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010932b:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0109332:	77 1d                	ja     f0109351 <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109334:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109337:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010933c:	83 ec 0c             	sub    $0xc,%esp
f010933f:	50                   	push   %eax
f0109340:	e8 28 08 00 00       	call   f0109b6d <kheap_virtual_address>
f0109345:	83 c4 10             	add    $0x10,%esp
f0109348:	89 c2                	mov    %eax,%edx
f010934a:	8b 45 10             	mov    0x10(%ebp),%eax
f010934d:	89 10                	mov    %edx,(%eax)
f010934f:	eb 44                	jmp    f0109395 <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109351:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109354:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109359:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010935c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010935f:	c1 e8 0c             	shr    $0xc,%eax
f0109362:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109365:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f010936a:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010936d:	72 17                	jb     f0109386 <get_page_table+0x130>
f010936f:	ff 75 e8             	pushl  -0x18(%ebp)
f0109372:	68 20 ea 12 f0       	push   $0xf012ea20
f0109377:	68 12 01 00 00       	push   $0x112
f010937c:	68 63 e9 12 f0       	push   $0xf012e963
f0109381:	e8 29 7b ff ff       	call   f0100eaf <_panic>
f0109386:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109389:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010938e:	89 c2                	mov    %eax,%edx
f0109390:	8b 45 10             	mov    0x10(%ebp),%eax
f0109393:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f0109395:	b8 00 00 00 00       	mov    $0x0,%eax
f010939a:	eb 0e                	jmp    f01093aa <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f010939c:	8b 45 10             	mov    0x10(%ebp),%eax
f010939f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f01093a5:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f01093aa:	c9                   	leave  
f01093ab:	c3                   	ret    

f01093ac <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f01093ac:	55                   	push   %ebp
f01093ad:	89 e5                	mov    %esp,%ebp
f01093af:	53                   	push   %ebx
f01093b0:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f01093b3:	83 ec 0c             	sub    $0xc,%esp
f01093b6:	68 00 10 00 00       	push   $0x1000
f01093bb:	e8 79 07 00 00       	call   f0109b39 <kmalloc>
f01093c0:	83 c4 10             	add    $0x10,%esp
f01093c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f01093c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01093ca:	75 17                	jne    f01093e3 <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f01093cc:	83 ec 04             	sub    $0x4,%esp
f01093cf:	68 4f ea 12 f0       	push   $0xf012ea4f
f01093d4:	68 32 01 00 00       	push   $0x132
f01093d9:	68 63 e9 12 f0       	push   $0xf012e963
f01093de:	e8 cc 7a ff ff       	call   f0100eaf <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01093e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01093e6:	c1 e8 16             	shr    $0x16,%eax
f01093e9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01093f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01093f3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01093f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093f9:	83 ec 0c             	sub    $0xc,%esp
f01093fc:	50                   	push   %eax
f01093fd:	e8 85 07 00 00       	call   f0109b87 <kheap_physical_address>
f0109402:	83 c4 10             	add    $0x10,%esp
f0109405:	83 c8 07             	or     $0x7,%eax
f0109408:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f010940a:	83 ec 04             	sub    $0x4,%esp
f010940d:	68 00 10 00 00       	push   $0x1000
f0109412:	6a 00                	push   $0x0
f0109414:	ff 75 f4             	pushl  -0xc(%ebp)
f0109417:	e8 4f 18 01 00       	call   f011ac6b <memset>
f010941c:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010941f:	0f 20 d8             	mov    %cr3,%eax
f0109422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109428:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f010942b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010942e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109431:	c9                   	leave  
f0109432:	c3                   	ret    

f0109433 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0109433:	55                   	push   %ebp
f0109434:	89 e5                	mov    %esp,%ebp
f0109436:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f0109439:	83 ec 0c             	sub    $0xc,%esp
f010943c:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010943f:	50                   	push   %eax
f0109440:	e8 00 fc ff ff       	call   f0109045 <allocate_frame>
f0109445:	83 c4 10             	add    $0x10,%esp
f0109448:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f010944b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010944e:	83 ec 0c             	sub    $0xc,%esp
f0109451:	50                   	push   %eax
f0109452:	e8 72 f7 ff ff       	call   f0108bc9 <to_physical_address>
f0109457:	83 c4 10             	add    $0x10,%esp
f010945a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f010945d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109460:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109463:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109466:	c1 e8 0c             	shr    $0xc,%eax
f0109469:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010946c:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f0109471:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0109474:	72 17                	jb     f010948d <__static_cpt+0x5a>
f0109476:	ff 75 ec             	pushl  -0x14(%ebp)
f0109479:	68 20 ea 12 f0       	push   $0xf012ea20
f010947e:	68 4d 01 00 00       	push   $0x14d
f0109483:	68 63 e9 12 f0       	push   $0xf012e963
f0109488:	e8 22 7a ff ff       	call   f0100eaf <_panic>
f010948d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109490:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0109495:	89 c2                	mov    %eax,%edx
f0109497:	8b 45 10             	mov    0x10(%ebp),%eax
f010949a:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f010949c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010949f:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f01094a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01094a8:	c1 e8 16             	shr    $0x16,%eax
f01094ab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01094b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01094b5:	01 d0                	add    %edx,%eax
f01094b7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01094ba:	83 ca 07             	or     $0x7,%edx
f01094bd:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f01094bf:	8b 45 10             	mov    0x10(%ebp),%eax
f01094c2:	8b 00                	mov    (%eax),%eax
f01094c4:	83 ec 04             	sub    $0x4,%esp
f01094c7:	68 00 10 00 00       	push   $0x1000
f01094cc:	6a 00                	push   $0x0
f01094ce:	50                   	push   %eax
f01094cf:	e8 97 17 01 00       	call   f011ac6b <memset>
f01094d4:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01094d7:	0f 20 d8             	mov    %cr3,%eax
f01094da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01094dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01094e0:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f01094e3:	90                   	nop
f01094e4:	c9                   	leave  
f01094e5:	c3                   	ret    

f01094e6 <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01094e6:	55                   	push   %ebp
f01094e7:	89 e5                	mov    %esp,%ebp
f01094e9:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01094ec:	ff 75 0c             	pushl  0xc(%ebp)
f01094ef:	e8 d5 f6 ff ff       	call   f0108bc9 <to_physical_address>
f01094f4:	83 c4 04             	add    $0x4,%esp
f01094f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f01094fa:	83 ec 04             	sub    $0x4,%esp
f01094fd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0109500:	50                   	push   %eax
f0109501:	ff 75 10             	pushl  0x10(%ebp)
f0109504:	ff 75 08             	pushl  0x8(%ebp)
f0109507:	e8 4a fd ff ff       	call   f0109256 <get_page_table>
f010950c:	83 c4 10             	add    $0x10,%esp
f010950f:	83 f8 01             	cmp    $0x1,%eax
f0109512:	75 1b                	jne    f010952f <map_frame+0x49>
		//page_directory_entry = ptr_page_directory[PDX(virtual_address)];
		//ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
		=============================================================================================*/
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f0109514:	83 ec 08             	sub    $0x8,%esp
f0109517:	ff 75 10             	pushl  0x10(%ebp)
f010951a:	ff 75 08             	pushl  0x8(%ebp)
f010951d:	e8 8a fe ff ff       	call   f01093ac <create_page_table>
f0109522:	83 c4 10             	add    $0x10,%esp
f0109525:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f0109528:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f010952f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109532:	8b 55 10             	mov    0x10(%ebp),%edx
f0109535:	c1 ea 0c             	shr    $0xc,%edx
f0109538:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010953e:	c1 e2 02             	shl    $0x2,%edx
f0109541:	01 d0                	add    %edx,%eax
f0109543:	8b 00                	mov    (%eax),%eax
f0109545:	89 45 ec             	mov    %eax,-0x14(%ebp)

	}*/

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0109548:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010954b:	83 e0 01             	and    $0x1,%eax
f010954e:	85 c0                	test   %eax,%eax
f0109550:	74 25                	je     f0109577 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f0109552:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109555:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010955a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010955d:	75 07                	jne    f0109566 <map_frame+0x80>
			return 0;
f010955f:	b8 00 00 00 00       	mov    $0x0,%eax
f0109564:	eb 68                	jmp    f01095ce <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0109566:	83 ec 08             	sub    $0x8,%esp
f0109569:	ff 75 10             	pushl  0x10(%ebp)
f010956c:	ff 75 08             	pushl  0x8(%ebp)
f010956f:	e8 de 00 00 00       	call   f0109652 <unmap_frame>
f0109574:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0109577:	8b 45 0c             	mov    0xc(%ebp),%eax
f010957a:	8b 40 08             	mov    0x8(%eax),%eax
f010957d:	40                   	inc    %eax
f010957e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109581:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0109585:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109588:	8b 55 10             	mov    0x10(%ebp),%edx
f010958b:	c1 ea 0c             	shr    $0xc,%edx
f010958e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109594:	c1 e2 02             	shl    $0x2,%edx
f0109597:	01 d0                	add    %edx,%eax
f0109599:	8b 00                	mov    (%eax),%eax
f010959b:	25 00 0e 00 00       	and    $0xe00,%eax
f01095a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f01095a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01095a6:	8b 55 10             	mov    0x10(%ebp),%edx
f01095a9:	c1 ea 0c             	shr    $0xc,%edx
f01095ac:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01095b2:	c1 e2 02             	shl    $0x2,%edx
f01095b5:	01 c2                	add    %eax,%edx
f01095b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01095ba:	0b 45 e8             	or     -0x18(%ebp),%eax
f01095bd:	89 c1                	mov    %eax,%ecx
f01095bf:	8b 45 14             	mov    0x14(%ebp),%eax
f01095c2:	09 c8                	or     %ecx,%eax
f01095c4:	83 c8 01             	or     $0x1,%eax
f01095c7:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f01095c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01095ce:	c9                   	leave  
f01095cf:	c3                   	ret    

f01095d0 <get_frame_info>:
//	2. buffered to 'virtual_address'
// If the page table entry corresponding to 'virtual_address' exists, then we store a pointer to the table in 'ptr_page_table'
// Return 0 if there is no frame mapped/buffered at virtual_address.
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f01095d0:	55                   	push   %ebp
f01095d1:	89 e5                	mov    %esp,%ebp
f01095d3:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f01095d6:	83 ec 04             	sub    $0x4,%esp
f01095d9:	ff 75 10             	pushl  0x10(%ebp)
f01095dc:	ff 75 0c             	pushl  0xc(%ebp)
f01095df:	ff 75 08             	pushl  0x8(%ebp)
f01095e2:	e8 6f fc ff ff       	call   f0109256 <get_page_table>
f01095e7:	83 c4 10             	add    $0x10,%esp
f01095ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if((*ptr_page_table) != 0)
f01095ed:	8b 45 10             	mov    0x10(%ebp),%eax
f01095f0:	8b 00                	mov    (%eax),%eax
f01095f2:	85 c0                	test   %eax,%eax
f01095f4:	74 55                	je     f010964b <get_frame_info+0x7b>
	{
		uint32 index_page_table = PTX(virtual_address);
f01095f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01095f9:	c1 e8 0c             	shr    $0xc,%eax
f01095fc:	25 ff 03 00 00       	and    $0x3ff,%eax
f0109601:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f0109604:	8b 45 10             	mov    0x10(%ebp),%eax
f0109607:	8b 00                	mov    (%eax),%eax
f0109609:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010960c:	c1 e2 02             	shl    $0x2,%edx
f010960f:	01 d0                	add    %edx,%eax
f0109611:	8b 00                	mov    (%eax),%eax
f0109613:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		/*2025 el7:)*///or if it's 0, make sure it's either present or buffered
		//if( page_table_entry != 0)
		//if((page_table_entry & ~0xFFF) != 0)
		if( ((page_table_entry & ~0xFFF) != 0) || ((page_table_entry & (PERM_PRESENT|PERM_BUFFERED)) != 0))
f0109616:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109619:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010961e:	85 c0                	test   %eax,%eax
f0109620:	75 0c                	jne    f010962e <get_frame_info+0x5e>
f0109622:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109625:	25 01 02 00 00       	and    $0x201,%eax
f010962a:	85 c0                	test   %eax,%eax
f010962c:	74 16                	je     f0109644 <get_frame_info+0x74>
		{
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f010962e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109631:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109636:	83 ec 0c             	sub    $0xc,%esp
f0109639:	50                   	push   %eax
f010963a:	e8 9d f5 ff ff       	call   f0108bdc <to_frame_info>
f010963f:	83 c4 10             	add    $0x10,%esp
f0109642:	eb 0c                	jmp    f0109650 <get_frame_info+0x80>
		}
		return 0;
f0109644:	b8 00 00 00 00       	mov    $0x0,%eax
f0109649:	eb 05                	jmp    f0109650 <get_frame_info+0x80>
	}
	return 0;
f010964b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109650:	c9                   	leave  
f0109651:	c3                   	ret    

f0109652 <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f0109652:	55                   	push   %ebp
f0109653:	89 e5                	mov    %esp,%ebp
f0109655:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f0109658:	83 ec 04             	sub    $0x4,%esp
f010965b:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010965e:	50                   	push   %eax
f010965f:	ff 75 0c             	pushl  0xc(%ebp)
f0109662:	ff 75 08             	pushl  0x8(%ebp)
f0109665:	e8 66 ff ff ff       	call   f01095d0 <get_frame_info>
f010966a:	83 c4 10             	add    $0x10,%esp
f010966d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f0109670:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109674:	74 7d                	je     f01096f3 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0109676:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109679:	8a 40 10             	mov    0x10(%eax),%al
f010967c:	84 c0                	test   %al,%al
f010967e:	74 1c                	je     f010969c <unmap_frame+0x4a>
f0109680:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0109687:	77 13                	ja     f010969c <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0109689:	83 ec 08             	sub    $0x8,%esp
f010968c:	ff 75 0c             	pushl  0xc(%ebp)
f010968f:	68 6c ea 12 f0       	push   $0xf012ea6c
f0109694:	e8 c3 84 ff ff       	call   f0101b5c <cprintf>
f0109699:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f010969c:	83 ec 0c             	sub    $0xc,%esp
f010969f:	ff 75 f4             	pushl  -0xc(%ebp)
f01096a2:	e8 7f fb ff ff       	call   f0109226 <decrement_references>
f01096a7:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f01096aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01096ad:	8b 55 0c             	mov    0xc(%ebp),%edx
f01096b0:	c1 ea 0c             	shr    $0xc,%edx
f01096b3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01096b9:	c1 e2 02             	shl    $0x2,%edx
f01096bc:	01 d0                	add    %edx,%eax
f01096be:	8b 00                	mov    (%eax),%eax
f01096c0:	25 00 0e 00 00       	and    $0xe00,%eax
f01096c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f01096c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01096cb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01096ce:	c1 ea 0c             	shr    $0xc,%edx
f01096d1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01096d7:	c1 e2 02             	shl    $0x2,%edx
f01096da:	01 c2                	add    %eax,%edx
f01096dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096df:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f01096e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01096e4:	83 ec 08             	sub    $0x8,%esp
f01096e7:	50                   	push   %eax
f01096e8:	ff 75 08             	pushl  0x8(%ebp)
f01096eb:	e8 33 f5 ff ff       	call   f0108c23 <tlb_invalidate>
f01096f0:	83 c4 10             	add    $0x10,%esp
	}
}
f01096f3:	90                   	nop
f01096f4:	c9                   	leave  
f01096f5:	c3                   	ret    

f01096f6 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01096f6:	55                   	push   %ebp
f01096f7:	89 e5                	mov    %esp,%ebp
f01096f9:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01096fc:	ff 75 0c             	pushl  0xc(%ebp)
f01096ff:	e8 c5 f4 ff ff       	call   f0108bc9 <to_physical_address>
f0109704:	83 c4 04             	add    $0x4,%esp
f0109707:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f010970a:	8b 45 10             	mov    0x10(%ebp),%eax
f010970d:	c1 e8 16             	shr    $0x16,%eax
f0109710:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109717:	8b 45 08             	mov    0x8(%ebp),%eax
f010971a:	01 d0                	add    %edx,%eax
f010971c:	8b 00                	mov    (%eax),%eax
f010971e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0109721:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0109728:	77 19                	ja     f0109743 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010972a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010972d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109732:	83 ec 0c             	sub    $0xc,%esp
f0109735:	50                   	push   %eax
f0109736:	e8 32 04 00 00       	call   f0109b6d <kheap_virtual_address>
f010973b:	83 c4 10             	add    $0x10,%esp
f010973e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109741:	eb 40                	jmp    f0109783 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109743:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109746:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010974b:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010974e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109751:	c1 e8 0c             	shr    $0xc,%eax
f0109754:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109757:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f010975c:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010975f:	72 17                	jb     f0109778 <loadtime_map_frame+0x82>
f0109761:	ff 75 e8             	pushl  -0x18(%ebp)
f0109764:	68 20 ea 12 f0       	push   $0xf012ea20
f0109769:	68 0c 02 00 00       	push   $0x20c
f010976e:	68 63 e9 12 f0       	push   $0xf012e963
f0109773:	e8 37 77 ff ff       	call   f0100eaf <_panic>
f0109778:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010977b:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0109780:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0109783:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109787:	75 14                	jne    f010979d <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0109789:	83 ec 08             	sub    $0x8,%esp
f010978c:	ff 75 10             	pushl  0x10(%ebp)
f010978f:	ff 75 08             	pushl  0x8(%ebp)
f0109792:	e8 15 fc ff ff       	call   f01093ac <create_page_table>
f0109797:	83 c4 10             	add    $0x10,%esp
f010979a:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f010979d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01097a0:	8b 40 08             	mov    0x8(%eax),%eax
f01097a3:	40                   	inc    %eax
f01097a4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01097a7:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f01097ab:	8b 45 10             	mov    0x10(%ebp),%eax
f01097ae:	c1 e8 0c             	shr    $0xc,%eax
f01097b1:	25 ff 03 00 00       	and    $0x3ff,%eax
f01097b6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01097bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01097c0:	01 c2                	add    %eax,%edx
f01097c2:	8b 45 14             	mov    0x14(%ebp),%eax
f01097c5:	0b 45 f0             	or     -0x10(%ebp),%eax
f01097c8:	83 c8 01             	or     $0x1,%eax
f01097cb:	89 02                	mov    %eax,(%edx)

	return 0;
f01097cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01097d2:	c9                   	leave  
f01097d3:	c3                   	ret    

f01097d4 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f01097d4:	55                   	push   %ebp
f01097d5:	89 e5                	mov    %esp,%ebp
f01097d7:	57                   	push   %edi
f01097d8:	56                   	push   %esi
f01097d9:	53                   	push   %ebx
f01097da:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f01097dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f01097e4:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f01097eb:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_kspinlock(&MemFrameLists.mfllock);
f01097f2:	83 ec 0c             	sub    $0xc,%esp
f01097f5:	68 40 de 83 f0       	push   $0xf083de40
f01097fa:	e8 d3 67 00 00       	call   f010ffd2 <holding_kspinlock>
f01097ff:	83 c4 10             	add    $0x10,%esp
f0109802:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0109805:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0109809:	75 10                	jne    f010981b <calculate_available_frames+0x47>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f010980b:	83 ec 0c             	sub    $0xc,%esp
f010980e:	68 40 de 83 f0       	push   $0xf083de40
f0109813:	e8 65 65 00 00       	call   f010fd7d <acquire_kspinlock>
f0109818:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f010981b:	a1 20 de 83 f0       	mov    0xf083de20,%eax
f0109820:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109823:	eb 1a                	jmp    f010983f <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f0109825:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109828:	8a 40 10             	mov    0x10(%eax),%al
f010982b:	84 c0                	test   %al,%al
f010982d:	74 05                	je     f0109834 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f010982f:	ff 45 dc             	incl   -0x24(%ebp)
f0109832:	eb 03                	jmp    f0109837 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f0109834:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_kspinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0109837:	a1 28 de 83 f0       	mov    0xf083de28,%eax
f010983c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010983f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109843:	74 07                	je     f010984c <calculate_available_frames+0x78>
f0109845:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109848:	8b 00                	mov    (%eax),%eax
f010984a:	eb 05                	jmp    f0109851 <calculate_available_frames+0x7d>
f010984c:	b8 00 00 00 00       	mov    $0x0,%eax
f0109851:	a3 28 de 83 f0       	mov    %eax,0xf083de28
f0109856:	a1 28 de 83 f0       	mov    0xf083de28,%eax
f010985b:	85 c0                	test   %eax,%eax
f010985d:	75 c6                	jne    f0109825 <calculate_available_frames+0x51>
f010985f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109863:	75 c0                	jne    f0109825 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f0109865:	a1 3c de 83 f0       	mov    0xf083de3c,%eax
f010986a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f010986d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0109871:	75 10                	jne    f0109883 <calculate_available_frames+0xaf>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f0109873:	83 ec 0c             	sub    $0xc,%esp
f0109876:	68 40 de 83 f0       	push   $0xf083de40
f010987b:	e8 a2 65 00 00       	call   f010fe22 <release_kspinlock>
f0109880:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0109883:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109886:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0109889:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010988c:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f010988f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109892:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0109895:	8b 45 08             	mov    0x8(%ebp),%eax
f0109898:	89 c3                	mov    %eax,%ebx
f010989a:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010989d:	ba 03 00 00 00       	mov    $0x3,%edx
f01098a2:	89 df                	mov    %ebx,%edi
f01098a4:	89 c6                	mov    %eax,%esi
f01098a6:	89 d1                	mov    %edx,%ecx
f01098a8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f01098aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01098ad:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01098b0:	5b                   	pop    %ebx
f01098b1:	5e                   	pop    %esi
f01098b2:	5f                   	pop    %edi
f01098b3:	5d                   	pop    %ebp
f01098b4:	c2 04 00             	ret    $0x4

f01098b7 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f01098b7:	55                   	push   %ebp
f01098b8:	89 e5                	mov    %esp,%ebp
f01098ba:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f01098bd:	c7 05 e0 dc 83 f0 00 	movl   $0x0,0xf083dce0
f01098c4:	00 00 00 
f01098c7:	c7 05 e4 dc 83 f0 00 	movl   $0x0,0xf083dce4
f01098ce:	00 00 00 
f01098d1:	c7 05 ec dc 83 f0 00 	movl   $0x0,0xf083dcec
f01098d8:	00 00 00 
	init_kspinlock(&AllShares.shareslock, "shares lock");
f01098db:	83 ec 08             	sub    $0x8,%esp
f01098de:	68 9c ea 12 f0       	push   $0xf012ea9c
f01098e3:	68 f0 dc 83 f0       	push   $0xf083dcf0
f01098e8:	e8 5f 64 00 00       	call   f010fd4c <init_kspinlock>
f01098ed:	83 c4 10             	add    $0x10,%esp
	//init_sleeplock(&AllShares.sharessleeplock, "shares sleep lock");
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f01098f0:	90                   	nop
f01098f1:	c9                   	leave  
f01098f2:	c3                   	ret    

f01098f3 <find_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* find_share(int32 ownerID, char* name)
{
f01098f3:	55                   	push   %ebp
f01098f4:	89 e5                	mov    %esp,%ebp
f01098f6:	83 ec 18             	sub    $0x18,%esp
#if USE_KHEAP
	struct Share * ret = NULL;
f01098f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool wasHeld = holding_kspinlock(&(AllShares.shareslock));
f0109900:	83 ec 0c             	sub    $0xc,%esp
f0109903:	68 f0 dc 83 f0       	push   $0xf083dcf0
f0109908:	e8 c5 66 00 00       	call   f010ffd2 <holding_kspinlock>
f010990d:	83 c4 10             	add    $0x10,%esp
f0109910:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (!wasHeld)
f0109913:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109917:	75 10                	jne    f0109929 <find_share+0x36>
	{
		acquire_kspinlock(&(AllShares.shareslock));
f0109919:	83 ec 0c             	sub    $0xc,%esp
f010991c:	68 f0 dc 83 f0       	push   $0xf083dcf0
f0109921:	e8 57 64 00 00       	call   f010fd7d <acquire_kspinlock>
f0109926:	83 c4 10             	add    $0x10,%esp
	}
	{
		struct Share * shr ;
		LIST_FOREACH(shr, &(AllShares.shares_list))
f0109929:	a1 e0 dc 83 f0       	mov    0xf083dce0,%eax
f010992e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109931:	eb 34                	jmp    f0109967 <find_share+0x74>
		{
			//cprintf("shared var name = %s compared with %s\n", name, shr->name);
			if(shr->ownerID == ownerID && strcmp(name, shr->name)==0)
f0109933:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109936:	8b 40 04             	mov    0x4(%eax),%eax
f0109939:	3b 45 08             	cmp    0x8(%ebp),%eax
f010993c:	75 21                	jne    f010995f <find_share+0x6c>
f010993e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109941:	83 c0 08             	add    $0x8,%eax
f0109944:	83 ec 08             	sub    $0x8,%esp
f0109947:	50                   	push   %eax
f0109948:	ff 75 0c             	pushl  0xc(%ebp)
f010994b:	e8 39 12 01 00       	call   f011ab89 <strcmp>
f0109950:	83 c4 10             	add    $0x10,%esp
f0109953:	85 c0                	test   %eax,%eax
f0109955:	75 08                	jne    f010995f <find_share+0x6c>
			{
				//cprintf("%s found\n", name);
				ret = shr;
f0109957:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010995a:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f010995d:	eb 2f                	jmp    f010998e <find_share+0x9b>
	{
		acquire_kspinlock(&(AllShares.shareslock));
	}
	{
		struct Share * shr ;
		LIST_FOREACH(shr, &(AllShares.shares_list))
f010995f:	a1 e8 dc 83 f0       	mov    0xf083dce8,%eax
f0109964:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109967:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010996b:	74 08                	je     f0109975 <find_share+0x82>
f010996d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109970:	8b 40 58             	mov    0x58(%eax),%eax
f0109973:	eb 05                	jmp    f010997a <find_share+0x87>
f0109975:	b8 00 00 00 00       	mov    $0x0,%eax
f010997a:	a3 e8 dc 83 f0       	mov    %eax,0xf083dce8
f010997f:	a1 e8 dc 83 f0       	mov    0xf083dce8,%eax
f0109984:	85 c0                	test   %eax,%eax
f0109986:	75 ab                	jne    f0109933 <find_share+0x40>
f0109988:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010998c:	75 a5                	jne    f0109933 <find_share+0x40>
				ret = shr;
				break;
			}
		}
	}
	if (!wasHeld)
f010998e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109992:	75 10                	jne    f01099a4 <find_share+0xb1>
	{
		release_kspinlock(&(AllShares.shareslock));
f0109994:	83 ec 0c             	sub    $0xc,%esp
f0109997:	68 f0 dc 83 f0       	push   $0xf083dcf0
f010999c:	e8 81 64 00 00       	call   f010fe22 <release_kspinlock>
f01099a1:	83 c4 10             	add    $0x10,%esp
	}
	return ret;
f01099a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f01099a7:	c9                   	leave  
f01099a8:	c3                   	ret    

f01099a9 <size_of_shared_object>:

//==============================
// [3] Get Size of Share Object:
//==============================
int size_of_shared_object(int32 ownerID, char* shareName)
{
f01099a9:	55                   	push   %ebp
f01099aa:	89 e5                	mov    %esp,%ebp
f01099ac:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = find_share(ownerID, shareName);
f01099af:	83 ec 08             	sub    $0x8,%esp
f01099b2:	ff 75 0c             	pushl  0xc(%ebp)
f01099b5:	ff 75 08             	pushl  0x8(%ebp)
f01099b8:	e8 36 ff ff ff       	call   f01098f3 <find_share>
f01099bd:	83 c4 10             	add    $0x10,%esp
f01099c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f01099c3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01099c7:	75 07                	jne    f01099d0 <size_of_shared_object+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f01099c9:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f01099ce:	eb 06                	jmp    f01099d6 <size_of_shared_object+0x2d>
	else
		return ptr_share->size;
f01099d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01099d3:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f01099d6:	c9                   	leave  
f01099d7:	c3                   	ret    

f01099d8 <alloc_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* alloc_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f01099d8:	55                   	push   %ebp
f01099d9:	89 e5                	mov    %esp,%ebp
f01099db:	83 ec 18             	sub    $0x18,%esp
f01099de:	8b 45 14             	mov    0x14(%ebp),%eax
f01099e1:	88 45 f4             	mov    %al,-0xc(%ebp)
	//TODO: [PROJECT'25.IM#3] SHARED MEMORY - #1 alloc_share
	//Your code is here
	//Comment the following line
	panic("alloc_share() is not implemented yet...!!");
f01099e4:	83 ec 04             	sub    $0x4,%esp
f01099e7:	68 a8 ea 12 f0       	push   $0xf012eaa8
f01099ec:	6a 6e                	push   $0x6e
f01099ee:	68 d4 ea 12 f0       	push   $0xf012ead4
f01099f3:	e8 b7 74 ff ff       	call   f0100eaf <_panic>

f01099f8 <create_shared_object>:

//=========================
// [4] Create Share Object:
//=========================
int create_shared_object(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f01099f8:	55                   	push   %ebp
f01099f9:	89 e5                	mov    %esp,%ebp
f01099fb:	83 ec 18             	sub    $0x18,%esp
f01099fe:	8b 45 14             	mov    0x14(%ebp),%eax
f0109a01:	88 45 f4             	mov    %al,-0xc(%ebp)
	//TODO: [PROJECT'25.IM#3] SHARED MEMORY - #3 create_shared_object
	//Your code is here
	//Comment the following line
	panic("create_shared_object() is not implemented yet...!!");
f0109a04:	83 ec 04             	sub    $0x4,%esp
f0109a07:	68 f8 ea 12 f0       	push   $0xf012eaf8
f0109a0c:	6a 7a                	push   $0x7a
f0109a0e:	68 d4 ea 12 f0       	push   $0xf012ead4
f0109a13:	e8 97 74 ff ff       	call   f0100eaf <_panic>

f0109a18 <get_shared_object>:

//======================
// [5] Get Share Object:
//======================
int get_shared_object(int32 ownerID, char* shareName, void* virtual_address)
{
f0109a18:	55                   	push   %ebp
f0109a19:	89 e5                	mov    %esp,%ebp
f0109a1b:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#3] SHARED MEMORY - #5 get_shared_object
	//Your code is here
	//Comment the following line
	panic("get_shared_object() is not implemented yet...!!");
f0109a1e:	83 ec 04             	sub    $0x4,%esp
f0109a21:	68 2c eb 12 f0       	push   $0xf012eb2c
f0109a26:	68 8f 00 00 00       	push   $0x8f
f0109a2b:	68 d4 ea 12 f0       	push   $0xf012ead4
f0109a30:	e8 7a 74 ff ff       	call   f0100eaf <_panic>

f0109a35 <free_share>:
// [1] Delete Share Object:
//=========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0109a35:	55                   	push   %ebp
f0109a36:	89 e5                	mov    %esp,%ebp
f0109a38:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#5] EXIT #2 - free_share
	//Your code is here
	//Comment the following line
	panic("free_share() is not implemented yet...!!");
f0109a3b:	83 ec 04             	sub    $0x4,%esp
f0109a3e:	68 5c eb 12 f0       	push   $0xf012eb5c
f0109a43:	68 a9 00 00 00       	push   $0xa9
f0109a48:	68 d4 ea 12 f0       	push   $0xf012ead4
f0109a4d:	e8 5d 74 ff ff       	call   f0100eaf <_panic>

f0109a52 <delete_shared_object>:

//=========================
// [2] Free Share Object:
//=========================
int delete_shared_object(int32 sharedObjectID, void *startVA)
{
f0109a52:	55                   	push   %ebp
f0109a53:	89 e5                	mov    %esp,%ebp
f0109a55:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#5] EXIT #2 - delete_shared_object
	//Your code is here
	//Comment the following line
	panic("delete_shared_object() is not implemented yet...!!");
f0109a58:	83 ec 04             	sub    $0x4,%esp
f0109a5b:	68 88 eb 12 f0       	push   $0xf012eb88
f0109a60:	68 b5 00 00 00       	push   $0xb5
f0109a65:	68 d4 ea 12 f0       	push   $0xf012ead4
f0109a6a:	e8 40 74 ff ff       	call   f0100eaf <_panic>

f0109a6f <set_kheap_strategy>:
uint32 kheapPageAllocStart ;
uint32 kheapPageAllocBreak ;
uint32 kheapPlacementStrategy;

/*2025*/ //Replaced by setter & getter function
static inline void set_kheap_strategy(uint32 strategy){kheapPlacementStrategy = strategy;}
f0109a6f:	55                   	push   %ebp
f0109a70:	89 e5                	mov    %esp,%ebp
f0109a72:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a75:	a3 24 60 85 f0       	mov    %eax,0xf0856024
f0109a7a:	90                   	nop
f0109a7b:	5d                   	pop    %ebp
f0109a7c:	c3                   	ret    

f0109a7d <kheap_init>:
// [1] INITIALIZE KERNEL HEAP:
//==============================================
//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #0 kheap_init [GIVEN]
//Remember to initialize locks (if any)
void kheap_init()
{
f0109a7d:	55                   	push   %ebp
f0109a7e:	89 e5                	mov    %esp,%ebp
f0109a80:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		initialize_dynamic_allocator(KERNEL_HEAP_START, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0109a83:	83 ec 08             	sub    $0x8,%esp
f0109a86:	68 00 00 00 f8       	push   $0xf8000000
f0109a8b:	68 00 00 00 f6       	push   $0xf6000000
f0109a90:	e8 fe 1b 01 00       	call   f011b693 <initialize_dynamic_allocator>
f0109a95:	83 c4 10             	add    $0x10,%esp
		set_kheap_strategy(KHP_PLACE_CUSTOMFIT);
f0109a98:	83 ec 0c             	sub    $0xc,%esp
f0109a9b:	6a 05                	push   $0x5
f0109a9d:	e8 cd ff ff ff       	call   f0109a6f <set_kheap_strategy>
f0109aa2:	83 c4 10             	add    $0x10,%esp
		kheapPageAllocStart = dynAllocEnd + PAGE_SIZE;
f0109aa5:	a1 a0 db 83 f0       	mov    0xf083dba0,%eax
f0109aaa:	05 00 10 00 00       	add    $0x1000,%eax
f0109aaf:	a3 5c df 83 f0       	mov    %eax,0xf083df5c
		kheapPageAllocBreak = kheapPageAllocStart;
f0109ab4:	a1 5c df 83 f0       	mov    0xf083df5c,%eax
f0109ab9:	a3 70 61 85 f0       	mov    %eax,0xf0856170
	}
	//==================================================================================
	//==================================================================================
}
f0109abe:	90                   	nop
f0109abf:	c9                   	leave  
f0109ac0:	c3                   	ret    

f0109ac1 <get_page>:

//==============================================
// [2] GET A PAGE FROM THE KERNEL FOR DA:
//==============================================
int get_page(void* va)
{
f0109ac1:	55                   	push   %ebp
f0109ac2:	89 e5                	mov    %esp,%ebp
f0109ac4:	83 ec 18             	sub    $0x18,%esp
	int ret = alloc_page(ptr_page_directory, ROUNDDOWN((uint32)va, PAGE_SIZE), PERM_WRITEABLE, 1);
f0109ac7:	8b 45 08             	mov    0x8(%ebp),%eax
f0109aca:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109ad0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109ad5:	89 c2                	mov    %eax,%edx
f0109ad7:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0109adc:	6a 01                	push   $0x1
f0109ade:	6a 02                	push   $0x2
f0109ae0:	52                   	push   %edx
f0109ae1:	50                   	push   %eax
f0109ae2:	e8 6a 02 00 00       	call   f0109d51 <alloc_page>
f0109ae7:	83 c4 10             	add    $0x10,%esp
f0109aea:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret < 0)
f0109aed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109af1:	79 14                	jns    f0109b07 <get_page+0x46>
		panic("get_page() in kern: failed to allocate page from the kernel");
f0109af3:	83 ec 04             	sub    $0x4,%esp
f0109af6:	68 bc eb 12 f0       	push   $0xf012ebbc
f0109afb:	6a 29                	push   $0x29
f0109afd:	68 f8 eb 12 f0       	push   $0xf012ebf8
f0109b02:	e8 a8 73 ff ff       	call   f0100eaf <_panic>
	return 0;
f0109b07:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109b0c:	c9                   	leave  
f0109b0d:	c3                   	ret    

f0109b0e <return_page>:

//==============================================
// [3] RETURN A PAGE FROM THE DA TO KERNEL:
//==============================================
void return_page(void* va)
{
f0109b0e:	55                   	push   %ebp
f0109b0f:	89 e5                	mov    %esp,%ebp
f0109b11:	83 ec 18             	sub    $0x18,%esp
	unmap_frame(ptr_page_directory, ROUNDDOWN((uint32)va, PAGE_SIZE));
f0109b14:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b17:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109b1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109b1d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109b22:	89 c2                	mov    %eax,%edx
f0109b24:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0109b29:	83 ec 08             	sub    $0x8,%esp
f0109b2c:	52                   	push   %edx
f0109b2d:	50                   	push   %eax
f0109b2e:	e8 1f fb ff ff       	call   f0109652 <unmap_frame>
f0109b33:	83 c4 10             	add    $0x10,%esp
}
f0109b36:	90                   	nop
f0109b37:	c9                   	leave  
f0109b38:	c3                   	ret    

f0109b39 <kmalloc>:
//==================================================================================//
//===================================
// [1] ALLOCATE SPACE IN KERNEL HEAP:
//===================================
void* kmalloc(unsigned int size)
{
f0109b39:	55                   	push   %ebp
f0109b3a:	89 e5                	mov    %esp,%ebp
f0109b3c:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #1 kmalloc
	//Your code is here
	//Comment the following line
	kpanic_into_prompt("kmalloc() is not implemented yet...!!");
f0109b3f:	83 ec 04             	sub    $0x4,%esp
f0109b42:	68 0c ec 12 f0       	push   $0xf012ec0c
f0109b47:	6a 40                	push   $0x40
f0109b49:	68 f8 eb 12 f0       	push   $0xf012ebf8
f0109b4e:	e8 90 74 ff ff       	call   f0100fe3 <_panic_into_prompt>

f0109b53 <kfree>:

//=================================
// [2] FREE SPACE FROM KERNEL HEAP:
//=================================
void kfree(void* virtual_address)
{
f0109b53:	55                   	push   %ebp
f0109b54:	89 e5                	mov    %esp,%ebp
f0109b56:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #2 kfree
	//Your code is here
	//Comment the following line
	panic("kfree() is not implemented yet...!!");
f0109b59:	83 ec 04             	sub    $0x4,%esp
f0109b5c:	68 34 ec 12 f0       	push   $0xf012ec34
f0109b61:	6a 4d                	push   $0x4d
f0109b63:	68 f8 eb 12 f0       	push   $0xf012ebf8
f0109b68:	e8 42 73 ff ff       	call   f0100eaf <_panic>

f0109b6d <kheap_virtual_address>:

//=================================
// [3] FIND VA OF GIVEN PA:
//=================================
unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0109b6d:	55                   	push   %ebp
f0109b6e:	89 e5                	mov    %esp,%ebp
f0109b70:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #3 kheap_virtual_address
	//Your code is here
	//Comment the following line
	panic("kheap_virtual_address() is not implemented yet...!!");
f0109b73:	83 ec 04             	sub    $0x4,%esp
f0109b76:	68 58 ec 12 f0       	push   $0xf012ec58
f0109b7b:	6a 58                	push   $0x58
f0109b7d:	68 f8 eb 12 f0       	push   $0xf012ebf8
f0109b82:	e8 28 73 ff ff       	call   f0100eaf <_panic>

f0109b87 <kheap_physical_address>:

//=================================
// [4] FIND PA OF GIVEN VA:
//=================================
unsigned int kheap_physical_address(unsigned int virtual_address)
{
f0109b87:	55                   	push   %ebp
f0109b88:	89 e5                	mov    %esp,%ebp
f0109b8a:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #4 kheap_physical_address
	//Your code is here
	//Comment the following line
	panic("kheap_physical_address() is not implemented yet...!!");
f0109b8d:	83 ec 04             	sub    $0x4,%esp
f0109b90:	68 8c ec 12 f0       	push   $0xf012ec8c
f0109b95:	6a 65                	push   $0x65
f0109b97:	68 f8 eb 12 f0       	push   $0xf012ebf8
f0109b9c:	e8 0e 73 ff ff       	call   f0100eaf <_panic>

f0109ba1 <krealloc>:
//	A call with new_size = zero is equivalent to kfree().

extern __inline__ uint32 get_block_size(void *va);

void *krealloc(void *virtual_address, uint32 new_size)
{
f0109ba1:	55                   	push   %ebp
f0109ba2:	89 e5                	mov    %esp,%ebp
f0109ba4:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#2] KERNEL REALLOC - krealloc
	//Your code is here
	//Comment the following line
	panic("krealloc() is not implemented yet...!!");
f0109ba7:	83 ec 04             	sub    $0x4,%esp
f0109baa:	68 c4 ec 12 f0       	push   $0xf012ecc4
f0109baf:	6a 7e                	push   $0x7e
f0109bb1:	68 f8 eb 12 f0       	push   $0xf012ebf8
f0109bb6:	e8 f4 72 ff ff       	call   f0100eaf <_panic>

f0109bbb <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0109bbb:	55                   	push   %ebp
f0109bbc:	89 e5                	mov    %esp,%ebp
f0109bbe:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0109bc1:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bc4:	c1 e8 0c             	shr    $0xc,%eax
f0109bc7:	89 c2                	mov    %eax,%edx
f0109bc9:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f0109bce:	39 c2                	cmp    %eax,%edx
f0109bd0:	72 14                	jb     f0109be6 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0109bd2:	83 ec 04             	sub    $0x4,%esp
f0109bd5:	68 ec ec 12 f0       	push   $0xf012ecec
f0109bda:	6a 4e                	push   $0x4e
f0109bdc:	68 11 ed 12 f0       	push   $0xf012ed11
f0109be1:	e8 c9 72 ff ff       	call   f0100eaf <_panic>
	return &frames_info[PPN(physical_address)];
f0109be6:	8b 15 68 61 85 f0    	mov    0xf0856168,%edx
f0109bec:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bef:	c1 e8 0c             	shr    $0xc,%eax
f0109bf2:	89 c1                	mov    %eax,%ecx
f0109bf4:	89 c8                	mov    %ecx,%eax
f0109bf6:	c1 e0 02             	shl    $0x2,%eax
f0109bf9:	01 c8                	add    %ecx,%eax
f0109bfb:	c1 e0 02             	shl    $0x2,%eax
f0109bfe:	01 d0                	add    %edx,%eax
}
f0109c00:	c9                   	leave  
f0109c01:	c3                   	ret    

f0109c02 <pt_set_page_permissions>:
//	1. Set to 1 all "permissions_to_set"
//	2. Set to 0 all "permissions_to_reset"
//It's expected that the page table already exist. If not, the function should panic
//REMEMBER: to invalidate the TLB cache
inline void pt_set_page_permissions(uint32* directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0109c02:	55                   	push   %ebp
f0109c03:	89 e5                	mov    %esp,%ebp
f0109c05:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(directory, virtual_address, &ptr_page_table);
f0109c08:	83 ec 04             	sub    $0x4,%esp
f0109c0b:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109c0e:	50                   	push   %eax
f0109c0f:	ff 75 0c             	pushl  0xc(%ebp)
f0109c12:	ff 75 08             	pushl  0x8(%ebp)
f0109c15:	e8 3c f6 ff ff       	call   f0109256 <get_page_table>
f0109c1a:	83 c4 10             	add    $0x10,%esp
f0109c1d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109c20:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c23:	85 c0                	test   %eax,%eax
f0109c25:	74 64                	je     f0109c8b <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0109c27:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c2a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109c2d:	c1 ea 0c             	shr    $0xc,%edx
f0109c30:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109c36:	c1 e2 02             	shl    $0x2,%edx
f0109c39:	01 c2                	add    %eax,%edx
f0109c3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c3e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109c41:	c1 e9 0c             	shr    $0xc,%ecx
f0109c44:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109c4a:	c1 e1 02             	shl    $0x2,%ecx
f0109c4d:	01 c8                	add    %ecx,%eax
f0109c4f:	8b 00                	mov    (%eax),%eax
f0109c51:	0b 45 10             	or     0x10(%ebp),%eax
f0109c54:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109c56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c59:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109c5c:	c1 ea 0c             	shr    $0xc,%edx
f0109c5f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109c65:	c1 e2 02             	shl    $0x2,%edx
f0109c68:	01 d0                	add    %edx,%eax
f0109c6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109c6d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109c70:	c1 e9 0c             	shr    $0xc,%ecx
f0109c73:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109c79:	c1 e1 02             	shl    $0x2,%ecx
f0109c7c:	01 ca                	add    %ecx,%edx
f0109c7e:	8b 12                	mov    (%edx),%edx
f0109c80:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0109c83:	f7 d1                	not    %ecx
f0109c85:	21 ca                	and    %ecx,%edx
f0109c87:	89 10                	mov    %edx,(%eax)
f0109c89:	eb 27                	jmp    f0109cb2 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0109c8b:	83 ec 08             	sub    $0x8,%esp
f0109c8e:	ff 75 0c             	pushl  0xc(%ebp)
f0109c91:	68 2c ed 12 f0       	push   $0xf012ed2c
f0109c96:	e8 c1 7e ff ff       	call   f0101b5c <cprintf>
f0109c9b:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109c9e:	83 ec 04             	sub    $0x4,%esp
f0109ca1:	68 54 ed 12 f0       	push   $0xf012ed54
f0109ca6:	6a 27                	push   $0x27
f0109ca8:	68 c8 ed 12 f0       	push   $0xf012edc8
f0109cad:	e8 fd 71 ff ff       	call   f0100eaf <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	//tlb_invalidate(NULL, (void *)virtual_address);
	tlb_invalidate(directory, (void *)virtual_address);
f0109cb2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109cb5:	83 ec 08             	sub    $0x8,%esp
f0109cb8:	50                   	push   %eax
f0109cb9:	ff 75 08             	pushl  0x8(%ebp)
f0109cbc:	e8 62 ef ff ff       	call   f0108c23 <tlb_invalidate>
f0109cc1:	83 c4 10             	add    $0x10,%esp
}
f0109cc4:	90                   	nop
f0109cc5:	c9                   	leave  
f0109cc6:	c3                   	ret    

f0109cc7 <pt_get_page_permissions>:
//2) GET PAGE PERMISSIONS
//===============================
//Should get ALL page permissions of the given VA
//If the page table not exist, return -1
inline int pt_get_page_permissions(uint32* directory, uint32 virtual_address )
{
f0109cc7:	55                   	push   %ebp
f0109cc8:	89 e5                	mov    %esp,%ebp
f0109cca:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("pt_get_page_permissions() is not implemented yet!");
f0109ccd:	83 ec 04             	sub    $0x4,%esp
f0109cd0:	68 e4 ed 12 f0       	push   $0xf012ede4
f0109cd5:	6a 38                	push   $0x38
f0109cd7:	68 c8 ed 12 f0       	push   $0xf012edc8
f0109cdc:	e8 ce 71 ff ff       	call   f0100eaf <_panic>

f0109ce1 <pt_clear_page_table_entry>:
//Should clear the entire entry of the page table for the given VA
//If the page table not exist, return -1
//It's expected that the page table already exist. If not, the function should panic
//REMEMBER: to invalidate the TLB cache
inline void pt_clear_page_table_entry(uint32* directory, uint32 virtual_address)
{
f0109ce1:	55                   	push   %ebp
f0109ce2:	89 e5                	mov    %esp,%ebp
f0109ce4:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("pt_clear_page_table_entry() is not implemented yet!");
f0109ce7:	83 ec 04             	sub    $0x4,%esp
f0109cea:	68 18 ee 12 f0       	push   $0xf012ee18
f0109cef:	6a 46                	push   $0x46
f0109cf1:	68 c8 ed 12 f0       	push   $0xf012edc8
f0109cf6:	e8 b4 71 ff ff       	call   f0100eaf <_panic>

f0109cfb <virtual_to_physical>:
//1) ADDRESS CONVERTION (VA->PA)
//===============================
//return the physical address corresponding to given virtual_address
//If the page or the page table is not present, return -1
inline uint32 virtual_to_physical(uint32* directory, uint32 virtual_address)
{
f0109cfb:	55                   	push   %ebp
f0109cfc:	89 e5                	mov    %esp,%ebp
f0109cfe:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("Function is not implemented yet!");
f0109d01:	83 ec 04             	sub    $0x4,%esp
f0109d04:	68 4c ee 12 f0       	push   $0xf012ee4c
f0109d09:	6a 58                	push   $0x58
f0109d0b:	68 c8 ed 12 f0       	push   $0xf012edc8
f0109d10:	e8 9a 71 ff ff       	call   f0100eaf <_panic>

f0109d15 <physical_to_virtual>:
//===============================
//return the VIRTUAL address corresponding to given physical address
//If multiple VA's, return the first occurrence
//If not found, return 0xFFFFFFFF
inline uint32 physical_to_virtual(uint32* directory, uint32 physical_address)
{
f0109d15:	55                   	push   %ebp
f0109d16:	89 e5                	mov    %esp,%ebp
f0109d18:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("Function is not implemented yet!");
f0109d1b:	83 ec 04             	sub    $0x4,%esp
f0109d1e:	68 4c ee 12 f0       	push   $0xf012ee4c
f0109d23:	6a 65                	push   $0x65
f0109d25:	68 c8 ed 12 f0       	push   $0xf012edc8
f0109d2a:	e8 80 71 ff ff       	call   f0100eaf <_panic>

f0109d2f <num_of_references>:
//===============================
//3) NUMBER OF REFERENCES
//===============================
//return the number of page references on the frame at the given physical address
inline uint32 num_of_references(uint32 physical_address)
{
f0109d2f:	55                   	push   %ebp
f0109d30:	89 e5                	mov    %esp,%ebp
f0109d32:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#1: fill this function.
	//Comment the following line
//	panic("Function is not implemented yet!");
	struct FrameInfo* ptr_fi = to_frame_info(physical_address);
f0109d35:	83 ec 0c             	sub    $0xc,%esp
f0109d38:	ff 75 08             	pushl  0x8(%ebp)
f0109d3b:	e8 7b fe ff ff       	call   f0109bbb <to_frame_info>
f0109d40:	83 c4 10             	add    $0x10,%esp
f0109d43:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ptr_fi->references;
f0109d46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109d49:	8b 40 08             	mov    0x8(%eax),%eax
f0109d4c:	0f b7 c0             	movzwl %ax,%eax
}
f0109d4f:	c9                   	leave  
f0109d50:	c3                   	ret    

f0109d51 <alloc_page>:
//	0 on success,
//	1 if already mapped
//  E_NO_MEM if no memory
//HINT: remember to free the allocated frame if there is no space for the necessary page table
inline int alloc_page(uint32* directory, uint32 va, uint32 perms, bool set_to_zero)
{
f0109d51:	55                   	push   %ebp
f0109d52:	89 e5                	mov    %esp,%ebp
f0109d54:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#2: fill this function.
	//Comment the following line
	//panic("Function is not implemented yet!");
	uint32* ptr_table ;
	struct FrameInfo* ptr_fi = get_frame_info(directory, va, &ptr_table);
f0109d57:	83 ec 04             	sub    $0x4,%esp
f0109d5a:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109d5d:	50                   	push   %eax
f0109d5e:	ff 75 0c             	pushl  0xc(%ebp)
f0109d61:	ff 75 08             	pushl  0x8(%ebp)
f0109d64:	e8 67 f8 ff ff       	call   f01095d0 <get_frame_info>
f0109d69:	83 c4 10             	add    $0x10,%esp
f0109d6c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (ptr_fi != NULL) {
f0109d6f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d72:	85 c0                	test   %eax,%eax
f0109d74:	74 07                	je     f0109d7d <alloc_page+0x2c>
		return 1;
f0109d76:	b8 01 00 00 00       	mov    $0x1,%eax
f0109d7b:	eb 75                	jmp    f0109df2 <alloc_page+0xa1>
	}
	else {
		int ret = allocate_frame(&ptr_fi);
f0109d7d:	83 ec 0c             	sub    $0xc,%esp
f0109d80:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0109d83:	50                   	push   %eax
f0109d84:	e8 bc f2 ff ff       	call   f0109045 <allocate_frame>
f0109d89:	83 c4 10             	add    $0x10,%esp
f0109d8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (ret == E_NO_MEM) {
f0109d8f:	83 7d f4 fc          	cmpl   $0xfffffffc,-0xc(%ebp)
f0109d93:	75 07                	jne    f0109d9c <alloc_page+0x4b>
			return E_NO_MEM;
f0109d95:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f0109d9a:	eb 56                	jmp    f0109df2 <alloc_page+0xa1>
		}
		ret = map_frame(directory, ptr_fi, va, perms);
f0109d9c:	8b 55 10             	mov    0x10(%ebp),%edx
f0109d9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109da2:	52                   	push   %edx
f0109da3:	ff 75 0c             	pushl  0xc(%ebp)
f0109da6:	50                   	push   %eax
f0109da7:	ff 75 08             	pushl  0x8(%ebp)
f0109daa:	e8 37 f7 ff ff       	call   f01094e6 <map_frame>
f0109daf:	83 c4 10             	add    $0x10,%esp
f0109db2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (ret == E_NO_MEM) {
f0109db5:	83 7d f4 fc          	cmpl   $0xfffffffc,-0xc(%ebp)
f0109db9:	75 16                	jne    f0109dd1 <alloc_page+0x80>
			free_frame(ptr_fi);
f0109dbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109dbe:	83 ec 0c             	sub    $0xc,%esp
f0109dc1:	50                   	push   %eax
f0109dc2:	e8 a6 f3 ff ff       	call   f010916d <free_frame>
f0109dc7:	83 c4 10             	add    $0x10,%esp
			return E_NO_MEM;
f0109dca:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f0109dcf:	eb 21                	jmp    f0109df2 <alloc_page+0xa1>
		}
		if (set_to_zero) {
f0109dd1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0109dd5:	74 16                	je     f0109ded <alloc_page+0x9c>
			memset((void*)va, 0, PAGE_SIZE);
f0109dd7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109dda:	83 ec 04             	sub    $0x4,%esp
f0109ddd:	68 00 10 00 00       	push   $0x1000
f0109de2:	6a 00                	push   $0x0
f0109de4:	50                   	push   %eax
f0109de5:	e8 81 0e 01 00       	call   f011ac6b <memset>
f0109dea:	83 c4 10             	add    $0x10,%esp
		}
		return 0;
f0109ded:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0109df2:	c9                   	leave  
f0109df3:	c3                   	ret    

f0109df4 <alloc_shared_page>:
//Return
//	0 on success,
//  E_NO_MEM if no memory
//HINT: remember to free the allocated frame if there is no space for the necessary page table
inline int alloc_shared_page(uint32* page_dir1, uint32 va1,uint32* page_dir2, uint32 va2, uint32 perms)
{
f0109df4:	55                   	push   %ebp
f0109df5:	89 e5                	mov    %esp,%ebp
f0109df7:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("Function is not implemented yet!");
f0109dfa:	83 ec 04             	sub    $0x4,%esp
f0109dfd:	68 4c ee 12 f0       	push   $0xf012ee4c
f0109e02:	68 a9 00 00 00       	push   $0xa9
f0109e07:	68 c8 ed 12 f0       	push   $0xf012edc8
f0109e0c:	e8 9e 70 ff ff       	call   f0100eaf <_panic>

f0109e11 <del_page_table>:
//	1. removing the link between the directory and the table and
//	2. adding the frame of the table to the free frame list.

//REMEMBER: to invalidate the TLB cache
inline void del_page_table(uint32* page_dir, uint32 va)
{
f0109e11:	55                   	push   %ebp
f0109e12:	89 e5                	mov    %esp,%ebp
f0109e14:	83 ec 18             	sub    $0x18,%esp
	//Comment the following line
	//panic("Function is not implemented yet!");

	// get the page table of the given virtual address
	uint32 * ptr_page_table ;
	get_page_table(ptr_page_directory, va, &ptr_page_table);
f0109e17:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0109e1c:	83 ec 04             	sub    $0x4,%esp
f0109e1f:	8d 55 ec             	lea    -0x14(%ebp),%edx
f0109e22:	52                   	push   %edx
f0109e23:	ff 75 0c             	pushl  0xc(%ebp)
f0109e26:	50                   	push   %eax
f0109e27:	e8 2a f4 ff ff       	call   f0109256 <get_page_table>
f0109e2c:	83 c4 10             	add    $0x10,%esp

	if (ptr_page_table == NULL)
f0109e2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109e32:	85 c0                	test   %eax,%eax
f0109e34:	74 39                	je     f0109e6f <del_page_table+0x5e>
		return ;

#if USE_KHEAP
	// directly remove the page table from the kernel heap
	kfree(ptr_page_table);
f0109e36:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109e39:	83 ec 0c             	sub    $0xc,%esp
f0109e3c:	50                   	push   %eax
f0109e3d:	e8 11 fd ff ff       	call   f0109b53 <kfree>
f0109e42:	83 c4 10             	add    $0x10,%esp
	table_frame_info->references = 0;
	free_frame(table_frame_info);
#endif

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0109e45:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e48:	c1 e8 16             	shr    $0x16,%eax
f0109e4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_page_directory[dir_index] = 0;
f0109e4e:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0109e53:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109e56:	c1 e2 02             	shl    $0x2,%edx
f0109e59:	01 d0                	add    %edx,%eax
f0109e5b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109e61:	0f 20 d8             	mov    %cr3,%eax
f0109e64:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109e67:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e6a:	0f 22 d8             	mov    %eax,%cr3
f0109e6d:	eb 01                	jmp    f0109e70 <del_page_table+0x5f>
	// get the page table of the given virtual address
	uint32 * ptr_page_table ;
	get_page_table(ptr_page_directory, va, &ptr_page_table);

	if (ptr_page_table == NULL)
		return ;
f0109e6f:	90                   	nop
	uint32 dir_index = PDX(va);
	ptr_page_directory[dir_index] = 0;

	//clear the TLB cache
	tlbflush();
}
f0109e70:	c9                   	leave  
f0109e71:	c3                   	ret    

f0109e72 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* directory, uint32 virtual_address)
{
f0109e72:	55                   	push   %ebp
f0109e73:	89 e5                	mov    %esp,%ebp
	return ( (directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0109e75:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e78:	c1 e8 16             	shr    $0x16,%eax
f0109e7b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109e82:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e85:	01 d0                	add    %edx,%eax
f0109e87:	8b 00                	mov    (%eax),%eax
f0109e89:	83 e0 20             	and    $0x20,%eax
f0109e8c:	85 c0                	test   %eax,%eax
f0109e8e:	0f 95 c0             	setne  %al
f0109e91:	0f b6 c0             	movzbl %al,%eax
}
f0109e94:	5d                   	pop    %ebp
f0109e95:	c3                   	ret    

f0109e96 <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* directory, uint32 virtual_address)
{
f0109e96:	55                   	push   %ebp
f0109e97:	89 e5                	mov    %esp,%ebp
f0109e99:	83 ec 08             	sub    $0x8,%esp
	directory[PDX(virtual_address)] &= (~PERM_USED);
f0109e9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e9f:	c1 e8 16             	shr    $0x16,%eax
f0109ea2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109ea9:	8b 45 08             	mov    0x8(%ebp),%eax
f0109eac:	01 d0                	add    %edx,%eax
f0109eae:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109eb1:	c1 ea 16             	shr    $0x16,%edx
f0109eb4:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0109ebb:	8b 55 08             	mov    0x8(%ebp),%edx
f0109ebe:	01 ca                	add    %ecx,%edx
f0109ec0:	8b 12                	mov    (%edx),%edx
f0109ec2:	83 e2 df             	and    $0xffffffdf,%edx
f0109ec5:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109ec7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109eca:	83 ec 08             	sub    $0x8,%esp
f0109ecd:	50                   	push   %eax
f0109ece:	6a 00                	push   $0x0
f0109ed0:	e8 4e ed ff ff       	call   f0108c23 <tlb_invalidate>
f0109ed5:	83 c4 10             	add    $0x10,%esp
}
f0109ed8:	90                   	nop
f0109ed9:	c9                   	leave  
f0109eda:	c3                   	ret    

f0109edb <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* directory, uint32 virtual_address)
{
f0109edb:	55                   	push   %ebp
f0109edc:	89 e5                	mov    %esp,%ebp
f0109ede:	83 ec 10             	sub    $0x10,%esp
	directory[PDX(virtual_address)] = 0 ;
f0109ee1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109ee4:	c1 e8 16             	shr    $0x16,%eax
f0109ee7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109eee:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ef1:	01 d0                	add    %edx,%eax
f0109ef3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109ef9:	0f 20 d8             	mov    %cr3,%eax
f0109efc:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109eff:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0109f02:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0109f05:	90                   	nop
f0109f06:	c9                   	leave  
f0109f07:	c3                   	ret    

f0109f08 <env_page_ws_list_create_element>:
//==============================
// [1] CREATE A NEW WS ELEMENT
//==============================
//If failed to create a new one, kernel should panic()!
inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f0109f08:	55                   	push   %ebp
f0109f09:	89 e5                	mov    %esp,%ebp
f0109f0b:	83 ec 18             	sub    $0x18,%esp
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f0109f0e:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0109f15:	76 16                	jbe    f0109f2d <env_page_ws_list_create_element+0x25>
f0109f17:	68 70 ee 12 f0       	push   $0xf012ee70
f0109f1c:	68 a3 ee 12 f0       	push   $0xf012eea3
f0109f21:	6a 16                	push   $0x16
f0109f23:	68 b8 ee 12 f0       	push   $0xf012eeb8
f0109f28:	e8 82 6f ff ff       	call   f0100eaf <_panic>
	struct WorkingSetElement *wse = kmalloc(sizeof(struct WorkingSetElement)) ;
f0109f2d:	83 ec 0c             	sub    $0xc,%esp
f0109f30:	6a 18                	push   $0x18
f0109f32:	e8 02 fc ff ff       	call   f0109b39 <kmalloc>
f0109f37:	83 c4 10             	add    $0x10,%esp
f0109f3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (wse == NULL)
f0109f3d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109f41:	75 14                	jne    f0109f57 <env_page_ws_list_create_element+0x4f>
	{
		panic("can't create a new WS element");
f0109f43:	83 ec 04             	sub    $0x4,%esp
f0109f46:	68 d7 ee 12 f0       	push   $0xf012eed7
f0109f4b:	6a 1a                	push   $0x1a
f0109f4d:	68 b8 ee 12 f0       	push   $0xf012eeb8
f0109f52:	e8 58 6f ff ff       	call   f0100eaf <_panic>
	}
	wse->virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE);
f0109f57:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109f5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109f5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f60:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109f65:	89 c2                	mov    %eax,%edx
f0109f67:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109f6a:	89 10                	mov    %edx,(%eax)
	wse->sweeps_counter = 0;
f0109f6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109f6f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	wse->time_stamp = 0x00000000;
f0109f76:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109f79:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	return wse;
f0109f80:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109f83:	c9                   	leave  
f0109f84:	c3                   	ret    

f0109f85 <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109f85:	55                   	push   %ebp
f0109f86:	89 e5                	mov    %esp,%ebp
f0109f88:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109f8b:	83 ec 0c             	sub    $0xc,%esp
f0109f8e:	6a 02                	push   $0x2
f0109f90:	e8 90 58 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f0109f95:	83 c4 10             	add    $0x10,%esp
f0109f98:	85 c0                	test   %eax,%eax
f0109f9a:	0f 84 e5 03 00 00    	je     f010a385 <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f0109fa0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f0109fa7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109fae:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fb1:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109fb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109fba:	e9 3b 02 00 00       	jmp    f010a1fa <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109fbf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fc2:	8b 00                	mov    (%eax),%eax
f0109fc4:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109fc7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109fca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109fcf:	89 c2                	mov    %eax,%edx
f0109fd1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109fd4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109fd7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109fda:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109fdf:	39 c2                	cmp    %eax,%edx
f0109fe1:	0f 85 07 02 00 00    	jne    f010a1ee <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f0109fe7:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fea:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109ff0:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f0109ff3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ff6:	8b 10                	mov    (%eax),%edx
f0109ff8:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ffb:	8b 40 64             	mov    0x64(%eax),%eax
f0109ffe:	83 ec 08             	sub    $0x8,%esp
f010a001:	52                   	push   %edx
f010a002:	50                   	push   %eax
f010a003:	e8 4a f6 ff ff       	call   f0109652 <unmap_frame>
f010a008:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f010a00b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a00f:	75 14                	jne    f010a025 <env_page_ws_invalidate+0xa0>
f010a011:	83 ec 04             	sub    $0x4,%esp
f010a014:	68 f5 ee 12 f0       	push   $0xf012eef5
f010a019:	6a 2e                	push   $0x2e
f010a01b:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010a020:	e8 8a 6e ff ff       	call   f0100eaf <_panic>
f010a025:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a028:	8b 40 10             	mov    0x10(%eax),%eax
f010a02b:	85 c0                	test   %eax,%eax
f010a02d:	74 11                	je     f010a040 <env_page_ws_invalidate+0xbb>
f010a02f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a032:	8b 40 10             	mov    0x10(%eax),%eax
f010a035:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a038:	8b 52 14             	mov    0x14(%edx),%edx
f010a03b:	89 50 14             	mov    %edx,0x14(%eax)
f010a03e:	eb 0f                	jmp    f010a04f <env_page_ws_invalidate+0xca>
f010a040:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a043:	8b 50 14             	mov    0x14(%eax),%edx
f010a046:	8b 45 08             	mov    0x8(%ebp),%eax
f010a049:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010a04f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a052:	8b 40 14             	mov    0x14(%eax),%eax
f010a055:	85 c0                	test   %eax,%eax
f010a057:	74 11                	je     f010a06a <env_page_ws_invalidate+0xe5>
f010a059:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a05c:	8b 40 14             	mov    0x14(%eax),%eax
f010a05f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a062:	8b 52 10             	mov    0x10(%edx),%edx
f010a065:	89 50 10             	mov    %edx,0x10(%eax)
f010a068:	eb 0f                	jmp    f010a079 <env_page_ws_invalidate+0xf4>
f010a06a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a06d:	8b 50 10             	mov    0x10(%eax),%edx
f010a070:	8b 45 08             	mov    0x8(%ebp),%eax
f010a073:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010a079:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a07c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a083:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a086:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a08d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a090:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010a096:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a099:	8b 45 08             	mov    0x8(%ebp),%eax
f010a09c:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010a0a2:	83 ec 0c             	sub    $0xc,%esp
f010a0a5:	ff 75 f0             	pushl  -0x10(%ebp)
f010a0a8:	e8 a6 fa ff ff       	call   f0109b53 <kfree>
f010a0ad:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f010a0b0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a0b4:	0f 84 2b 01 00 00    	je     f010a1e5 <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010a0ba:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a0be:	75 14                	jne    f010a0d4 <env_page_ws_invalidate+0x14f>
f010a0c0:	83 ec 04             	sub    $0x4,%esp
f010a0c3:	68 f5 ee 12 f0       	push   $0xf012eef5
f010a0c8:	6a 34                	push   $0x34
f010a0ca:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010a0cf:	e8 db 6d ff ff       	call   f0100eaf <_panic>
f010a0d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0d7:	8b 40 10             	mov    0x10(%eax),%eax
f010a0da:	85 c0                	test   %eax,%eax
f010a0dc:	74 11                	je     f010a0ef <env_page_ws_invalidate+0x16a>
f010a0de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0e1:	8b 40 10             	mov    0x10(%eax),%eax
f010a0e4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a0e7:	8b 52 14             	mov    0x14(%edx),%edx
f010a0ea:	89 50 14             	mov    %edx,0x14(%eax)
f010a0ed:	eb 0f                	jmp    f010a0fe <env_page_ws_invalidate+0x179>
f010a0ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0f2:	8b 50 14             	mov    0x14(%eax),%edx
f010a0f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0f8:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010a0fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a101:	8b 40 14             	mov    0x14(%eax),%eax
f010a104:	85 c0                	test   %eax,%eax
f010a106:	74 11                	je     f010a119 <env_page_ws_invalidate+0x194>
f010a108:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a10b:	8b 40 14             	mov    0x14(%eax),%eax
f010a10e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a111:	8b 52 10             	mov    0x10(%edx),%edx
f010a114:	89 50 10             	mov    %edx,0x10(%eax)
f010a117:	eb 0f                	jmp    f010a128 <env_page_ws_invalidate+0x1a3>
f010a119:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a11c:	8b 50 10             	mov    0x10(%eax),%edx
f010a11f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a122:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010a128:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a12b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a132:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a135:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a13c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a13f:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010a145:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a148:	8b 45 08             	mov    0x8(%ebp),%eax
f010a14b:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010a151:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a155:	75 14                	jne    f010a16b <env_page_ws_invalidate+0x1e6>
f010a157:	83 ec 04             	sub    $0x4,%esp
f010a15a:	68 14 ef 12 f0       	push   $0xf012ef14
f010a15f:	6a 35                	push   $0x35
f010a161:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010a166:	e8 44 6d ff ff       	call   f0100eaf <_panic>
f010a16b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a16e:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010a174:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a177:	89 50 14             	mov    %edx,0x14(%eax)
f010a17a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a17d:	8b 40 14             	mov    0x14(%eax),%eax
f010a180:	85 c0                	test   %eax,%eax
f010a182:	74 11                	je     f010a195 <env_page_ws_invalidate+0x210>
f010a184:	8b 45 08             	mov    0x8(%ebp),%eax
f010a187:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a18d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a190:	89 50 10             	mov    %edx,0x10(%eax)
f010a193:	eb 0c                	jmp    f010a1a1 <env_page_ws_invalidate+0x21c>
f010a195:	8b 45 08             	mov    0x8(%ebp),%eax
f010a198:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a19b:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010a1a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a1a7:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010a1ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a1b0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a1b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1ba:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010a1c0:	8d 50 01             	lea    0x1(%eax),%edx
f010a1c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1c6:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010a1cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a1cf:	8b 10                	mov    (%eax),%edx
f010a1d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1d4:	8b 40 64             	mov    0x64(%eax),%eax
f010a1d7:	6a 00                	push   $0x0
f010a1d9:	6a 01                	push   $0x1
f010a1db:	52                   	push   %edx
f010a1dc:	50                   	push   %eax
f010a1dd:	e8 20 fa ff ff       	call   f0109c02 <pt_set_page_permissions>
f010a1e2:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f010a1e5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010a1ec:	eb 43                	jmp    f010a231 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a1ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1f1:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a1f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a1fa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a1fe:	74 08                	je     f010a208 <env_page_ws_invalidate+0x283>
f010a200:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a203:	8b 40 10             	mov    0x10(%eax),%eax
f010a206:	eb 05                	jmp    f010a20d <env_page_ws_invalidate+0x288>
f010a208:	b8 00 00 00 00       	mov    $0x0,%eax
f010a20d:	8b 55 08             	mov    0x8(%ebp),%edx
f010a210:	89 82 70 05 00 00    	mov    %eax,0x570(%edx)
f010a216:	8b 45 08             	mov    0x8(%ebp),%eax
f010a219:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a21f:	85 c0                	test   %eax,%eax
f010a221:	0f 85 98 fd ff ff    	jne    f0109fbf <env_page_ws_invalidate+0x3a>
f010a227:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a22b:	0f 85 8e fd ff ff    	jne    f0109fbf <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f010a231:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a235:	0f 85 a4 02 00 00    	jne    f010a4df <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010a23b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a242:	8b 45 08             	mov    0x8(%ebp),%eax
f010a245:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a24b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a24e:	e9 f6 00 00 00       	jmp    f010a349 <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a253:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a256:	8b 00                	mov    (%eax),%eax
f010a258:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a25b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a25e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a263:	89 c2                	mov    %eax,%edx
f010a265:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a268:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a26b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a26e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a273:	39 c2                	cmp    %eax,%edx
f010a275:	0f 85 c2 00 00 00    	jne    f010a33d <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a27b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a27e:	8b 10                	mov    (%eax),%edx
f010a280:	8b 45 08             	mov    0x8(%ebp),%eax
f010a283:	8b 40 64             	mov    0x64(%eax),%eax
f010a286:	83 ec 08             	sub    $0x8,%esp
f010a289:	52                   	push   %edx
f010a28a:	50                   	push   %eax
f010a28b:	e8 c2 f3 ff ff       	call   f0109652 <unmap_frame>
f010a290:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010a293:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a297:	75 14                	jne    f010a2ad <env_page_ws_invalidate+0x328>
f010a299:	83 ec 04             	sub    $0x4,%esp
f010a29c:	68 f5 ee 12 f0       	push   $0xf012eef5
f010a2a1:	6a 45                	push   $0x45
f010a2a3:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010a2a8:	e8 02 6c ff ff       	call   f0100eaf <_panic>
f010a2ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2b0:	8b 40 10             	mov    0x10(%eax),%eax
f010a2b3:	85 c0                	test   %eax,%eax
f010a2b5:	74 11                	je     f010a2c8 <env_page_ws_invalidate+0x343>
f010a2b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2ba:	8b 40 10             	mov    0x10(%eax),%eax
f010a2bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a2c0:	8b 52 14             	mov    0x14(%edx),%edx
f010a2c3:	89 50 14             	mov    %edx,0x14(%eax)
f010a2c6:	eb 0f                	jmp    f010a2d7 <env_page_ws_invalidate+0x352>
f010a2c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2cb:	8b 50 14             	mov    0x14(%eax),%edx
f010a2ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2d1:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010a2d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2da:	8b 40 14             	mov    0x14(%eax),%eax
f010a2dd:	85 c0                	test   %eax,%eax
f010a2df:	74 11                	je     f010a2f2 <env_page_ws_invalidate+0x36d>
f010a2e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2e4:	8b 40 14             	mov    0x14(%eax),%eax
f010a2e7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a2ea:	8b 52 10             	mov    0x10(%edx),%edx
f010a2ed:	89 50 10             	mov    %edx,0x10(%eax)
f010a2f0:	eb 0f                	jmp    f010a301 <env_page_ws_invalidate+0x37c>
f010a2f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2f5:	8b 50 10             	mov    0x10(%eax),%edx
f010a2f8:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2fb:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010a301:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a304:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a30b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a30e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a315:	8b 45 08             	mov    0x8(%ebp),%eax
f010a318:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010a31e:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a321:	8b 45 08             	mov    0x8(%ebp),%eax
f010a324:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)

					kfree(ptr_WS_element);
f010a32a:	83 ec 0c             	sub    $0xc,%esp
f010a32d:	ff 75 f0             	pushl  -0x10(%ebp)
f010a330:	e8 1e f8 ff ff       	call   f0109b53 <kfree>
f010a335:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010a338:	e9 a2 01 00 00       	jmp    f010a4df <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a33d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a340:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a346:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a349:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a34d:	74 08                	je     f010a357 <env_page_ws_invalidate+0x3d2>
f010a34f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a352:	8b 40 10             	mov    0x10(%eax),%eax
f010a355:	eb 05                	jmp    f010a35c <env_page_ws_invalidate+0x3d7>
f010a357:	b8 00 00 00 00       	mov    $0x0,%eax
f010a35c:	8b 55 08             	mov    0x8(%ebp),%edx
f010a35f:	89 82 80 05 00 00    	mov    %eax,0x580(%edx)
f010a365:	8b 45 08             	mov    0x8(%ebp),%eax
f010a368:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a36e:	85 c0                	test   %eax,%eax
f010a370:	0f 85 dd fe ff ff    	jne    f010a253 <env_page_ws_invalidate+0x2ce>
f010a376:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a37a:	0f 85 d3 fe ff ff    	jne    f010a253 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f010a380:	e9 5a 01 00 00       	jmp    f010a4df <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a385:	8b 45 08             	mov    0x8(%ebp),%eax
f010a388:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010a38e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a391:	e9 10 01 00 00       	jmp    f010a4a6 <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a396:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a399:	8b 00                	mov    (%eax),%eax
f010a39b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a39e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a3a1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a3a6:	89 c2                	mov    %eax,%edx
f010a3a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a3ab:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a3ae:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a3b1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a3b6:	39 c2                	cmp    %eax,%edx
f010a3b8:	0f 85 dc 00 00 00    	jne    f010a49a <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f010a3be:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3c1:	8b 10                	mov    (%eax),%edx
f010a3c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3c6:	8b 40 64             	mov    0x64(%eax),%eax
f010a3c9:	83 ec 08             	sub    $0x8,%esp
f010a3cc:	52                   	push   %edx
f010a3cd:	50                   	push   %eax
f010a3ce:	e8 7f f2 ff ff       	call   f0109652 <unmap_frame>
f010a3d3:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010a3d6:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3d9:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010a3df:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a3e2:	75 0f                	jne    f010a3f3 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010a3e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3e7:	8b 50 10             	mov    0x10(%eax),%edx
f010a3ea:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3ed:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010a3f3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a3f7:	75 14                	jne    f010a40d <env_page_ws_invalidate+0x488>
f010a3f9:	83 ec 04             	sub    $0x4,%esp
f010a3fc:	68 f5 ee 12 f0       	push   $0xf012eef5
f010a401:	6a 5b                	push   $0x5b
f010a403:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010a408:	e8 a2 6a ff ff       	call   f0100eaf <_panic>
f010a40d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a410:	8b 40 10             	mov    0x10(%eax),%eax
f010a413:	85 c0                	test   %eax,%eax
f010a415:	74 11                	je     f010a428 <env_page_ws_invalidate+0x4a3>
f010a417:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a41a:	8b 40 10             	mov    0x10(%eax),%eax
f010a41d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a420:	8b 52 14             	mov    0x14(%edx),%edx
f010a423:	89 50 14             	mov    %edx,0x14(%eax)
f010a426:	eb 0f                	jmp    f010a437 <env_page_ws_invalidate+0x4b2>
f010a428:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a42b:	8b 50 14             	mov    0x14(%eax),%edx
f010a42e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a431:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010a437:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a43a:	8b 40 14             	mov    0x14(%eax),%eax
f010a43d:	85 c0                	test   %eax,%eax
f010a43f:	74 11                	je     f010a452 <env_page_ws_invalidate+0x4cd>
f010a441:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a444:	8b 40 14             	mov    0x14(%eax),%eax
f010a447:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a44a:	8b 52 10             	mov    0x10(%edx),%edx
f010a44d:	89 50 10             	mov    %edx,0x10(%eax)
f010a450:	eb 0f                	jmp    f010a461 <env_page_ws_invalidate+0x4dc>
f010a452:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a455:	8b 50 10             	mov    0x10(%eax),%edx
f010a458:	8b 45 08             	mov    0x8(%ebp),%eax
f010a45b:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010a461:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a464:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a46b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a46e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a475:	8b 45 08             	mov    0x8(%ebp),%eax
f010a478:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a47e:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a481:	8b 45 08             	mov    0x8(%ebp),%eax
f010a484:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)

				kfree(wse);
f010a48a:	83 ec 0c             	sub    $0xc,%esp
f010a48d:	ff 75 ec             	pushl  -0x14(%ebp)
f010a490:	e8 be f6 ff ff       	call   f0109b53 <kfree>
f010a495:	83 c4 10             	add    $0x10,%esp

				break;
f010a498:	eb 45                	jmp    f010a4df <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a49a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a49d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a4a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a4a6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a4aa:	74 08                	je     f010a4b4 <env_page_ws_invalidate+0x52f>
f010a4ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a4af:	8b 40 10             	mov    0x10(%eax),%eax
f010a4b2:	eb 05                	jmp    f010a4b9 <env_page_ws_invalidate+0x534>
f010a4b4:	b8 00 00 00 00       	mov    $0x0,%eax
f010a4b9:	8b 55 08             	mov    0x8(%ebp),%edx
f010a4bc:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010a4c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4c5:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a4cb:	85 c0                	test   %eax,%eax
f010a4cd:	0f 85 c3 fe ff ff    	jne    f010a396 <env_page_ws_invalidate+0x411>
f010a4d3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a4d7:	0f 85 b9 fe ff ff    	jne    f010a396 <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010a4dd:	eb 00                	jmp    f010a4df <env_page_ws_invalidate+0x55a>
f010a4df:	90                   	nop
f010a4e0:	c9                   	leave  
f010a4e1:	c3                   	ret    

f010a4e2 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010a4e2:	55                   	push   %ebp
f010a4e3:	89 e5                	mov    %esp,%ebp
f010a4e5:	53                   	push   %ebx
f010a4e6:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a4e9:	83 ec 0c             	sub    $0xc,%esp
f010a4ec:	6a 02                	push   $0x2
f010a4ee:	e8 32 53 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f010a4f3:	83 c4 10             	add    $0x10,%esp
f010a4f6:	85 c0                	test   %eax,%eax
f010a4f8:	0f 84 fe 00 00 00    	je     f010a5fc <env_page_ws_print+0x11a>
	{
		int i = 0;
f010a4fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010a505:	83 ec 0c             	sub    $0xc,%esp
f010a508:	68 37 ef 12 f0       	push   $0xf012ef37
f010a50d:	e8 4a 76 ff ff       	call   f0101b5c <cprintf>
f010a512:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a515:	8b 45 08             	mov    0x8(%ebp),%eax
f010a518:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a51e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a521:	eb 2c                	jmp    f010a54f <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a523:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a526:	8b 10                	mov    (%eax),%edx
f010a528:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a52b:	8d 48 01             	lea    0x1(%eax),%ecx
f010a52e:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a531:	83 ec 04             	sub    $0x4,%esp
f010a534:	52                   	push   %edx
f010a535:	50                   	push   %eax
f010a536:	68 51 ef 12 f0       	push   $0xf012ef51
f010a53b:	e8 1c 76 ff ff       	call   f0101b5c <cprintf>
f010a540:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a543:	8b 45 08             	mov    0x8(%ebp),%eax
f010a546:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a54c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a54f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a553:	74 08                	je     f010a55d <env_page_ws_print+0x7b>
f010a555:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a558:	8b 40 10             	mov    0x10(%eax),%eax
f010a55b:	eb 05                	jmp    f010a562 <env_page_ws_print+0x80>
f010a55d:	b8 00 00 00 00       	mov    $0x0,%eax
f010a562:	8b 55 08             	mov    0x8(%ebp),%edx
f010a565:	89 82 70 05 00 00    	mov    %eax,0x570(%edx)
f010a56b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a56e:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a574:	85 c0                	test   %eax,%eax
f010a576:	75 ab                	jne    f010a523 <env_page_ws_print+0x41>
f010a578:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a57c:	75 a5                	jne    f010a523 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f010a57e:	83 ec 0c             	sub    $0xc,%esp
f010a581:	68 59 ef 12 f0       	push   $0xf012ef59
f010a586:	e8 d1 75 ff ff       	call   f0101b5c <cprintf>
f010a58b:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a58e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a591:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a597:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a59a:	eb 2c                	jmp    f010a5c8 <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a59c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a59f:	8b 10                	mov    (%eax),%edx
f010a5a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5a4:	8d 48 01             	lea    0x1(%eax),%ecx
f010a5a7:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a5aa:	83 ec 04             	sub    $0x4,%esp
f010a5ad:	52                   	push   %edx
f010a5ae:	50                   	push   %eax
f010a5af:	68 51 ef 12 f0       	push   $0xf012ef51
f010a5b4:	e8 a3 75 ff ff       	call   f0101b5c <cprintf>
f010a5b9:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a5bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5bf:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a5c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a5c8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a5cc:	74 08                	je     f010a5d6 <env_page_ws_print+0xf4>
f010a5ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a5d1:	8b 40 10             	mov    0x10(%eax),%eax
f010a5d4:	eb 05                	jmp    f010a5db <env_page_ws_print+0xf9>
f010a5d6:	b8 00 00 00 00       	mov    $0x0,%eax
f010a5db:	8b 55 08             	mov    0x8(%ebp),%edx
f010a5de:	89 82 80 05 00 00    	mov    %eax,0x580(%edx)
f010a5e4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5e7:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a5ed:	85 c0                	test   %eax,%eax
f010a5ef:	75 ab                	jne    f010a59c <env_page_ws_print+0xba>
f010a5f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a5f5:	75 a5                	jne    f010a59c <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a5f7:	e9 5a 01 00 00       	jmp    f010a756 <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010a5fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010a603:	83 ec 0c             	sub    $0xc,%esp
f010a606:	68 74 ef 12 f0       	push   $0xf012ef74
f010a60b:	e8 4c 75 ff ff       	call   f0101b5c <cprintf>
f010a610:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010a613:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a61a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a61d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010a623:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a626:	e9 d1 00 00 00       	jmp    f010a6fc <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f010a62b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a62e:	8b 00                	mov    (%eax),%eax
f010a630:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f010a633:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a636:	8b 40 08             	mov    0x8(%eax),%eax
f010a639:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010a63c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a63f:	8b 40 64             	mov    0x64(%eax),%eax
f010a642:	83 ec 08             	sub    $0x8,%esp
f010a645:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a648:	50                   	push   %eax
f010a649:	e8 79 f6 ff ff       	call   f0109cc7 <pt_get_page_permissions>
f010a64e:	83 c4 10             	add    $0x10,%esp
f010a651:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010a654:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a657:	83 e0 40             	and    $0x40,%eax
f010a65a:	85 c0                	test   %eax,%eax
f010a65c:	0f 95 c0             	setne  %al
f010a65f:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010a662:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a665:	83 e0 20             	and    $0x20,%eax
f010a668:	85 c0                	test   %eax,%eax
f010a66a:	0f 95 c0             	setne  %al
f010a66d:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010a670:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a673:	25 00 02 00 00       	and    $0x200,%eax
f010a678:	85 c0                	test   %eax,%eax
f010a67a:	0f 95 c0             	setne  %al
f010a67d:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f010a680:	83 ec 04             	sub    $0x4,%esp
f010a683:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a686:	ff 75 ec             	pushl  -0x14(%ebp)
f010a689:	68 7e ef 12 f0       	push   $0xf012ef7e
f010a68e:	e8 c9 74 ff ff       	call   f0101b5c <cprintf>
f010a693:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f010a696:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a699:	8b 58 0c             	mov    0xc(%eax),%ebx
f010a69c:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f010a6a0:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010a6a4:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f010a6a8:	83 ec 08             	sub    $0x8,%esp
f010a6ab:	53                   	push   %ebx
f010a6ac:	ff 75 e0             	pushl  -0x20(%ebp)
f010a6af:	51                   	push   %ecx
f010a6b0:	52                   	push   %edx
f010a6b1:	50                   	push   %eax
f010a6b2:	68 88 ef 12 f0       	push   $0xf012ef88
f010a6b7:	e8 a0 74 ff ff       	call   f0101b5c <cprintf>
f010a6bc:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f010a6bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6c2:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010a6c8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a6cb:	75 10                	jne    f010a6dd <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f010a6cd:	83 ec 0c             	sub    $0xc,%esp
f010a6d0:	68 cf ef 12 f0       	push   $0xf012efcf
f010a6d5:	e8 82 74 ff ff       	call   f0101b5c <cprintf>
f010a6da:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a6dd:	83 ec 0c             	sub    $0xc,%esp
f010a6e0:	68 d4 ef 12 f0       	push   $0xf012efd4
f010a6e5:	e8 72 74 ff ff       	call   f0101b5c <cprintf>
f010a6ea:	83 c4 10             	add    $0x10,%esp
			i++;
f010a6ed:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a6f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6f3:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a6f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a6fc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a700:	74 08                	je     f010a70a <env_page_ws_print+0x228>
f010a702:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a705:	8b 40 10             	mov    0x10(%eax),%eax
f010a708:	eb 05                	jmp    f010a70f <env_page_ws_print+0x22d>
f010a70a:	b8 00 00 00 00       	mov    $0x0,%eax
f010a70f:	8b 55 08             	mov    0x8(%ebp),%edx
f010a712:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010a718:	8b 45 08             	mov    0x8(%ebp),%eax
f010a71b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a721:	85 c0                	test   %eax,%eax
f010a723:	0f 85 02 ff ff ff    	jne    f010a62b <env_page_ws_print+0x149>
f010a729:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a72d:	0f 85 f8 fe ff ff    	jne    f010a62b <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a733:	eb 13                	jmp    f010a748 <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010a735:	83 ec 0c             	sub    $0xc,%esp
f010a738:	68 d6 ef 12 f0       	push   $0xf012efd6
f010a73d:	e8 1a 74 ff ff       	call   f0101b5c <cprintf>
f010a742:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a745:	ff 45 ec             	incl   -0x14(%ebp)
f010a748:	8b 45 08             	mov    0x8(%ebp),%eax
f010a74b:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010a751:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a754:	77 df                	ja     f010a735 <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a756:	90                   	nop
f010a757:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a75a:	c9                   	leave  
f010a75b:	c3                   	ret    

f010a75c <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010a75c:	55                   	push   %ebp
f010a75d:	89 e5                	mov    %esp,%ebp
f010a75f:	53                   	push   %ebx
f010a760:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010a763:	83 ec 0c             	sub    $0xc,%esp
f010a766:	68 e8 ef 12 f0       	push   $0xf012efe8
f010a76b:	e8 ec 73 ff ff       	call   f0101b5c <cprintf>
f010a770:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010a773:	83 ec 0c             	sub    $0xc,%esp
f010a776:	68 1d f0 12 f0       	push   $0xf012f01d
f010a77b:	e8 dc 73 ff ff       	call   f0101b5c <cprintf>
f010a780:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a783:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a78a:	e9 16 01 00 00       	jmp    f010a8a5 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010a78f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a792:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a795:	89 d0                	mov    %edx,%eax
f010a797:	01 c0                	add    %eax,%eax
f010a799:	01 d0                	add    %edx,%eax
f010a79b:	c1 e0 03             	shl    $0x3,%eax
f010a79e:	01 c8                	add    %ecx,%eax
f010a7a0:	05 b8 00 00 00       	add    $0xb8,%eax
f010a7a5:	8a 00                	mov    (%eax),%al
f010a7a7:	84 c0                	test   %al,%al
f010a7a9:	74 43                	je     f010a7ee <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010a7ab:	83 ec 0c             	sub    $0xc,%esp
f010a7ae:	68 28 f0 12 f0       	push   $0xf012f028
f010a7b3:	e8 a4 73 ff ff       	call   f0101b5c <cprintf>
f010a7b8:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010a7bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7be:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a7c4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a7c7:	75 10                	jne    f010a7d9 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010a7c9:	83 ec 0c             	sub    $0xc,%esp
f010a7cc:	68 37 f0 12 f0       	push   $0xf012f037
f010a7d1:	e8 86 73 ff ff       	call   f0101b5c <cprintf>
f010a7d6:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a7d9:	83 ec 0c             	sub    $0xc,%esp
f010a7dc:	68 d4 ef 12 f0       	push   $0xf012efd4
f010a7e1:	e8 76 73 ff ff       	call   f0101b5c <cprintf>
f010a7e6:	83 c4 10             	add    $0x10,%esp
			continue;
f010a7e9:	e9 b4 00 00 00       	jmp    f010a8a2 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010a7ee:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a7f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7f4:	89 d0                	mov    %edx,%eax
f010a7f6:	01 c0                	add    %eax,%eax
f010a7f8:	01 d0                	add    %edx,%eax
f010a7fa:	c1 e0 03             	shl    $0x3,%eax
f010a7fd:	01 c8                	add    %ecx,%eax
f010a7ff:	05 b4 00 00 00       	add    $0xb4,%eax
f010a804:	8b 00                	mov    (%eax),%eax
f010a806:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010a809:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a80c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a80f:	89 d0                	mov    %edx,%eax
f010a811:	01 c0                	add    %eax,%eax
f010a813:	01 d0                	add    %edx,%eax
f010a815:	c1 e0 03             	shl    $0x3,%eax
f010a818:	01 c8                	add    %ecx,%eax
f010a81a:	05 b4 00 00 00       	add    $0xb4,%eax
f010a81f:	8b 00                	mov    (%eax),%eax
f010a821:	83 ec 04             	sub    $0x4,%esp
f010a824:	50                   	push   %eax
f010a825:	ff 75 f4             	pushl  -0xc(%ebp)
f010a828:	68 3d f0 12 f0       	push   $0xf012f03d
f010a82d:	e8 2a 73 ff ff       	call   f0101b5c <cprintf>
f010a832:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010a835:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a838:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a83b:	89 d0                	mov    %edx,%eax
f010a83d:	01 c0                	add    %eax,%eax
f010a83f:	01 d0                	add    %edx,%eax
f010a841:	c1 e0 03             	shl    $0x3,%eax
f010a844:	01 c8                	add    %ecx,%eax
f010a846:	05 bc 00 00 00       	add    $0xbc,%eax
f010a84b:	8b 18                	mov    (%eax),%ebx
f010a84d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a850:	8b 40 64             	mov    0x64(%eax),%eax
f010a853:	83 ec 08             	sub    $0x8,%esp
f010a856:	ff 75 f0             	pushl  -0x10(%ebp)
f010a859:	50                   	push   %eax
f010a85a:	e8 13 f6 ff ff       	call   f0109e72 <pd_is_table_used>
f010a85f:	83 c4 10             	add    $0x10,%esp
f010a862:	83 ec 04             	sub    $0x4,%esp
f010a865:	53                   	push   %ebx
f010a866:	50                   	push   %eax
f010a867:	68 54 f0 12 f0       	push   $0xf012f054
f010a86c:	e8 eb 72 ff ff       	call   f0101b5c <cprintf>
f010a871:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010a874:	8b 45 08             	mov    0x8(%ebp),%eax
f010a877:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a87d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a880:	75 10                	jne    f010a892 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010a882:	83 ec 0c             	sub    $0xc,%esp
f010a885:	68 cf ef 12 f0       	push   $0xf012efcf
f010a88a:	e8 cd 72 ff ff       	call   f0101b5c <cprintf>
f010a88f:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010a892:	83 ec 0c             	sub    $0xc,%esp
f010a895:	68 d4 ef 12 f0       	push   $0xf012efd4
f010a89a:	e8 bd 72 ff ff       	call   f0101b5c <cprintf>
f010a89f:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a8a2:	ff 45 f4             	incl   -0xc(%ebp)
f010a8a5:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a8a9:	0f 86 e0 fe ff ff    	jbe    f010a78f <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010a8af:	90                   	nop
f010a8b0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a8b3:	c9                   	leave  
f010a8b4:	c3                   	ret    

f010a8b5 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010a8b5:	55                   	push   %ebp
f010a8b6:	89 e5                	mov    %esp,%ebp
f010a8b8:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010a8bb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010a8c2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010a8c9:	eb 22                	jmp    f010a8ed <env_table_ws_get_size+0x38>
f010a8cb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a8ce:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010a8d1:	89 d0                	mov    %edx,%eax
f010a8d3:	01 c0                	add    %eax,%eax
f010a8d5:	01 d0                	add    %edx,%eax
f010a8d7:	c1 e0 03             	shl    $0x3,%eax
f010a8da:	01 c8                	add    %ecx,%eax
f010a8dc:	05 b8 00 00 00       	add    $0xb8,%eax
f010a8e1:	8a 00                	mov    (%eax),%al
f010a8e3:	84 c0                	test   %al,%al
f010a8e5:	75 03                	jne    f010a8ea <env_table_ws_get_size+0x35>
f010a8e7:	ff 45 f8             	incl   -0x8(%ebp)
f010a8ea:	ff 45 fc             	incl   -0x4(%ebp)
f010a8ed:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010a8f1:	7e d8                	jle    f010a8cb <env_table_ws_get_size+0x16>
	return counter;
f010a8f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010a8f6:	c9                   	leave  
f010a8f7:	c3                   	ret    

f010a8f8 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a8f8:	55                   	push   %ebp
f010a8f9:	89 e5                	mov    %esp,%ebp
f010a8fb:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010a8fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010a905:	eb 4e                	jmp    f010a955 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010a907:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a90a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a90d:	89 d0                	mov    %edx,%eax
f010a90f:	01 c0                	add    %eax,%eax
f010a911:	01 d0                	add    %edx,%eax
f010a913:	c1 e0 03             	shl    $0x3,%eax
f010a916:	01 c8                	add    %ecx,%eax
f010a918:	05 b4 00 00 00       	add    $0xb4,%eax
f010a91d:	8b 00                	mov    (%eax),%eax
f010a91f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a922:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a925:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a92a:	89 c2                	mov    %eax,%edx
f010a92c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a92f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a932:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a935:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a93a:	39 c2                	cmp    %eax,%edx
f010a93c:	75 14                	jne    f010a952 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010a93e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a941:	83 ec 08             	sub    $0x8,%esp
f010a944:	50                   	push   %eax
f010a945:	ff 75 08             	pushl  0x8(%ebp)
f010a948:	e8 bc 00 00 00       	call   f010aa09 <env_table_ws_clear_entry>
f010a94d:	83 c4 10             	add    $0x10,%esp
			break;
f010a950:	eb 09                	jmp    f010a95b <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010a952:	ff 45 f4             	incl   -0xc(%ebp)
f010a955:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a959:	7e ac                	jle    f010a907 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010a95b:	90                   	nop
f010a95c:	c9                   	leave  
f010a95d:	c3                   	ret    

f010a95e <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010a95e:	55                   	push   %ebp
f010a95f:	89 e5                	mov    %esp,%ebp
f010a961:	53                   	push   %ebx
f010a962:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a965:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a969:	76 19                	jbe    f010a984 <env_table_ws_set_entry+0x26>
f010a96b:	68 78 f0 12 f0       	push   $0xf012f078
f010a970:	68 a3 ee 12 f0       	push   $0xf012eea3
f010a975:	68 3e 01 00 00       	push   $0x13e
f010a97a:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010a97f:	e8 2b 65 ff ff       	call   f0100eaf <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010a984:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010a98b:	76 19                	jbe    f010a9a6 <env_table_ws_set_entry+0x48>
f010a98d:	68 70 ee 12 f0       	push   $0xf012ee70
f010a992:	68 a3 ee 12 f0       	push   $0xf012eea3
f010a997:	68 3f 01 00 00       	push   $0x13f
f010a99c:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010a9a1:	e8 09 65 ff ff       	call   f0100eaf <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010a9a6:	8b 45 10             	mov    0x10(%ebp),%eax
f010a9a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a9ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a9af:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a9b4:	89 c1                	mov    %eax,%ecx
f010a9b6:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010a9b9:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9bc:	89 d0                	mov    %edx,%eax
f010a9be:	01 c0                	add    %eax,%eax
f010a9c0:	01 d0                	add    %edx,%eax
f010a9c2:	c1 e0 03             	shl    $0x3,%eax
f010a9c5:	01 d8                	add    %ebx,%eax
f010a9c7:	05 b4 00 00 00       	add    $0xb4,%eax
f010a9cc:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010a9ce:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9d1:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9d4:	89 d0                	mov    %edx,%eax
f010a9d6:	01 c0                	add    %eax,%eax
f010a9d8:	01 d0                	add    %edx,%eax
f010a9da:	c1 e0 03             	shl    $0x3,%eax
f010a9dd:	01 c8                	add    %ecx,%eax
f010a9df:	05 b8 00 00 00       	add    $0xb8,%eax
f010a9e4:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x00000000;
f010a9e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9ea:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9ed:	89 d0                	mov    %edx,%eax
f010a9ef:	01 c0                	add    %eax,%eax
f010a9f1:	01 d0                	add    %edx,%eax
f010a9f3:	c1 e0 03             	shl    $0x3,%eax
f010a9f6:	01 c8                	add    %ecx,%eax
f010a9f8:	05 bc 00 00 00       	add    $0xbc,%eax
f010a9fd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return;
f010aa03:	90                   	nop
}
f010aa04:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010aa07:	c9                   	leave  
f010aa08:	c3                   	ret    

f010aa09 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010aa09:	55                   	push   %ebp
f010aa0a:	89 e5                	mov    %esp,%ebp
f010aa0c:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aa0f:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aa13:	76 19                	jbe    f010aa2e <env_table_ws_clear_entry+0x25>
f010aa15:	68 78 f0 12 f0       	push   $0xf012f078
f010aa1a:	68 a3 ee 12 f0       	push   $0xf012eea3
f010aa1f:	68 4a 01 00 00       	push   $0x14a
f010aa24:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010aa29:	e8 81 64 ff ff       	call   f0100eaf <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010aa2e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa31:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa34:	89 d0                	mov    %edx,%eax
f010aa36:	01 c0                	add    %eax,%eax
f010aa38:	01 d0                	add    %edx,%eax
f010aa3a:	c1 e0 03             	shl    $0x3,%eax
f010aa3d:	01 c8                	add    %ecx,%eax
f010aa3f:	05 b4 00 00 00       	add    $0xb4,%eax
f010aa44:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010aa4a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa4d:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa50:	89 d0                	mov    %edx,%eax
f010aa52:	01 c0                	add    %eax,%eax
f010aa54:	01 d0                	add    %edx,%eax
f010aa56:	c1 e0 03             	shl    $0x3,%eax
f010aa59:	01 c8                	add    %ecx,%eax
f010aa5b:	05 b8 00 00 00       	add    $0xb8,%eax
f010aa60:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010aa63:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa66:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa69:	89 d0                	mov    %edx,%eax
f010aa6b:	01 c0                	add    %eax,%eax
f010aa6d:	01 d0                	add    %edx,%eax
f010aa6f:	c1 e0 03             	shl    $0x3,%eax
f010aa72:	01 c8                	add    %ecx,%eax
f010aa74:	05 bc 00 00 00       	add    $0xbc,%eax
f010aa79:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010aa7f:	90                   	nop
f010aa80:	c9                   	leave  
f010aa81:	c3                   	ret    

f010aa82 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010aa82:	55                   	push   %ebp
f010aa83:	89 e5                	mov    %esp,%ebp
f010aa85:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aa88:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aa8c:	76 19                	jbe    f010aaa7 <env_table_ws_get_virtual_address+0x25>
f010aa8e:	68 78 f0 12 f0       	push   $0xf012f078
f010aa93:	68 a3 ee 12 f0       	push   $0xf012eea3
f010aa98:	68 52 01 00 00       	push   $0x152
f010aa9d:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010aaa2:	e8 08 64 ff ff       	call   f0100eaf <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010aaa7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aaaa:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aaad:	89 d0                	mov    %edx,%eax
f010aaaf:	01 c0                	add    %eax,%eax
f010aab1:	01 d0                	add    %edx,%eax
f010aab3:	c1 e0 03             	shl    $0x3,%eax
f010aab6:	01 c8                	add    %ecx,%eax
f010aab8:	05 b4 00 00 00       	add    $0xb4,%eax
f010aabd:	8b 00                	mov    (%eax),%eax
f010aabf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010aac2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aac5:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010aaca:	c9                   	leave  
f010aacb:	c3                   	ret    

f010aacc <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010aacc:	55                   	push   %ebp
f010aacd:	89 e5                	mov    %esp,%ebp
f010aacf:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aad2:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aad6:	76 19                	jbe    f010aaf1 <env_table_ws_get_time_stamp+0x25>
f010aad8:	68 78 f0 12 f0       	push   $0xf012f078
f010aadd:	68 a3 ee 12 f0       	push   $0xf012eea3
f010aae2:	68 59 01 00 00       	push   $0x159
f010aae7:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010aaec:	e8 be 63 ff ff       	call   f0100eaf <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010aaf1:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aaf4:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aaf7:	89 d0                	mov    %edx,%eax
f010aaf9:	01 c0                	add    %eax,%eax
f010aafb:	01 d0                	add    %edx,%eax
f010aafd:	c1 e0 03             	shl    $0x3,%eax
f010ab00:	01 c8                	add    %ecx,%eax
f010ab02:	05 bc 00 00 00       	add    $0xbc,%eax
f010ab07:	8b 00                	mov    (%eax),%eax
}
f010ab09:	c9                   	leave  
f010ab0a:	c3                   	ret    

f010ab0b <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010ab0b:	55                   	push   %ebp
f010ab0c:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010ab0e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab11:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ab14:	89 d0                	mov    %edx,%eax
f010ab16:	01 c0                	add    %eax,%eax
f010ab18:	01 d0                	add    %edx,%eax
f010ab1a:	c1 e0 03             	shl    $0x3,%eax
f010ab1d:	01 c8                	add    %ecx,%eax
f010ab1f:	05 b8 00 00 00       	add    $0xb8,%eax
f010ab24:	8a 00                	mov    (%eax),%al
f010ab26:	0f b6 c0             	movzbl %al,%eax
}
f010ab29:	5d                   	pop    %ebp
f010ab2a:	c3                   	ret    

f010ab2b <cut_paste_WS>:
///=================================================================================================

// Change WS Sizes For PRIORITY  =========================================================

void cut_paste_WS(struct WorkingSetElement* newWS, int newSize, struct Env* e)
{
f010ab2b:	55                   	push   %ebp
f010ab2c:	89 e5                	mov    %esp,%ebp
f010ab2e:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ab31:	83 ec 04             	sub    $0x4,%esp
f010ab34:	68 a9 f0 12 f0       	push   $0xf012f0a9
f010ab39:	68 6b 01 00 00       	push   $0x16b
f010ab3e:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010ab43:	e8 67 63 ff ff       	call   f0100eaf <_panic>

f010ab48 <double_WS_Size>:
}

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010ab48:	55                   	push   %ebp
f010ab49:	89 e5                	mov    %esp,%ebp
f010ab4b:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ab4e:	83 ec 04             	sub    $0x4,%esp
f010ab51:	68 a9 f0 12 f0       	push   $0xf012f0a9
f010ab56:	68 70 01 00 00       	push   $0x170
f010ab5b:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010ab60:	e8 4a 63 ff ff       	call   f0100eaf <_panic>

f010ab65 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010ab65:	55                   	push   %ebp
f010ab66:	89 e5                	mov    %esp,%ebp
f010ab68:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ab6b:	83 ec 04             	sub    $0x4,%esp
f010ab6e:	68 a9 f0 12 f0       	push   $0xf012f0a9
f010ab73:	68 75 01 00 00       	push   $0x175
f010ab78:	68 b8 ee 12 f0       	push   $0xf012eeb8
f010ab7d:	e8 2d 63 ff ff       	call   f0100eaf <_panic>

f010ab82 <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010ab82:	55                   	push   %ebp
f010ab83:	89 e5                	mov    %esp,%ebp
f010ab85:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("cut_paste_pages() is not implemented yet...!!");
f010ab88:	83 ec 04             	sub    $0x4,%esp
f010ab8b:	68 bc f0 12 f0       	push   $0xf012f0bc
f010ab90:	6a 21                	push   $0x21
f010ab92:	68 ea f0 12 f0       	push   $0xf012f0ea
f010ab97:	e8 13 63 ff ff       	call   f0100eaf <_panic>

f010ab9c <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010ab9c:	55                   	push   %ebp
f010ab9d:	89 e5                	mov    %esp,%ebp
f010ab9f:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("copy_paste_chunk() is not implemented yet...!!");
f010aba2:	83 ec 04             	sub    $0x4,%esp
f010aba5:	68 08 f1 12 f0       	push   $0xf012f108
f010abaa:	6a 34                	push   $0x34
f010abac:	68 ea f0 12 f0       	push   $0xf012f0ea
f010abb1:	e8 f9 62 ff ff       	call   f0100eaf <_panic>

f010abb6 <share_chunk>:
//	Otherwise, share the required range and return 0
//	During the share process:
//		1. If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010abb6:	55                   	push   %ebp
f010abb7:	89 e5                	mov    %esp,%ebp
f010abb9:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("share_chunk() is not implemented yet...!!");
f010abbc:	83 ec 04             	sub    $0x4,%esp
f010abbf:	68 38 f1 12 f0       	push   $0xf012f138
f010abc4:	6a 46                	push   $0x46
f010abc6:	68 ea f0 12 f0       	push   $0xf012f0ea
f010abcb:	e8 df 62 ff ff       	call   f0100eaf <_panic>

f010abd0 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010abd0:	55                   	push   %ebp
f010abd1:	89 e5                	mov    %esp,%ebp
f010abd3:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("allocate_chunk() is not implemented yet...!!");
f010abd6:	83 ec 04             	sub    $0x4,%esp
f010abd9:	68 64 f1 12 f0       	push   $0xf012f164
f010abde:	6a 54                	push   $0x54
f010abe0:	68 ea f0 12 f0       	push   $0xf012f0ea
f010abe5:	e8 c5 62 ff ff       	call   f0100eaf <_panic>

f010abea <calculate_free_space>:
//=====================================
//It should count the number of free pages in the given range [va1, va2)
//(i.e. number of pages that are not mapped).
//Addresses may not be aligned on page boundaries
uint32 calculate_free_space(uint32* page_directory, uint32 sva, uint32 eva)
{
f010abea:	55                   	push   %ebp
f010abeb:	89 e5                	mov    %esp,%ebp
f010abed:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("calculate_free_space() is not implemented yet...!!");
f010abf0:	83 ec 04             	sub    $0x4,%esp
f010abf3:	68 94 f1 12 f0       	push   $0xf012f194
f010abf8:	6a 62                	push   $0x62
f010abfa:	68 ea f0 12 f0       	push   $0xf012f0ea
f010abff:	e8 ab 62 ff ff       	call   f0100eaf <_panic>

f010ac04 <calculate_allocated_space>:

//=====================================
// 6) CALCULATE ALLOCATED SPACE:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010ac04:	55                   	push   %ebp
f010ac05:	89 e5                	mov    %esp,%ebp
f010ac07:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("calculate_allocated_space() is not implemented yet...!!");
f010ac0a:	83 ec 04             	sub    $0x4,%esp
f010ac0d:	68 c8 f1 12 f0       	push   $0xf012f1c8
f010ac12:	6a 6c                	push   $0x6c
f010ac14:	68 ea f0 12 f0       	push   $0xf012f0ea
f010ac19:	e8 91 62 ff ff       	call   f0100eaf <_panic>

f010ac1e <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010ac1e:	55                   	push   %ebp
f010ac1f:	89 e5                	mov    %esp,%ebp
f010ac21:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("calculate_required_frames() is not implemented yet...!!");
f010ac24:	83 ec 04             	sub    $0x4,%esp
f010ac27:	68 00 f2 12 f0       	push   $0xf012f200
f010ac2c:	6a 79                	push   $0x79
f010ac2e:	68 ea f0 12 f0       	push   $0xf012f0ea
f010ac33:	e8 77 62 ff ff       	call   f0100eaf <_panic>

f010ac38 <sys_sbrk>:
//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
/*2024*/
void* sys_sbrk(int numOfPages)
{
f010ac38:	55                   	push   %ebp
f010ac39:	89 e5                	mov    %esp,%ebp
f010ac3b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f010ac3e:	83 ec 04             	sub    $0x4,%esp
f010ac41:	68 38 f2 12 f0       	push   $0xf012f238
f010ac46:	68 8e 00 00 00       	push   $0x8e
f010ac4b:	68 ea f0 12 f0       	push   $0xf012f0ea
f010ac50:	e8 5a 62 ff ff       	call   f0100eaf <_panic>

f010ac55 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ac55:	55                   	push   %ebp
f010ac56:	89 e5                	mov    %esp,%ebp
f010ac58:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/

	//TODO: [PROJECT'25.IM#2] USER HEAP - #2 allocate_user_mem
	//Your code is here
	//Comment the following line
	panic("allocate_user_mem() is not implemented yet...!!");
f010ac5b:	83 ec 04             	sub    $0x4,%esp
f010ac5e:	68 54 f2 12 f0       	push   $0xf012f254
f010ac63:	68 9f 00 00 00       	push   $0x9f
f010ac68:	68 ea f0 12 f0       	push   $0xf012f0ea
f010ac6d:	e8 3d 62 ff ff       	call   f0100eaf <_panic>

f010ac72 <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ac72:	55                   	push   %ebp
f010ac73:	89 e5                	mov    %esp,%ebp
f010ac75:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/

	//TODO: [PROJECT'25.IM#2] USER HEAP - #4 free_user_mem
	//Your code is here
	//Comment the following line
	panic("free_user_mem() is not implemented yet...!!");
f010ac78:	83 ec 04             	sub    $0x4,%esp
f010ac7b:	68 84 f2 12 f0       	push   $0xf012f284
f010ac80:	68 b0 00 00 00       	push   $0xb0
f010ac85:	68 ea f0 12 f0       	push   $0xf012f0ea
f010ac8a:	e8 20 62 ff ff       	call   f0100eaf <_panic>

f010ac8f <__free_user_mem_with_buffering>:

//=====================================
// 4) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ac8f:	55                   	push   %ebp
f010ac90:	89 e5                	mov    %esp,%ebp
f010ac92:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010ac95:	83 ec 04             	sub    $0x4,%esp
f010ac98:	68 b0 f2 12 f0       	push   $0xf012f2b0
f010ac9d:	68 b9 00 00 00       	push   $0xb9
f010aca2:	68 ea f0 12 f0       	push   $0xf012f0ea
f010aca7:	e8 03 62 ff ff       	call   f0100eaf <_panic>

f010acac <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010acac:	55                   	push   %ebp
f010acad:	89 e5                	mov    %esp,%ebp
f010acaf:	83 ec 08             	sub    $0x8,%esp
	panic("move_user_mem() is not implemented yet...!!");
f010acb2:	83 ec 04             	sub    $0x4,%esp
f010acb5:	68 f0 f2 12 f0       	push   $0xf012f2f0
f010acba:	68 c1 00 00 00       	push   $0xc1
f010acbf:	68 ea f0 12 f0       	push   $0xf012f0ea
f010acc4:	e8 e6 61 ff ff       	call   f0100eaf <_panic>

f010acc9 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010acc9:	55                   	push   %ebp
f010acca:	89 e5                	mov    %esp,%ebp
f010accc:	53                   	push   %ebx
f010accd:	83 ec 14             	sub    $0x14,%esp
	int iEnv = NENV-1;
f010acd0:	c7 45 f4 c5 02 00 00 	movl   $0x2c5,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010acd7:	e9 78 01 00 00       	jmp    f010ae54 <env_init+0x18b>
	{
		envs[iEnv].env_status = ENV_FREE;
f010acdc:	8b 0d f0 51 81 f0    	mov    0xf08151f0,%ecx
f010ace2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ace5:	89 d0                	mov    %edx,%eax
f010ace7:	c1 e0 02             	shl    $0x2,%eax
f010acea:	01 d0                	add    %edx,%eax
f010acec:	c1 e0 03             	shl    $0x3,%eax
f010acef:	01 d0                	add    %edx,%eax
f010acf1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010acf8:	01 d0                	add    %edx,%eax
f010acfa:	c1 e0 02             	shl    $0x2,%eax
f010acfd:	01 c8                	add    %ecx,%eax
f010acff:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010ad06:	8b 0d f0 51 81 f0    	mov    0xf08151f0,%ecx
f010ad0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ad0f:	89 d0                	mov    %edx,%eax
f010ad11:	c1 e0 02             	shl    $0x2,%eax
f010ad14:	01 d0                	add    %edx,%eax
f010ad16:	c1 e0 03             	shl    $0x3,%eax
f010ad19:	01 d0                	add    %edx,%eax
f010ad1b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ad22:	01 d0                	add    %edx,%eax
f010ad24:	c1 e0 02             	shl    $0x2,%eax
f010ad27:	01 c8                	add    %ecx,%eax
f010ad29:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010ad30:	8b 0d f0 51 81 f0    	mov    0xf08151f0,%ecx
f010ad36:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ad39:	89 d0                	mov    %edx,%eax
f010ad3b:	c1 e0 02             	shl    $0x2,%eax
f010ad3e:	01 d0                	add    %edx,%eax
f010ad40:	c1 e0 03             	shl    $0x3,%eax
f010ad43:	01 d0                	add    %edx,%eax
f010ad45:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ad4c:	01 d0                	add    %edx,%eax
f010ad4e:	c1 e0 02             	shl    $0x2,%eax
f010ad51:	01 c8                	add    %ecx,%eax
f010ad53:	85 c0                	test   %eax,%eax
f010ad55:	75 14                	jne    f010ad6b <env_init+0xa2>
f010ad57:	83 ec 04             	sub    $0x4,%esp
f010ad5a:	68 1c f3 12 f0       	push   $0xf012f31c
f010ad5f:	6a 65                	push   $0x65
f010ad61:	68 3f f3 12 f0       	push   $0xf012f33f
f010ad66:	e8 44 61 ff ff       	call   f0100eaf <_panic>
f010ad6b:	8b 0d f0 51 81 f0    	mov    0xf08151f0,%ecx
f010ad71:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ad74:	89 d0                	mov    %edx,%eax
f010ad76:	c1 e0 02             	shl    $0x2,%eax
f010ad79:	01 d0                	add    %edx,%eax
f010ad7b:	c1 e0 03             	shl    $0x3,%eax
f010ad7e:	01 d0                	add    %edx,%eax
f010ad80:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ad87:	01 d0                	add    %edx,%eax
f010ad89:	c1 e0 02             	shl    $0x2,%eax
f010ad8c:	01 c8                	add    %ecx,%eax
f010ad8e:	8b 15 f4 51 81 f0    	mov    0xf08151f4,%edx
f010ad94:	89 50 08             	mov    %edx,0x8(%eax)
f010ad97:	8b 40 08             	mov    0x8(%eax),%eax
f010ad9a:	85 c0                	test   %eax,%eax
f010ad9c:	74 2e                	je     f010adcc <env_init+0x103>
f010ad9e:	8b 0d f4 51 81 f0    	mov    0xf08151f4,%ecx
f010ada4:	8b 1d f0 51 81 f0    	mov    0xf08151f0,%ebx
f010adaa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010adad:	89 d0                	mov    %edx,%eax
f010adaf:	c1 e0 02             	shl    $0x2,%eax
f010adb2:	01 d0                	add    %edx,%eax
f010adb4:	c1 e0 03             	shl    $0x3,%eax
f010adb7:	01 d0                	add    %edx,%eax
f010adb9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010adc0:	01 d0                	add    %edx,%eax
f010adc2:	c1 e0 02             	shl    $0x2,%eax
f010adc5:	01 d8                	add    %ebx,%eax
f010adc7:	89 41 0c             	mov    %eax,0xc(%ecx)
f010adca:	eb 28                	jmp    f010adf4 <env_init+0x12b>
f010adcc:	8b 0d f0 51 81 f0    	mov    0xf08151f0,%ecx
f010add2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010add5:	89 d0                	mov    %edx,%eax
f010add7:	c1 e0 02             	shl    $0x2,%eax
f010adda:	01 d0                	add    %edx,%eax
f010addc:	c1 e0 03             	shl    $0x3,%eax
f010addf:	01 d0                	add    %edx,%eax
f010ade1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ade8:	01 d0                	add    %edx,%eax
f010adea:	c1 e0 02             	shl    $0x2,%eax
f010aded:	01 c8                	add    %ecx,%eax
f010adef:	a3 f8 51 81 f0       	mov    %eax,0xf08151f8
f010adf4:	8b 0d f0 51 81 f0    	mov    0xf08151f0,%ecx
f010adfa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010adfd:	89 d0                	mov    %edx,%eax
f010adff:	c1 e0 02             	shl    $0x2,%eax
f010ae02:	01 d0                	add    %edx,%eax
f010ae04:	c1 e0 03             	shl    $0x3,%eax
f010ae07:	01 d0                	add    %edx,%eax
f010ae09:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ae10:	01 d0                	add    %edx,%eax
f010ae12:	c1 e0 02             	shl    $0x2,%eax
f010ae15:	01 c8                	add    %ecx,%eax
f010ae17:	a3 f4 51 81 f0       	mov    %eax,0xf08151f4
f010ae1c:	8b 0d f0 51 81 f0    	mov    0xf08151f0,%ecx
f010ae22:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae25:	89 d0                	mov    %edx,%eax
f010ae27:	c1 e0 02             	shl    $0x2,%eax
f010ae2a:	01 d0                	add    %edx,%eax
f010ae2c:	c1 e0 03             	shl    $0x3,%eax
f010ae2f:	01 d0                	add    %edx,%eax
f010ae31:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ae38:	01 d0                	add    %edx,%eax
f010ae3a:	c1 e0 02             	shl    $0x2,%eax
f010ae3d:	01 c8                	add    %ecx,%eax
f010ae3f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010ae46:	a1 00 52 81 f0       	mov    0xf0815200,%eax
f010ae4b:	40                   	inc    %eax
f010ae4c:	a3 00 52 81 f0       	mov    %eax,0xf0815200
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010ae51:	ff 4d f4             	decl   -0xc(%ebp)
f010ae54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ae58:	0f 89 7e fe ff ff    	jns    f010acdc <env_init+0x13>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010ae5e:	90                   	nop
f010ae5f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ae62:	c9                   	leave  
f010ae63:	c3                   	ret    

f010ae64 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010ae64:	55                   	push   %ebp
f010ae65:	89 e5                	mov    %esp,%ebp
f010ae67:	57                   	push   %edi
f010ae68:	56                   	push   %esi
f010ae69:	53                   	push   %ebx
f010ae6a:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	//[0] 2024: Disable the interrupt through the entire function to avoid concurrency issues while:
	//		1. switching the directories
	//		2. between allocate_environment and removing it later in complete_env..._initi...
	/*THANKS to T58 - 2024/2025*/

	struct Env* e = NULL;
f010ae70:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
f010ae77:	00 00 00 

	pushcli();
f010ae7a:	e8 b4 d1 ff ff       	call   f0108033 <pushcli>
	{
		//[1] get pointer to the start of the "user_program_name" program in memory
		// Hint: use "get_user_program_info" function,
		// you should set the following "ptr_program_start" by the start address of the user program
		uint8* ptr_program_start = 0;
f010ae7f:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)

		struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010ae86:	83 ec 0c             	sub    $0xc,%esp
f010ae89:	ff 75 08             	pushl  0x8(%ebp)
f010ae8c:	e8 f0 1e 00 00       	call   f010cd81 <get_user_program_info>
f010ae91:	83 c4 10             	add    $0x10,%esp
f010ae94:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if(ptr_user_program_info == 0)
f010ae97:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
f010ae9b:	75 0f                	jne    f010aeac <env_create+0x48>
		{
			popcli();
f010ae9d:	e8 e3 d1 ff ff       	call   f0108085 <popcli>
			return NULL;
f010aea2:	b8 00 00 00 00       	mov    $0x0,%eax
f010aea7:	e9 b6 0a 00 00       	jmp    f010b962 <env_create+0xafe>
		}
		ptr_program_start = ptr_user_program_info->ptr_start ;
f010aeac:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010aeaf:	8b 40 08             	mov    0x8(%eax),%eax
f010aeb2:	89 45 b0             	mov    %eax,-0x50(%ebp)

		//[2] allocate new environment, (from the free environment list)
		//if there's no one, return NULL
		// Hint: use "allocate_environment" function
		if(allocate_environment(&e) < 0)
f010aeb5:	83 ec 0c             	sub    $0xc,%esp
f010aeb8:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010aebe:	50                   	push   %eax
f010aebf:	e8 bd 0f 00 00       	call   f010be81 <allocate_environment>
f010aec4:	83 c4 10             	add    $0x10,%esp
f010aec7:	85 c0                	test   %eax,%eax
f010aec9:	79 0f                	jns    f010aeda <env_create+0x76>
		{
			popcli();
f010aecb:	e8 b5 d1 ff ff       	call   f0108085 <popcli>
			return NULL;
f010aed0:	b8 00 00 00 00       	mov    $0x0,%eax
f010aed5:	e9 88 0a 00 00       	jmp    f010b962 <env_create+0xafe>
		}

		//[2.5 - 2012] Set program name inside the environment
		//e->prog_name = ptr_user_program_info->name ;
		//2017: changed to fixed size array to be abale to access it from user side
		if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010aeda:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010aedd:	8b 00                	mov    (%eax),%eax
f010aedf:	83 ec 0c             	sub    $0xc,%esp
f010aee2:	50                   	push   %eax
f010aee3:	e8 95 fb 00 00       	call   f011aa7d <strlen>
f010aee8:	83 c4 10             	add    $0x10,%esp
f010aeeb:	83 f8 3f             	cmp    $0x3f,%eax
f010aeee:	7f 1d                	jg     f010af0d <env_create+0xa9>
			strcpy(e->prog_name, ptr_user_program_info->name);
f010aef0:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010aef3:	8b 00                	mov    (%eax),%eax
f010aef5:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010aefb:	83 c2 20             	add    $0x20,%edx
f010aefe:	83 ec 08             	sub    $0x8,%esp
f010af01:	50                   	push   %eax
f010af02:	52                   	push   %edx
f010af03:	e8 c4 fb 00 00       	call   f011aacc <strcpy>
f010af08:	83 c4 10             	add    $0x10,%esp
f010af0b:	eb 1d                	jmp    f010af2a <env_create+0xc6>
		else
			strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010af0d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010af10:	8b 00                	mov    (%eax),%eax
f010af12:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010af18:	83 c2 20             	add    $0x20,%edx
f010af1b:	83 ec 04             	sub    $0x4,%esp
f010af1e:	6a 3f                	push   $0x3f
f010af20:	50                   	push   %eax
f010af21:	52                   	push   %edx
f010af22:	e8 d3 fb 00 00       	call   f011aafa <strncpy>
f010af27:	83 c4 10             	add    $0x10,%esp
		//REMEMBER: "allocate_frame" should always return a free frame
		uint32* ptr_user_page_directory;
		unsigned int phys_user_page_directory;
#if USE_KHEAP
		{
			ptr_user_page_directory = create_user_directory();
f010af2a:	e8 1e 15 00 00       	call   f010c44d <create_user_directory>
f010af2f:	89 45 a8             	mov    %eax,-0x58(%ebp)
			phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010af32:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010af35:	83 ec 0c             	sub    $0xc,%esp
f010af38:	50                   	push   %eax
f010af39:	e8 49 ec ff ff       	call   f0109b87 <kheap_physical_address>
f010af3e:	83 c4 10             	add    $0x10,%esp
f010af41:	89 45 a4             	mov    %eax,-0x5c(%ebp)
#endif
		//[4] initialize the new environment by the virtual address of the page directory
		// Hint: use "initialize_environment" function

		//2016
		e->page_WS_max_size = page_WS_size;
f010af44:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010af4a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010af4d:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

		//2020
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010af53:	83 ec 0c             	sub    $0xc,%esp
f010af56:	6a 02                	push   $0x2
f010af58:	e8 c8 48 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f010af5d:	83 c4 10             	add    $0x10,%esp
f010af60:	85 c0                	test   %eax,%eax
f010af62:	74 21                	je     f010af85 <env_create+0x121>
		{
			e->SecondListSize = LRU_second_list_size;
f010af64:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010af6a:	8b 55 10             	mov    0x10(%ebp),%edx
f010af6d:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)
			e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010af73:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010af79:	8b 55 0c             	mov    0xc(%ebp),%edx
f010af7c:	2b 55 10             	sub    0x10(%ebp),%edx
f010af7f:	89 90 88 05 00 00    	mov    %edx,0x588(%eax)
		}

		//2018
		if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010af85:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010af89:	75 12                	jne    f010af9d <env_create+0x139>
			e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010af8b:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010af91:	c7 80 94 05 00 00 0a 	movl   $0xa,0x594(%eax)
f010af98:	00 00 00 
f010af9b:	eb 0f                	jmp    f010afac <env_create+0x148>
		else
			e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010af9d:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010afa3:	8b 55 14             	mov    0x14(%ebp),%edx
f010afa6:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010afac:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010afb2:	83 ec 04             	sub    $0x4,%esp
f010afb5:	ff 75 a4             	pushl  -0x5c(%ebp)
f010afb8:	ff 75 a8             	pushl  -0x58(%ebp)
f010afbb:	50                   	push   %eax
f010afbc:	e8 01 15 00 00       	call   f010c4c2 <initialize_environment>
f010afc1:	83 c4 10             	add    $0x10,%esp

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010afc4:	0f 20 d8             	mov    %cr3,%eax
f010afc7:	89 45 98             	mov    %eax,-0x68(%ebp)
	return val;
f010afca:	8b 45 98             	mov    -0x68(%ebp),%eax
		//	3- uint32 size_in_memory: actual size required by this segment in memory
		// 	usually size_in_file < or = size_in_memory
		//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010afcd:	89 45 9c             	mov    %eax,-0x64(%ebp)
		lcr3(e->env_cr3) ;
f010afd0:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010afd6:	8b 40 68             	mov    0x68(%eax),%eax
f010afd9:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010afdf:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f010afe5:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010afe8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		int segment_counter=0;
f010afef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010aff6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010affc:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010b002:	48                   	dec    %eax
f010b003:	89 45 dc             	mov    %eax,-0x24(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010b006:	c7 85 40 ff ff ff ff 	movl   $0xffffffff,-0xc0(%ebp)
f010b00d:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b010:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
f010b016:	83 ec 08             	sub    $0x8,%esp
f010b019:	ff 75 b0             	pushl  -0x50(%ebp)
f010b01c:	50                   	push   %eax
f010b01d:	e8 6e 1a 00 00       	call   f010ca90 <PROGRAM_SEGMENT_FIRST>
f010b022:	83 c4 0c             	add    $0xc,%esp
f010b025:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
f010b02b:	8d 95 f8 fe ff ff    	lea    -0x108(%ebp),%edx
f010b031:	b9 05 00 00 00       	mov    $0x5,%ecx
f010b036:	89 c7                	mov    %eax,%edi
f010b038:	89 d6                	mov    %edx,%esi
f010b03a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010b03c:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
f010b042:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010b045:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b048:	8b 40 10             	mov    0x10(%eax),%eax
f010b04b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010b04e:	75 07                	jne    f010b057 <env_create+0x1f3>
f010b050:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010b057:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b05a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010b05d:	e9 2d 03 00 00       	jmp    f010b38f <env_create+0x52b>
		{
			segment_counter++;
f010b062:	ff 45 e0             	incl   -0x20(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010b065:	c7 85 28 ff ff ff 00 	movl   $0x0,-0xd8(%ebp)
f010b06c:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010b06f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b075:	83 ec 0c             	sub    $0xc,%esp
f010b078:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010b07e:	52                   	push   %edx
f010b07f:	ff 75 dc             	pushl  -0x24(%ebp)
f010b082:	8d 95 28 ff ff ff    	lea    -0xd8(%ebp),%edx
f010b088:	52                   	push   %edx
f010b089:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b08c:	50                   	push   %eax
f010b08d:	e8 ad 0e 00 00       	call   f010bf3f <program_segment_alloc_map_copy_workingset>
f010b092:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010b095:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f010b09b:	29 45 dc             	sub    %eax,-0x24(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010b09e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b0a1:	8b 00                	mov    (%eax),%eax
f010b0a3:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010b0a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b0a9:	8b 40 0c             	mov    0xc(%eax),%eax
f010b0ac:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010b0af:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b0b2:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010b0b5:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010b0b8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b0bd:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010b0c0:	c7 45 84 00 10 00 00 	movl   $0x1000,-0x7c(%ebp)
f010b0c7:	8b 55 90             	mov    -0x70(%ebp),%edx
f010b0ca:	8b 45 84             	mov    -0x7c(%ebp),%eax
f010b0cd:	01 d0                	add    %edx,%eax
f010b0cf:	48                   	dec    %eax
f010b0d0:	89 45 80             	mov    %eax,-0x80(%ebp)
f010b0d3:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b0d6:	ba 00 00 00 00       	mov    $0x0,%edx
f010b0db:	f7 75 84             	divl   -0x7c(%ebp)
f010b0de:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b0e1:	29 d0                	sub    %edx,%eax
f010b0e3:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010b0e9:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b0ec:	2b 45 88             	sub    -0x78(%ebp),%eax
f010b0ef:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010b0f5:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010b0f8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010b0fb:	8b 15 c4 63 85 f0    	mov    0xf08563c4,%edx
f010b101:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010b107:	01 d0                	add    %edx,%eax
f010b109:	89 45 d0             	mov    %eax,-0x30(%ebp)
			int i;
			if (offset_first_page)
f010b10c:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f010b113:	74 76                	je     f010b18b <env_create+0x327>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010b115:	a1 c4 63 85 f0       	mov    0xf08563c4,%eax
f010b11a:	83 ec 04             	sub    $0x4,%esp
f010b11d:	68 00 10 00 00       	push   $0x1000
f010b122:	6a 00                	push   $0x0
f010b124:	50                   	push   %eax
f010b125:	e8 41 fb 00 00       	call   f011ac6b <memset>
f010b12a:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b12d:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b130:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b133:	eb 13                	jmp    f010b148 <env_create+0x2e4>
				{
					*dst_ptr = *src_ptr ;
f010b135:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b138:	8a 10                	mov    (%eax),%dl
f010b13a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b13d:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b13f:	ff 45 cc             	incl   -0x34(%ebp)
f010b142:	ff 45 d4             	incl   -0x2c(%ebp)
f010b145:	ff 45 d0             	incl   -0x30(%ebp)
f010b148:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b14b:	3b 85 7c ff ff ff    	cmp    -0x84(%ebp),%eax
f010b151:	72 e2                	jb     f010b135 <env_create+0x2d1>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b153:	8b 15 c4 63 85 f0    	mov    0xf08563c4,%edx
f010b159:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b15f:	83 ec 04             	sub    $0x4,%esp
f010b162:	52                   	push   %edx
f010b163:	ff 75 88             	pushl  -0x78(%ebp)
f010b166:	50                   	push   %eax
f010b167:	e8 8b a0 ff ff       	call   f01051f7 <pf_add_env_page>
f010b16c:	83 c4 10             	add    $0x10,%esp
f010b16f:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b172:	75 17                	jne    f010b18b <env_create+0x327>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b174:	83 ec 04             	sub    $0x4,%esp
f010b177:	68 5c f3 12 f0       	push   $0xf012f35c
f010b17c:	68 fe 00 00 00       	push   $0xfe
f010b181:	68 3f f3 12 f0       	push   $0xf012f33f
f010b186:	e8 24 5d ff ff       	call   f0100eaf <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010b18b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b18e:	8b 50 04             	mov    0x4(%eax),%edx
f010b191:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b194:	01 d0                	add    %edx,%eax
f010b196:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f010b19c:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010b1a2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b1a7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010b1ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b1b0:	8b 50 04             	mov    0x4(%eax),%edx
f010b1b3:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b1b6:	01 d0                	add    %edx,%eax
f010b1b8:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b1be:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b1c4:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b1c7:	eb 43                	jmp    f010b20c <env_create+0x3a8>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010b1c9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b1cc:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b1d2:	83 ec 04             	sub    $0x4,%esp
f010b1d5:	ff 75 d4             	pushl  -0x2c(%ebp)
f010b1d8:	52                   	push   %edx
f010b1d9:	50                   	push   %eax
f010b1da:	e8 18 a0 ff ff       	call   f01051f7 <pf_add_env_page>
f010b1df:	83 c4 10             	add    $0x10,%esp
f010b1e2:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b1e5:	75 17                	jne    f010b1fe <env_create+0x39a>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b1e7:	83 ec 04             	sub    $0x4,%esp
f010b1ea:	68 5c f3 12 f0       	push   $0xf012f35c
f010b1ef:	68 0b 01 00 00       	push   $0x10b
f010b1f4:	68 3f f3 12 f0       	push   $0xf012f33f
f010b1f9:	e8 b1 5c ff ff       	call   f0100eaf <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b1fe:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f010b205:	81 45 d4 00 10 00 00 	addl   $0x1000,-0x2c(%ebp)
f010b20c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b20f:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f010b215:	72 b2                	jb     f010b1c9 <env_create+0x365>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010b217:	a1 c4 63 85 f0       	mov    0xf08563c4,%eax
f010b21c:	89 45 d0             	mov    %eax,-0x30(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010b21f:	83 ec 04             	sub    $0x4,%esp
f010b222:	68 00 10 00 00       	push   $0x1000
f010b227:	6a 00                	push   $0x0
f010b229:	ff 75 d0             	pushl  -0x30(%ebp)
f010b22c:	e8 3a fa 00 00       	call   f011ac6b <memset>
f010b231:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b234:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b23a:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b23d:	eb 13                	jmp    f010b252 <env_create+0x3ee>
			{
				*dst_ptr = *src_ptr;
f010b23f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b242:	8a 10                	mov    (%eax),%dl
f010b244:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b247:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b249:	ff 45 cc             	incl   -0x34(%ebp)
f010b24c:	ff 45 d4             	incl   -0x2c(%ebp)
f010b24f:	ff 45 d0             	incl   -0x30(%ebp)
f010b252:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b255:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
f010b25b:	72 e2                	jb     f010b23f <env_create+0x3db>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b25d:	8b 15 c4 63 85 f0    	mov    0xf08563c4,%edx
f010b263:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b269:	83 ec 04             	sub    $0x4,%esp
f010b26c:	52                   	push   %edx
f010b26d:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
f010b273:	50                   	push   %eax
f010b274:	e8 7e 9f ff ff       	call   f01051f7 <pf_add_env_page>
f010b279:	83 c4 10             	add    $0x10,%esp
f010b27c:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b27f:	75 17                	jne    f010b298 <env_create+0x434>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b281:	83 ec 04             	sub    $0x4,%esp
f010b284:	68 5c f3 12 f0       	push   $0xf012f35c
f010b289:	68 1a 01 00 00       	push   $0x11a
f010b28e:	68 3f f3 12 f0       	push   $0xf012f33f
f010b293:	e8 17 5c ff ff       	call   f0100eaf <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010b298:	c7 85 68 ff ff ff 00 	movl   $0x1000,-0x98(%ebp)
f010b29f:	10 00 00 
f010b2a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b2a5:	8b 50 04             	mov    0x4(%eax),%edx
f010b2a8:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b2ab:	01 c2                	add    %eax,%edx
f010b2ad:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f010b2b3:	01 d0                	add    %edx,%eax
f010b2b5:	48                   	dec    %eax
f010b2b6:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
f010b2bc:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f010b2c2:	ba 00 00 00 00       	mov    $0x0,%edx
f010b2c7:	f7 b5 68 ff ff ff    	divl   -0x98(%ebp)
f010b2cd:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f010b2d3:	29 d0                	sub    %edx,%eax
f010b2d5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010b2d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b2db:	8b 50 08             	mov    0x8(%eax),%edx
f010b2de:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b2e1:	01 d0                	add    %edx,%eax
f010b2e3:	2b 45 c8             	sub    -0x38(%ebp),%eax
f010b2e6:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b2ec:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010b2f3:	eb 41                	jmp    f010b336 <env_create+0x4d2>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010b2f5:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b2fb:	83 ec 04             	sub    $0x4,%esp
f010b2fe:	6a 01                	push   $0x1
f010b300:	ff 75 c8             	pushl  -0x38(%ebp)
f010b303:	50                   	push   %eax
f010b304:	e8 c0 9d ff ff       	call   f01050c9 <pf_add_empty_env_page>
f010b309:	83 c4 10             	add    $0x10,%esp
f010b30c:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b30f:	75 17                	jne    f010b328 <env_create+0x4c4>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b311:	83 ec 04             	sub    $0x4,%esp
f010b314:	68 5c f3 12 f0       	push   $0xf012f35c
f010b319:	68 27 01 00 00       	push   $0x127
f010b31e:	68 3f f3 12 f0       	push   $0xf012f33f
f010b323:	e8 87 5b ff ff       	call   f0100eaf <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b328:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f010b32f:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f010b336:	c7 85 5c ff ff ff 00 	movl   $0x1000,-0xa4(%ebp)
f010b33d:	10 00 00 
f010b340:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
f010b346:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b34c:	01 d0                	add    %edx,%eax
f010b34e:	48                   	dec    %eax
f010b34f:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
f010b355:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f010b35b:	ba 00 00 00 00       	mov    $0x0,%edx
f010b360:	f7 b5 5c ff ff ff    	divl   -0xa4(%ebp)
f010b366:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f010b36c:	29 d0                	sub    %edx,%eax
f010b36e:	89 c2                	mov    %eax,%edx
f010b370:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b373:	39 c2                	cmp    %eax,%edx
f010b375:	0f 87 7a ff ff ff    	ja     f010b2f5 <env_create+0x491>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b37b:	83 ec 08             	sub    $0x8,%esp
f010b37e:	ff 75 b0             	pushl  -0x50(%ebp)
f010b381:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b384:	e8 fc 15 00 00       	call   f010c985 <PROGRAM_SEGMENT_NEXT>
f010b389:	83 c4 10             	add    $0x10,%esp
f010b38c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010b38f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010b393:	0f 85 c9 fc ff ff    	jne    f010b062 <env_create+0x1fe>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b399:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b39f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010b3a5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b3a8:	eb 77                	jmp    f010b421 <env_create+0x5bd>
		{
			uint32 virtual_address = wse->virtual_address;
f010b3aa:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b3ad:	8b 00                	mov    (%eax),%eax
f010b3af:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010b3b5:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b3bb:	8b 40 64             	mov    0x64(%eax),%eax
f010b3be:	83 ec 04             	sub    $0x4,%esp
f010b3c1:	8d 95 24 ff ff ff    	lea    -0xdc(%ebp),%edx
f010b3c7:	52                   	push   %edx
f010b3c8:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
f010b3ce:	50                   	push   %eax
f010b3cf:	e8 82 de ff ff       	call   f0109256 <get_page_table>
f010b3d4:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010b3d7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f010b3dd:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
f010b3e3:	c1 ea 0c             	shr    $0xc,%edx
f010b3e6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b3ec:	c1 e2 02             	shl    $0x2,%edx
f010b3ef:	01 d0                	add    %edx,%eax
f010b3f1:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f010b3f7:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
f010b3fd:	c1 e9 0c             	shr    $0xc,%ecx
f010b400:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010b406:	c1 e1 02             	shl    $0x2,%ecx
f010b409:	01 ca                	add    %ecx,%edx
f010b40b:	8b 12                	mov    (%edx),%edx
f010b40d:	83 e2 bf             	and    $0xffffffbf,%edx
f010b410:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b412:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b418:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b41e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b421:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b427:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b42b:	74 08                	je     f010b435 <env_create+0x5d1>
f010b42d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b430:	8b 52 10             	mov    0x10(%edx),%edx
f010b433:	eb 05                	jmp    f010b43a <env_create+0x5d6>
f010b435:	ba 00 00 00 00       	mov    $0x0,%edx
f010b43a:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
f010b440:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b446:	85 c0                	test   %eax,%eax
f010b448:	0f 85 5c ff ff ff    	jne    f010b3aa <env_create+0x546>
f010b44e:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b452:	0f 85 52 ff ff ff    	jne    f010b3aa <env_create+0x546>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010b458:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b45b:	8b 50 08             	mov    0x8(%eax),%edx
f010b45e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b464:	83 ec 08             	sub    $0x8,%esp
f010b467:	52                   	push   %edx
f010b468:	50                   	push   %eax
f010b469:	e8 d7 14 00 00       	call   f010c945 <set_environment_entry_point>
f010b46e:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010b471:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b477:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010b47e:	c7 85 50 ff ff ff 00 	movl   $0xeebfd000,-0xb0(%ebp)
f010b485:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010b488:	c7 45 c0 00 d0 bf ee 	movl   $0xeebfd000,-0x40(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b48f:	e9 42 03 00 00       	jmp    f010b7d6 <env_create+0x972>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010b494:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f010b49b:	00 00 00 
			allocate_frame(&pp);
f010b49e:	83 ec 0c             	sub    $0xc,%esp
f010b4a1:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f010b4a7:	50                   	push   %eax
f010b4a8:	e8 98 db ff ff       	call   f0109045 <allocate_frame>
f010b4ad:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010b4b0:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f010b4b6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b4bc:	8b 40 64             	mov    0x64(%eax),%eax
f010b4bf:	6a 06                	push   $0x6
f010b4c1:	ff 75 c0             	pushl  -0x40(%ebp)
f010b4c4:	52                   	push   %edx
f010b4c5:	50                   	push   %eax
f010b4c6:	e8 2b e2 ff ff       	call   f01096f6 <loadtime_map_frame>
f010b4cb:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010b4ce:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b4d1:	83 ec 04             	sub    $0x4,%esp
f010b4d4:	68 00 10 00 00       	push   $0x1000
f010b4d9:	6a 00                	push   $0x0
f010b4db:	50                   	push   %eax
f010b4dc:	e8 8a f7 00 00       	call   f011ac6b <memset>
f010b4e1:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010b4e4:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b4ea:	83 ec 08             	sub    $0x8,%esp
f010b4ed:	ff 75 c0             	pushl  -0x40(%ebp)
f010b4f0:	50                   	push   %eax
f010b4f1:	e8 12 ea ff ff       	call   f0109f08 <env_page_ws_list_create_element>
f010b4f6:	83 c4 10             	add    $0x10,%esp
f010b4f9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b4fc:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b500:	75 17                	jne    f010b519 <env_create+0x6b5>
f010b502:	83 ec 04             	sub    $0x4,%esp
f010b505:	68 a4 f3 12 f0       	push   $0xf012f3a4
f010b50a:	68 66 01 00 00       	push   $0x166
f010b50f:	68 3f f3 12 f0       	push   $0xf012f33f
f010b514:	e8 96 59 ff ff       	call   f0100eaf <_panic>
f010b519:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b51f:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010b525:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b528:	89 50 14             	mov    %edx,0x14(%eax)
f010b52b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b52e:	8b 40 14             	mov    0x14(%eax),%eax
f010b531:	85 c0                	test   %eax,%eax
f010b533:	74 14                	je     f010b549 <env_create+0x6e5>
f010b535:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b53b:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010b541:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b544:	89 50 10             	mov    %edx,0x10(%eax)
f010b547:	eb 0f                	jmp    f010b558 <env_create+0x6f4>
f010b549:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b54f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b552:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010b558:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b55e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b561:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010b567:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b56a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b571:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b577:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010b57d:	42                   	inc    %edx
f010b57e:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b584:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b58a:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010b590:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b596:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010b59c:	39 c2                	cmp    %eax,%edx
f010b59e:	75 1a                	jne    f010b5ba <env_create+0x756>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b5a0:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b5a6:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010b5ac:	8b 92 88 00 00 00    	mov    0x88(%edx),%edx
f010b5b2:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b5b8:	eb 10                	jmp    f010b5ca <env_create+0x766>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010b5ba:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b5c0:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010b5c7:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b5ca:	83 ec 0c             	sub    $0xc,%esp
f010b5cd:	6a 02                	push   $0x2
f010b5cf:	e8 51 42 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f010b5d4:	83 c4 10             	add    $0x10,%esp
f010b5d7:	85 c0                	test   %eax,%eax
f010b5d9:	0f 84 d3 01 00 00    	je     f010b7b2 <env_create+0x94e>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010b5df:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b5e3:	75 17                	jne    f010b5fc <env_create+0x798>
f010b5e5:	83 ec 04             	sub    $0x4,%esp
f010b5e8:	68 c7 f3 12 f0       	push   $0xf012f3c7
f010b5ed:	68 73 01 00 00       	push   $0x173
f010b5f2:	68 3f f3 12 f0       	push   $0xf012f33f
f010b5f7:	e8 b3 58 ff ff       	call   f0100eaf <_panic>
f010b5fc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b5ff:	8b 40 10             	mov    0x10(%eax),%eax
f010b602:	85 c0                	test   %eax,%eax
f010b604:	74 11                	je     f010b617 <env_create+0x7b3>
f010b606:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b609:	8b 40 10             	mov    0x10(%eax),%eax
f010b60c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b60f:	8b 52 14             	mov    0x14(%edx),%edx
f010b612:	89 50 14             	mov    %edx,0x14(%eax)
f010b615:	eb 12                	jmp    f010b629 <env_create+0x7c5>
f010b617:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b61d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b620:	8b 52 14             	mov    0x14(%edx),%edx
f010b623:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010b629:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b62c:	8b 40 14             	mov    0x14(%eax),%eax
f010b62f:	85 c0                	test   %eax,%eax
f010b631:	74 11                	je     f010b644 <env_create+0x7e0>
f010b633:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b636:	8b 40 14             	mov    0x14(%eax),%eax
f010b639:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b63c:	8b 52 10             	mov    0x10(%edx),%edx
f010b63f:	89 50 10             	mov    %edx,0x10(%eax)
f010b642:	eb 12                	jmp    f010b656 <env_create+0x7f2>
f010b644:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b64a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b64d:	8b 52 10             	mov    0x10(%edx),%edx
f010b650:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010b656:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b659:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b660:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b663:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b66a:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b670:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010b676:	4a                   	dec    %edx
f010b677:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010b67d:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b683:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f010b689:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b68f:	8b 80 88 05 00 00    	mov    0x588(%eax),%eax
f010b695:	39 c2                	cmp    %eax,%edx
f010b697:	0f 83 8d 00 00 00    	jae    f010b72a <env_create+0x8c6>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b69d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b6a1:	75 17                	jne    f010b6ba <env_create+0x856>
f010b6a3:	83 ec 04             	sub    $0x4,%esp
f010b6a6:	68 1c f3 12 f0       	push   $0xf012f31c
f010b6ab:	68 78 01 00 00       	push   $0x178
f010b6b0:	68 3f f3 12 f0       	push   $0xf012f33f
f010b6b5:	e8 f5 57 ff ff       	call   f0100eaf <_panic>
f010b6ba:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b6c0:	8b 90 68 05 00 00    	mov    0x568(%eax),%edx
f010b6c6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b6c9:	89 50 10             	mov    %edx,0x10(%eax)
f010b6cc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b6cf:	8b 40 10             	mov    0x10(%eax),%eax
f010b6d2:	85 c0                	test   %eax,%eax
f010b6d4:	74 14                	je     f010b6ea <env_create+0x886>
f010b6d6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b6dc:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010b6e2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b6e5:	89 50 14             	mov    %edx,0x14(%eax)
f010b6e8:	eb 0f                	jmp    f010b6f9 <env_create+0x895>
f010b6ea:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b6f0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b6f3:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010b6f9:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b6ff:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b702:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010b708:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b70b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b712:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b718:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f010b71e:	42                   	inc    %edx
f010b71f:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010b725:	e9 88 00 00 00       	jmp    f010b7b2 <env_create+0x94e>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b72a:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b72e:	75 17                	jne    f010b747 <env_create+0x8e3>
f010b730:	83 ec 04             	sub    $0x4,%esp
f010b733:	68 1c f3 12 f0       	push   $0xf012f31c
f010b738:	68 7c 01 00 00       	push   $0x17c
f010b73d:	68 3f f3 12 f0       	push   $0xf012f33f
f010b742:	e8 68 57 ff ff       	call   f0100eaf <_panic>
f010b747:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b74d:	8b 90 78 05 00 00    	mov    0x578(%eax),%edx
f010b753:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b756:	89 50 10             	mov    %edx,0x10(%eax)
f010b759:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b75c:	8b 40 10             	mov    0x10(%eax),%eax
f010b75f:	85 c0                	test   %eax,%eax
f010b761:	74 14                	je     f010b777 <env_create+0x913>
f010b763:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b769:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b76f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b772:	89 50 14             	mov    %edx,0x14(%eax)
f010b775:	eb 0f                	jmp    f010b786 <env_create+0x922>
f010b777:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b77d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b780:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010b786:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b78c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b78f:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010b795:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b798:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b79f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b7a5:	8b 90 84 05 00 00    	mov    0x584(%eax),%edx
f010b7ab:	42                   	inc    %edx
f010b7ac:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010b7b2:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b7b8:	83 ec 04             	sub    $0x4,%esp
f010b7bb:	6a 01                	push   $0x1
f010b7bd:	ff 75 c0             	pushl  -0x40(%ebp)
f010b7c0:	50                   	push   %eax
f010b7c1:	e8 03 99 ff ff       	call   f01050c9 <pf_add_empty_env_page>
f010b7c6:	83 c4 10             	add    $0x10,%esp
f010b7c9:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b7cf:	81 6d c0 00 10 00 00 	subl   $0x1000,-0x40(%ebp)
f010b7d6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b7d9:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
f010b7df:	0f 83 af fc ff ff    	jae    f010b494 <env_create+0x630>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b7e5:	83 ec 0c             	sub    $0xc,%esp
f010b7e8:	6a 02                	push   $0x2
f010b7ea:	e8 36 40 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f010b7ef:	83 c4 10             	add    $0x10,%esp
f010b7f2:	85 c0                	test   %eax,%eax
f010b7f4:	74 72                	je     f010b868 <env_create+0xa04>
		{
			struct WorkingSetElement * elm = NULL;
f010b7f6:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010b7fd:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b803:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b809:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010b80c:	eb 2b                	jmp    f010b839 <env_create+0x9d5>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010b80e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010b811:	8b 10                	mov    (%eax),%edx
f010b813:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b819:	8b 40 64             	mov    0x64(%eax),%eax
f010b81c:	6a 01                	push   $0x1
f010b81e:	6a 00                	push   $0x0
f010b820:	52                   	push   %edx
f010b821:	50                   	push   %eax
f010b822:	e8 db e3 ff ff       	call   f0109c02 <pt_set_page_permissions>
f010b827:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010b82a:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b830:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b836:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010b839:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b83f:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010b843:	74 08                	je     f010b84d <env_create+0x9e9>
f010b845:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010b848:	8b 52 10             	mov    0x10(%edx),%edx
f010b84b:	eb 05                	jmp    f010b852 <env_create+0x9ee>
f010b84d:	ba 00 00 00 00       	mov    $0x0,%edx
f010b852:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
f010b858:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b85e:	85 c0                	test   %eax,%eax
f010b860:	75 ac                	jne    f010b80e <env_create+0x9aa>
f010b862:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010b866:	75 a6                	jne    f010b80e <env_create+0x9aa>
f010b868:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010b86b:	89 45 a0             	mov    %eax,-0x60(%ebp)
f010b86e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f010b871:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010b874:	e8 0c c8 ff ff       	call   f0108085 <popcli>

	//[13] Copy the prepaged VAs into the corresponding array
#if USE_KHEAP
	e->numOfPrepagedVAs = LIST_SIZE(&(e->page_WS_list));
f010b879:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b87f:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010b885:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010b88b:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	e->prepagedVAs = kmalloc(sizeof(uint32) * e->numOfPrepagedVAs);
f010b891:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f010b897:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b89d:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b8a3:	c1 e0 02             	shl    $0x2,%eax
f010b8a6:	83 ec 0c             	sub    $0xc,%esp
f010b8a9:	50                   	push   %eax
f010b8aa:	e8 8a e2 ff ff       	call   f0109b39 <kmalloc>
f010b8af:	83 c4 10             	add    $0x10,%esp
f010b8b2:	89 83 ac 00 00 00    	mov    %eax,0xac(%ebx)
	struct WorkingSetElement *ptrWSE;
	int w = 0;
f010b8b8:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	LIST_FOREACH(ptrWSE, &(e->page_WS_list))
f010b8bf:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b8c5:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010b8cb:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b8ce:	eb 31                	jmp    f010b901 <env_create+0xa9d>
	{
		e->prepagedVAs[w++] = ptrWSE->virtual_address;
f010b8d0:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b8d6:	8b 88 ac 00 00 00    	mov    0xac(%eax),%ecx
f010b8dc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b8df:	8d 50 01             	lea    0x1(%eax),%edx
f010b8e2:	89 55 b4             	mov    %edx,-0x4c(%ebp)
f010b8e5:	c1 e0 02             	shl    $0x2,%eax
f010b8e8:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010b8eb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b8ee:	8b 00                	mov    (%eax),%eax
f010b8f0:	89 02                	mov    %eax,(%edx)
#if USE_KHEAP
	e->numOfPrepagedVAs = LIST_SIZE(&(e->page_WS_list));
	e->prepagedVAs = kmalloc(sizeof(uint32) * e->numOfPrepagedVAs);
	struct WorkingSetElement *ptrWSE;
	int w = 0;
	LIST_FOREACH(ptrWSE, &(e->page_WS_list))
f010b8f2:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b8f8:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b8fe:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b901:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b907:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f010b90b:	74 08                	je     f010b915 <env_create+0xab1>
f010b90d:	8b 55 b8             	mov    -0x48(%ebp),%edx
f010b910:	8b 52 10             	mov    0x10(%edx),%edx
f010b913:	eb 05                	jmp    f010b91a <env_create+0xab6>
f010b915:	ba 00 00 00 00       	mov    $0x0,%edx
f010b91a:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
f010b920:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b926:	85 c0                	test   %eax,%eax
f010b928:	75 a6                	jne    f010b8d0 <env_create+0xa6c>
f010b92a:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f010b92e:	75 a0                	jne    f010b8d0 <env_create+0xa6c>
	{
		e->prepagedVAs[w++] = ptrWSE->virtual_address;
	}
	assert(w == e->numOfPrepagedVAs);
f010b930:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b936:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
f010b93c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b93f:	39 c2                	cmp    %eax,%edx
f010b941:	74 19                	je     f010b95c <env_create+0xaf8>
f010b943:	68 e5 f3 12 f0       	push   $0xf012f3e5
f010b948:	68 fe f3 12 f0       	push   $0xf012f3fe
f010b94d:	68 b9 01 00 00       	push   $0x1b9
f010b952:	68 3f f3 12 f0       	push   $0xf012f33f
f010b957:	e8 53 55 ff ff       	call   f0100eaf <_panic>
		//env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010b95c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
}
f010b962:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010b965:	5b                   	pop    %ebx
f010b966:	5e                   	pop    %esi
f010b967:	5f                   	pop    %edi
f010b968:	5d                   	pop    %ebp
f010b969:	c3                   	ret    

f010b96a <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010b96a:	55                   	push   %ebp
f010b96b:	89 e5                	mov    %esp,%ebp
f010b96d:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_kspinlock(&ProcessQueues.qlock);
f010b970:	83 ec 0c             	sub    $0xc,%esp
f010b973:	68 80 dd 83 f0       	push   $0xf083dd80
f010b978:	e8 a5 44 00 00       	call   f010fe22 <release_kspinlock>
f010b97d:	83 c4 10             	add    $0x10,%esp

	if (first)
f010b980:	a1 c4 fb 17 f0       	mov    0xf017fbc4,%eax
f010b985:	85 c0                	test   %eax,%eax
f010b987:	74 30                	je     f010b9b9 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010b989:	e8 8d 00 00 00       	call   f010ba1b <get_cpu_proc>
f010b98e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010b991:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b994:	8b 40 10             	mov    0x10(%eax),%eax
f010b997:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b99a:	83 c2 20             	add    $0x20,%edx
f010b99d:	83 ec 04             	sub    $0x4,%esp
f010b9a0:	50                   	push   %eax
f010b9a1:	52                   	push   %edx
f010b9a2:	68 13 f4 12 f0       	push   $0xf012f413
f010b9a7:	e8 b0 61 ff ff       	call   f0101b5c <cprintf>
f010b9ac:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010b9af:	c7 05 c4 fb 17 f0 00 	movl   $0x0,0xf017fbc4
f010b9b6:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010b9b9:	90                   	nop
f010b9ba:	c9                   	leave  
f010b9bb:	c3                   	ret    

f010b9bc <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010b9bc:	55                   	push   %ebp
f010b9bd:	89 e5                	mov    %esp,%ebp
f010b9bf:	83 ec 08             	sub    $0x8,%esp
#endif
	/*****************************************/
	//TODO: [PROJECT'25.BONUS#4] EXIT #1 & #2 - env_free
	//Your code is here
	//Comment the following line
	panic("env_free() is not implemented yet...!!");
f010b9c2:	83 ec 04             	sub    $0x4,%esp
f010b9c5:	68 2c f4 12 f0       	push   $0xf012f42c
f010b9ca:	68 f3 01 00 00       	push   $0x1f3
f010b9cf:	68 3f f3 12 f0       	push   $0xf012f33f
f010b9d4:	e8 d6 54 ff ff       	call   f0100eaf <_panic>

f010b9d9 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010b9d9:	55                   	push   %ebp
f010b9da:	89 e5                	mov    %esp,%ebp
f010b9dc:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010b9df:	e8 37 00 00 00       	call   f010ba1b <get_cpu_proc>
f010b9e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010b9e7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b9eb:	75 19                	jne    f010ba06 <env_exit+0x2d>
f010b9ed:	68 53 f4 12 f0       	push   $0xf012f453
f010b9f2:	68 fe f3 12 f0       	push   $0xf012f3fe
f010b9f7:	68 0e 02 00 00       	push   $0x20e
f010b9fc:	68 3f f3 12 f0       	push   $0xf012f33f
f010ba01:	e8 a9 54 ff ff       	call   f0100eaf <_panic>
	sched_exit_env(cur_env->env_id);
f010ba06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba09:	8b 40 10             	mov    0x10(%eax),%eax
f010ba0c:	83 ec 0c             	sub    $0xc,%esp
f010ba0f:	50                   	push   %eax
f010ba10:	e8 81 ad ff ff       	call   f0106796 <sched_exit_env>
f010ba15:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch in the sched() function which will be called in sched_exit_env()
	//fos_scheduler();
}
f010ba18:	90                   	nop
f010ba19:	c9                   	leave  
f010ba1a:	c3                   	ret    

f010ba1b <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010ba1b:	55                   	push   %ebp
f010ba1c:	89 e5                	mov    %esp,%ebp
f010ba1e:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010ba21:	e8 0d c6 ff ff       	call   f0108033 <pushcli>
	c = mycpu();
f010ba26:	e8 45 c5 ff ff       	call   f0107f70 <mycpu>
f010ba2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010ba2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba31:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010ba37:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010ba3a:	e8 46 c6 ff ff       	call   f0108085 <popcli>
	return p;
f010ba3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010ba42:	c9                   	leave  
f010ba43:	c3                   	ret    

f010ba44 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010ba44:	55                   	push   %ebp
f010ba45:	89 e5                	mov    %esp,%ebp
f010ba47:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010ba4a:	e8 e4 c5 ff ff       	call   f0108033 <pushcli>
	c = mycpu();
f010ba4f:	e8 1c c5 ff ff       	call   f0107f70 <mycpu>
f010ba54:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010ba57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba5a:	8b 55 08             	mov    0x8(%ebp),%edx
f010ba5d:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010ba63:	e8 1d c6 ff ff       	call   f0108085 <popcli>
}
f010ba68:	90                   	nop
f010ba69:	c9                   	leave  
f010ba6a:	c3                   	ret    

f010ba6b <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010ba6b:	55                   	push   %ebp
f010ba6c:	89 e5                	mov    %esp,%ebp
f010ba6e:	53                   	push   %ebx
f010ba6f:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010ba72:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ba76:	75 16                	jne    f010ba8e <envid2env+0x23>
		*env_store = get_cpu_proc();
f010ba78:	e8 9e ff ff ff       	call   f010ba1b <get_cpu_proc>
f010ba7d:	89 c2                	mov    %eax,%edx
f010ba7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ba82:	89 10                	mov    %edx,(%eax)
		return 0;
f010ba84:	b8 00 00 00 00       	mov    $0x0,%eax
f010ba89:	e9 a3 00 00 00       	jmp    f010bb31 <envid2env+0xc6>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010ba8e:	8b 1d f0 51 81 f0    	mov    0xf08151f0,%ebx
f010ba94:	83 ec 0c             	sub    $0xc,%esp
f010ba97:	68 c6 02 00 00       	push   $0x2c6
f010ba9c:	e8 7c d0 00 00       	call   f0118b1d <nearest_pow2_ceil>
f010baa1:	83 c4 10             	add    $0x10,%esp
f010baa4:	8d 50 ff             	lea    -0x1(%eax),%edx
f010baa7:	8b 45 08             	mov    0x8(%ebp),%eax
f010baaa:	21 c2                	and    %eax,%edx
f010baac:	89 d0                	mov    %edx,%eax
f010baae:	c1 e0 02             	shl    $0x2,%eax
f010bab1:	01 d0                	add    %edx,%eax
f010bab3:	c1 e0 03             	shl    $0x3,%eax
f010bab6:	01 d0                	add    %edx,%eax
f010bab8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010babf:	01 d0                	add    %edx,%eax
f010bac1:	c1 e0 02             	shl    $0x2,%eax
f010bac4:	01 d8                	add    %ebx,%eax
f010bac6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010bac9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bacc:	8b 40 18             	mov    0x18(%eax),%eax
f010bacf:	85 c0                	test   %eax,%eax
f010bad1:	74 0b                	je     f010bade <envid2env+0x73>
f010bad3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bad6:	8b 40 10             	mov    0x10(%eax),%eax
f010bad9:	3b 45 08             	cmp    0x8(%ebp),%eax
f010badc:	74 10                	je     f010baee <envid2env+0x83>
		*env_store = 0;
f010bade:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bae1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bae7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010baec:	eb 43                	jmp    f010bb31 <envid2env+0xc6>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010baee:	e8 28 ff ff ff       	call   f010ba1b <get_cpu_proc>
f010baf3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010baf6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010bafa:	74 28                	je     f010bb24 <envid2env+0xb9>
f010bafc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010baff:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010bb02:	74 20                	je     f010bb24 <envid2env+0xb9>
f010bb04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb07:	8b 50 14             	mov    0x14(%eax),%edx
f010bb0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bb0d:	8b 40 10             	mov    0x10(%eax),%eax
f010bb10:	39 c2                	cmp    %eax,%edx
f010bb12:	74 10                	je     f010bb24 <envid2env+0xb9>
		*env_store = 0;
f010bb14:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb17:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bb1d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bb22:	eb 0d                	jmp    f010bb31 <envid2env+0xc6>
	}

	*env_store = e;
f010bb24:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb27:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bb2a:	89 10                	mov    %edx,(%eax)
	return 0;
f010bb2c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bb31:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bb34:	c9                   	leave  
f010bb35:	c3                   	ret    

f010bb36 <yield>:
// 7) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010bb36:	55                   	push   %ebp
f010bb37:	89 e5                	mov    %esp,%ebp
f010bb39:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010bb3c:	83 ec 0c             	sub    $0xc,%esp
f010bb3f:	68 80 dd 83 f0       	push   $0xf083dd80
f010bb44:	e8 34 42 00 00       	call   f010fd7d <acquire_kspinlock>
f010bb49:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010bb4c:	e8 ca fe ff ff       	call   f010ba1b <get_cpu_proc>
f010bb51:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010bb54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bb58:	75 19                	jne    f010bb73 <yield+0x3d>
f010bb5a:	68 63 f4 12 f0       	push   $0xf012f463
f010bb5f:	68 fe f3 12 f0       	push   $0xf012f3fe
f010bb64:	68 6c 02 00 00       	push   $0x26c
f010bb69:	68 3f f3 12 f0       	push   $0xf012f33f
f010bb6e:	e8 3c 53 ff ff       	call   f0100eaf <_panic>
		p->env_status = ENV_READY;
f010bb73:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb76:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010bb7d:	e8 13 00 00 00       	call   f010bb95 <sched>
	}
	release_kspinlock(&ProcessQueues.qlock); ////release lock
f010bb82:	83 ec 0c             	sub    $0xc,%esp
f010bb85:	68 80 dd 83 f0       	push   $0xf083dd80
f010bb8a:	e8 93 42 00 00       	call   f010fe22 <release_kspinlock>
f010bb8f:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010bb92:	90                   	nop
f010bb93:	c9                   	leave  
f010bb94:	c3                   	ret    

f010bb95 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010bb95:	55                   	push   %ebp
f010bb96:	89 e5                	mov    %esp,%ebp
f010bb98:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010bb9b:	e8 7b fe ff ff       	call   f010ba1b <get_cpu_proc>
f010bba0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010bba3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bba7:	75 19                	jne    f010bbc2 <sched+0x2d>
f010bba9:	68 63 f4 12 f0       	push   $0xf012f463
f010bbae:	68 fe f3 12 f0       	push   $0xf012f3fe
f010bbb3:	68 80 02 00 00       	push   $0x280
f010bbb8:	68 3f f3 12 f0       	push   $0xf012f33f
f010bbbd:	e8 ed 52 ff ff       	call   f0100eaf <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f010bbc2:	83 ec 0c             	sub    $0xc,%esp
f010bbc5:	68 80 dd 83 f0       	push   $0xf083dd80
f010bbca:	e8 03 44 00 00       	call   f010ffd2 <holding_kspinlock>
f010bbcf:	83 c4 10             	add    $0x10,%esp
f010bbd2:	85 c0                	test   %eax,%eax
f010bbd4:	75 17                	jne    f010bbed <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010bbd6:	83 ec 04             	sub    $0x4,%esp
f010bbd9:	68 70 f4 12 f0       	push   $0xf012f470
f010bbde:	68 84 02 00 00       	push   $0x284
f010bbe3:	68 3f f3 12 f0       	push   $0xf012f33f
f010bbe8:	e8 c2 52 ff ff       	call   f0100eaf <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010bbed:	e8 7e c3 ff ff       	call   f0107f70 <mycpu>
f010bbf2:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bbf8:	83 f8 01             	cmp    $0x1,%eax
f010bbfb:	74 20                	je     f010bc1d <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010bbfd:	e8 6e c3 ff ff       	call   f0107f70 <mycpu>
f010bc02:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bc08:	50                   	push   %eax
f010bc09:	68 b2 f4 12 f0       	push   $0xf012f4b2
f010bc0e:	68 87 02 00 00       	push   $0x287
f010bc13:	68 3f f3 12 f0       	push   $0xf012f33f
f010bc18:	e8 92 52 ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010bc1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc20:	8b 40 18             	mov    0x18(%eax),%eax
f010bc23:	83 f8 02             	cmp    $0x2,%eax
f010bc26:	75 17                	jne    f010bc3f <sched+0xaa>
		panic("sched a running process");
f010bc28:	83 ec 04             	sub    $0x4,%esp
f010bc2b:	68 c9 f4 12 f0       	push   $0xf012f4c9
f010bc30:	68 8a 02 00 00       	push   $0x28a
f010bc35:	68 3f f3 12 f0       	push   $0xf012f33f
f010bc3a:	e8 70 52 ff ff       	call   f0100eaf <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010bc3f:	9c                   	pushf  
f010bc40:	58                   	pop    %eax
f010bc41:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010bc44:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010bc47:	25 00 02 00 00       	and    $0x200,%eax
f010bc4c:	85 c0                	test   %eax,%eax
f010bc4e:	74 17                	je     f010bc67 <sched+0xd2>
		panic("sched is interruptible!");
f010bc50:	83 ec 04             	sub    $0x4,%esp
f010bc53:	68 e1 f4 12 f0       	push   $0xf012f4e1
f010bc58:	68 8c 02 00 00       	push   $0x28c
f010bc5d:	68 3f f3 12 f0       	push   $0xf012f33f
f010bc62:	e8 48 52 ff ff       	call   f0100eaf <_panic>
	intena = mycpu()->intena;
f010bc67:	e8 04 c3 ff ff       	call   f0107f70 <mycpu>
f010bc6c:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010bc72:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010bc75:	e8 f6 c2 ff ff       	call   f0107f70 <mycpu>
f010bc7a:	8b 40 04             	mov    0x4(%eax),%eax
f010bc7d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bc80:	83 c2 04             	add    $0x4,%edx
f010bc83:	83 ec 08             	sub    $0x8,%esp
f010bc86:	50                   	push   %eax
f010bc87:	52                   	push   %edx
f010bc88:	e8 45 9e ff ff       	call   f0105ad2 <context_switch>
f010bc8d:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010bc90:	e8 db c2 ff ff       	call   f0107f70 <mycpu>
f010bc95:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bc98:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010bc9e:	90                   	nop
f010bc9f:	c9                   	leave  
f010bca0:	c3                   	ret    

f010bca1 <switchkvm>:
// 9) SWITCH VIRTUAL MEMORYs:
//===============================
// [9.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010bca1:	55                   	push   %ebp
f010bca2:	89 e5                	mov    %esp,%ebp
f010bca4:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010bca7:	a1 40 64 85 f0       	mov    0xf0856440,%eax
f010bcac:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bcaf:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010bcb2:	0f 22 d8             	mov    %eax,%cr3
}
f010bcb5:	90                   	nop
f010bcb6:	c9                   	leave  
f010bcb7:	c3                   	ret    

f010bcb8 <switchuvm>:

// [9.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010bcb8:	55                   	push   %ebp
f010bcb9:	89 e5                	mov    %esp,%ebp
f010bcbb:	53                   	push   %ebx
f010bcbc:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010bcbf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bcc3:	75 17                	jne    f010bcdc <switchuvm+0x24>
		panic("switchuvm: no process");
f010bcc5:	83 ec 04             	sub    $0x4,%esp
f010bcc8:	68 f9 f4 12 f0       	push   $0xf012f4f9
f010bccd:	68 a1 02 00 00       	push   $0x2a1
f010bcd2:	68 3f f3 12 f0       	push   $0xf012f33f
f010bcd7:	e8 d3 51 ff ff       	call   f0100eaf <_panic>
	if(proc->kstack == 0)
f010bcdc:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcdf:	8b 40 70             	mov    0x70(%eax),%eax
f010bce2:	85 c0                	test   %eax,%eax
f010bce4:	75 17                	jne    f010bcfd <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010bce6:	83 ec 04             	sub    $0x4,%esp
f010bce9:	68 0f f5 12 f0       	push   $0xf012f50f
f010bcee:	68 a3 02 00 00       	push   $0x2a3
f010bcf3:	68 3f f3 12 f0       	push   $0xf012f33f
f010bcf8:	e8 b2 51 ff ff       	call   f0100eaf <_panic>
	if(proc->env_page_directory == 0)
f010bcfd:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd00:	8b 40 64             	mov    0x64(%eax),%eax
f010bd03:	85 c0                	test   %eax,%eax
f010bd05:	75 17                	jne    f010bd1e <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010bd07:	83 ec 04             	sub    $0x4,%esp
f010bd0a:	68 24 f5 12 f0       	push   $0xf012f524
f010bd0f:	68 a5 02 00 00       	push   $0x2a5
f010bd14:	68 3f f3 12 f0       	push   $0xf012f33f
f010bd19:	e8 91 51 ff ff       	call   f0100eaf <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010bd1e:	e8 10 c3 ff ff       	call   f0108033 <pushcli>
	struct cpu* c = mycpu();
f010bd23:	e8 48 c2 ff ff       	call   f0107f70 <mycpu>
f010bd28:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010bd2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd2e:	8b 55 08             	mov    0x8(%ebp),%edx
f010bd31:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010bd37:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd3a:	83 c0 0c             	add    $0xc,%eax
f010bd3d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd40:	83 c2 0c             	add    $0xc,%edx
f010bd43:	c1 ea 10             	shr    $0x10,%edx
f010bd46:	88 d3                	mov    %dl,%bl
f010bd48:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd4b:	83 c2 0c             	add    $0xc,%edx
f010bd4e:	c1 ea 18             	shr    $0x18,%edx
f010bd51:	88 d1                	mov    %dl,%cl
f010bd53:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd56:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010bd5d:	68 00 
f010bd5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd62:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010bd69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd6c:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010bd72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd75:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bd7b:	83 e2 f0             	and    $0xfffffff0,%edx
f010bd7e:	83 ca 09             	or     $0x9,%edx
f010bd81:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bd87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd8a:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bd90:	83 ca 10             	or     $0x10,%edx
f010bd93:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bd99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd9c:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bda2:	83 e2 9f             	and    $0xffffff9f,%edx
f010bda5:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bdab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdae:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bdb4:	83 ca 80             	or     $0xffffff80,%edx
f010bdb7:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bdbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdc0:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bdc6:	83 e2 f0             	and    $0xfffffff0,%edx
f010bdc9:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bdcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdd2:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bdd8:	83 e2 ef             	and    $0xffffffef,%edx
f010bddb:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bde1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bde4:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bdea:	83 e2 df             	and    $0xffffffdf,%edx
f010bded:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bdf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdf6:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bdfc:	83 ca 40             	or     $0x40,%edx
f010bdff:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be08:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be0e:	83 e2 7f             	and    $0x7f,%edx
f010be11:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be17:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be1a:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010be20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be23:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be29:	83 e2 ef             	and    $0xffffffef,%edx
f010be2c:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010be32:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be35:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010be3b:	8b 40 70             	mov    0x70(%eax),%eax
f010be3e:	05 00 80 00 00       	add    $0x8000,%eax
f010be43:	89 c2                	mov    %eax,%edx
f010be45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be48:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010be4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be4e:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010be54:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010be5a:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010be5e:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010be61:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be64:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010be6a:	8b 40 68             	mov    0x68(%eax),%eax
f010be6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010be70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010be73:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010be76:	e8 0a c2 ff ff       	call   f0108085 <popcli>
}
f010be7b:	90                   	nop
f010be7c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010be7f:	c9                   	leave  
f010be80:	c3                   	ret    

f010be81 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010be81:	55                   	push   %ebp
f010be82:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010be84:	8b 15 f4 51 81 f0    	mov    0xf08151f4,%edx
f010be8a:	8b 45 08             	mov    0x8(%ebp),%eax
f010be8d:	89 10                	mov    %edx,(%eax)
f010be8f:	8b 45 08             	mov    0x8(%ebp),%eax
f010be92:	8b 00                	mov    (%eax),%eax
f010be94:	85 c0                	test   %eax,%eax
f010be96:	75 07                	jne    f010be9f <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010be98:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010be9d:	eb 11                	jmp    f010beb0 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010be9f:	8b 45 08             	mov    0x8(%ebp),%eax
f010bea2:	8b 00                	mov    (%eax),%eax
f010bea4:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
	return 0;
f010beab:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010beb0:	5d                   	pop    %ebp
f010beb1:	c3                   	ret    

f010beb2 <free_environment>:
//===============================
// 3) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010beb2:	55                   	push   %ebp
f010beb3:	89 e5                	mov    %esp,%ebp
f010beb5:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010beb8:	83 ec 04             	sub    $0x4,%esp
f010bebb:	68 c4 05 00 00       	push   $0x5c4
f010bec0:	6a 00                	push   $0x0
f010bec2:	ff 75 08             	pushl  0x8(%ebp)
f010bec5:	e8 a1 ed 00 00       	call   f011ac6b <memset>
f010beca:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010becd:	8b 45 08             	mov    0x8(%ebp),%eax
f010bed0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010bed7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bedb:	75 17                	jne    f010bef4 <free_environment+0x42>
f010bedd:	83 ec 04             	sub    $0x4,%esp
f010bee0:	68 1c f3 12 f0       	push   $0xf012f31c
f010bee5:	68 e4 02 00 00       	push   $0x2e4
f010beea:	68 3f f3 12 f0       	push   $0xf012f33f
f010beef:	e8 bb 4f ff ff       	call   f0100eaf <_panic>
f010bef4:	8b 15 f4 51 81 f0    	mov    0xf08151f4,%edx
f010befa:	8b 45 08             	mov    0x8(%ebp),%eax
f010befd:	89 50 08             	mov    %edx,0x8(%eax)
f010bf00:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf03:	8b 40 08             	mov    0x8(%eax),%eax
f010bf06:	85 c0                	test   %eax,%eax
f010bf08:	74 0d                	je     f010bf17 <free_environment+0x65>
f010bf0a:	a1 f4 51 81 f0       	mov    0xf08151f4,%eax
f010bf0f:	8b 55 08             	mov    0x8(%ebp),%edx
f010bf12:	89 50 0c             	mov    %edx,0xc(%eax)
f010bf15:	eb 08                	jmp    f010bf1f <free_environment+0x6d>
f010bf17:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf1a:	a3 f8 51 81 f0       	mov    %eax,0xf08151f8
f010bf1f:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf22:	a3 f4 51 81 f0       	mov    %eax,0xf08151f4
f010bf27:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf2a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010bf31:	a1 00 52 81 f0       	mov    0xf0815200,%eax
f010bf36:	40                   	inc    %eax
f010bf37:	a3 00 52 81 f0       	mov    %eax,0xf0815200
}
f010bf3c:	90                   	nop
f010bf3d:	c9                   	leave  
f010bf3e:	c3                   	ret    

f010bf3f <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010bf3f:	55                   	push   %ebp
f010bf40:	89 e5                	mov    %esp,%ebp
f010bf42:	53                   	push   %ebx
f010bf43:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010bf46:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bf49:	8b 40 0c             	mov    0xc(%eax),%eax
f010bf4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010bf4f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bf52:	8b 40 08             	mov    0x8(%eax),%eax
f010bf55:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010bf58:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010bf5f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010bf62:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bf65:	01 c2                	add    %eax,%edx
f010bf67:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bf6a:	01 d0                	add    %edx,%eax
f010bf6c:	48                   	dec    %eax
f010bf6d:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010bf70:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bf73:	ba 00 00 00 00       	mov    $0x0,%edx
f010bf78:	f7 75 dc             	divl   -0x24(%ebp)
f010bf7b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bf7e:	29 d0                	sub    %edx,%eax
f010bf80:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010bf83:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bf86:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010bf89:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010bf8c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bf91:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010bf94:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010bf9b:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010bfa2:	8b 45 10             	mov    0x10(%ebp),%eax
f010bfa5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010bfab:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010bfb2:	0f 85 f5 03 00 00    	jne    f010c3ad <program_segment_alloc_map_copy_workingset+0x46e>
f010bfb8:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfbb:	83 c0 20             	add    $0x20,%eax
f010bfbe:	83 ec 08             	sub    $0x8,%esp
f010bfc1:	68 38 f5 12 f0       	push   $0xf012f538
f010bfc6:	50                   	push   %eax
f010bfc7:	e8 bd eb 00 00       	call   f011ab89 <strcmp>
f010bfcc:	83 c4 10             	add    $0x10,%esp
f010bfcf:	85 c0                	test   %eax,%eax
f010bfd1:	0f 84 d6 03 00 00    	je     f010c3ad <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010bfd7:	8b 45 14             	mov    0x14(%ebp),%eax
f010bfda:	83 f8 06             	cmp    $0x6,%eax
f010bfdd:	76 05                	jbe    f010bfe4 <program_segment_alloc_map_copy_workingset+0xa5>
f010bfdf:	b8 06 00 00 00       	mov    $0x6,%eax
f010bfe4:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010bfe7:	e9 c1 03 00 00       	jmp    f010c3ad <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010bfec:	83 ec 0c             	sub    $0xc,%esp
f010bfef:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010bff2:	50                   	push   %eax
f010bff3:	e8 4d d0 ff ff       	call   f0109045 <allocate_frame>
f010bff8:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010bffb:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010bffe:	8b 45 08             	mov    0x8(%ebp),%eax
f010c001:	8b 40 64             	mov    0x64(%eax),%eax
f010c004:	6a 06                	push   $0x6
f010c006:	ff 75 f4             	pushl  -0xc(%ebp)
f010c009:	52                   	push   %edx
f010c00a:	50                   	push   %eax
f010c00b:	e8 e6 d6 ff ff       	call   f01096f6 <loadtime_map_frame>
f010c010:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010c013:	83 ec 08             	sub    $0x8,%esp
f010c016:	ff 75 f4             	pushl  -0xc(%ebp)
f010c019:	ff 75 08             	pushl  0x8(%ebp)
f010c01c:	e8 e7 de ff ff       	call   f0109f08 <env_page_ws_list_create_element>
f010c021:	83 c4 10             	add    $0x10,%esp
f010c024:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010c027:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c02a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010c031:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c035:	75 17                	jne    f010c04e <program_segment_alloc_map_copy_workingset+0x10f>
f010c037:	83 ec 04             	sub    $0x4,%esp
f010c03a:	68 a4 f3 12 f0       	push   $0xf012f3a4
f010c03f:	68 0e 03 00 00       	push   $0x30e
f010c044:	68 3f f3 12 f0       	push   $0xf012f33f
f010c049:	e8 61 4e ff ff       	call   f0100eaf <_panic>
f010c04e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c051:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010c057:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c05a:	89 50 14             	mov    %edx,0x14(%eax)
f010c05d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c060:	8b 40 14             	mov    0x14(%eax),%eax
f010c063:	85 c0                	test   %eax,%eax
f010c065:	74 11                	je     f010c078 <program_segment_alloc_map_copy_workingset+0x139>
f010c067:	8b 45 08             	mov    0x8(%ebp),%eax
f010c06a:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010c070:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c073:	89 50 10             	mov    %edx,0x10(%eax)
f010c076:	eb 0c                	jmp    f010c084 <program_segment_alloc_map_copy_workingset+0x145>
f010c078:	8b 45 08             	mov    0x8(%ebp),%eax
f010c07b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c07e:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010c084:	8b 45 08             	mov    0x8(%ebp),%eax
f010c087:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c08a:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010c090:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c093:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c09a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c09d:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010c0a3:	8d 50 01             	lea    0x1(%eax),%edx
f010c0a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0a9:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c0af:	83 ec 0c             	sub    $0xc,%esp
f010c0b2:	6a 02                	push   $0x2
f010c0b4:	e8 6c 37 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f010c0b9:	83 c4 10             	add    $0x10,%esp
f010c0bc:	85 c0                	test   %eax,%eax
f010c0be:	0f 84 b3 01 00 00    	je     f010c277 <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			//Remove wse from page_WS_list
			LIST_REMOVE(&(e->page_WS_list), wse);
f010c0c4:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c0c8:	75 17                	jne    f010c0e1 <program_segment_alloc_map_copy_workingset+0x1a2>
f010c0ca:	83 ec 04             	sub    $0x4,%esp
f010c0cd:	68 c7 f3 12 f0       	push   $0xf012f3c7
f010c0d2:	68 1b 03 00 00       	push   $0x31b
f010c0d7:	68 3f f3 12 f0       	push   $0xf012f33f
f010c0dc:	e8 ce 4d ff ff       	call   f0100eaf <_panic>
f010c0e1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0e4:	8b 40 10             	mov    0x10(%eax),%eax
f010c0e7:	85 c0                	test   %eax,%eax
f010c0e9:	74 11                	je     f010c0fc <program_segment_alloc_map_copy_workingset+0x1bd>
f010c0eb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0ee:	8b 40 10             	mov    0x10(%eax),%eax
f010c0f1:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c0f4:	8b 52 14             	mov    0x14(%edx),%edx
f010c0f7:	89 50 14             	mov    %edx,0x14(%eax)
f010c0fa:	eb 0f                	jmp    f010c10b <program_segment_alloc_map_copy_workingset+0x1cc>
f010c0fc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0ff:	8b 50 14             	mov    0x14(%eax),%edx
f010c102:	8b 45 08             	mov    0x8(%ebp),%eax
f010c105:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010c10b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c10e:	8b 40 14             	mov    0x14(%eax),%eax
f010c111:	85 c0                	test   %eax,%eax
f010c113:	74 11                	je     f010c126 <program_segment_alloc_map_copy_workingset+0x1e7>
f010c115:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c118:	8b 40 14             	mov    0x14(%eax),%eax
f010c11b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c11e:	8b 52 10             	mov    0x10(%edx),%edx
f010c121:	89 50 10             	mov    %edx,0x10(%eax)
f010c124:	eb 0f                	jmp    f010c135 <program_segment_alloc_map_copy_workingset+0x1f6>
f010c126:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c129:	8b 50 10             	mov    0x10(%eax),%edx
f010c12c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c12f:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010c135:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c138:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c13f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c142:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c149:	8b 45 08             	mov    0x8(%ebp),%eax
f010c14c:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010c152:	8d 50 ff             	lea    -0x1(%eax),%edx
f010c155:	8b 45 08             	mov    0x8(%ebp),%eax
f010c158:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010c15e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c161:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f010c167:	8b 45 08             	mov    0x8(%ebp),%eax
f010c16a:	8b 80 88 05 00 00    	mov    0x588(%eax),%eax
f010c170:	48                   	dec    %eax
f010c171:	39 c2                	cmp    %eax,%edx
f010c173:	0f 83 80 00 00 00    	jae    f010c1f9 <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010c179:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c17d:	75 17                	jne    f010c196 <program_segment_alloc_map_copy_workingset+0x257>
f010c17f:	83 ec 04             	sub    $0x4,%esp
f010c182:	68 1c f3 12 f0       	push   $0xf012f31c
f010c187:	68 1f 03 00 00       	push   $0x31f
f010c18c:	68 3f f3 12 f0       	push   $0xf012f33f
f010c191:	e8 19 4d ff ff       	call   f0100eaf <_panic>
f010c196:	8b 45 08             	mov    0x8(%ebp),%eax
f010c199:	8b 90 68 05 00 00    	mov    0x568(%eax),%edx
f010c19f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1a2:	89 50 10             	mov    %edx,0x10(%eax)
f010c1a5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1a8:	8b 40 10             	mov    0x10(%eax),%eax
f010c1ab:	85 c0                	test   %eax,%eax
f010c1ad:	74 11                	je     f010c1c0 <program_segment_alloc_map_copy_workingset+0x281>
f010c1af:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1b2:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010c1b8:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1bb:	89 50 14             	mov    %edx,0x14(%eax)
f010c1be:	eb 0c                	jmp    f010c1cc <program_segment_alloc_map_copy_workingset+0x28d>
f010c1c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1c3:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1c6:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010c1cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1cf:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1d2:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010c1d8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1db:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c1e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1e5:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010c1eb:	8d 50 01             	lea    0x1(%eax),%edx
f010c1ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1f1:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010c1f7:	eb 7e                	jmp    f010c277 <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010c1f9:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c1fd:	75 17                	jne    f010c216 <program_segment_alloc_map_copy_workingset+0x2d7>
f010c1ff:	83 ec 04             	sub    $0x4,%esp
f010c202:	68 1c f3 12 f0       	push   $0xf012f31c
f010c207:	68 24 03 00 00       	push   $0x324
f010c20c:	68 3f f3 12 f0       	push   $0xf012f33f
f010c211:	e8 99 4c ff ff       	call   f0100eaf <_panic>
f010c216:	8b 45 08             	mov    0x8(%ebp),%eax
f010c219:	8b 90 78 05 00 00    	mov    0x578(%eax),%edx
f010c21f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c222:	89 50 10             	mov    %edx,0x10(%eax)
f010c225:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c228:	8b 40 10             	mov    0x10(%eax),%eax
f010c22b:	85 c0                	test   %eax,%eax
f010c22d:	74 11                	je     f010c240 <program_segment_alloc_map_copy_workingset+0x301>
f010c22f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c232:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010c238:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c23b:	89 50 14             	mov    %edx,0x14(%eax)
f010c23e:	eb 0c                	jmp    f010c24c <program_segment_alloc_map_copy_workingset+0x30d>
f010c240:	8b 45 08             	mov    0x8(%ebp),%eax
f010c243:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c246:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010c24c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c24f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c252:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010c258:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c25b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c262:	8b 45 08             	mov    0x8(%ebp),%eax
f010c265:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010c26b:	8d 50 01             	lea    0x1(%eax),%edx
f010c26e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c271:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010c277:	8b 45 08             	mov    0x8(%ebp),%eax
f010c27a:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010c280:	8b 45 08             	mov    0x8(%ebp),%eax
f010c283:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010c289:	39 c2                	cmp    %eax,%edx
f010c28b:	75 14                	jne    f010c2a1 <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010c28d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c290:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f010c296:	8b 45 08             	mov    0x8(%ebp),%eax
f010c299:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c29f:	eb 0d                	jmp    f010c2ae <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010c2a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2a4:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010c2ab:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010c2ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c2b1:	c1 e8 16             	shr    $0x16,%eax
f010c2b4:	89 c2                	mov    %eax,%edx
f010c2b6:	8b 45 18             	mov    0x18(%ebp),%eax
f010c2b9:	8b 00                	mov    (%eax),%eax
f010c2bb:	39 c2                	cmp    %eax,%edx
f010c2bd:	0f 84 d3 00 00 00    	je     f010c396 <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010c2c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2c6:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010c2cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c2cf:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010c2d2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c2d5:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c2da:	89 c1                	mov    %eax,%ecx
f010c2dc:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010c2df:	89 d0                	mov    %edx,%eax
f010c2e1:	01 c0                	add    %eax,%eax
f010c2e3:	01 d0                	add    %edx,%eax
f010c2e5:	c1 e0 03             	shl    $0x3,%eax
f010c2e8:	01 d8                	add    %ebx,%eax
f010c2ea:	05 b4 00 00 00       	add    $0xb4,%eax
f010c2ef:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010c2f1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2f4:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010c2fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c2fd:	89 d0                	mov    %edx,%eax
f010c2ff:	01 c0                	add    %eax,%eax
f010c301:	01 d0                	add    %edx,%eax
f010c303:	c1 e0 03             	shl    $0x3,%eax
f010c306:	01 c8                	add    %ecx,%eax
f010c308:	05 b8 00 00 00       	add    $0xb8,%eax
f010c30d:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010c310:	8b 45 08             	mov    0x8(%ebp),%eax
f010c313:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010c319:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c31c:	89 d0                	mov    %edx,%eax
f010c31e:	01 c0                	add    %eax,%eax
f010c320:	01 d0                	add    %edx,%eax
f010c322:	c1 e0 03             	shl    $0x3,%eax
f010c325:	01 c8                	add    %ecx,%eax
f010c327:	05 bc 00 00 00       	add    $0xbc,%eax
f010c32c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010c332:	8b 45 08             	mov    0x8(%ebp),%eax
f010c335:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010c33b:	8d 50 01             	lea    0x1(%eax),%edx
f010c33e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c341:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010c347:	8b 45 08             	mov    0x8(%ebp),%eax
f010c34a:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010c350:	b9 32 00 00 00       	mov    $0x32,%ecx
f010c355:	ba 00 00 00 00       	mov    $0x0,%edx
f010c35a:	f7 f1                	div    %ecx
f010c35c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c35f:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
			if (e->table_last_WS_index == 0)
f010c365:	8b 45 08             	mov    0x8(%ebp),%eax
f010c368:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010c36e:	85 c0                	test   %eax,%eax
f010c370:	75 17                	jne    f010c389 <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010c372:	83 ec 04             	sub    $0x4,%esp
f010c375:	68 3c f5 12 f0       	push   $0xf012f53c
f010c37a:	68 4b 03 00 00       	push   $0x34b
f010c37f:	68 3f f3 12 f0       	push   $0xf012f33f
f010c384:	e8 26 4b ff ff       	call   f0100eaf <_panic>
			(*lastTableNumber) = PDX(iVA);
f010c389:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c38c:	c1 e8 16             	shr    $0x16,%eax
f010c38f:	89 c2                	mov    %eax,%edx
f010c391:	8b 45 18             	mov    0x18(%ebp),%eax
f010c394:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010c396:	8b 45 10             	mov    0x10(%ebp),%eax
f010c399:	8b 00                	mov    (%eax),%eax
f010c39b:	8d 50 01             	lea    0x1(%eax),%edx
f010c39e:	8b 45 10             	mov    0x10(%ebp),%eax
f010c3a1:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c3a3:	ff 45 f0             	incl   -0x10(%ebp)
f010c3a6:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c3ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c3b0:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010c3b3:	73 0c                	jae    f010c3c1 <program_segment_alloc_map_copy_workingset+0x482>
f010c3b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c3b8:	3b 45 14             	cmp    0x14(%ebp),%eax
f010c3bb:	0f 82 2b fc ff ff    	jb     f010bfec <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010c3c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c3c4:	8b 00                	mov    (%eax),%eax
f010c3c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010c3c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c3cc:	8b 40 0c             	mov    0xc(%eax),%eax
f010c3cf:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c3d2:	eb 10                	jmp    f010c3e4 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010c3d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c3d7:	8a 10                	mov    (%eax),%dl
f010c3d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c3dc:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010c3de:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010c3e1:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c3e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c3e7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010c3ea:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c3ed:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c3f2:	89 c2                	mov    %eax,%edx
f010c3f4:	8b 45 10             	mov    0x10(%ebp),%eax
f010c3f7:	8b 00                	mov    (%eax),%eax
f010c3f9:	c1 e0 0c             	shl    $0xc,%eax
f010c3fc:	01 c2                	add    %eax,%edx
f010c3fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c401:	39 c2                	cmp    %eax,%edx
f010c403:	76 1d                	jbe    f010c422 <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010c405:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c408:	8b 50 04             	mov    0x4(%eax),%edx
f010c40b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c40e:	01 c2                	add    %eax,%edx
f010c410:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c413:	39 c2                	cmp    %eax,%edx
f010c415:	77 bd                	ja     f010c3d4 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c417:	eb 09                	jmp    f010c422 <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010c419:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c41c:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010c41f:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c422:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c425:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010c428:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010c42b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c430:	89 c2                	mov    %eax,%edx
f010c432:	8b 45 10             	mov    0x10(%ebp),%eax
f010c435:	8b 00                	mov    (%eax),%eax
f010c437:	c1 e0 0c             	shl    $0xc,%eax
f010c43a:	01 c2                	add    %eax,%edx
f010c43c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c43f:	39 c2                	cmp    %eax,%edx
f010c441:	77 d6                	ja     f010c419 <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010c443:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c448:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c44b:	c9                   	leave  
f010c44c:	c3                   	ret    

f010c44d <create_user_directory>:

//==================================================
// 5) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010c44d:	55                   	push   %ebp
f010c44e:	89 e5                	mov    %esp,%ebp
f010c450:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010c453:	83 ec 0c             	sub    $0xc,%esp
f010c456:	68 00 10 00 00       	push   $0x1000
f010c45b:	e8 d9 d6 ff ff       	call   f0109b39 <kmalloc>
f010c460:	83 c4 10             	add    $0x10,%esp
f010c463:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010c466:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c46a:	75 17                	jne    f010c483 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010c46c:	83 ec 04             	sub    $0x4,%esp
f010c46f:	68 df f5 12 f0       	push   $0xf012f5df
f010c474:	68 7b 03 00 00       	push   $0x37b
f010c479:	68 3f f3 12 f0       	push   $0xf012f33f
f010c47e:	e8 2c 4a ff ff       	call   f0100eaf <_panic>
	}
	return ptr_user_page_directory;
f010c483:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010c486:	c9                   	leave  
f010c487:	c3                   	ret    

f010c488 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 6) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010c488:	55                   	push   %ebp
f010c489:	89 e5                	mov    %esp,%ebp
f010c48b:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#3] FAULT HANDLER I - #1 create_user_kern_stack
	//Your code is here
	//Comment the following line
	panic("create_user_kern_stack() is not implemented yet...!!");
f010c48e:	83 ec 04             	sub    $0x4,%esp
f010c491:	68 fc f5 12 f0       	push   $0xf012f5fc
f010c496:	68 8b 03 00 00       	push   $0x38b
f010c49b:	68 3f f3 12 f0       	push   $0xf012f33f
f010c4a0:	e8 0a 4a ff ff       	call   f0100eaf <_panic>

f010c4a5 <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010c4a5:	55                   	push   %ebp
f010c4a6:	89 e5                	mov    %esp,%ebp
f010c4a8:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//TODO: [PROJECT'25.BONUS#4] EXIT #1 & #2 - delete_user_kern_stack
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010c4ab:	83 ec 04             	sub    $0x4,%esp
f010c4ae:	68 34 f6 12 f0       	push   $0xf012f634
f010c4b3:	68 9b 03 00 00       	push   $0x39b
f010c4b8:	68 3f f3 12 f0       	push   $0xf012f33f
f010c4bd:	e8 ed 49 ff ff       	call   f0100eaf <_panic>

f010c4c2 <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010c4c2:	55                   	push   %ebp
f010c4c3:	89 e5                	mov    %esp,%ebp
f010c4c5:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010c4c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4cb:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c4ce:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010c4d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4d4:	8b 55 10             	mov    0x10(%ebp),%edx
f010c4d7:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c4da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c4e1:	eb 17                	jmp    f010c4fa <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010c4e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4e6:	8b 40 64             	mov    0x64(%eax),%eax
f010c4e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c4ec:	c1 e2 02             	shl    $0x2,%edx
f010c4ef:	01 d0                	add    %edx,%eax
f010c4f1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c4f7:	ff 45 f4             	incl   -0xc(%ebp)
f010c4fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4fd:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010c502:	76 df                	jbe    f010c4e3 <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c504:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010c50b:	eb 22                	jmp    f010c52f <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010c50d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c510:	8b 40 64             	mov    0x64(%eax),%eax
f010c513:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c516:	c1 e2 02             	shl    $0x2,%edx
f010c519:	01 c2                	add    %eax,%edx
f010c51b:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f010c520:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c523:	c1 e1 02             	shl    $0x2,%ecx
f010c526:	01 c8                	add    %ecx,%eax
f010c528:	8b 00                	mov    (%eax),%eax
f010c52a:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c52c:	ff 45 f4             	incl   -0xc(%ebp)
f010c52f:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010c536:	7e d5                	jle    f010c50d <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010c538:	8b 45 08             	mov    0x8(%ebp),%eax
f010c53b:	8b 40 64             	mov    0x64(%eax),%eax
f010c53e:	83 ec 0c             	sub    $0xc,%esp
f010c541:	50                   	push   %eax
f010c542:	e8 41 ff ff ff       	call   f010c488 <create_user_kern_stack>
f010c547:	83 c4 10             	add    $0x10,%esp
f010c54a:	89 c2                	mov    %eax,%edx
f010c54c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c54f:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010c552:	8b 45 08             	mov    0x8(%ebp),%eax
f010c555:	8b 40 70             	mov    0x70(%eax),%eax
f010c558:	05 00 80 00 00       	add    $0x8000,%eax
f010c55d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010c560:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010c564:	8b 45 08             	mov    0x8(%ebp),%eax
f010c567:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c56a:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010c56c:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010c570:	ba 6a e6 10 f0       	mov    $0xf010e66a,%edx
f010c575:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c578:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010c57a:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010c57e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c581:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c584:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010c587:	8b 45 08             	mov    0x8(%ebp),%eax
f010c58a:	8b 40 04             	mov    0x4(%eax),%eax
f010c58d:	83 ec 04             	sub    $0x4,%esp
f010c590:	6a 20                	push   $0x20
f010c592:	6a 00                	push   $0x0
f010c594:	50                   	push   %eax
f010c595:	e8 d1 e6 00 00       	call   f011ac6b <memset>
f010c59a:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010c59d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5a0:	8b 40 04             	mov    0x4(%eax),%eax
f010c5a3:	ba 6a b9 10 f0       	mov    $0xf010b96a,%edx
f010c5a8:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010c5ab:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5ae:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010c5b5:	00 00 00 
f010c5b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5bb:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010c5c2:	00 00 00 
f010c5c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5c8:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010c5cf:	00 00 00 
		LIST_INIT(&(e->referenceStreamList));
f010c5d2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5d5:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f010c5dc:	00 00 00 
f010c5df:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5e2:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010c5e9:	00 00 00 
f010c5ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5ef:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010c5f6:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c5f9:	83 ec 0c             	sub    $0xc,%esp
f010c5fc:	6a 02                	push   $0x2
f010c5fe:	e8 22 32 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f010c603:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c606:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c60d:	eb 54                	jmp    f010c663 <initialize_environment+0x1a1>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010c60f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c612:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c615:	89 d0                	mov    %edx,%eax
f010c617:	01 c0                	add    %eax,%eax
f010c619:	01 d0                	add    %edx,%eax
f010c61b:	c1 e0 03             	shl    $0x3,%eax
f010c61e:	01 c8                	add    %ecx,%eax
f010c620:	05 b4 00 00 00       	add    $0xb4,%eax
f010c625:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010c62b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c62e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c631:	89 d0                	mov    %edx,%eax
f010c633:	01 c0                	add    %eax,%eax
f010c635:	01 d0                	add    %edx,%eax
f010c637:	c1 e0 03             	shl    $0x3,%eax
f010c63a:	01 c8                	add    %ecx,%eax
f010c63c:	05 b8 00 00 00       	add    $0xb8,%eax
f010c641:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010c644:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c647:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c64a:	89 d0                	mov    %edx,%eax
f010c64c:	01 c0                	add    %eax,%eax
f010c64e:	01 d0                	add    %edx,%eax
f010c650:	c1 e0 03             	shl    $0x3,%eax
f010c653:	01 c8                	add    %ecx,%eax
f010c655:	05 bc 00 00 00       	add    $0xbc,%eax
f010c65a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c660:	ff 45 f4             	incl   -0xc(%ebp)
f010c663:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010c667:	7e a6                	jle    f010c60f <initialize_environment+0x14d>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010c669:	8b 45 08             	mov    0x8(%ebp),%eax
f010c66c:	c7 80 64 05 00 00 00 	movl   $0x0,0x564(%eax)
f010c673:	00 00 00 

	e->pageFaultsCounter=0;
f010c676:	8b 45 08             	mov    0x8(%ebp),%eax
f010c679:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010c680:	00 00 00 
	e->tableFaultsCounter=0;
f010c683:	8b 45 08             	mov    0x8(%ebp),%eax
f010c686:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010c68d:	00 00 00 

	e->freeingFullWSCounter = 0;
f010c690:	8b 45 08             	mov    0x8(%ebp),%eax
f010c693:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010c69a:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010c69d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6a0:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010c6a7:	00 00 00 

	e->nModifiedPages=0;
f010c6aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6ad:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010c6b4:	00 00 00 
	e->nNotModifiedPages=0;
f010c6b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6ba:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010c6c1:	00 00 00 
	e->nClocks = 0;
f010c6c4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6c7:	c7 80 c0 05 00 00 00 	movl   $0x0,0x5c0(%eax)
f010c6ce:	00 00 00 

	//2020
	e->nPageIn = 0;
f010c6d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6d4:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010c6db:	00 00 00 
	e->nPageOut = 0;
f010c6de:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6e1:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010c6e8:	00 00 00 
	e->nNewPageAdded = 0;
f010c6eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6ee:	c7 80 bc 05 00 00 00 	movl   $0x0,0x5bc(%eax)
f010c6f5:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010c6f8:	83 ec 0c             	sub    $0xc,%esp
f010c6fb:	ff 75 08             	pushl  0x8(%ebp)
f010c6fe:	e8 06 00 00 00       	call   f010c709 <complete_environment_initialization>
f010c703:	83 c4 10             	add    $0x10,%esp
}
f010c706:	90                   	nop
f010c707:	c9                   	leave  
f010c708:	c3                   	ret    

f010c709 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010c709:	55                   	push   %ebp
f010c70a:	89 e5                	mov    %esp,%ebp
f010c70c:	53                   	push   %ebx
f010c70d:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010c710:	8b 45 08             	mov    0x8(%ebp),%eax
f010c713:	8b 40 64             	mov    0x64(%eax),%eax
f010c716:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010c71c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c71f:	8b 40 68             	mov    0x68(%eax),%eax
f010c722:	83 c8 03             	or     $0x3,%eax
f010c725:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010c727:	8b 45 08             	mov    0x8(%ebp),%eax
f010c72a:	8b 40 64             	mov    0x64(%eax),%eax
f010c72d:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010c733:	8b 45 08             	mov    0x8(%ebp),%eax
f010c736:	8b 40 68             	mov    0x68(%eax),%eax
f010c739:	83 c8 05             	or     $0x5,%eax
f010c73c:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010c73e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c741:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	e->disk_env_pgdir_PA= 0;
f010c748:	8b 45 08             	mov    0x8(%ebp),%eax
f010c74b:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	e->disk_env_tabledir = 0;
f010c752:	8b 45 08             	mov    0x8(%ebp),%eax
f010c755:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	e->disk_env_tabledir_PA = 0;
f010c75c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c75f:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010c766:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010c769:	8b 45 08             	mov    0x8(%ebp),%eax
f010c76c:	8b 58 10             	mov    0x10(%eax),%ebx
f010c76f:	83 ec 0c             	sub    $0xc,%esp
f010c772:	68 c6 02 00 00       	push   $0x2c6
f010c777:	e8 d6 c3 00 00       	call   f0118b52 <log2_ceil>
f010c77c:	83 c4 10             	add    $0x10,%esp
f010c77f:	ba 01 00 00 00       	mov    $0x1,%edx
f010c784:	88 c1                	mov    %al,%cl
f010c786:	d3 e2                	shl    %cl,%edx
f010c788:	89 d0                	mov    %edx,%eax
f010c78a:	01 d8                	add    %ebx,%eax
f010c78c:	89 c3                	mov    %eax,%ebx
f010c78e:	83 ec 0c             	sub    $0xc,%esp
f010c791:	68 c6 02 00 00       	push   $0x2c6
f010c796:	e8 82 c3 00 00       	call   f0118b1d <nearest_pow2_ceil>
f010c79b:	83 c4 10             	add    $0x10,%esp
f010c79e:	f7 d8                	neg    %eax
f010c7a0:	21 d8                	and    %ebx,%eax
f010c7a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010c7a5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c7a9:	7f 1e                	jg     f010c7c9 <complete_environment_initialization+0xc0>
		generation = 1 << ENVGENSHIFT;
f010c7ab:	83 ec 0c             	sub    $0xc,%esp
f010c7ae:	68 c6 02 00 00       	push   $0x2c6
f010c7b3:	e8 9a c3 00 00       	call   f0118b52 <log2_ceil>
f010c7b8:	83 c4 10             	add    $0x10,%esp
f010c7bb:	ba 01 00 00 00       	mov    $0x1,%edx
f010c7c0:	88 c1                	mov    %al,%cl
f010c7c2:	d3 e2                	shl    %cl,%edx
f010c7c4:	89 d0                	mov    %edx,%eax
f010c7c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010c7c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7cc:	8b 15 f0 51 81 f0    	mov    0xf08151f0,%edx
f010c7d2:	29 d0                	sub    %edx,%eax
f010c7d4:	c1 f8 02             	sar    $0x2,%eax
f010c7d7:	89 c1                	mov    %eax,%ecx
f010c7d9:	89 ca                	mov    %ecx,%edx
f010c7db:	c1 e2 02             	shl    $0x2,%edx
f010c7de:	01 ca                	add    %ecx,%edx
f010c7e0:	c1 e2 02             	shl    $0x2,%edx
f010c7e3:	01 ca                	add    %ecx,%edx
f010c7e5:	c1 e2 03             	shl    $0x3,%edx
f010c7e8:	01 ca                	add    %ecx,%edx
f010c7ea:	89 d0                	mov    %edx,%eax
f010c7ec:	c1 e0 05             	shl    $0x5,%eax
f010c7ef:	29 d0                	sub    %edx,%eax
f010c7f1:	c1 e0 02             	shl    $0x2,%eax
f010c7f4:	01 c8                	add    %ecx,%eax
f010c7f6:	c1 e0 02             	shl    $0x2,%eax
f010c7f9:	01 c8                	add    %ecx,%eax
f010c7fb:	c1 e0 02             	shl    $0x2,%eax
f010c7fe:	01 c8                	add    %ecx,%eax
f010c800:	c1 e0 06             	shl    $0x6,%eax
f010c803:	29 c8                	sub    %ecx,%eax
f010c805:	c1 e0 03             	shl    $0x3,%eax
f010c808:	01 c8                	add    %ecx,%eax
f010c80a:	c1 e0 04             	shl    $0x4,%eax
f010c80d:	01 c8                	add    %ecx,%eax
f010c80f:	0b 45 f4             	or     -0xc(%ebp),%eax
f010c812:	89 c2                	mov    %eax,%edx
f010c814:	8b 45 08             	mov    0x8(%ebp),%eax
f010c817:	89 50 10             	mov    %edx,0x10(%eax)
	//cprintf("\n[%d] user kernel stack located in [%x,%x)\n", e->env_id, e->kstack, e->kstack + KERNEL_STACK_SIZE);
	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010c81a:	e8 fc f1 ff ff       	call   f010ba1b <get_cpu_proc>
f010c81f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010c822:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010c826:	75 0c                	jne    f010c834 <complete_environment_initialization+0x12b>
		e->env_parent_id = 0;//no parent;
f010c828:	8b 45 08             	mov    0x8(%ebp),%eax
f010c82b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c832:	eb 0c                	jmp    f010c840 <complete_environment_initialization+0x137>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010c834:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c837:	8b 50 10             	mov    0x10(%eax),%edx
f010c83a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c83d:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010c840:	8b 45 08             	mov    0x8(%ebp),%eax
f010c843:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010c84a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c84d:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010c854:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010c857:	8b 45 08             	mov    0x8(%ebp),%eax
f010c85a:	8b 00                	mov    (%eax),%eax
f010c85c:	83 ec 04             	sub    $0x4,%esp
f010c85f:	6a 44                	push   $0x44
f010c861:	6a 00                	push   $0x0
f010c863:	50                   	push   %eax
f010c864:	e8 02 e4 00 00       	call   f011ac6b <memset>
f010c869:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010c86c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c86f:	8b 00                	mov    (%eax),%eax
f010c871:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010c877:	8b 45 08             	mov    0x8(%ebp),%eax
f010c87a:	8b 00                	mov    (%eax),%eax
f010c87c:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010c882:	8b 45 08             	mov    0x8(%ebp),%eax
f010c885:	8b 00                	mov    (%eax),%eax
f010c887:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010c88d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c890:	8b 00                	mov    (%eax),%eax
f010c892:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010c899:	8b 45 08             	mov    0x8(%ebp),%eax
f010c89c:	8b 00                	mov    (%eax),%eax
f010c89e:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010c8a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8a7:	8b 00                	mov    (%eax),%eax
f010c8a9:	8b 55 08             	mov    0x8(%ebp),%edx
f010c8ac:	8b 12                	mov    (%edx),%edx
f010c8ae:	8b 52 38             	mov    0x38(%edx),%edx
f010c8b1:	80 ce 02             	or     $0x2,%dh
f010c8b4:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010c8b7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c8bb:	75 17                	jne    f010c8d4 <complete_environment_initialization+0x1cb>
f010c8bd:	83 ec 04             	sub    $0x4,%esp
f010c8c0:	68 c7 f3 12 f0       	push   $0xf012f3c7
f010c8c5:	68 65 04 00 00       	push   $0x465
f010c8ca:	68 3f f3 12 f0       	push   $0xf012f33f
f010c8cf:	e8 db 45 ff ff       	call   f0100eaf <_panic>
f010c8d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8d7:	8b 40 08             	mov    0x8(%eax),%eax
f010c8da:	85 c0                	test   %eax,%eax
f010c8dc:	74 11                	je     f010c8ef <complete_environment_initialization+0x1e6>
f010c8de:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8e1:	8b 40 08             	mov    0x8(%eax),%eax
f010c8e4:	8b 55 08             	mov    0x8(%ebp),%edx
f010c8e7:	8b 52 0c             	mov    0xc(%edx),%edx
f010c8ea:	89 50 0c             	mov    %edx,0xc(%eax)
f010c8ed:	eb 0b                	jmp    f010c8fa <complete_environment_initialization+0x1f1>
f010c8ef:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8f2:	8b 40 0c             	mov    0xc(%eax),%eax
f010c8f5:	a3 f8 51 81 f0       	mov    %eax,0xf08151f8
f010c8fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8fd:	8b 40 0c             	mov    0xc(%eax),%eax
f010c900:	85 c0                	test   %eax,%eax
f010c902:	74 11                	je     f010c915 <complete_environment_initialization+0x20c>
f010c904:	8b 45 08             	mov    0x8(%ebp),%eax
f010c907:	8b 40 0c             	mov    0xc(%eax),%eax
f010c90a:	8b 55 08             	mov    0x8(%ebp),%edx
f010c90d:	8b 52 08             	mov    0x8(%edx),%edx
f010c910:	89 50 08             	mov    %edx,0x8(%eax)
f010c913:	eb 0b                	jmp    f010c920 <complete_environment_initialization+0x217>
f010c915:	8b 45 08             	mov    0x8(%ebp),%eax
f010c918:	8b 40 08             	mov    0x8(%eax),%eax
f010c91b:	a3 f4 51 81 f0       	mov    %eax,0xf08151f4
f010c920:	8b 45 08             	mov    0x8(%ebp),%eax
f010c923:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010c92a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c92d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010c934:	a1 00 52 81 f0       	mov    0xf0815200,%eax
f010c939:	48                   	dec    %eax
f010c93a:	a3 00 52 81 f0       	mov    %eax,0xf0815200
	return ;
f010c93f:	90                   	nop
}
f010c940:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c943:	c9                   	leave  
f010c944:	c3                   	ret    

f010c945 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010c945:	55                   	push   %ebp
f010c946:	89 e5                	mov    %esp,%ebp
f010c948:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c94b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c94e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c951:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c954:	8b 00                	mov    (%eax),%eax
f010c956:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c95b:	74 17                	je     f010c974 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010c95d:	83 ec 04             	sub    $0x4,%esp
f010c960:	68 69 f6 12 f0       	push   $0xf012f669
f010c965:	68 71 04 00 00       	push   $0x471
f010c96a:	68 3f f3 12 f0       	push   $0xf012f33f
f010c96f:	e8 3b 45 ff ff       	call   f0100eaf <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010c974:	8b 45 08             	mov    0x8(%ebp),%eax
f010c977:	8b 00                	mov    (%eax),%eax
f010c979:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c97c:	8b 52 18             	mov    0x18(%edx),%edx
f010c97f:	89 50 30             	mov    %edx,0x30(%eax)
}
f010c982:	90                   	nop
f010c983:	c9                   	leave  
f010c984:	c3                   	ret    

f010c985 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 13) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010c985:	55                   	push   %ebp
f010c986:	89 e5                	mov    %esp,%ebp
f010c988:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010c98b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c98e:	8b 40 10             	mov    0x10(%eax),%eax
f010c991:	8d 48 01             	lea    0x1(%eax),%ecx
f010c994:	8b 55 08             	mov    0x8(%ebp),%edx
f010c997:	89 4a 10             	mov    %ecx,0x10(%edx)
f010c99a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c99d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c9a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c9a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c9a6:	8b 00                	mov    (%eax),%eax
f010c9a8:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c9ad:	74 17                	je     f010c9c6 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010c9af:	83 ec 04             	sub    $0x4,%esp
f010c9b2:	68 69 f6 12 f0       	push   $0xf012f669
f010c9b7:	68 7f 04 00 00       	push   $0x47f
f010c9bc:	68 3f f3 12 f0       	push   $0xf012f33f
f010c9c1:	e8 e9 44 ff ff       	call   f0100eaf <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010c9c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c9c9:	8b 50 1c             	mov    0x1c(%eax),%edx
f010c9cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c9cf:	01 d0                	add    %edx,%eax
f010c9d1:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010c9d4:	eb 0f                	jmp    f010c9e5 <PROGRAM_SEGMENT_NEXT+0x60>
f010c9d6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9d9:	8b 40 10             	mov    0x10(%eax),%eax
f010c9dc:	8d 50 01             	lea    0x1(%eax),%edx
f010c9df:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9e2:	89 50 10             	mov    %edx,0x10(%eax)
f010c9e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9e8:	8b 40 10             	mov    0x10(%eax),%eax
f010c9eb:	c1 e0 05             	shl    $0x5,%eax
f010c9ee:	89 c2                	mov    %eax,%edx
f010c9f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c9f3:	01 d0                	add    %edx,%eax
f010c9f5:	8b 00                	mov    (%eax),%eax
f010c9f7:	83 f8 01             	cmp    $0x1,%eax
f010c9fa:	74 13                	je     f010ca0f <PROGRAM_SEGMENT_NEXT+0x8a>
f010c9fc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9ff:	8b 50 10             	mov    0x10(%eax),%edx
f010ca02:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ca05:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ca08:	0f b7 c0             	movzwl %ax,%eax
f010ca0b:	39 c2                	cmp    %eax,%edx
f010ca0d:	72 c7                	jb     f010c9d6 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010ca0f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca12:	8b 40 10             	mov    0x10(%eax),%eax
f010ca15:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010ca18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ca1b:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ca1e:	0f b7 c0             	movzwl %ax,%eax
f010ca21:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ca24:	7e 63                	jle    f010ca89 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010ca26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca29:	c1 e0 05             	shl    $0x5,%eax
f010ca2c:	89 c2                	mov    %eax,%edx
f010ca2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ca31:	01 d0                	add    %edx,%eax
f010ca33:	8b 50 04             	mov    0x4(%eax),%edx
f010ca36:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ca39:	01 c2                	add    %eax,%edx
f010ca3b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca3e:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010ca40:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca43:	c1 e0 05             	shl    $0x5,%eax
f010ca46:	89 c2                	mov    %eax,%edx
f010ca48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ca4b:	01 d0                	add    %edx,%eax
f010ca4d:	8b 50 14             	mov    0x14(%eax),%edx
f010ca50:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca53:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010ca56:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca59:	c1 e0 05             	shl    $0x5,%eax
f010ca5c:	89 c2                	mov    %eax,%edx
f010ca5e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ca61:	01 d0                	add    %edx,%eax
f010ca63:	8b 50 10             	mov    0x10(%eax),%edx
f010ca66:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca69:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010ca6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca6f:	c1 e0 05             	shl    $0x5,%eax
f010ca72:	89 c2                	mov    %eax,%edx
f010ca74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ca77:	01 d0                	add    %edx,%eax
f010ca79:	8b 40 08             	mov    0x8(%eax),%eax
f010ca7c:	89 c2                	mov    %eax,%edx
f010ca7e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca81:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010ca84:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca87:	eb 05                	jmp    f010ca8e <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010ca89:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ca8e:	c9                   	leave  
f010ca8f:	c3                   	ret    

f010ca90 <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 14) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010ca90:	55                   	push   %ebp
f010ca91:	89 e5                	mov    %esp,%ebp
f010ca93:	57                   	push   %edi
f010ca94:	56                   	push   %esi
f010ca95:	53                   	push   %ebx
f010ca96:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010ca99:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010caa0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010caa3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010caa6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010caa9:	8b 00                	mov    (%eax),%eax
f010caab:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cab0:	74 17                	je     f010cac9 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010cab2:	83 ec 04             	sub    $0x4,%esp
f010cab5:	68 69 f6 12 f0       	push   $0xf012f669
f010caba:	68 9b 04 00 00       	push   $0x49b
f010cabf:	68 3f f3 12 f0       	push   $0xf012f33f
f010cac4:	e8 e6 43 ff ff       	call   f0100eaf <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cac9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cacc:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cacf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cad2:	01 d0                	add    %edx,%eax
f010cad4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010cad7:	eb 07                	jmp    f010cae0 <PROGRAM_SEGMENT_FIRST+0x50>
f010cad9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cadc:	40                   	inc    %eax
f010cadd:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010cae0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cae3:	c1 e0 05             	shl    $0x5,%eax
f010cae6:	89 c2                	mov    %eax,%edx
f010cae8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010caeb:	01 d0                	add    %edx,%eax
f010caed:	8b 00                	mov    (%eax),%eax
f010caef:	83 f8 01             	cmp    $0x1,%eax
f010caf2:	74 10                	je     f010cb04 <PROGRAM_SEGMENT_FIRST+0x74>
f010caf4:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010caf7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cafa:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cafd:	0f b7 c0             	movzwl %ax,%eax
f010cb00:	39 c2                	cmp    %eax,%edx
f010cb02:	72 d5                	jb     f010cad9 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010cb04:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cb07:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010cb0a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cb0d:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cb10:	0f b7 c0             	movzwl %ax,%eax
f010cb13:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010cb16:	7e 68                	jle    f010cb80 <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cb18:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cb1b:	c1 e0 05             	shl    $0x5,%eax
f010cb1e:	89 c2                	mov    %eax,%edx
f010cb20:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cb23:	01 d0                	add    %edx,%eax
f010cb25:	8b 50 04             	mov    0x4(%eax),%edx
f010cb28:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cb2b:	01 d0                	add    %edx,%eax
f010cb2d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010cb30:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cb33:	c1 e0 05             	shl    $0x5,%eax
f010cb36:	89 c2                	mov    %eax,%edx
f010cb38:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cb3b:	01 d0                	add    %edx,%eax
f010cb3d:	8b 40 14             	mov    0x14(%eax),%eax
f010cb40:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010cb43:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cb46:	c1 e0 05             	shl    $0x5,%eax
f010cb49:	89 c2                	mov    %eax,%edx
f010cb4b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cb4e:	01 d0                	add    %edx,%eax
f010cb50:	8b 40 10             	mov    0x10(%eax),%eax
f010cb53:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010cb56:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cb59:	c1 e0 05             	shl    $0x5,%eax
f010cb5c:	89 c2                	mov    %eax,%edx
f010cb5e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cb61:	01 d0                	add    %edx,%eax
f010cb63:	8b 40 08             	mov    0x8(%eax),%eax
f010cb66:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010cb69:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb6c:	89 c3                	mov    %eax,%ebx
f010cb6e:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cb71:	ba 05 00 00 00       	mov    $0x5,%edx
f010cb76:	89 df                	mov    %ebx,%edi
f010cb78:	89 c6                	mov    %eax,%esi
f010cb7a:	89 d1                	mov    %edx,%ecx
f010cb7c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010cb7e:	eb 1c                	jmp    f010cb9c <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010cb80:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010cb87:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb8a:	89 c3                	mov    %eax,%ebx
f010cb8c:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cb8f:	ba 05 00 00 00       	mov    $0x5,%edx
f010cb94:	89 df                	mov    %ebx,%edi
f010cb96:	89 c6                	mov    %eax,%esi
f010cb98:	89 d1                	mov    %edx,%ecx
f010cb9a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010cb9c:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb9f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010cba2:	5b                   	pop    %ebx
f010cba3:	5e                   	pop    %esi
f010cba4:	5f                   	pop    %edi
f010cba5:	5d                   	pop    %ebp
f010cba6:	c2 04 00             	ret    $0x4

f010cba9 <cleanup_buffers>:

//===============================================================================
// 15) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010cba9:	55                   	push   %ebp
f010cbaa:	89 e5                	mov    %esp,%ebp
f010cbac:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010cbaf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	bool lock_already_held = holding_kspinlock(&MemFrameLists.mfllock);
f010cbb6:	83 ec 0c             	sub    $0xc,%esp
f010cbb9:	68 40 de 83 f0       	push   $0xf083de40
f010cbbe:	e8 0f 34 00 00       	call   f010ffd2 <holding_kspinlock>
f010cbc3:	83 c4 10             	add    $0x10,%esp
f010cbc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (!lock_already_held)
f010cbc9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010cbcd:	75 10                	jne    f010cbdf <cleanup_buffers+0x36>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f010cbcf:	83 ec 0c             	sub    $0xc,%esp
f010cbd2:	68 40 de 83 f0       	push   $0xf083de40
f010cbd7:	e8 a1 31 00 00       	call   f010fd7d <acquire_kspinlock>
f010cbdc:	83 c4 10             	add    $0x10,%esp
	}
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cbdf:	a1 30 de 83 f0       	mov    0xf083de30,%eax
f010cbe4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cbe7:	e9 a7 00 00 00       	jmp    f010cc93 <cleanup_buffers+0xea>
						{
			if(ptr_fi->proc == e)
f010cbec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cbef:	8b 40 0c             	mov    0xc(%eax),%eax
f010cbf2:	3b 45 08             	cmp    0x8(%ebp),%eax
f010cbf5:	0f 85 90 00 00 00    	jne    f010cc8b <cleanup_buffers+0xe2>
				/*MUST UN-COMMENT THIS LINE*/
				//pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->va);

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010cbfb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cbff:	75 17                	jne    f010cc18 <cleanup_buffers+0x6f>
f010cc01:	83 ec 04             	sub    $0x4,%esp
f010cc04:	68 c7 f3 12 f0       	push   $0xf012f3c7
f010cc09:	68 c9 04 00 00       	push   $0x4c9
f010cc0e:	68 3f f3 12 f0       	push   $0xf012f33f
f010cc13:	e8 97 42 ff ff       	call   f0100eaf <_panic>
f010cc18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc1b:	8b 00                	mov    (%eax),%eax
f010cc1d:	85 c0                	test   %eax,%eax
f010cc1f:	74 10                	je     f010cc31 <cleanup_buffers+0x88>
f010cc21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc24:	8b 00                	mov    (%eax),%eax
f010cc26:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cc29:	8b 52 04             	mov    0x4(%edx),%edx
f010cc2c:	89 50 04             	mov    %edx,0x4(%eax)
f010cc2f:	eb 0b                	jmp    f010cc3c <cleanup_buffers+0x93>
f010cc31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc34:	8b 40 04             	mov    0x4(%eax),%eax
f010cc37:	a3 34 de 83 f0       	mov    %eax,0xf083de34
f010cc3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc3f:	8b 40 04             	mov    0x4(%eax),%eax
f010cc42:	85 c0                	test   %eax,%eax
f010cc44:	74 0f                	je     f010cc55 <cleanup_buffers+0xac>
f010cc46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc49:	8b 40 04             	mov    0x4(%eax),%eax
f010cc4c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cc4f:	8b 12                	mov    (%edx),%edx
f010cc51:	89 10                	mov    %edx,(%eax)
f010cc53:	eb 0a                	jmp    f010cc5f <cleanup_buffers+0xb6>
f010cc55:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc58:	8b 00                	mov    (%eax),%eax
f010cc5a:	a3 30 de 83 f0       	mov    %eax,0xf083de30
f010cc5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc62:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010cc68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc6b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010cc72:	a1 3c de 83 f0       	mov    0xf083de3c,%eax
f010cc77:	48                   	dec    %eax
f010cc78:	a3 3c de 83 f0       	mov    %eax,0xf083de3c

				free_frame(ptr_fi);
f010cc7d:	83 ec 0c             	sub    $0xc,%esp
f010cc80:	ff 75 f4             	pushl  -0xc(%ebp)
f010cc83:	e8 e5 c4 ff ff       	call   f010916d <free_frame>
f010cc88:	83 c4 10             	add    $0x10,%esp
	if (!lock_already_held)
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
	}
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cc8b:	a1 38 de 83 f0       	mov    0xf083de38,%eax
f010cc90:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cc93:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cc97:	74 07                	je     f010cca0 <cleanup_buffers+0xf7>
f010cc99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc9c:	8b 00                	mov    (%eax),%eax
f010cc9e:	eb 05                	jmp    f010cca5 <cleanup_buffers+0xfc>
f010cca0:	b8 00 00 00 00       	mov    $0x0,%eax
f010cca5:	a3 38 de 83 f0       	mov    %eax,0xf083de38
f010ccaa:	a1 38 de 83 f0       	mov    0xf083de38,%eax
f010ccaf:	85 c0                	test   %eax,%eax
f010ccb1:	0f 85 35 ff ff ff    	jne    f010cbec <cleanup_buffers+0x43>
f010ccb7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ccbb:	0f 85 2b ff ff ff    	jne    f010cbec <cleanup_buffers+0x43>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
						}
	}
	if (!lock_already_held)
f010ccc1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ccc5:	75 10                	jne    f010ccd7 <cleanup_buffers+0x12e>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f010ccc7:	83 ec 0c             	sub    $0xc,%esp
f010ccca:	68 40 de 83 f0       	push   $0xf083de40
f010cccf:	e8 4e 31 00 00       	call   f010fe22 <release_kspinlock>
f010ccd4:	83 c4 10             	add    $0x10,%esp
	}
	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010ccd7:	90                   	nop
f010ccd8:	c9                   	leave  
f010ccd9:	c3                   	ret    

f010ccda <set_program_priority>:
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"


void set_program_priority(struct Env* env, int priority)
{
f010ccda:	55                   	push   %ebp
f010ccdb:	89 e5                	mov    %esp,%ebp
f010ccdd:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010cce0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010cce4:	7e 06                	jle    f010ccec <set_program_priority+0x12>
f010cce6:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010ccea:	7e 14                	jle    f010cd00 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010ccec:	83 ec 04             	sub    $0x4,%esp
f010ccef:	68 80 f6 12 f0       	push   $0xf012f680
f010ccf4:	6a 11                	push   $0x11
f010ccf6:	68 a4 f6 12 f0       	push   $0xf012f6a4
f010ccfb:	e8 af 41 ff ff       	call   f0100eaf <_panic>
		return;
	}
	if(env == NULL)
f010cd00:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010cd04:	74 78                	je     f010cd7e <set_program_priority+0xa4>
		return;
	switch(priority)
f010cd06:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010cd0a:	77 56                	ja     f010cd62 <set_program_priority+0x88>
f010cd0c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cd0f:	c1 e0 02             	shl    $0x2,%eax
f010cd12:	05 e0 f6 12 f0       	add    $0xf012f6e0,%eax
f010cd17:	8b 00                	mov    (%eax),%eax
f010cd19:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010cd1b:	83 ec 08             	sub    $0x8,%esp
f010cd1e:	6a 01                	push   $0x1
f010cd20:	ff 75 08             	pushl  0x8(%ebp)
f010cd23:	e8 3d de ff ff       	call   f010ab65 <half_WS_Size>
f010cd28:	83 c4 10             	add    $0x10,%esp
			break;
f010cd2b:	eb 35                	jmp    f010cd62 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010cd2d:	83 ec 08             	sub    $0x8,%esp
f010cd30:	6a 00                	push   $0x0
f010cd32:	ff 75 08             	pushl  0x8(%ebp)
f010cd35:	e8 2b de ff ff       	call   f010ab65 <half_WS_Size>
f010cd3a:	83 c4 10             	add    $0x10,%esp
			break;
f010cd3d:	eb 23                	jmp    f010cd62 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010cd3f:	83 ec 08             	sub    $0x8,%esp
f010cd42:	6a 01                	push   $0x1
f010cd44:	ff 75 08             	pushl  0x8(%ebp)
f010cd47:	e8 fc dd ff ff       	call   f010ab48 <double_WS_Size>
f010cd4c:	83 c4 10             	add    $0x10,%esp
			break;
f010cd4f:	eb 11                	jmp    f010cd62 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010cd51:	83 ec 08             	sub    $0x8,%esp
f010cd54:	6a 00                	push   $0x0
f010cd56:	ff 75 08             	pushl  0x8(%ebp)
f010cd59:	e8 ea dd ff ff       	call   f010ab48 <double_WS_Size>
f010cd5e:	83 c4 10             	add    $0x10,%esp
			break;
f010cd61:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010cd62:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd65:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010cd6b:	83 ec 08             	sub    $0x8,%esp
f010cd6e:	50                   	push   %eax
f010cd6f:	68 c1 f6 12 f0       	push   $0xf012f6c1
f010cd74:	e8 e3 4d ff ff       	call   f0101b5c <cprintf>
f010cd79:	83 c4 10             	add    $0x10,%esp
f010cd7c:	eb 01                	jmp    f010cd7f <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010cd7e:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010cd7f:	c9                   	leave  
f010cd80:	c3                   	ret    

f010cd81 <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010cd81:	55                   	push   %ebp
f010cd82:	89 e5                	mov    %esp,%ebp
f010cd84:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cd87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010cd8e:	eb 29                	jmp    f010cdb9 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010cd90:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cd93:	89 d0                	mov    %edx,%eax
f010cd95:	01 c0                	add    %eax,%eax
f010cd97:	01 d0                	add    %edx,%eax
f010cd99:	c1 e0 02             	shl    $0x2,%eax
f010cd9c:	05 e0 fb 17 f0       	add    $0xf017fbe0,%eax
f010cda1:	8b 00                	mov    (%eax),%eax
f010cda3:	83 ec 08             	sub    $0x8,%esp
f010cda6:	50                   	push   %eax
f010cda7:	ff 75 08             	pushl  0x8(%ebp)
f010cdaa:	e8 da dd 00 00       	call   f011ab89 <strcmp>
f010cdaf:	83 c4 10             	add    $0x10,%esp
f010cdb2:	85 c0                	test   %eax,%eax
f010cdb4:	74 0f                	je     f010cdc5 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cdb6:	ff 45 f4             	incl   -0xc(%ebp)
f010cdb9:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010cdbe:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cdc1:	7c cd                	jl     f010cd90 <get_user_program_info+0xf>
f010cdc3:	eb 01                	jmp    f010cdc6 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010cdc5:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010cdc6:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010cdcb:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cdce:	75 1a                	jne    f010cdea <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010cdd0:	83 ec 08             	sub    $0x8,%esp
f010cdd3:	ff 75 08             	pushl  0x8(%ebp)
f010cdd6:	68 44 08 13 f0       	push   $0xf0130844
f010cddb:	e8 7c 4d ff ff       	call   f0101b5c <cprintf>
f010cde0:	83 c4 10             	add    $0x10,%esp
		return 0;
f010cde3:	b8 00 00 00 00       	mov    $0x0,%eax
f010cde8:	eb 11                	jmp    f010cdfb <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010cdea:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cded:	89 d0                	mov    %edx,%eax
f010cdef:	01 c0                	add    %eax,%eax
f010cdf1:	01 d0                	add    %edx,%eax
f010cdf3:	c1 e0 02             	shl    $0x2,%eax
f010cdf6:	05 e0 fb 17 f0       	add    $0xf017fbe0,%eax
}
f010cdfb:	c9                   	leave  
f010cdfc:	c3                   	ret    

f010cdfd <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010cdfd:	55                   	push   %ebp
f010cdfe:	89 e5                	mov    %esp,%ebp
f010ce00:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ce03:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ce0a:	eb 2d                	jmp    f010ce39 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010ce0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ce0f:	89 d0                	mov    %edx,%eax
f010ce11:	01 c0                	add    %eax,%eax
f010ce13:	01 d0                	add    %edx,%eax
f010ce15:	c1 e0 02             	shl    $0x2,%eax
f010ce18:	05 e0 fb 17 f0       	add    $0xf017fbe0,%eax
f010ce1d:	8b 00                	mov    (%eax),%eax
f010ce1f:	8b 55 08             	mov    0x8(%ebp),%edx
f010ce22:	83 c2 20             	add    $0x20,%edx
f010ce25:	83 ec 08             	sub    $0x8,%esp
f010ce28:	50                   	push   %eax
f010ce29:	52                   	push   %edx
f010ce2a:	e8 5a dd 00 00       	call   f011ab89 <strcmp>
f010ce2f:	83 c4 10             	add    $0x10,%esp
f010ce32:	85 c0                	test   %eax,%eax
f010ce34:	74 0f                	je     f010ce45 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ce36:	ff 45 f4             	incl   -0xc(%ebp)
f010ce39:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010ce3e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010ce41:	7c c9                	jl     f010ce0c <get_user_program_info_by_env+0xf>
f010ce43:	eb 01                	jmp    f010ce46 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010ce45:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010ce46:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010ce4b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010ce4e:	75 17                	jne    f010ce67 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010ce50:	83 ec 0c             	sub    $0xc,%esp
f010ce53:	68 5f 08 13 f0       	push   $0xf013085f
f010ce58:	e8 ff 4c ff ff       	call   f0101b5c <cprintf>
f010ce5d:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ce60:	b8 00 00 00 00       	mov    $0x0,%eax
f010ce65:	eb 11                	jmp    f010ce78 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010ce67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ce6a:	89 d0                	mov    %edx,%eax
f010ce6c:	01 c0                	add    %eax,%eax
f010ce6e:	01 d0                	add    %edx,%eax
f010ce70:	c1 e0 02             	shl    $0x2,%eax
f010ce73:	05 e0 fb 17 f0       	add    $0xf017fbe0,%eax
}
f010ce78:	c9                   	leave  
f010ce79:	c3                   	ret    

f010ce7a <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010ce7a:	55                   	push   %ebp
f010ce7b:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010ce7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce80:	83 f8 13             	cmp    $0x13,%eax
f010ce83:	77 0c                	ja     f010ce91 <trapname+0x17>
		return excnames[trapno];
f010ce85:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce88:	8b 04 85 e0 0c 13 f0 	mov    -0xfecf320(,%eax,4),%eax
f010ce8f:	eb 2c                	jmp    f010cebd <trapname+0x43>
	if (trapno == T_SYSCALL)
f010ce91:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010ce95:	75 07                	jne    f010ce9e <trapname+0x24>
		return "System call";
f010ce97:	b8 80 08 13 f0       	mov    $0xf0130880,%eax
f010ce9c:	eb 1f                	jmp    f010cebd <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010ce9e:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010cea2:	75 07                	jne    f010ceab <trapname+0x31>
		return "Clock Interrupt";
f010cea4:	b8 8c 08 13 f0       	mov    $0xf013088c,%eax
f010cea9:	eb 12                	jmp    f010cebd <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010ceab:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010ceaf:	75 07                	jne    f010ceb8 <trapname+0x3e>
		return "Keyboard Interrupt";
f010ceb1:	b8 9c 08 13 f0       	mov    $0xf013089c,%eax
f010ceb6:	eb 05                	jmp    f010cebd <trapname+0x43>
	return "(unknown trap)";
f010ceb8:	b8 af 08 13 f0       	mov    $0xf01308af,%eax
}
f010cebd:	5d                   	pop    %ebp
f010cebe:	c3                   	ret    

f010cebf <ts_init>:


void ts_init(void)
{
f010cebf:	55                   	push   %ebp
f010cec0:	89 e5                	mov    %esp,%ebp
f010cec2:	53                   	push   %ebx
f010cec3:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010cec6:	e8 68 b1 ff ff       	call   f0108033 <pushcli>

	struct cpu* c = mycpu();
f010cecb:	e8 a0 b0 ff ff       	call   f0107f70 <mycpu>
f010ced0:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010ced3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ced6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010cedd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cee0:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010cee6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cee9:	83 c0 0c             	add    $0xc,%eax
f010ceec:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ceef:	83 c2 0c             	add    $0xc,%edx
f010cef2:	c1 ea 10             	shr    $0x10,%edx
f010cef5:	88 d3                	mov    %dl,%bl
f010cef7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cefa:	83 c2 0c             	add    $0xc,%edx
f010cefd:	c1 ea 18             	shr    $0x18,%edx
f010cf00:	88 d1                	mov    %dl,%cl
f010cf02:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf05:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010cf0c:	68 00 
f010cf0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf11:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010cf18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf1b:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010cf21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf24:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cf2a:	83 e2 f0             	and    $0xfffffff0,%edx
f010cf2d:	83 ca 09             	or     $0x9,%edx
f010cf30:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cf36:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf39:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cf3f:	83 ca 10             	or     $0x10,%edx
f010cf42:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cf48:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf4b:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cf51:	83 e2 9f             	and    $0xffffff9f,%edx
f010cf54:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cf5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf5d:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cf63:	83 ca 80             	or     $0xffffff80,%edx
f010cf66:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cf6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf6f:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cf75:	83 e2 f0             	and    $0xfffffff0,%edx
f010cf78:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010cf7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf81:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cf87:	83 e2 ef             	and    $0xffffffef,%edx
f010cf8a:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010cf90:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf93:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cf99:	83 e2 df             	and    $0xffffffdf,%edx
f010cf9c:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010cfa2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfa5:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cfab:	83 ca 40             	or     $0x40,%edx
f010cfae:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010cfb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfb7:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cfbd:	83 e2 7f             	and    $0x7f,%edx
f010cfc0:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010cfc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfc9:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010cfcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfd2:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cfd8:	83 e2 ef             	and    $0xffffffef,%edx
f010cfdb:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010cfe1:	e8 9f b0 ff ff       	call   f0108085 <popcli>
f010cfe6:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010cfec:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010cff0:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010cff3:	90                   	nop
f010cff4:	83 c4 14             	add    $0x14,%esp
f010cff7:	5b                   	pop    %ebx
f010cff8:	5d                   	pop    %ebp
f010cff9:	c3                   	ret    

f010cffa <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010cffa:	55                   	push   %ebp
f010cffb:	89 e5                	mov    %esp,%ebp
f010cffd:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010d000:	b8 64 e5 10 f0       	mov    $0xf010e564,%eax
f010d005:	66 a3 60 52 81 f0    	mov    %ax,0xf0815260
f010d00b:	66 c7 05 62 52 81 f0 	movw   $0x8,0xf0815262
f010d012:	08 00 
f010d014:	a0 64 52 81 f0       	mov    0xf0815264,%al
f010d019:	83 e0 e0             	and    $0xffffffe0,%eax
f010d01c:	a2 64 52 81 f0       	mov    %al,0xf0815264
f010d021:	a0 64 52 81 f0       	mov    0xf0815264,%al
f010d026:	83 e0 1f             	and    $0x1f,%eax
f010d029:	a2 64 52 81 f0       	mov    %al,0xf0815264
f010d02e:	a0 65 52 81 f0       	mov    0xf0815265,%al
f010d033:	83 e0 f0             	and    $0xfffffff0,%eax
f010d036:	83 c8 0e             	or     $0xe,%eax
f010d039:	a2 65 52 81 f0       	mov    %al,0xf0815265
f010d03e:	a0 65 52 81 f0       	mov    0xf0815265,%al
f010d043:	83 e0 ef             	and    $0xffffffef,%eax
f010d046:	a2 65 52 81 f0       	mov    %al,0xf0815265
f010d04b:	a0 65 52 81 f0       	mov    0xf0815265,%al
f010d050:	83 e0 9f             	and    $0xffffff9f,%eax
f010d053:	a2 65 52 81 f0       	mov    %al,0xf0815265
f010d058:	a0 65 52 81 f0       	mov    0xf0815265,%al
f010d05d:	83 c8 80             	or     $0xffffff80,%eax
f010d060:	a2 65 52 81 f0       	mov    %al,0xf0815265
f010d065:	b8 64 e5 10 f0       	mov    $0xf010e564,%eax
f010d06a:	c1 e8 10             	shr    $0x10,%eax
f010d06d:	66 a3 66 52 81 f0    	mov    %ax,0xf0815266
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010d073:	b8 6c e5 10 f0       	mov    $0xf010e56c,%eax
f010d078:	66 a3 90 52 81 f0    	mov    %ax,0xf0815290
f010d07e:	66 c7 05 92 52 81 f0 	movw   $0x8,0xf0815292
f010d085:	08 00 
f010d087:	a0 94 52 81 f0       	mov    0xf0815294,%al
f010d08c:	83 e0 e0             	and    $0xffffffe0,%eax
f010d08f:	a2 94 52 81 f0       	mov    %al,0xf0815294
f010d094:	a0 94 52 81 f0       	mov    0xf0815294,%al
f010d099:	83 e0 1f             	and    $0x1f,%eax
f010d09c:	a2 94 52 81 f0       	mov    %al,0xf0815294
f010d0a1:	a0 95 52 81 f0       	mov    0xf0815295,%al
f010d0a6:	83 e0 f0             	and    $0xfffffff0,%eax
f010d0a9:	83 c8 0e             	or     $0xe,%eax
f010d0ac:	a2 95 52 81 f0       	mov    %al,0xf0815295
f010d0b1:	a0 95 52 81 f0       	mov    0xf0815295,%al
f010d0b6:	83 e0 ef             	and    $0xffffffef,%eax
f010d0b9:	a2 95 52 81 f0       	mov    %al,0xf0815295
f010d0be:	a0 95 52 81 f0       	mov    0xf0815295,%al
f010d0c3:	83 e0 9f             	and    $0xffffff9f,%eax
f010d0c6:	a2 95 52 81 f0       	mov    %al,0xf0815295
f010d0cb:	a0 95 52 81 f0       	mov    0xf0815295,%al
f010d0d0:	83 c8 80             	or     $0xffffff80,%eax
f010d0d3:	a2 95 52 81 f0       	mov    %al,0xf0815295
f010d0d8:	b8 6c e5 10 f0       	mov    $0xf010e56c,%eax
f010d0dd:	c1 e8 10             	shr    $0x10,%eax
f010d0e0:	66 a3 96 52 81 f0    	mov    %ax,0xf0815296
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010d0e6:	b8 74 e5 10 f0       	mov    $0xf010e574,%eax
f010d0eb:	66 a3 20 53 81 f0    	mov    %ax,0xf0815320
f010d0f1:	66 c7 05 22 53 81 f0 	movw   $0x8,0xf0815322
f010d0f8:	08 00 
f010d0fa:	a0 24 53 81 f0       	mov    0xf0815324,%al
f010d0ff:	83 e0 e0             	and    $0xffffffe0,%eax
f010d102:	a2 24 53 81 f0       	mov    %al,0xf0815324
f010d107:	a0 24 53 81 f0       	mov    0xf0815324,%al
f010d10c:	83 e0 1f             	and    $0x1f,%eax
f010d10f:	a2 24 53 81 f0       	mov    %al,0xf0815324
f010d114:	a0 25 53 81 f0       	mov    0xf0815325,%al
f010d119:	83 e0 f0             	and    $0xfffffff0,%eax
f010d11c:	83 c8 0e             	or     $0xe,%eax
f010d11f:	a2 25 53 81 f0       	mov    %al,0xf0815325
f010d124:	a0 25 53 81 f0       	mov    0xf0815325,%al
f010d129:	83 e0 ef             	and    $0xffffffef,%eax
f010d12c:	a2 25 53 81 f0       	mov    %al,0xf0815325
f010d131:	a0 25 53 81 f0       	mov    0xf0815325,%al
f010d136:	83 c8 60             	or     $0x60,%eax
f010d139:	a2 25 53 81 f0       	mov    %al,0xf0815325
f010d13e:	a0 25 53 81 f0       	mov    0xf0815325,%al
f010d143:	83 c8 80             	or     $0xffffff80,%eax
f010d146:	a2 25 53 81 f0       	mov    %al,0xf0815325
f010d14b:	b8 74 e5 10 f0       	mov    $0xf010e574,%eax
f010d150:	c1 e8 10             	shr    $0x10,%eax
f010d153:	66 a3 26 53 81 f0    	mov    %ax,0xf0815326
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010d159:	b8 7e e5 10 f0       	mov    $0xf010e57e,%eax
f010d15e:	66 a3 28 53 81 f0    	mov    %ax,0xf0815328
f010d164:	66 c7 05 2a 53 81 f0 	movw   $0x8,0xf081532a
f010d16b:	08 00 
f010d16d:	a0 2c 53 81 f0       	mov    0xf081532c,%al
f010d172:	83 e0 e0             	and    $0xffffffe0,%eax
f010d175:	a2 2c 53 81 f0       	mov    %al,0xf081532c
f010d17a:	a0 2c 53 81 f0       	mov    0xf081532c,%al
f010d17f:	83 e0 1f             	and    $0x1f,%eax
f010d182:	a2 2c 53 81 f0       	mov    %al,0xf081532c
f010d187:	a0 2d 53 81 f0       	mov    0xf081532d,%al
f010d18c:	83 e0 f0             	and    $0xfffffff0,%eax
f010d18f:	83 c8 0e             	or     $0xe,%eax
f010d192:	a2 2d 53 81 f0       	mov    %al,0xf081532d
f010d197:	a0 2d 53 81 f0       	mov    0xf081532d,%al
f010d19c:	83 e0 ef             	and    $0xffffffef,%eax
f010d19f:	a2 2d 53 81 f0       	mov    %al,0xf081532d
f010d1a4:	a0 2d 53 81 f0       	mov    0xf081532d,%al
f010d1a9:	83 c8 60             	or     $0x60,%eax
f010d1ac:	a2 2d 53 81 f0       	mov    %al,0xf081532d
f010d1b1:	a0 2d 53 81 f0       	mov    0xf081532d,%al
f010d1b6:	83 c8 80             	or     $0xffffff80,%eax
f010d1b9:	a2 2d 53 81 f0       	mov    %al,0xf081532d
f010d1be:	b8 7e e5 10 f0       	mov    $0xf010e57e,%eax
f010d1c3:	c1 e8 10             	shr    $0x10,%eax
f010d1c6:	66 a3 2e 53 81 f0    	mov    %ax,0xf081532e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010d1cc:	b8 88 e5 10 f0       	mov    $0xf010e588,%eax
f010d1d1:	66 a3 a0 53 81 f0    	mov    %ax,0xf08153a0
f010d1d7:	66 c7 05 a2 53 81 f0 	movw   $0x8,0xf08153a2
f010d1de:	08 00 
f010d1e0:	a0 a4 53 81 f0       	mov    0xf08153a4,%al
f010d1e5:	83 e0 e0             	and    $0xffffffe0,%eax
f010d1e8:	a2 a4 53 81 f0       	mov    %al,0xf08153a4
f010d1ed:	a0 a4 53 81 f0       	mov    0xf08153a4,%al
f010d1f2:	83 e0 1f             	and    $0x1f,%eax
f010d1f5:	a2 a4 53 81 f0       	mov    %al,0xf08153a4
f010d1fa:	a0 a5 53 81 f0       	mov    0xf08153a5,%al
f010d1ff:	83 e0 f0             	and    $0xfffffff0,%eax
f010d202:	83 c8 0e             	or     $0xe,%eax
f010d205:	a2 a5 53 81 f0       	mov    %al,0xf08153a5
f010d20a:	a0 a5 53 81 f0       	mov    0xf08153a5,%al
f010d20f:	83 e0 ef             	and    $0xffffffef,%eax
f010d212:	a2 a5 53 81 f0       	mov    %al,0xf08153a5
f010d217:	a0 a5 53 81 f0       	mov    0xf08153a5,%al
f010d21c:	83 c8 60             	or     $0x60,%eax
f010d21f:	a2 a5 53 81 f0       	mov    %al,0xf08153a5
f010d224:	a0 a5 53 81 f0       	mov    0xf08153a5,%al
f010d229:	83 c8 80             	or     $0xffffff80,%eax
f010d22c:	a2 a5 53 81 f0       	mov    %al,0xf08153a5
f010d231:	b8 88 e5 10 f0       	mov    $0xf010e588,%eax
f010d236:	c1 e8 10             	shr    $0x10,%eax
f010d239:	66 a3 a6 53 81 f0    	mov    %ax,0xf08153a6

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010d23f:	b8 92 e5 10 f0       	mov    $0xf010e592,%eax
f010d244:	66 a3 20 52 81 f0    	mov    %ax,0xf0815220
f010d24a:	66 c7 05 22 52 81 f0 	movw   $0x8,0xf0815222
f010d251:	08 00 
f010d253:	a0 24 52 81 f0       	mov    0xf0815224,%al
f010d258:	83 e0 e0             	and    $0xffffffe0,%eax
f010d25b:	a2 24 52 81 f0       	mov    %al,0xf0815224
f010d260:	a0 24 52 81 f0       	mov    0xf0815224,%al
f010d265:	83 e0 1f             	and    $0x1f,%eax
f010d268:	a2 24 52 81 f0       	mov    %al,0xf0815224
f010d26d:	a0 25 52 81 f0       	mov    0xf0815225,%al
f010d272:	83 e0 f0             	and    $0xfffffff0,%eax
f010d275:	83 c8 0e             	or     $0xe,%eax
f010d278:	a2 25 52 81 f0       	mov    %al,0xf0815225
f010d27d:	a0 25 52 81 f0       	mov    0xf0815225,%al
f010d282:	83 e0 ef             	and    $0xffffffef,%eax
f010d285:	a2 25 52 81 f0       	mov    %al,0xf0815225
f010d28a:	a0 25 52 81 f0       	mov    0xf0815225,%al
f010d28f:	83 c8 60             	or     $0x60,%eax
f010d292:	a2 25 52 81 f0       	mov    %al,0xf0815225
f010d297:	a0 25 52 81 f0       	mov    0xf0815225,%al
f010d29c:	83 c8 80             	or     $0xffffff80,%eax
f010d29f:	a2 25 52 81 f0       	mov    %al,0xf0815225
f010d2a4:	b8 92 e5 10 f0       	mov    $0xf010e592,%eax
f010d2a9:	c1 e8 10             	shr    $0x10,%eax
f010d2ac:	66 a3 26 52 81 f0    	mov    %ax,0xf0815226
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010d2b2:	b8 9c e5 10 f0       	mov    $0xf010e59c,%eax
f010d2b7:	66 a3 28 52 81 f0    	mov    %ax,0xf0815228
f010d2bd:	66 c7 05 2a 52 81 f0 	movw   $0x8,0xf081522a
f010d2c4:	08 00 
f010d2c6:	a0 2c 52 81 f0       	mov    0xf081522c,%al
f010d2cb:	83 e0 e0             	and    $0xffffffe0,%eax
f010d2ce:	a2 2c 52 81 f0       	mov    %al,0xf081522c
f010d2d3:	a0 2c 52 81 f0       	mov    0xf081522c,%al
f010d2d8:	83 e0 1f             	and    $0x1f,%eax
f010d2db:	a2 2c 52 81 f0       	mov    %al,0xf081522c
f010d2e0:	a0 2d 52 81 f0       	mov    0xf081522d,%al
f010d2e5:	83 c8 0f             	or     $0xf,%eax
f010d2e8:	a2 2d 52 81 f0       	mov    %al,0xf081522d
f010d2ed:	a0 2d 52 81 f0       	mov    0xf081522d,%al
f010d2f2:	83 e0 ef             	and    $0xffffffef,%eax
f010d2f5:	a2 2d 52 81 f0       	mov    %al,0xf081522d
f010d2fa:	a0 2d 52 81 f0       	mov    0xf081522d,%al
f010d2ff:	83 c8 60             	or     $0x60,%eax
f010d302:	a2 2d 52 81 f0       	mov    %al,0xf081522d
f010d307:	a0 2d 52 81 f0       	mov    0xf081522d,%al
f010d30c:	83 c8 80             	or     $0xffffff80,%eax
f010d30f:	a2 2d 52 81 f0       	mov    %al,0xf081522d
f010d314:	b8 9c e5 10 f0       	mov    $0xf010e59c,%eax
f010d319:	c1 e8 10             	shr    $0x10,%eax
f010d31c:	66 a3 2e 52 81 f0    	mov    %ax,0xf081522e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010d322:	b8 a6 e5 10 f0       	mov    $0xf010e5a6,%eax
f010d327:	66 a3 30 52 81 f0    	mov    %ax,0xf0815230
f010d32d:	66 c7 05 32 52 81 f0 	movw   $0x8,0xf0815232
f010d334:	08 00 
f010d336:	a0 34 52 81 f0       	mov    0xf0815234,%al
f010d33b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d33e:	a2 34 52 81 f0       	mov    %al,0xf0815234
f010d343:	a0 34 52 81 f0       	mov    0xf0815234,%al
f010d348:	83 e0 1f             	and    $0x1f,%eax
f010d34b:	a2 34 52 81 f0       	mov    %al,0xf0815234
f010d350:	a0 35 52 81 f0       	mov    0xf0815235,%al
f010d355:	83 e0 f0             	and    $0xfffffff0,%eax
f010d358:	83 c8 0e             	or     $0xe,%eax
f010d35b:	a2 35 52 81 f0       	mov    %al,0xf0815235
f010d360:	a0 35 52 81 f0       	mov    0xf0815235,%al
f010d365:	83 e0 ef             	and    $0xffffffef,%eax
f010d368:	a2 35 52 81 f0       	mov    %al,0xf0815235
f010d36d:	a0 35 52 81 f0       	mov    0xf0815235,%al
f010d372:	83 c8 60             	or     $0x60,%eax
f010d375:	a2 35 52 81 f0       	mov    %al,0xf0815235
f010d37a:	a0 35 52 81 f0       	mov    0xf0815235,%al
f010d37f:	83 c8 80             	or     $0xffffff80,%eax
f010d382:	a2 35 52 81 f0       	mov    %al,0xf0815235
f010d387:	b8 a6 e5 10 f0       	mov    $0xf010e5a6,%eax
f010d38c:	c1 e8 10             	shr    $0x10,%eax
f010d38f:	66 a3 36 52 81 f0    	mov    %ax,0xf0815236
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010d395:	b8 b0 e5 10 f0       	mov    $0xf010e5b0,%eax
f010d39a:	66 a3 38 52 81 f0    	mov    %ax,0xf0815238
f010d3a0:	66 c7 05 3a 52 81 f0 	movw   $0x8,0xf081523a
f010d3a7:	08 00 
f010d3a9:	a0 3c 52 81 f0       	mov    0xf081523c,%al
f010d3ae:	83 e0 e0             	and    $0xffffffe0,%eax
f010d3b1:	a2 3c 52 81 f0       	mov    %al,0xf081523c
f010d3b6:	a0 3c 52 81 f0       	mov    0xf081523c,%al
f010d3bb:	83 e0 1f             	and    $0x1f,%eax
f010d3be:	a2 3c 52 81 f0       	mov    %al,0xf081523c
f010d3c3:	a0 3d 52 81 f0       	mov    0xf081523d,%al
f010d3c8:	83 c8 0f             	or     $0xf,%eax
f010d3cb:	a2 3d 52 81 f0       	mov    %al,0xf081523d
f010d3d0:	a0 3d 52 81 f0       	mov    0xf081523d,%al
f010d3d5:	83 e0 ef             	and    $0xffffffef,%eax
f010d3d8:	a2 3d 52 81 f0       	mov    %al,0xf081523d
f010d3dd:	a0 3d 52 81 f0       	mov    0xf081523d,%al
f010d3e2:	83 c8 60             	or     $0x60,%eax
f010d3e5:	a2 3d 52 81 f0       	mov    %al,0xf081523d
f010d3ea:	a0 3d 52 81 f0       	mov    0xf081523d,%al
f010d3ef:	83 c8 80             	or     $0xffffff80,%eax
f010d3f2:	a2 3d 52 81 f0       	mov    %al,0xf081523d
f010d3f7:	b8 b0 e5 10 f0       	mov    $0xf010e5b0,%eax
f010d3fc:	c1 e8 10             	shr    $0x10,%eax
f010d3ff:	66 a3 3e 52 81 f0    	mov    %ax,0xf081523e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010d405:	b8 ba e5 10 f0       	mov    $0xf010e5ba,%eax
f010d40a:	66 a3 40 52 81 f0    	mov    %ax,0xf0815240
f010d410:	66 c7 05 42 52 81 f0 	movw   $0x8,0xf0815242
f010d417:	08 00 
f010d419:	a0 44 52 81 f0       	mov    0xf0815244,%al
f010d41e:	83 e0 e0             	and    $0xffffffe0,%eax
f010d421:	a2 44 52 81 f0       	mov    %al,0xf0815244
f010d426:	a0 44 52 81 f0       	mov    0xf0815244,%al
f010d42b:	83 e0 1f             	and    $0x1f,%eax
f010d42e:	a2 44 52 81 f0       	mov    %al,0xf0815244
f010d433:	a0 45 52 81 f0       	mov    0xf0815245,%al
f010d438:	83 c8 0f             	or     $0xf,%eax
f010d43b:	a2 45 52 81 f0       	mov    %al,0xf0815245
f010d440:	a0 45 52 81 f0       	mov    0xf0815245,%al
f010d445:	83 e0 ef             	and    $0xffffffef,%eax
f010d448:	a2 45 52 81 f0       	mov    %al,0xf0815245
f010d44d:	a0 45 52 81 f0       	mov    0xf0815245,%al
f010d452:	83 c8 60             	or     $0x60,%eax
f010d455:	a2 45 52 81 f0       	mov    %al,0xf0815245
f010d45a:	a0 45 52 81 f0       	mov    0xf0815245,%al
f010d45f:	83 c8 80             	or     $0xffffff80,%eax
f010d462:	a2 45 52 81 f0       	mov    %al,0xf0815245
f010d467:	b8 ba e5 10 f0       	mov    $0xf010e5ba,%eax
f010d46c:	c1 e8 10             	shr    $0x10,%eax
f010d46f:	66 a3 46 52 81 f0    	mov    %ax,0xf0815246
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010d475:	b8 c4 e5 10 f0       	mov    $0xf010e5c4,%eax
f010d47a:	66 a3 48 52 81 f0    	mov    %ax,0xf0815248
f010d480:	66 c7 05 4a 52 81 f0 	movw   $0x8,0xf081524a
f010d487:	08 00 
f010d489:	a0 4c 52 81 f0       	mov    0xf081524c,%al
f010d48e:	83 e0 e0             	and    $0xffffffe0,%eax
f010d491:	a2 4c 52 81 f0       	mov    %al,0xf081524c
f010d496:	a0 4c 52 81 f0       	mov    0xf081524c,%al
f010d49b:	83 e0 1f             	and    $0x1f,%eax
f010d49e:	a2 4c 52 81 f0       	mov    %al,0xf081524c
f010d4a3:	a0 4d 52 81 f0       	mov    0xf081524d,%al
f010d4a8:	83 e0 f0             	and    $0xfffffff0,%eax
f010d4ab:	83 c8 0e             	or     $0xe,%eax
f010d4ae:	a2 4d 52 81 f0       	mov    %al,0xf081524d
f010d4b3:	a0 4d 52 81 f0       	mov    0xf081524d,%al
f010d4b8:	83 e0 ef             	and    $0xffffffef,%eax
f010d4bb:	a2 4d 52 81 f0       	mov    %al,0xf081524d
f010d4c0:	a0 4d 52 81 f0       	mov    0xf081524d,%al
f010d4c5:	83 c8 60             	or     $0x60,%eax
f010d4c8:	a2 4d 52 81 f0       	mov    %al,0xf081524d
f010d4cd:	a0 4d 52 81 f0       	mov    0xf081524d,%al
f010d4d2:	83 c8 80             	or     $0xffffff80,%eax
f010d4d5:	a2 4d 52 81 f0       	mov    %al,0xf081524d
f010d4da:	b8 c4 e5 10 f0       	mov    $0xf010e5c4,%eax
f010d4df:	c1 e8 10             	shr    $0x10,%eax
f010d4e2:	66 a3 4e 52 81 f0    	mov    %ax,0xf081524e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010d4e8:	b8 ce e5 10 f0       	mov    $0xf010e5ce,%eax
f010d4ed:	66 a3 50 52 81 f0    	mov    %ax,0xf0815250
f010d4f3:	66 c7 05 52 52 81 f0 	movw   $0x8,0xf0815252
f010d4fa:	08 00 
f010d4fc:	a0 54 52 81 f0       	mov    0xf0815254,%al
f010d501:	83 e0 e0             	and    $0xffffffe0,%eax
f010d504:	a2 54 52 81 f0       	mov    %al,0xf0815254
f010d509:	a0 54 52 81 f0       	mov    0xf0815254,%al
f010d50e:	83 e0 1f             	and    $0x1f,%eax
f010d511:	a2 54 52 81 f0       	mov    %al,0xf0815254
f010d516:	a0 55 52 81 f0       	mov    0xf0815255,%al
f010d51b:	83 e0 f0             	and    $0xfffffff0,%eax
f010d51e:	83 c8 0e             	or     $0xe,%eax
f010d521:	a2 55 52 81 f0       	mov    %al,0xf0815255
f010d526:	a0 55 52 81 f0       	mov    0xf0815255,%al
f010d52b:	83 e0 ef             	and    $0xffffffef,%eax
f010d52e:	a2 55 52 81 f0       	mov    %al,0xf0815255
f010d533:	a0 55 52 81 f0       	mov    0xf0815255,%al
f010d538:	83 c8 60             	or     $0x60,%eax
f010d53b:	a2 55 52 81 f0       	mov    %al,0xf0815255
f010d540:	a0 55 52 81 f0       	mov    0xf0815255,%al
f010d545:	83 c8 80             	or     $0xffffff80,%eax
f010d548:	a2 55 52 81 f0       	mov    %al,0xf0815255
f010d54d:	b8 ce e5 10 f0       	mov    $0xf010e5ce,%eax
f010d552:	c1 e8 10             	shr    $0x10,%eax
f010d555:	66 a3 56 52 81 f0    	mov    %ax,0xf0815256
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010d55b:	b8 d8 e5 10 f0       	mov    $0xf010e5d8,%eax
f010d560:	66 a3 58 52 81 f0    	mov    %ax,0xf0815258
f010d566:	66 c7 05 5a 52 81 f0 	movw   $0x8,0xf081525a
f010d56d:	08 00 
f010d56f:	a0 5c 52 81 f0       	mov    0xf081525c,%al
f010d574:	83 e0 e0             	and    $0xffffffe0,%eax
f010d577:	a2 5c 52 81 f0       	mov    %al,0xf081525c
f010d57c:	a0 5c 52 81 f0       	mov    0xf081525c,%al
f010d581:	83 e0 1f             	and    $0x1f,%eax
f010d584:	a2 5c 52 81 f0       	mov    %al,0xf081525c
f010d589:	a0 5d 52 81 f0       	mov    0xf081525d,%al
f010d58e:	83 e0 f0             	and    $0xfffffff0,%eax
f010d591:	83 c8 0e             	or     $0xe,%eax
f010d594:	a2 5d 52 81 f0       	mov    %al,0xf081525d
f010d599:	a0 5d 52 81 f0       	mov    0xf081525d,%al
f010d59e:	83 e0 ef             	and    $0xffffffef,%eax
f010d5a1:	a2 5d 52 81 f0       	mov    %al,0xf081525d
f010d5a6:	a0 5d 52 81 f0       	mov    0xf081525d,%al
f010d5ab:	83 c8 60             	or     $0x60,%eax
f010d5ae:	a2 5d 52 81 f0       	mov    %al,0xf081525d
f010d5b3:	a0 5d 52 81 f0       	mov    0xf081525d,%al
f010d5b8:	83 c8 80             	or     $0xffffff80,%eax
f010d5bb:	a2 5d 52 81 f0       	mov    %al,0xf081525d
f010d5c0:	b8 d8 e5 10 f0       	mov    $0xf010e5d8,%eax
f010d5c5:	c1 e8 10             	shr    $0x10,%eax
f010d5c8:	66 a3 5e 52 81 f0    	mov    %ax,0xf081525e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010d5ce:	b8 de e5 10 f0       	mov    $0xf010e5de,%eax
f010d5d3:	66 a3 70 52 81 f0    	mov    %ax,0xf0815270
f010d5d9:	66 c7 05 72 52 81 f0 	movw   $0x8,0xf0815272
f010d5e0:	08 00 
f010d5e2:	a0 74 52 81 f0       	mov    0xf0815274,%al
f010d5e7:	83 e0 e0             	and    $0xffffffe0,%eax
f010d5ea:	a2 74 52 81 f0       	mov    %al,0xf0815274
f010d5ef:	a0 74 52 81 f0       	mov    0xf0815274,%al
f010d5f4:	83 e0 1f             	and    $0x1f,%eax
f010d5f7:	a2 74 52 81 f0       	mov    %al,0xf0815274
f010d5fc:	a0 75 52 81 f0       	mov    0xf0815275,%al
f010d601:	83 e0 f0             	and    $0xfffffff0,%eax
f010d604:	83 c8 0e             	or     $0xe,%eax
f010d607:	a2 75 52 81 f0       	mov    %al,0xf0815275
f010d60c:	a0 75 52 81 f0       	mov    0xf0815275,%al
f010d611:	83 e0 ef             	and    $0xffffffef,%eax
f010d614:	a2 75 52 81 f0       	mov    %al,0xf0815275
f010d619:	a0 75 52 81 f0       	mov    0xf0815275,%al
f010d61e:	83 c8 60             	or     $0x60,%eax
f010d621:	a2 75 52 81 f0       	mov    %al,0xf0815275
f010d626:	a0 75 52 81 f0       	mov    0xf0815275,%al
f010d62b:	83 c8 80             	or     $0xffffff80,%eax
f010d62e:	a2 75 52 81 f0       	mov    %al,0xf0815275
f010d633:	b8 de e5 10 f0       	mov    $0xf010e5de,%eax
f010d638:	c1 e8 10             	shr    $0x10,%eax
f010d63b:	66 a3 76 52 81 f0    	mov    %ax,0xf0815276
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010d641:	b8 e2 e5 10 f0       	mov    $0xf010e5e2,%eax
f010d646:	66 a3 78 52 81 f0    	mov    %ax,0xf0815278
f010d64c:	66 c7 05 7a 52 81 f0 	movw   $0x8,0xf081527a
f010d653:	08 00 
f010d655:	a0 7c 52 81 f0       	mov    0xf081527c,%al
f010d65a:	83 e0 e0             	and    $0xffffffe0,%eax
f010d65d:	a2 7c 52 81 f0       	mov    %al,0xf081527c
f010d662:	a0 7c 52 81 f0       	mov    0xf081527c,%al
f010d667:	83 e0 1f             	and    $0x1f,%eax
f010d66a:	a2 7c 52 81 f0       	mov    %al,0xf081527c
f010d66f:	a0 7d 52 81 f0       	mov    0xf081527d,%al
f010d674:	83 e0 f0             	and    $0xfffffff0,%eax
f010d677:	83 c8 0e             	or     $0xe,%eax
f010d67a:	a2 7d 52 81 f0       	mov    %al,0xf081527d
f010d67f:	a0 7d 52 81 f0       	mov    0xf081527d,%al
f010d684:	83 e0 ef             	and    $0xffffffef,%eax
f010d687:	a2 7d 52 81 f0       	mov    %al,0xf081527d
f010d68c:	a0 7d 52 81 f0       	mov    0xf081527d,%al
f010d691:	83 c8 60             	or     $0x60,%eax
f010d694:	a2 7d 52 81 f0       	mov    %al,0xf081527d
f010d699:	a0 7d 52 81 f0       	mov    0xf081527d,%al
f010d69e:	83 c8 80             	or     $0xffffff80,%eax
f010d6a1:	a2 7d 52 81 f0       	mov    %al,0xf081527d
f010d6a6:	b8 e2 e5 10 f0       	mov    $0xf010e5e2,%eax
f010d6ab:	c1 e8 10             	shr    $0x10,%eax
f010d6ae:	66 a3 7e 52 81 f0    	mov    %ax,0xf081527e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010d6b4:	b8 e6 e5 10 f0       	mov    $0xf010e5e6,%eax
f010d6b9:	66 a3 80 52 81 f0    	mov    %ax,0xf0815280
f010d6bf:	66 c7 05 82 52 81 f0 	movw   $0x8,0xf0815282
f010d6c6:	08 00 
f010d6c8:	a0 84 52 81 f0       	mov    0xf0815284,%al
f010d6cd:	83 e0 e0             	and    $0xffffffe0,%eax
f010d6d0:	a2 84 52 81 f0       	mov    %al,0xf0815284
f010d6d5:	a0 84 52 81 f0       	mov    0xf0815284,%al
f010d6da:	83 e0 1f             	and    $0x1f,%eax
f010d6dd:	a2 84 52 81 f0       	mov    %al,0xf0815284
f010d6e2:	a0 85 52 81 f0       	mov    0xf0815285,%al
f010d6e7:	83 e0 f0             	and    $0xfffffff0,%eax
f010d6ea:	83 c8 0e             	or     $0xe,%eax
f010d6ed:	a2 85 52 81 f0       	mov    %al,0xf0815285
f010d6f2:	a0 85 52 81 f0       	mov    0xf0815285,%al
f010d6f7:	83 e0 ef             	and    $0xffffffef,%eax
f010d6fa:	a2 85 52 81 f0       	mov    %al,0xf0815285
f010d6ff:	a0 85 52 81 f0       	mov    0xf0815285,%al
f010d704:	83 c8 60             	or     $0x60,%eax
f010d707:	a2 85 52 81 f0       	mov    %al,0xf0815285
f010d70c:	a0 85 52 81 f0       	mov    0xf0815285,%al
f010d711:	83 c8 80             	or     $0xffffff80,%eax
f010d714:	a2 85 52 81 f0       	mov    %al,0xf0815285
f010d719:	b8 e6 e5 10 f0       	mov    $0xf010e5e6,%eax
f010d71e:	c1 e8 10             	shr    $0x10,%eax
f010d721:	66 a3 86 52 81 f0    	mov    %ax,0xf0815286
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010d727:	b8 ea e5 10 f0       	mov    $0xf010e5ea,%eax
f010d72c:	66 a3 88 52 81 f0    	mov    %ax,0xf0815288
f010d732:	66 c7 05 8a 52 81 f0 	movw   $0x8,0xf081528a
f010d739:	08 00 
f010d73b:	a0 8c 52 81 f0       	mov    0xf081528c,%al
f010d740:	83 e0 e0             	and    $0xffffffe0,%eax
f010d743:	a2 8c 52 81 f0       	mov    %al,0xf081528c
f010d748:	a0 8c 52 81 f0       	mov    0xf081528c,%al
f010d74d:	83 e0 1f             	and    $0x1f,%eax
f010d750:	a2 8c 52 81 f0       	mov    %al,0xf081528c
f010d755:	a0 8d 52 81 f0       	mov    0xf081528d,%al
f010d75a:	83 e0 f0             	and    $0xfffffff0,%eax
f010d75d:	83 c8 0e             	or     $0xe,%eax
f010d760:	a2 8d 52 81 f0       	mov    %al,0xf081528d
f010d765:	a0 8d 52 81 f0       	mov    0xf081528d,%al
f010d76a:	83 e0 ef             	and    $0xffffffef,%eax
f010d76d:	a2 8d 52 81 f0       	mov    %al,0xf081528d
f010d772:	a0 8d 52 81 f0       	mov    0xf081528d,%al
f010d777:	83 c8 60             	or     $0x60,%eax
f010d77a:	a2 8d 52 81 f0       	mov    %al,0xf081528d
f010d77f:	a0 8d 52 81 f0       	mov    0xf081528d,%al
f010d784:	83 c8 80             	or     $0xffffff80,%eax
f010d787:	a2 8d 52 81 f0       	mov    %al,0xf081528d
f010d78c:	b8 ea e5 10 f0       	mov    $0xf010e5ea,%eax
f010d791:	c1 e8 10             	shr    $0x10,%eax
f010d794:	66 a3 8e 52 81 f0    	mov    %ax,0xf081528e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010d79a:	b8 ee e5 10 f0       	mov    $0xf010e5ee,%eax
f010d79f:	66 a3 a0 52 81 f0    	mov    %ax,0xf08152a0
f010d7a5:	66 c7 05 a2 52 81 f0 	movw   $0x8,0xf08152a2
f010d7ac:	08 00 
f010d7ae:	a0 a4 52 81 f0       	mov    0xf08152a4,%al
f010d7b3:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7b6:	a2 a4 52 81 f0       	mov    %al,0xf08152a4
f010d7bb:	a0 a4 52 81 f0       	mov    0xf08152a4,%al
f010d7c0:	83 e0 1f             	and    $0x1f,%eax
f010d7c3:	a2 a4 52 81 f0       	mov    %al,0xf08152a4
f010d7c8:	a0 a5 52 81 f0       	mov    0xf08152a5,%al
f010d7cd:	83 e0 f0             	and    $0xfffffff0,%eax
f010d7d0:	83 c8 0e             	or     $0xe,%eax
f010d7d3:	a2 a5 52 81 f0       	mov    %al,0xf08152a5
f010d7d8:	a0 a5 52 81 f0       	mov    0xf08152a5,%al
f010d7dd:	83 e0 ef             	and    $0xffffffef,%eax
f010d7e0:	a2 a5 52 81 f0       	mov    %al,0xf08152a5
f010d7e5:	a0 a5 52 81 f0       	mov    0xf08152a5,%al
f010d7ea:	83 c8 60             	or     $0x60,%eax
f010d7ed:	a2 a5 52 81 f0       	mov    %al,0xf08152a5
f010d7f2:	a0 a5 52 81 f0       	mov    0xf08152a5,%al
f010d7f7:	83 c8 80             	or     $0xffffff80,%eax
f010d7fa:	a2 a5 52 81 f0       	mov    %al,0xf08152a5
f010d7ff:	b8 ee e5 10 f0       	mov    $0xf010e5ee,%eax
f010d804:	c1 e8 10             	shr    $0x10,%eax
f010d807:	66 a3 a6 52 81 f0    	mov    %ax,0xf08152a6
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010d80d:	b8 f4 e5 10 f0       	mov    $0xf010e5f4,%eax
f010d812:	66 a3 a8 52 81 f0    	mov    %ax,0xf08152a8
f010d818:	66 c7 05 aa 52 81 f0 	movw   $0x8,0xf08152aa
f010d81f:	08 00 
f010d821:	a0 ac 52 81 f0       	mov    0xf08152ac,%al
f010d826:	83 e0 e0             	and    $0xffffffe0,%eax
f010d829:	a2 ac 52 81 f0       	mov    %al,0xf08152ac
f010d82e:	a0 ac 52 81 f0       	mov    0xf08152ac,%al
f010d833:	83 e0 1f             	and    $0x1f,%eax
f010d836:	a2 ac 52 81 f0       	mov    %al,0xf08152ac
f010d83b:	a0 ad 52 81 f0       	mov    0xf08152ad,%al
f010d840:	83 e0 f0             	and    $0xfffffff0,%eax
f010d843:	83 c8 0e             	or     $0xe,%eax
f010d846:	a2 ad 52 81 f0       	mov    %al,0xf08152ad
f010d84b:	a0 ad 52 81 f0       	mov    0xf08152ad,%al
f010d850:	83 e0 ef             	and    $0xffffffef,%eax
f010d853:	a2 ad 52 81 f0       	mov    %al,0xf08152ad
f010d858:	a0 ad 52 81 f0       	mov    0xf08152ad,%al
f010d85d:	83 c8 60             	or     $0x60,%eax
f010d860:	a2 ad 52 81 f0       	mov    %al,0xf08152ad
f010d865:	a0 ad 52 81 f0       	mov    0xf08152ad,%al
f010d86a:	83 c8 80             	or     $0xffffff80,%eax
f010d86d:	a2 ad 52 81 f0       	mov    %al,0xf08152ad
f010d872:	b8 f4 e5 10 f0       	mov    $0xf010e5f4,%eax
f010d877:	c1 e8 10             	shr    $0x10,%eax
f010d87a:	66 a3 ae 52 81 f0    	mov    %ax,0xf08152ae
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010d880:	b8 f8 e5 10 f0       	mov    $0xf010e5f8,%eax
f010d885:	66 a3 b0 52 81 f0    	mov    %ax,0xf08152b0
f010d88b:	66 c7 05 b2 52 81 f0 	movw   $0x8,0xf08152b2
f010d892:	08 00 
f010d894:	a0 b4 52 81 f0       	mov    0xf08152b4,%al
f010d899:	83 e0 e0             	and    $0xffffffe0,%eax
f010d89c:	a2 b4 52 81 f0       	mov    %al,0xf08152b4
f010d8a1:	a0 b4 52 81 f0       	mov    0xf08152b4,%al
f010d8a6:	83 e0 1f             	and    $0x1f,%eax
f010d8a9:	a2 b4 52 81 f0       	mov    %al,0xf08152b4
f010d8ae:	a0 b5 52 81 f0       	mov    0xf08152b5,%al
f010d8b3:	83 e0 f0             	and    $0xfffffff0,%eax
f010d8b6:	83 c8 0e             	or     $0xe,%eax
f010d8b9:	a2 b5 52 81 f0       	mov    %al,0xf08152b5
f010d8be:	a0 b5 52 81 f0       	mov    0xf08152b5,%al
f010d8c3:	83 e0 ef             	and    $0xffffffef,%eax
f010d8c6:	a2 b5 52 81 f0       	mov    %al,0xf08152b5
f010d8cb:	a0 b5 52 81 f0       	mov    0xf08152b5,%al
f010d8d0:	83 c8 60             	or     $0x60,%eax
f010d8d3:	a2 b5 52 81 f0       	mov    %al,0xf08152b5
f010d8d8:	a0 b5 52 81 f0       	mov    0xf08152b5,%al
f010d8dd:	83 c8 80             	or     $0xffffff80,%eax
f010d8e0:	a2 b5 52 81 f0       	mov    %al,0xf08152b5
f010d8e5:	b8 f8 e5 10 f0       	mov    $0xf010e5f8,%eax
f010d8ea:	c1 e8 10             	shr    $0x10,%eax
f010d8ed:	66 a3 b6 52 81 f0    	mov    %ax,0xf08152b6
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010d8f3:	b8 fe e5 10 f0       	mov    $0xf010e5fe,%eax
f010d8f8:	66 a3 b8 52 81 f0    	mov    %ax,0xf08152b8
f010d8fe:	66 c7 05 ba 52 81 f0 	movw   $0x8,0xf08152ba
f010d905:	08 00 
f010d907:	a0 bc 52 81 f0       	mov    0xf08152bc,%al
f010d90c:	83 e0 e0             	and    $0xffffffe0,%eax
f010d90f:	a2 bc 52 81 f0       	mov    %al,0xf08152bc
f010d914:	a0 bc 52 81 f0       	mov    0xf08152bc,%al
f010d919:	83 e0 1f             	and    $0x1f,%eax
f010d91c:	a2 bc 52 81 f0       	mov    %al,0xf08152bc
f010d921:	a0 bd 52 81 f0       	mov    0xf08152bd,%al
f010d926:	83 e0 f0             	and    $0xfffffff0,%eax
f010d929:	83 c8 0e             	or     $0xe,%eax
f010d92c:	a2 bd 52 81 f0       	mov    %al,0xf08152bd
f010d931:	a0 bd 52 81 f0       	mov    0xf08152bd,%al
f010d936:	83 e0 ef             	and    $0xffffffef,%eax
f010d939:	a2 bd 52 81 f0       	mov    %al,0xf08152bd
f010d93e:	a0 bd 52 81 f0       	mov    0xf08152bd,%al
f010d943:	83 c8 60             	or     $0x60,%eax
f010d946:	a2 bd 52 81 f0       	mov    %al,0xf08152bd
f010d94b:	a0 bd 52 81 f0       	mov    0xf08152bd,%al
f010d950:	83 c8 80             	or     $0xffffff80,%eax
f010d953:	a2 bd 52 81 f0       	mov    %al,0xf08152bd
f010d958:	b8 fe e5 10 f0       	mov    $0xf010e5fe,%eax
f010d95d:	c1 e8 10             	shr    $0x10,%eax
f010d960:	66 a3 be 52 81 f0    	mov    %ax,0xf08152be

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010d966:	b8 04 e6 10 f0       	mov    $0xf010e604,%eax
f010d96b:	66 a3 30 53 81 f0    	mov    %ax,0xf0815330
f010d971:	66 c7 05 32 53 81 f0 	movw   $0x8,0xf0815332
f010d978:	08 00 
f010d97a:	a0 34 53 81 f0       	mov    0xf0815334,%al
f010d97f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d982:	a2 34 53 81 f0       	mov    %al,0xf0815334
f010d987:	a0 34 53 81 f0       	mov    0xf0815334,%al
f010d98c:	83 e0 1f             	and    $0x1f,%eax
f010d98f:	a2 34 53 81 f0       	mov    %al,0xf0815334
f010d994:	a0 35 53 81 f0       	mov    0xf0815335,%al
f010d999:	83 e0 f0             	and    $0xfffffff0,%eax
f010d99c:	83 c8 0e             	or     $0xe,%eax
f010d99f:	a2 35 53 81 f0       	mov    %al,0xf0815335
f010d9a4:	a0 35 53 81 f0       	mov    0xf0815335,%al
f010d9a9:	83 e0 ef             	and    $0xffffffef,%eax
f010d9ac:	a2 35 53 81 f0       	mov    %al,0xf0815335
f010d9b1:	a0 35 53 81 f0       	mov    0xf0815335,%al
f010d9b6:	83 c8 60             	or     $0x60,%eax
f010d9b9:	a2 35 53 81 f0       	mov    %al,0xf0815335
f010d9be:	a0 35 53 81 f0       	mov    0xf0815335,%al
f010d9c3:	83 c8 80             	or     $0xffffff80,%eax
f010d9c6:	a2 35 53 81 f0       	mov    %al,0xf0815335
f010d9cb:	b8 04 e6 10 f0       	mov    $0xf010e604,%eax
f010d9d0:	c1 e8 10             	shr    $0x10,%eax
f010d9d3:	66 a3 36 53 81 f0    	mov    %ax,0xf0815336
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010d9d9:	b8 0a e6 10 f0       	mov    $0xf010e60a,%eax
f010d9de:	66 a3 38 53 81 f0    	mov    %ax,0xf0815338
f010d9e4:	66 c7 05 3a 53 81 f0 	movw   $0x8,0xf081533a
f010d9eb:	08 00 
f010d9ed:	a0 3c 53 81 f0       	mov    0xf081533c,%al
f010d9f2:	83 e0 e0             	and    $0xffffffe0,%eax
f010d9f5:	a2 3c 53 81 f0       	mov    %al,0xf081533c
f010d9fa:	a0 3c 53 81 f0       	mov    0xf081533c,%al
f010d9ff:	83 e0 1f             	and    $0x1f,%eax
f010da02:	a2 3c 53 81 f0       	mov    %al,0xf081533c
f010da07:	a0 3d 53 81 f0       	mov    0xf081533d,%al
f010da0c:	83 e0 f0             	and    $0xfffffff0,%eax
f010da0f:	83 c8 0e             	or     $0xe,%eax
f010da12:	a2 3d 53 81 f0       	mov    %al,0xf081533d
f010da17:	a0 3d 53 81 f0       	mov    0xf081533d,%al
f010da1c:	83 e0 ef             	and    $0xffffffef,%eax
f010da1f:	a2 3d 53 81 f0       	mov    %al,0xf081533d
f010da24:	a0 3d 53 81 f0       	mov    0xf081533d,%al
f010da29:	83 c8 60             	or     $0x60,%eax
f010da2c:	a2 3d 53 81 f0       	mov    %al,0xf081533d
f010da31:	a0 3d 53 81 f0       	mov    0xf081533d,%al
f010da36:	83 c8 80             	or     $0xffffff80,%eax
f010da39:	a2 3d 53 81 f0       	mov    %al,0xf081533d
f010da3e:	b8 0a e6 10 f0       	mov    $0xf010e60a,%eax
f010da43:	c1 e8 10             	shr    $0x10,%eax
f010da46:	66 a3 3e 53 81 f0    	mov    %ax,0xf081533e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010da4c:	b8 10 e6 10 f0       	mov    $0xf010e610,%eax
f010da51:	66 a3 40 53 81 f0    	mov    %ax,0xf0815340
f010da57:	66 c7 05 42 53 81 f0 	movw   $0x8,0xf0815342
f010da5e:	08 00 
f010da60:	a0 44 53 81 f0       	mov    0xf0815344,%al
f010da65:	83 e0 e0             	and    $0xffffffe0,%eax
f010da68:	a2 44 53 81 f0       	mov    %al,0xf0815344
f010da6d:	a0 44 53 81 f0       	mov    0xf0815344,%al
f010da72:	83 e0 1f             	and    $0x1f,%eax
f010da75:	a2 44 53 81 f0       	mov    %al,0xf0815344
f010da7a:	a0 45 53 81 f0       	mov    0xf0815345,%al
f010da7f:	83 e0 f0             	and    $0xfffffff0,%eax
f010da82:	83 c8 0e             	or     $0xe,%eax
f010da85:	a2 45 53 81 f0       	mov    %al,0xf0815345
f010da8a:	a0 45 53 81 f0       	mov    0xf0815345,%al
f010da8f:	83 e0 ef             	and    $0xffffffef,%eax
f010da92:	a2 45 53 81 f0       	mov    %al,0xf0815345
f010da97:	a0 45 53 81 f0       	mov    0xf0815345,%al
f010da9c:	83 c8 60             	or     $0x60,%eax
f010da9f:	a2 45 53 81 f0       	mov    %al,0xf0815345
f010daa4:	a0 45 53 81 f0       	mov    0xf0815345,%al
f010daa9:	83 c8 80             	or     $0xffffff80,%eax
f010daac:	a2 45 53 81 f0       	mov    %al,0xf0815345
f010dab1:	b8 10 e6 10 f0       	mov    $0xf010e610,%eax
f010dab6:	c1 e8 10             	shr    $0x10,%eax
f010dab9:	66 a3 46 53 81 f0    	mov    %ax,0xf0815346
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010dabf:	b8 16 e6 10 f0       	mov    $0xf010e616,%eax
f010dac4:	66 a3 48 53 81 f0    	mov    %ax,0xf0815348
f010daca:	66 c7 05 4a 53 81 f0 	movw   $0x8,0xf081534a
f010dad1:	08 00 
f010dad3:	a0 4c 53 81 f0       	mov    0xf081534c,%al
f010dad8:	83 e0 e0             	and    $0xffffffe0,%eax
f010dadb:	a2 4c 53 81 f0       	mov    %al,0xf081534c
f010dae0:	a0 4c 53 81 f0       	mov    0xf081534c,%al
f010dae5:	83 e0 1f             	and    $0x1f,%eax
f010dae8:	a2 4c 53 81 f0       	mov    %al,0xf081534c
f010daed:	a0 4d 53 81 f0       	mov    0xf081534d,%al
f010daf2:	83 e0 f0             	and    $0xfffffff0,%eax
f010daf5:	83 c8 0e             	or     $0xe,%eax
f010daf8:	a2 4d 53 81 f0       	mov    %al,0xf081534d
f010dafd:	a0 4d 53 81 f0       	mov    0xf081534d,%al
f010db02:	83 e0 ef             	and    $0xffffffef,%eax
f010db05:	a2 4d 53 81 f0       	mov    %al,0xf081534d
f010db0a:	a0 4d 53 81 f0       	mov    0xf081534d,%al
f010db0f:	83 c8 60             	or     $0x60,%eax
f010db12:	a2 4d 53 81 f0       	mov    %al,0xf081534d
f010db17:	a0 4d 53 81 f0       	mov    0xf081534d,%al
f010db1c:	83 c8 80             	or     $0xffffff80,%eax
f010db1f:	a2 4d 53 81 f0       	mov    %al,0xf081534d
f010db24:	b8 16 e6 10 f0       	mov    $0xf010e616,%eax
f010db29:	c1 e8 10             	shr    $0x10,%eax
f010db2c:	66 a3 4e 53 81 f0    	mov    %ax,0xf081534e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010db32:	b8 1c e6 10 f0       	mov    $0xf010e61c,%eax
f010db37:	66 a3 50 53 81 f0    	mov    %ax,0xf0815350
f010db3d:	66 c7 05 52 53 81 f0 	movw   $0x8,0xf0815352
f010db44:	08 00 
f010db46:	a0 54 53 81 f0       	mov    0xf0815354,%al
f010db4b:	83 e0 e0             	and    $0xffffffe0,%eax
f010db4e:	a2 54 53 81 f0       	mov    %al,0xf0815354
f010db53:	a0 54 53 81 f0       	mov    0xf0815354,%al
f010db58:	83 e0 1f             	and    $0x1f,%eax
f010db5b:	a2 54 53 81 f0       	mov    %al,0xf0815354
f010db60:	a0 55 53 81 f0       	mov    0xf0815355,%al
f010db65:	83 e0 f0             	and    $0xfffffff0,%eax
f010db68:	83 c8 0e             	or     $0xe,%eax
f010db6b:	a2 55 53 81 f0       	mov    %al,0xf0815355
f010db70:	a0 55 53 81 f0       	mov    0xf0815355,%al
f010db75:	83 e0 ef             	and    $0xffffffef,%eax
f010db78:	a2 55 53 81 f0       	mov    %al,0xf0815355
f010db7d:	a0 55 53 81 f0       	mov    0xf0815355,%al
f010db82:	83 c8 60             	or     $0x60,%eax
f010db85:	a2 55 53 81 f0       	mov    %al,0xf0815355
f010db8a:	a0 55 53 81 f0       	mov    0xf0815355,%al
f010db8f:	83 c8 80             	or     $0xffffff80,%eax
f010db92:	a2 55 53 81 f0       	mov    %al,0xf0815355
f010db97:	b8 1c e6 10 f0       	mov    $0xf010e61c,%eax
f010db9c:	c1 e8 10             	shr    $0x10,%eax
f010db9f:	66 a3 56 53 81 f0    	mov    %ax,0xf0815356
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010dba5:	b8 22 e6 10 f0       	mov    $0xf010e622,%eax
f010dbaa:	66 a3 58 53 81 f0    	mov    %ax,0xf0815358
f010dbb0:	66 c7 05 5a 53 81 f0 	movw   $0x8,0xf081535a
f010dbb7:	08 00 
f010dbb9:	a0 5c 53 81 f0       	mov    0xf081535c,%al
f010dbbe:	83 e0 e0             	and    $0xffffffe0,%eax
f010dbc1:	a2 5c 53 81 f0       	mov    %al,0xf081535c
f010dbc6:	a0 5c 53 81 f0       	mov    0xf081535c,%al
f010dbcb:	83 e0 1f             	and    $0x1f,%eax
f010dbce:	a2 5c 53 81 f0       	mov    %al,0xf081535c
f010dbd3:	a0 5d 53 81 f0       	mov    0xf081535d,%al
f010dbd8:	83 e0 f0             	and    $0xfffffff0,%eax
f010dbdb:	83 c8 0e             	or     $0xe,%eax
f010dbde:	a2 5d 53 81 f0       	mov    %al,0xf081535d
f010dbe3:	a0 5d 53 81 f0       	mov    0xf081535d,%al
f010dbe8:	83 e0 ef             	and    $0xffffffef,%eax
f010dbeb:	a2 5d 53 81 f0       	mov    %al,0xf081535d
f010dbf0:	a0 5d 53 81 f0       	mov    0xf081535d,%al
f010dbf5:	83 c8 60             	or     $0x60,%eax
f010dbf8:	a2 5d 53 81 f0       	mov    %al,0xf081535d
f010dbfd:	a0 5d 53 81 f0       	mov    0xf081535d,%al
f010dc02:	83 c8 80             	or     $0xffffff80,%eax
f010dc05:	a2 5d 53 81 f0       	mov    %al,0xf081535d
f010dc0a:	b8 22 e6 10 f0       	mov    $0xf010e622,%eax
f010dc0f:	c1 e8 10             	shr    $0x10,%eax
f010dc12:	66 a3 5e 53 81 f0    	mov    %ax,0xf081535e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010dc18:	b8 28 e6 10 f0       	mov    $0xf010e628,%eax
f010dc1d:	66 a3 60 53 81 f0    	mov    %ax,0xf0815360
f010dc23:	66 c7 05 62 53 81 f0 	movw   $0x8,0xf0815362
f010dc2a:	08 00 
f010dc2c:	a0 64 53 81 f0       	mov    0xf0815364,%al
f010dc31:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc34:	a2 64 53 81 f0       	mov    %al,0xf0815364
f010dc39:	a0 64 53 81 f0       	mov    0xf0815364,%al
f010dc3e:	83 e0 1f             	and    $0x1f,%eax
f010dc41:	a2 64 53 81 f0       	mov    %al,0xf0815364
f010dc46:	a0 65 53 81 f0       	mov    0xf0815365,%al
f010dc4b:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc4e:	83 c8 0e             	or     $0xe,%eax
f010dc51:	a2 65 53 81 f0       	mov    %al,0xf0815365
f010dc56:	a0 65 53 81 f0       	mov    0xf0815365,%al
f010dc5b:	83 e0 ef             	and    $0xffffffef,%eax
f010dc5e:	a2 65 53 81 f0       	mov    %al,0xf0815365
f010dc63:	a0 65 53 81 f0       	mov    0xf0815365,%al
f010dc68:	83 c8 60             	or     $0x60,%eax
f010dc6b:	a2 65 53 81 f0       	mov    %al,0xf0815365
f010dc70:	a0 65 53 81 f0       	mov    0xf0815365,%al
f010dc75:	83 c8 80             	or     $0xffffff80,%eax
f010dc78:	a2 65 53 81 f0       	mov    %al,0xf0815365
f010dc7d:	b8 28 e6 10 f0       	mov    $0xf010e628,%eax
f010dc82:	c1 e8 10             	shr    $0x10,%eax
f010dc85:	66 a3 66 53 81 f0    	mov    %ax,0xf0815366
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010dc8b:	b8 2e e6 10 f0       	mov    $0xf010e62e,%eax
f010dc90:	66 a3 68 53 81 f0    	mov    %ax,0xf0815368
f010dc96:	66 c7 05 6a 53 81 f0 	movw   $0x8,0xf081536a
f010dc9d:	08 00 
f010dc9f:	a0 6c 53 81 f0       	mov    0xf081536c,%al
f010dca4:	83 e0 e0             	and    $0xffffffe0,%eax
f010dca7:	a2 6c 53 81 f0       	mov    %al,0xf081536c
f010dcac:	a0 6c 53 81 f0       	mov    0xf081536c,%al
f010dcb1:	83 e0 1f             	and    $0x1f,%eax
f010dcb4:	a2 6c 53 81 f0       	mov    %al,0xf081536c
f010dcb9:	a0 6d 53 81 f0       	mov    0xf081536d,%al
f010dcbe:	83 e0 f0             	and    $0xfffffff0,%eax
f010dcc1:	83 c8 0e             	or     $0xe,%eax
f010dcc4:	a2 6d 53 81 f0       	mov    %al,0xf081536d
f010dcc9:	a0 6d 53 81 f0       	mov    0xf081536d,%al
f010dcce:	83 e0 ef             	and    $0xffffffef,%eax
f010dcd1:	a2 6d 53 81 f0       	mov    %al,0xf081536d
f010dcd6:	a0 6d 53 81 f0       	mov    0xf081536d,%al
f010dcdb:	83 c8 60             	or     $0x60,%eax
f010dcde:	a2 6d 53 81 f0       	mov    %al,0xf081536d
f010dce3:	a0 6d 53 81 f0       	mov    0xf081536d,%al
f010dce8:	83 c8 80             	or     $0xffffff80,%eax
f010dceb:	a2 6d 53 81 f0       	mov    %al,0xf081536d
f010dcf0:	b8 2e e6 10 f0       	mov    $0xf010e62e,%eax
f010dcf5:	c1 e8 10             	shr    $0x10,%eax
f010dcf8:	66 a3 6e 53 81 f0    	mov    %ax,0xf081536e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010dcfe:	b8 34 e6 10 f0       	mov    $0xf010e634,%eax
f010dd03:	66 a3 70 53 81 f0    	mov    %ax,0xf0815370
f010dd09:	66 c7 05 72 53 81 f0 	movw   $0x8,0xf0815372
f010dd10:	08 00 
f010dd12:	a0 74 53 81 f0       	mov    0xf0815374,%al
f010dd17:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd1a:	a2 74 53 81 f0       	mov    %al,0xf0815374
f010dd1f:	a0 74 53 81 f0       	mov    0xf0815374,%al
f010dd24:	83 e0 1f             	and    $0x1f,%eax
f010dd27:	a2 74 53 81 f0       	mov    %al,0xf0815374
f010dd2c:	a0 75 53 81 f0       	mov    0xf0815375,%al
f010dd31:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd34:	83 c8 0e             	or     $0xe,%eax
f010dd37:	a2 75 53 81 f0       	mov    %al,0xf0815375
f010dd3c:	a0 75 53 81 f0       	mov    0xf0815375,%al
f010dd41:	83 e0 ef             	and    $0xffffffef,%eax
f010dd44:	a2 75 53 81 f0       	mov    %al,0xf0815375
f010dd49:	a0 75 53 81 f0       	mov    0xf0815375,%al
f010dd4e:	83 c8 60             	or     $0x60,%eax
f010dd51:	a2 75 53 81 f0       	mov    %al,0xf0815375
f010dd56:	a0 75 53 81 f0       	mov    0xf0815375,%al
f010dd5b:	83 c8 80             	or     $0xffffff80,%eax
f010dd5e:	a2 75 53 81 f0       	mov    %al,0xf0815375
f010dd63:	b8 34 e6 10 f0       	mov    $0xf010e634,%eax
f010dd68:	c1 e8 10             	shr    $0x10,%eax
f010dd6b:	66 a3 76 53 81 f0    	mov    %ax,0xf0815376
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010dd71:	b8 3a e6 10 f0       	mov    $0xf010e63a,%eax
f010dd76:	66 a3 78 53 81 f0    	mov    %ax,0xf0815378
f010dd7c:	66 c7 05 7a 53 81 f0 	movw   $0x8,0xf081537a
f010dd83:	08 00 
f010dd85:	a0 7c 53 81 f0       	mov    0xf081537c,%al
f010dd8a:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd8d:	a2 7c 53 81 f0       	mov    %al,0xf081537c
f010dd92:	a0 7c 53 81 f0       	mov    0xf081537c,%al
f010dd97:	83 e0 1f             	and    $0x1f,%eax
f010dd9a:	a2 7c 53 81 f0       	mov    %al,0xf081537c
f010dd9f:	a0 7d 53 81 f0       	mov    0xf081537d,%al
f010dda4:	83 e0 f0             	and    $0xfffffff0,%eax
f010dda7:	83 c8 0e             	or     $0xe,%eax
f010ddaa:	a2 7d 53 81 f0       	mov    %al,0xf081537d
f010ddaf:	a0 7d 53 81 f0       	mov    0xf081537d,%al
f010ddb4:	83 e0 ef             	and    $0xffffffef,%eax
f010ddb7:	a2 7d 53 81 f0       	mov    %al,0xf081537d
f010ddbc:	a0 7d 53 81 f0       	mov    0xf081537d,%al
f010ddc1:	83 c8 60             	or     $0x60,%eax
f010ddc4:	a2 7d 53 81 f0       	mov    %al,0xf081537d
f010ddc9:	a0 7d 53 81 f0       	mov    0xf081537d,%al
f010ddce:	83 c8 80             	or     $0xffffff80,%eax
f010ddd1:	a2 7d 53 81 f0       	mov    %al,0xf081537d
f010ddd6:	b8 3a e6 10 f0       	mov    $0xf010e63a,%eax
f010dddb:	c1 e8 10             	shr    $0x10,%eax
f010ddde:	66 a3 7e 53 81 f0    	mov    %ax,0xf081537e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010dde4:	b8 40 e6 10 f0       	mov    $0xf010e640,%eax
f010dde9:	66 a3 80 53 81 f0    	mov    %ax,0xf0815380
f010ddef:	66 c7 05 82 53 81 f0 	movw   $0x8,0xf0815382
f010ddf6:	08 00 
f010ddf8:	a0 84 53 81 f0       	mov    0xf0815384,%al
f010ddfd:	83 e0 e0             	and    $0xffffffe0,%eax
f010de00:	a2 84 53 81 f0       	mov    %al,0xf0815384
f010de05:	a0 84 53 81 f0       	mov    0xf0815384,%al
f010de0a:	83 e0 1f             	and    $0x1f,%eax
f010de0d:	a2 84 53 81 f0       	mov    %al,0xf0815384
f010de12:	a0 85 53 81 f0       	mov    0xf0815385,%al
f010de17:	83 e0 f0             	and    $0xfffffff0,%eax
f010de1a:	83 c8 0e             	or     $0xe,%eax
f010de1d:	a2 85 53 81 f0       	mov    %al,0xf0815385
f010de22:	a0 85 53 81 f0       	mov    0xf0815385,%al
f010de27:	83 e0 ef             	and    $0xffffffef,%eax
f010de2a:	a2 85 53 81 f0       	mov    %al,0xf0815385
f010de2f:	a0 85 53 81 f0       	mov    0xf0815385,%al
f010de34:	83 c8 60             	or     $0x60,%eax
f010de37:	a2 85 53 81 f0       	mov    %al,0xf0815385
f010de3c:	a0 85 53 81 f0       	mov    0xf0815385,%al
f010de41:	83 c8 80             	or     $0xffffff80,%eax
f010de44:	a2 85 53 81 f0       	mov    %al,0xf0815385
f010de49:	b8 40 e6 10 f0       	mov    $0xf010e640,%eax
f010de4e:	c1 e8 10             	shr    $0x10,%eax
f010de51:	66 a3 86 53 81 f0    	mov    %ax,0xf0815386
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010de57:	b8 46 e6 10 f0       	mov    $0xf010e646,%eax
f010de5c:	66 a3 88 53 81 f0    	mov    %ax,0xf0815388
f010de62:	66 c7 05 8a 53 81 f0 	movw   $0x8,0xf081538a
f010de69:	08 00 
f010de6b:	a0 8c 53 81 f0       	mov    0xf081538c,%al
f010de70:	83 e0 e0             	and    $0xffffffe0,%eax
f010de73:	a2 8c 53 81 f0       	mov    %al,0xf081538c
f010de78:	a0 8c 53 81 f0       	mov    0xf081538c,%al
f010de7d:	83 e0 1f             	and    $0x1f,%eax
f010de80:	a2 8c 53 81 f0       	mov    %al,0xf081538c
f010de85:	a0 8d 53 81 f0       	mov    0xf081538d,%al
f010de8a:	83 e0 f0             	and    $0xfffffff0,%eax
f010de8d:	83 c8 0e             	or     $0xe,%eax
f010de90:	a2 8d 53 81 f0       	mov    %al,0xf081538d
f010de95:	a0 8d 53 81 f0       	mov    0xf081538d,%al
f010de9a:	83 e0 ef             	and    $0xffffffef,%eax
f010de9d:	a2 8d 53 81 f0       	mov    %al,0xf081538d
f010dea2:	a0 8d 53 81 f0       	mov    0xf081538d,%al
f010dea7:	83 c8 60             	or     $0x60,%eax
f010deaa:	a2 8d 53 81 f0       	mov    %al,0xf081538d
f010deaf:	a0 8d 53 81 f0       	mov    0xf081538d,%al
f010deb4:	83 c8 80             	or     $0xffffff80,%eax
f010deb7:	a2 8d 53 81 f0       	mov    %al,0xf081538d
f010debc:	b8 46 e6 10 f0       	mov    $0xf010e646,%eax
f010dec1:	c1 e8 10             	shr    $0x10,%eax
f010dec4:	66 a3 8e 53 81 f0    	mov    %ax,0xf081538e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010deca:	b8 4c e6 10 f0       	mov    $0xf010e64c,%eax
f010decf:	66 a3 90 53 81 f0    	mov    %ax,0xf0815390
f010ded5:	66 c7 05 92 53 81 f0 	movw   $0x8,0xf0815392
f010dedc:	08 00 
f010dede:	a0 94 53 81 f0       	mov    0xf0815394,%al
f010dee3:	83 e0 e0             	and    $0xffffffe0,%eax
f010dee6:	a2 94 53 81 f0       	mov    %al,0xf0815394
f010deeb:	a0 94 53 81 f0       	mov    0xf0815394,%al
f010def0:	83 e0 1f             	and    $0x1f,%eax
f010def3:	a2 94 53 81 f0       	mov    %al,0xf0815394
f010def8:	a0 95 53 81 f0       	mov    0xf0815395,%al
f010defd:	83 e0 f0             	and    $0xfffffff0,%eax
f010df00:	83 c8 0e             	or     $0xe,%eax
f010df03:	a2 95 53 81 f0       	mov    %al,0xf0815395
f010df08:	a0 95 53 81 f0       	mov    0xf0815395,%al
f010df0d:	83 e0 ef             	and    $0xffffffef,%eax
f010df10:	a2 95 53 81 f0       	mov    %al,0xf0815395
f010df15:	a0 95 53 81 f0       	mov    0xf0815395,%al
f010df1a:	83 c8 60             	or     $0x60,%eax
f010df1d:	a2 95 53 81 f0       	mov    %al,0xf0815395
f010df22:	a0 95 53 81 f0       	mov    0xf0815395,%al
f010df27:	83 c8 80             	or     $0xffffff80,%eax
f010df2a:	a2 95 53 81 f0       	mov    %al,0xf0815395
f010df2f:	b8 4c e6 10 f0       	mov    $0xf010e64c,%eax
f010df34:	c1 e8 10             	shr    $0x10,%eax
f010df37:	66 a3 96 53 81 f0    	mov    %ax,0xf0815396
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010df3d:	b8 52 e6 10 f0       	mov    $0xf010e652,%eax
f010df42:	66 a3 98 53 81 f0    	mov    %ax,0xf0815398
f010df48:	66 c7 05 9a 53 81 f0 	movw   $0x8,0xf081539a
f010df4f:	08 00 
f010df51:	a0 9c 53 81 f0       	mov    0xf081539c,%al
f010df56:	83 e0 e0             	and    $0xffffffe0,%eax
f010df59:	a2 9c 53 81 f0       	mov    %al,0xf081539c
f010df5e:	a0 9c 53 81 f0       	mov    0xf081539c,%al
f010df63:	83 e0 1f             	and    $0x1f,%eax
f010df66:	a2 9c 53 81 f0       	mov    %al,0xf081539c
f010df6b:	a0 9d 53 81 f0       	mov    0xf081539d,%al
f010df70:	83 e0 f0             	and    $0xfffffff0,%eax
f010df73:	83 c8 0e             	or     $0xe,%eax
f010df76:	a2 9d 53 81 f0       	mov    %al,0xf081539d
f010df7b:	a0 9d 53 81 f0       	mov    0xf081539d,%al
f010df80:	83 e0 ef             	and    $0xffffffef,%eax
f010df83:	a2 9d 53 81 f0       	mov    %al,0xf081539d
f010df88:	a0 9d 53 81 f0       	mov    0xf081539d,%al
f010df8d:	83 c8 60             	or     $0x60,%eax
f010df90:	a2 9d 53 81 f0       	mov    %al,0xf081539d
f010df95:	a0 9d 53 81 f0       	mov    0xf081539d,%al
f010df9a:	83 c8 80             	or     $0xffffff80,%eax
f010df9d:	a2 9d 53 81 f0       	mov    %al,0xf081539d
f010dfa2:	b8 52 e6 10 f0       	mov    $0xf010e652,%eax
f010dfa7:	c1 e8 10             	shr    $0x10,%eax
f010dfaa:	66 a3 9e 53 81 f0    	mov    %ax,0xf081539e
f010dfb0:	c7 45 fc 20 52 81 f0 	movl   $0xf0815220,-0x4(%ebp)
f010dfb7:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010dfbe:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010dfc1:	48                   	dec    %eax
f010dfc2:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010dfc6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010dfc9:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010dfcd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010dfd0:	c1 e8 10             	shr    $0x10,%eax
f010dfd3:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010dfd7:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010dfda:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010dfdd:	90                   	nop
f010dfde:	c9                   	leave  
f010dfdf:	c3                   	ret    

f010dfe0 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010dfe0:	55                   	push   %ebp
f010dfe1:	89 e5                	mov    %esp,%ebp
f010dfe3:	53                   	push   %ebx
f010dfe4:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010dfe7:	83 ec 08             	sub    $0x8,%esp
f010dfea:	ff 75 08             	pushl  0x8(%ebp)
f010dfed:	68 be 08 13 f0       	push   $0xf01308be
f010dff2:	e8 65 3b ff ff       	call   f0101b5c <cprintf>
f010dff7:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010dffa:	8b 45 08             	mov    0x8(%ebp),%eax
f010dffd:	83 ec 0c             	sub    $0xc,%esp
f010e000:	50                   	push   %eax
f010e001:	e8 fd 00 00 00       	call   f010e103 <print_regs>
f010e006:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010e009:	8b 45 08             	mov    0x8(%ebp),%eax
f010e00c:	8b 40 20             	mov    0x20(%eax),%eax
f010e00f:	0f b7 c0             	movzwl %ax,%eax
f010e012:	83 ec 08             	sub    $0x8,%esp
f010e015:	50                   	push   %eax
f010e016:	68 d0 08 13 f0       	push   $0xf01308d0
f010e01b:	e8 3c 3b ff ff       	call   f0101b5c <cprintf>
f010e020:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010e023:	8b 45 08             	mov    0x8(%ebp),%eax
f010e026:	8b 40 24             	mov    0x24(%eax),%eax
f010e029:	0f b7 c0             	movzwl %ax,%eax
f010e02c:	83 ec 08             	sub    $0x8,%esp
f010e02f:	50                   	push   %eax
f010e030:	68 e3 08 13 f0       	push   $0xf01308e3
f010e035:	e8 22 3b ff ff       	call   f0101b5c <cprintf>
f010e03a:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010e03d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e040:	8b 58 28             	mov    0x28(%eax),%ebx
f010e043:	8b 45 08             	mov    0x8(%ebp),%eax
f010e046:	8b 40 28             	mov    0x28(%eax),%eax
f010e049:	83 ec 0c             	sub    $0xc,%esp
f010e04c:	50                   	push   %eax
f010e04d:	e8 28 ee ff ff       	call   f010ce7a <trapname>
f010e052:	83 c4 10             	add    $0x10,%esp
f010e055:	89 c2                	mov    %eax,%edx
f010e057:	8b 45 08             	mov    0x8(%ebp),%eax
f010e05a:	8b 40 28             	mov    0x28(%eax),%eax
f010e05d:	53                   	push   %ebx
f010e05e:	52                   	push   %edx
f010e05f:	50                   	push   %eax
f010e060:	68 f6 08 13 f0       	push   $0xf01308f6
f010e065:	e8 f2 3a ff ff       	call   f0101b5c <cprintf>
f010e06a:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010e06d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e070:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e073:	83 ec 08             	sub    $0x8,%esp
f010e076:	50                   	push   %eax
f010e077:	68 0d 09 13 f0       	push   $0xf013090d
f010e07c:	e8 db 3a ff ff       	call   f0101b5c <cprintf>
f010e081:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010e084:	8b 45 08             	mov    0x8(%ebp),%eax
f010e087:	8b 40 30             	mov    0x30(%eax),%eax
f010e08a:	83 ec 08             	sub    $0x8,%esp
f010e08d:	50                   	push   %eax
f010e08e:	68 1c 09 13 f0       	push   $0xf013091c
f010e093:	e8 c4 3a ff ff       	call   f0101b5c <cprintf>
f010e098:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010e09b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e09e:	8b 40 34             	mov    0x34(%eax),%eax
f010e0a1:	0f b7 c0             	movzwl %ax,%eax
f010e0a4:	83 ec 08             	sub    $0x8,%esp
f010e0a7:	50                   	push   %eax
f010e0a8:	68 2b 09 13 f0       	push   $0xf013092b
f010e0ad:	e8 aa 3a ff ff       	call   f0101b5c <cprintf>
f010e0b2:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010e0b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0b8:	8b 40 38             	mov    0x38(%eax),%eax
f010e0bb:	83 ec 08             	sub    $0x8,%esp
f010e0be:	50                   	push   %eax
f010e0bf:	68 3e 09 13 f0       	push   $0xf013093e
f010e0c4:	e8 93 3a ff ff       	call   f0101b5c <cprintf>
f010e0c9:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010e0cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0cf:	8b 40 3c             	mov    0x3c(%eax),%eax
f010e0d2:	83 ec 08             	sub    $0x8,%esp
f010e0d5:	50                   	push   %eax
f010e0d6:	68 4d 09 13 f0       	push   $0xf013094d
f010e0db:	e8 7c 3a ff ff       	call   f0101b5c <cprintf>
f010e0e0:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010e0e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0e6:	8b 40 40             	mov    0x40(%eax),%eax
f010e0e9:	0f b7 c0             	movzwl %ax,%eax
f010e0ec:	83 ec 08             	sub    $0x8,%esp
f010e0ef:	50                   	push   %eax
f010e0f0:	68 5c 09 13 f0       	push   $0xf013095c
f010e0f5:	e8 62 3a ff ff       	call   f0101b5c <cprintf>
f010e0fa:	83 c4 10             	add    $0x10,%esp
}
f010e0fd:	90                   	nop
f010e0fe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e101:	c9                   	leave  
f010e102:	c3                   	ret    

f010e103 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010e103:	55                   	push   %ebp
f010e104:	89 e5                	mov    %esp,%ebp
f010e106:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010e109:	8b 45 08             	mov    0x8(%ebp),%eax
f010e10c:	8b 00                	mov    (%eax),%eax
f010e10e:	83 ec 08             	sub    $0x8,%esp
f010e111:	50                   	push   %eax
f010e112:	68 6f 09 13 f0       	push   $0xf013096f
f010e117:	e8 40 3a ff ff       	call   f0101b5c <cprintf>
f010e11c:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010e11f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e122:	8b 40 04             	mov    0x4(%eax),%eax
f010e125:	83 ec 08             	sub    $0x8,%esp
f010e128:	50                   	push   %eax
f010e129:	68 7e 09 13 f0       	push   $0xf013097e
f010e12e:	e8 29 3a ff ff       	call   f0101b5c <cprintf>
f010e133:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010e136:	8b 45 08             	mov    0x8(%ebp),%eax
f010e139:	8b 40 08             	mov    0x8(%eax),%eax
f010e13c:	83 ec 08             	sub    $0x8,%esp
f010e13f:	50                   	push   %eax
f010e140:	68 8d 09 13 f0       	push   $0xf013098d
f010e145:	e8 12 3a ff ff       	call   f0101b5c <cprintf>
f010e14a:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010e14d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e150:	8b 40 0c             	mov    0xc(%eax),%eax
f010e153:	83 ec 08             	sub    $0x8,%esp
f010e156:	50                   	push   %eax
f010e157:	68 9c 09 13 f0       	push   $0xf013099c
f010e15c:	e8 fb 39 ff ff       	call   f0101b5c <cprintf>
f010e161:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010e164:	8b 45 08             	mov    0x8(%ebp),%eax
f010e167:	8b 40 10             	mov    0x10(%eax),%eax
f010e16a:	83 ec 08             	sub    $0x8,%esp
f010e16d:	50                   	push   %eax
f010e16e:	68 ab 09 13 f0       	push   $0xf01309ab
f010e173:	e8 e4 39 ff ff       	call   f0101b5c <cprintf>
f010e178:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010e17b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e17e:	8b 40 14             	mov    0x14(%eax),%eax
f010e181:	83 ec 08             	sub    $0x8,%esp
f010e184:	50                   	push   %eax
f010e185:	68 ba 09 13 f0       	push   $0xf01309ba
f010e18a:	e8 cd 39 ff ff       	call   f0101b5c <cprintf>
f010e18f:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010e192:	8b 45 08             	mov    0x8(%ebp),%eax
f010e195:	8b 40 18             	mov    0x18(%eax),%eax
f010e198:	83 ec 08             	sub    $0x8,%esp
f010e19b:	50                   	push   %eax
f010e19c:	68 c9 09 13 f0       	push   $0xf01309c9
f010e1a1:	e8 b6 39 ff ff       	call   f0101b5c <cprintf>
f010e1a6:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010e1a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1ac:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e1af:	83 ec 08             	sub    $0x8,%esp
f010e1b2:	50                   	push   %eax
f010e1b3:	68 d8 09 13 f0       	push   $0xf01309d8
f010e1b8:	e8 9f 39 ff ff       	call   f0101b5c <cprintf>
f010e1bd:	83 c4 10             	add    $0x10,%esp
}
f010e1c0:	90                   	nop
f010e1c1:	c9                   	leave  
f010e1c2:	c3                   	ret    

f010e1c3 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010e1c3:	55                   	push   %ebp
f010e1c4:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010e1c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1c9:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e1cc:	89 14 85 20 5a 81 f0 	mov    %edx,-0xf7ea5e0(,%eax,4)
}
f010e1d3:	90                   	nop
f010e1d4:	5d                   	pop    %ebp
f010e1d5:	c3                   	ret    

f010e1d6 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010e1d6:	55                   	push   %ebp
f010e1d7:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010e1d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1dc:	c7 04 85 20 5a 81 f0 	movl   $0x0,-0xf7ea5e0(,%eax,4)
f010e1e3:	00 00 00 00 
}
f010e1e7:	90                   	nop
f010e1e8:	5d                   	pop    %ebp
f010e1e9:	c3                   	ret    

f010e1ea <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010e1ea:	55                   	push   %ebp
f010e1eb:	89 e5                	mov    %esp,%ebp
f010e1ed:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010e1f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1f3:	8b 40 28             	mov    0x28(%eax),%eax
f010e1f6:	83 e8 20             	sub    $0x20,%eax
f010e1f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010e1fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e1ff:	8b 04 85 20 5a 81 f0 	mov    -0xf7ea5e0(,%eax,4),%eax
f010e206:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010e209:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e20d:	74 0e                	je     f010e21d <irq_dispatch+0x33>
	{
		handler(tf);
f010e20f:	83 ec 0c             	sub    $0xc,%esp
f010e212:	ff 75 08             	pushl  0x8(%ebp)
f010e215:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e218:	ff d0                	call   *%eax
f010e21a:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010e21d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e220:	0f b6 c0             	movzbl %al,%eax
f010e223:	83 ec 0c             	sub    $0xc,%esp
f010e226:	50                   	push   %eax
f010e227:	e8 0b 9d ff ff       	call   f0107f37 <pic_sendEOI>
f010e22c:	83 c4 10             	add    $0x10,%esp
}
f010e22f:	90                   	nop
f010e230:	c9                   	leave  
f010e231:	c3                   	ret    

f010e232 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010e232:	55                   	push   %ebp
f010e233:	89 e5                	mov    %esp,%ebp
f010e235:	57                   	push   %edi
f010e236:	56                   	push   %esi
f010e237:	53                   	push   %ebx
f010e238:	83 ec 1c             	sub    $0x1c,%esp
	// Handle processor exceptions.
	// LAB 3: Your code here.

	if(tf->tf_trapno == T_PGFLT)
f010e23b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e23e:	8b 40 28             	mov    0x28(%eax),%eax
f010e241:	83 f8 0e             	cmp    $0xe,%eax
f010e244:	75 51                	jne    f010e297 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010e246:	a0 60 5a 81 f0       	mov    0xf0815a60,%al
f010e24b:	84 c0                	test   %al,%al
f010e24d:	74 1f                	je     f010e26e <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010e24f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e252:	8b 40 30             	mov    0x30(%eax),%eax
f010e255:	89 c2                	mov    %eax,%edx
f010e257:	a0 60 5a 81 f0       	mov    0xf0815a60,%al
f010e25c:	0f b6 c0             	movzbl %al,%eax
f010e25f:	01 d0                	add    %edx,%eax
f010e261:	89 c2                	mov    %eax,%edx
f010e263:	8b 45 08             	mov    0x8(%ebp),%eax
f010e266:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010e269:	e9 0c 01 00 00       	jmp    f010e37a <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010e26e:	83 ec 0c             	sub    $0xc,%esp
f010e271:	6a 01                	push   $0x1
f010e273:	e8 ad 15 00 00       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f010e278:	83 c4 10             	add    $0x10,%esp
f010e27b:	85 c0                	test   %eax,%eax
f010e27d:	74 05                	je     f010e284 <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010e27f:	e8 c5 99 ff ff       	call   f0107c49 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010e284:	83 ec 0c             	sub    $0xc,%esp
f010e287:	ff 75 08             	pushl  0x8(%ebp)
f010e28a:	e8 c2 16 00 00       	call   f010f951 <fault_handler>
f010e28f:	83 c4 10             	add    $0x10,%esp
f010e292:	e9 e3 00 00 00       	jmp    f010e37a <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010e297:	8b 45 08             	mov    0x8(%ebp),%eax
f010e29a:	8b 40 28             	mov    0x28(%eax),%eax
f010e29d:	83 f8 30             	cmp    $0x30,%eax
f010e2a0:	75 6e                	jne    f010e310 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010e2a2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2a5:	8b 40 38             	mov    0x38(%eax),%eax
f010e2a8:	25 00 02 00 00       	and    $0x200,%eax
f010e2ad:	85 c0                	test   %eax,%eax
f010e2af:	74 06                	je     f010e2b7 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010e2b1:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010e2b2:	e8 8c 79 ff ff       	call   f0105c43 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010e2b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2ba:	8b 78 04             	mov    0x4(%eax),%edi
f010e2bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2c0:	8b 30                	mov    (%eax),%esi
f010e2c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2c5:	8b 58 10             	mov    0x10(%eax),%ebx
f010e2c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2cb:	8b 48 18             	mov    0x18(%eax),%ecx
f010e2ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2d1:	8b 50 14             	mov    0x14(%eax),%edx
f010e2d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2d7:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e2da:	83 ec 08             	sub    $0x8,%esp
f010e2dd:	57                   	push   %edi
f010e2de:	56                   	push   %esi
f010e2df:	53                   	push   %ebx
f010e2e0:	51                   	push   %ecx
f010e2e1:	52                   	push   %edx
f010e2e2:	50                   	push   %eax
f010e2e3:	e8 9c 0c 00 00       	call   f010ef84 <syscall>
f010e2e8:	83 c4 20             	add    $0x20,%esp
f010e2eb:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010e2ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2f1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e2f4:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e2f7:	9c                   	pushf  
f010e2f8:	58                   	pop    %eax
f010e2f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010e2fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010e2ff:	25 00 02 00 00       	and    $0x200,%eax
f010e304:	85 c0                	test   %eax,%eax
f010e306:	74 72                	je     f010e37a <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010e308:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010e309:	e8 0d 79 ff ff       	call   f0105c1b <kclock_stop>
f010e30e:	eb 6a                	jmp    f010e37a <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010e310:	8b 45 08             	mov    0x8(%ebp),%eax
f010e313:	8b 40 28             	mov    0x28(%eax),%eax
f010e316:	83 f8 08             	cmp    $0x8,%eax
f010e319:	75 17                	jne    f010e332 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010e31b:	83 ec 04             	sub    $0x4,%esp
f010e31e:	68 e7 09 13 f0       	push   $0xf01309e7
f010e323:	68 29 01 00 00       	push   $0x129
f010e328:	68 f6 09 13 f0       	push   $0xf01309f6
f010e32d:	e8 7d 2b ff ff       	call   f0100eaf <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010e332:	83 ec 0c             	sub    $0xc,%esp
f010e335:	ff 75 08             	pushl  0x8(%ebp)
f010e338:	e8 a3 fc ff ff       	call   f010dfe0 <print_trapframe>
f010e33d:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010e340:	8b 45 08             	mov    0x8(%ebp),%eax
f010e343:	8b 40 34             	mov    0x34(%eax),%eax
f010e346:	66 83 f8 08          	cmp    $0x8,%ax
f010e34a:	75 17                	jne    f010e363 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010e34c:	83 ec 04             	sub    $0x4,%esp
f010e34f:	68 07 0a 13 f0       	push   $0xf0130a07
f010e354:	68 31 01 00 00       	push   $0x131
f010e359:	68 f6 09 13 f0       	push   $0xf01309f6
f010e35e:	e8 4c 2b ff ff       	call   f0100eaf <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010e363:	83 ec 04             	sub    $0x4,%esp
f010e366:	68 20 0a 13 f0       	push   $0xf0130a20
f010e36b:	68 36 01 00 00       	push   $0x136
f010e370:	68 f6 09 13 f0       	push   $0xf01309f6
f010e375:	e8 35 2b ff ff       	call   f0100eaf <_panic>
		}
	}
}
f010e37a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e37d:	5b                   	pop    %ebx
f010e37e:	5e                   	pop    %esi
f010e37f:	5f                   	pop    %edi
f010e380:	5d                   	pop    %ebp
f010e381:	c3                   	ret    

f010e382 <trap>:

void trap(struct Trapframe *tf)
{
f010e382:	55                   	push   %ebp
f010e383:	89 e5                	mov    %esp,%ebp
f010e385:	57                   	push   %edi
f010e386:	56                   	push   %esi
f010e387:	53                   	push   %ebx
f010e388:	83 ec 3c             	sub    $0x3c,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010e38b:	e8 8b 78 ff ff       	call   f0105c1b <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e390:	9c                   	pushf  
f010e391:	58                   	pop    %eax
f010e392:	89 45 c8             	mov    %eax,-0x38(%ebp)
        return eflags;
f010e395:	8b 45 c8             	mov    -0x38(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010e398:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (flags & FL_IF)
f010e39b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e39e:	25 00 02 00 00       	and    $0x200,%eax
f010e3a3:	85 c0                	test   %eax,%eax
f010e3a5:	74 25                	je     f010e3cc <trap+0x4a>
	{
		print_trapframe(tf);
f010e3a7:	83 ec 0c             	sub    $0xc,%esp
f010e3aa:	ff 75 08             	pushl  0x8(%ebp)
f010e3ad:	e8 2e fc ff ff       	call   f010dfe0 <print_trapframe>
f010e3b2:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010e3b5:	83 ec 04             	sub    $0x4,%esp
f010e3b8:	68 40 0a 13 f0       	push   $0xf0130a40
f010e3bd:	68 4c 01 00 00       	push   $0x14c
f010e3c2:	68 f6 09 13 f0       	push   $0xf01309f6
f010e3c7:	e8 e3 2a ff ff       	call   f0100eaf <_panic>
	}

	int userTrap = 0;
f010e3cc:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010e3d3:	e8 43 d6 ff ff       	call   f010ba1b <get_cpu_proc>
f010e3d8:	89 45 d8             	mov    %eax,-0x28(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010e3db:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3de:	8b 40 34             	mov    0x34(%eax),%eax
f010e3e1:	0f b7 c0             	movzwl %ax,%eax
f010e3e4:	83 e0 03             	and    $0x3,%eax
f010e3e7:	83 f8 03             	cmp    $0x3,%eax
f010e3ea:	0f 85 03 01 00 00    	jne    f010e4f3 <trap+0x171>
	{
		userTrap = 1;
f010e3f0:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010e3f7:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f010e3fb:	74 0b                	je     f010e408 <trap+0x86>
f010e3fd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e400:	8b 40 18             	mov    0x18(%eax),%eax
f010e403:	83 f8 02             	cmp    $0x2,%eax
f010e406:	74 19                	je     f010e421 <trap+0x9f>
f010e408:	68 84 0a 13 f0       	push   $0xf0130a84
f010e40d:	68 b2 0a 13 f0       	push   $0xf0130ab2
f010e412:	68 55 01 00 00       	push   $0x155
f010e417:	68 f6 09 13 f0       	push   $0xf01309f6
f010e41c:	e8 8e 2a ff ff       	call   f0100eaf <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		//assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
		if (cur_env->env_tf != tf)
f010e421:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e424:	8b 00                	mov    (%eax),%eax
f010e426:	3b 45 08             	cmp    0x8(%ebp),%eax
f010e429:	0f 84 c4 00 00 00    	je     f010e4f3 <trap+0x171>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e42f:	9c                   	pushf  
f010e430:	58                   	pop    %eax
f010e431:	89 45 d0             	mov    %eax,-0x30(%ebp)
        return eflags;
f010e434:	8b 45 d0             	mov    -0x30(%ebp),%eax
		{
			cprintf("\n[%s - %d] trap #%d - %s (cr2 = %x) tf va = %x - eip = %x - IEN = %d\n", userTrap == 1? "USER" : "KERNEL", userTrap == 1? cur_env->env_id : 0, tf->tf_trapno, trapname(tf->tf_trapno), rcr2(), tf, tf->tf_eip, (read_eflags() & FL_IF) == 0? 0 : 1);
f010e437:	25 00 02 00 00       	and    $0x200,%eax
f010e43c:	85 c0                	test   %eax,%eax
f010e43e:	0f 95 c0             	setne  %al
f010e441:	0f b6 c0             	movzbl %al,%eax
f010e444:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010e447:	8b 45 08             	mov    0x8(%ebp),%eax
f010e44a:	8b 78 30             	mov    0x30(%eax),%edi

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e44d:	0f 20 d0             	mov    %cr2,%eax
f010e450:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return val;
f010e453:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f010e456:	8b 45 08             	mov    0x8(%ebp),%eax
f010e459:	8b 40 28             	mov    0x28(%eax),%eax
f010e45c:	83 ec 0c             	sub    $0xc,%esp
f010e45f:	50                   	push   %eax
f010e460:	e8 15 ea ff ff       	call   f010ce7a <trapname>
f010e465:	83 c4 10             	add    $0x10,%esp
f010e468:	89 c3                	mov    %eax,%ebx
f010e46a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e46d:	8b 48 28             	mov    0x28(%eax),%ecx
f010e470:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f010e474:	75 08                	jne    f010e47e <trap+0xfc>
f010e476:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e479:	8b 40 10             	mov    0x10(%eax),%eax
f010e47c:	eb 05                	jmp    f010e483 <trap+0x101>
f010e47e:	b8 00 00 00 00       	mov    $0x0,%eax
f010e483:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f010e487:	75 07                	jne    f010e490 <trap+0x10e>
f010e489:	ba c7 0a 13 f0       	mov    $0xf0130ac7,%edx
f010e48e:	eb 05                	jmp    f010e495 <trap+0x113>
f010e490:	ba cc 0a 13 f0       	mov    $0xf0130acc,%edx
f010e495:	83 ec 0c             	sub    $0xc,%esp
f010e498:	ff 75 c4             	pushl  -0x3c(%ebp)
f010e49b:	57                   	push   %edi
f010e49c:	ff 75 08             	pushl  0x8(%ebp)
f010e49f:	56                   	push   %esi
f010e4a0:	53                   	push   %ebx
f010e4a1:	51                   	push   %ecx
f010e4a2:	50                   	push   %eax
f010e4a3:	52                   	push   %edx
f010e4a4:	68 d4 0a 13 f0       	push   $0xf0130ad4
f010e4a9:	e8 ae 36 ff ff       	call   f0101b5c <cprintf>
f010e4ae:	83 c4 30             	add    $0x30,%esp
			panic("USER TRAP [%d:%s]: unexpected trapframe! cur_env->env_tf (%x) != tf (%x). Kernel stack [%x, %x)",
f010e4b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4b4:	8b 40 70             	mov    0x70(%eax),%eax
f010e4b7:	8d b0 00 80 00 00    	lea    0x8000(%eax),%esi
f010e4bd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4c0:	8b 48 70             	mov    0x70(%eax),%ecx
f010e4c3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4c6:	8b 10                	mov    (%eax),%edx
f010e4c8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4cb:	8d 58 20             	lea    0x20(%eax),%ebx
f010e4ce:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4d1:	8b 40 10             	mov    0x10(%eax),%eax
f010e4d4:	83 ec 0c             	sub    $0xc,%esp
f010e4d7:	56                   	push   %esi
f010e4d8:	51                   	push   %ecx
f010e4d9:	ff 75 08             	pushl  0x8(%ebp)
f010e4dc:	52                   	push   %edx
f010e4dd:	53                   	push   %ebx
f010e4de:	50                   	push   %eax
f010e4df:	68 1c 0b 13 f0       	push   $0xf0130b1c
f010e4e4:	68 5c 01 00 00       	push   $0x15c
f010e4e9:	68 f6 09 13 f0       	push   $0xf01309f6
f010e4ee:	e8 bc 29 ff ff       	call   f0100eaf <_panic>
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010e4f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4f6:	8b 40 28             	mov    0x28(%eax),%eax
f010e4f9:	83 f8 1f             	cmp    $0x1f,%eax
f010e4fc:	76 1b                	jbe    f010e519 <trap+0x197>
f010e4fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010e501:	8b 40 28             	mov    0x28(%eax),%eax
f010e504:	83 f8 2f             	cmp    $0x2f,%eax
f010e507:	77 10                	ja     f010e519 <trap+0x197>
	{
		irq_dispatch(tf);
f010e509:	83 ec 0c             	sub    $0xc,%esp
f010e50c:	ff 75 08             	pushl  0x8(%ebp)
f010e50f:	e8 d6 fc ff ff       	call   f010e1ea <irq_dispatch>
f010e514:	83 c4 10             	add    $0x10,%esp
f010e517:	eb 0e                	jmp    f010e527 <trap+0x1a5>
	}
	else
	{
		trap_dispatch(tf);
f010e519:	83 ec 0c             	sub    $0xc,%esp
f010e51c:	ff 75 08             	pushl  0x8(%ebp)
f010e51f:	e8 0e fd ff ff       	call   f010e232 <trap_dispatch>
f010e524:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e527:	9c                   	pushf  
f010e528:	58                   	pop    %eax
f010e529:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        return eflags;
f010e52c:	8b 45 d4             	mov    -0x2c(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010e52f:	25 00 02 00 00       	and    $0x200,%eax
f010e534:	89 45 cc             	mov    %eax,-0x34(%ebp)
	assert(IEN == 0);
f010e537:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010e53b:	74 19                	je     f010e556 <trap+0x1d4>
f010e53d:	68 7c 0b 13 f0       	push   $0xf0130b7c
f010e542:	68 b2 0a 13 f0       	push   $0xf0130ab2
f010e547:	68 73 01 00 00       	push   $0x173
f010e54c:	68 f6 09 13 f0       	push   $0xf01309f6
f010e551:	e8 59 29 ff ff       	call   f0100eaf <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010e556:	e8 e8 76 ff ff       	call   f0105c43 <kclock_resume>
	//cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010e55b:	90                   	nop
f010e55c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e55f:	5b                   	pop    %ebx
f010e560:	5e                   	pop    %esi
f010e561:	5f                   	pop    %edi
f010e562:	5d                   	pop    %ebp
f010e563:	c3                   	ret    

f010e564 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010e564:	6a 08                	push   $0x8
f010e566:	e9 ed 00 00 00       	jmp    f010e658 <_alltraps>
f010e56b:	90                   	nop

f010e56c <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010e56c:	6a 0e                	push   $0xe
f010e56e:	e9 e5 00 00 00       	jmp    f010e658 <_alltraps>
f010e573:	90                   	nop

f010e574 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010e574:	6a 00                	push   $0x0
f010e576:	6a 20                	push   $0x20
f010e578:	e9 db 00 00 00       	jmp    f010e658 <_alltraps>
f010e57d:	90                   	nop

f010e57e <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010e57e:	6a 00                	push   $0x0
f010e580:	6a 21                	push   $0x21
f010e582:	e9 d1 00 00 00       	jmp    f010e658 <_alltraps>
f010e587:	90                   	nop

f010e588 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010e588:	6a 00                	push   $0x0
f010e58a:	6a 30                	push   $0x30
f010e58c:	e9 c7 00 00 00       	jmp    f010e658 <_alltraps>
f010e591:	90                   	nop

f010e592 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010e592:	6a 00                	push   $0x0
f010e594:	6a 00                	push   $0x0
f010e596:	e9 bd 00 00 00       	jmp    f010e658 <_alltraps>
f010e59b:	90                   	nop

f010e59c <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010e59c:	6a 00                	push   $0x0
f010e59e:	6a 01                	push   $0x1
f010e5a0:	e9 b3 00 00 00       	jmp    f010e658 <_alltraps>
f010e5a5:	90                   	nop

f010e5a6 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010e5a6:	6a 00                	push   $0x0
f010e5a8:	6a 02                	push   $0x2
f010e5aa:	e9 a9 00 00 00       	jmp    f010e658 <_alltraps>
f010e5af:	90                   	nop

f010e5b0 <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010e5b0:	6a 00                	push   $0x0
f010e5b2:	6a 03                	push   $0x3
f010e5b4:	e9 9f 00 00 00       	jmp    f010e658 <_alltraps>
f010e5b9:	90                   	nop

f010e5ba <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010e5ba:	6a 00                	push   $0x0
f010e5bc:	6a 04                	push   $0x4
f010e5be:	e9 95 00 00 00       	jmp    f010e658 <_alltraps>
f010e5c3:	90                   	nop

f010e5c4 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010e5c4:	6a 00                	push   $0x0
f010e5c6:	6a 05                	push   $0x5
f010e5c8:	e9 8b 00 00 00       	jmp    f010e658 <_alltraps>
f010e5cd:	90                   	nop

f010e5ce <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010e5ce:	6a 00                	push   $0x0
f010e5d0:	6a 06                	push   $0x6
f010e5d2:	e9 81 00 00 00       	jmp    f010e658 <_alltraps>
f010e5d7:	90                   	nop

f010e5d8 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010e5d8:	6a 00                	push   $0x0
f010e5da:	6a 07                	push   $0x7
f010e5dc:	eb 7a                	jmp    f010e658 <_alltraps>

f010e5de <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010e5de:	6a 0a                	push   $0xa
f010e5e0:	eb 76                	jmp    f010e658 <_alltraps>

f010e5e2 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010e5e2:	6a 0b                	push   $0xb
f010e5e4:	eb 72                	jmp    f010e658 <_alltraps>

f010e5e6 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010e5e6:	6a 0c                	push   $0xc
f010e5e8:	eb 6e                	jmp    f010e658 <_alltraps>

f010e5ea <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010e5ea:	6a 0d                	push   $0xd
f010e5ec:	eb 6a                	jmp    f010e658 <_alltraps>

f010e5ee <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010e5ee:	6a 00                	push   $0x0
f010e5f0:	6a 10                	push   $0x10
f010e5f2:	eb 64                	jmp    f010e658 <_alltraps>

f010e5f4 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010e5f4:	6a 11                	push   $0x11
f010e5f6:	eb 60                	jmp    f010e658 <_alltraps>

f010e5f8 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010e5f8:	6a 00                	push   $0x0
f010e5fa:	6a 12                	push   $0x12
f010e5fc:	eb 5a                	jmp    f010e658 <_alltraps>

f010e5fe <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010e5fe:	6a 00                	push   $0x0
f010e600:	6a 13                	push   $0x13
f010e602:	eb 54                	jmp    f010e658 <_alltraps>

f010e604 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010e604:	6a 00                	push   $0x0
f010e606:	6a 22                	push   $0x22
f010e608:	eb 4e                	jmp    f010e658 <_alltraps>

f010e60a <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010e60a:	6a 00                	push   $0x0
f010e60c:	6a 23                	push   $0x23
f010e60e:	eb 48                	jmp    f010e658 <_alltraps>

f010e610 <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010e610:	6a 00                	push   $0x0
f010e612:	6a 24                	push   $0x24
f010e614:	eb 42                	jmp    f010e658 <_alltraps>

f010e616 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010e616:	6a 00                	push   $0x0
f010e618:	6a 25                	push   $0x25
f010e61a:	eb 3c                	jmp    f010e658 <_alltraps>

f010e61c <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010e61c:	6a 00                	push   $0x0
f010e61e:	6a 26                	push   $0x26
f010e620:	eb 36                	jmp    f010e658 <_alltraps>

f010e622 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010e622:	6a 00                	push   $0x0
f010e624:	6a 27                	push   $0x27
f010e626:	eb 30                	jmp    f010e658 <_alltraps>

f010e628 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010e628:	6a 00                	push   $0x0
f010e62a:	6a 28                	push   $0x28
f010e62c:	eb 2a                	jmp    f010e658 <_alltraps>

f010e62e <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010e62e:	6a 00                	push   $0x0
f010e630:	6a 29                	push   $0x29
f010e632:	eb 24                	jmp    f010e658 <_alltraps>

f010e634 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010e634:	6a 00                	push   $0x0
f010e636:	6a 2a                	push   $0x2a
f010e638:	eb 1e                	jmp    f010e658 <_alltraps>

f010e63a <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010e63a:	6a 00                	push   $0x0
f010e63c:	6a 2b                	push   $0x2b
f010e63e:	eb 18                	jmp    f010e658 <_alltraps>

f010e640 <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010e640:	6a 00                	push   $0x0
f010e642:	6a 2c                	push   $0x2c
f010e644:	eb 12                	jmp    f010e658 <_alltraps>

f010e646 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010e646:	6a 00                	push   $0x0
f010e648:	6a 2d                	push   $0x2d
f010e64a:	eb 0c                	jmp    f010e658 <_alltraps>

f010e64c <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010e64c:	6a 00                	push   $0x0
f010e64e:	6a 2e                	push   $0x2e
f010e650:	eb 06                	jmp    f010e658 <_alltraps>

f010e652 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010e652:	6a 00                	push   $0x0
f010e654:	6a 2f                	push   $0x2f
f010e656:	eb 00                	jmp    f010e658 <_alltraps>

f010e658 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010e658:	1e                   	push   %ds
push 	%es
f010e659:	06                   	push   %es
pushal
f010e65a:	60                   	pusha  

mov 	$(GD_KD), %ax
f010e65b:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010e65f:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010e661:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010e663:	54                   	push   %esp
call 	trap
f010e664:	e8 19 fd ff ff       	call   f010e382 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010e669:	59                   	pop    %ecx

f010e66a <trapret>:
.globl trapret
trapret:
popal
f010e66a:	61                   	popa   
pop 	%es
f010e66b:	07                   	pop    %es
pop 	%ds
f010e66c:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010e66d:	83 c4 08             	add    $0x8,%esp
iret
f010e670:	cf                   	iret   

f010e671 <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName, int color)
{
f010e671:	55                   	push   %ebp
f010e672:	89 e5                	mov    %esp,%ebp
f010e674:	83 ec 28             	sub    $0x28,%esp
f010e677:	8b 45 10             	mov    0x10(%ebp),%eax
f010e67a:	88 45 e4             	mov    %al,-0x1c(%ebp)
	struct Env* cur_env = get_cpu_proc();
f010e67d:	e8 99 d3 ff ff       	call   f010ba1b <get_cpu_proc>
f010e682:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010e685:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e689:	75 16                	jne    f010e6a1 <sys_cputs+0x30>
f010e68b:	68 30 0d 13 f0       	push   $0xf0130d30
f010e690:	68 40 0d 13 f0       	push   $0xf0130d40
f010e695:	6a 22                	push   $0x22
f010e697:	68 55 0d 13 f0       	push   $0xf0130d55
f010e69c:	e8 0e 28 ff ff       	call   f0100eaf <_panic>

	pushcli();	//disable interrupts
f010e6a1:	e8 8d 99 ff ff       	call   f0108033 <pushcli>
	{
		// Check that the user has permission to read memory [s, s+len).
		// Destroy the environment if not.
		current_text_color = color; // setting text color to be used in cga_putc()
f010e6a6:	8b 45 14             	mov    0x14(%ebp),%eax
f010e6a9:	a3 50 61 85 f0       	mov    %eax,0xf0856150
		{
			// Print the string supplied by the user.
			if (printProgName)
f010e6ae:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f010e6b2:	74 1e                	je     f010e6d2 <sys_cputs+0x61>
				cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010e6b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e6b7:	8b 40 10             	mov    0x10(%eax),%eax
f010e6ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e6bd:	83 c2 20             	add    $0x20,%edx
f010e6c0:	83 ec 04             	sub    $0x4,%esp
f010e6c3:	50                   	push   %eax
f010e6c4:	52                   	push   %edx
f010e6c5:	68 69 0d 13 f0       	push   $0xf0130d69
f010e6ca:	e8 8d 34 ff ff       	call   f0101b5c <cprintf>
f010e6cf:	83 c4 10             	add    $0x10,%esp
			cprintf("%.*s",len, s);
f010e6d2:	83 ec 04             	sub    $0x4,%esp
f010e6d5:	ff 75 08             	pushl  0x8(%ebp)
f010e6d8:	ff 75 0c             	pushl  0xc(%ebp)
f010e6db:	68 72 0d 13 f0       	push   $0xf0130d72
f010e6e0:	e8 77 34 ff ff       	call   f0101b5c <cprintf>
f010e6e5:	83 c4 10             	add    $0x10,%esp
		}
		current_text_color = TEXT_DEFAULT_CLR; //restore default text color
f010e6e8:	c7 05 50 61 85 f0 00 	movl   $0x700,0xf0856150
f010e6ef:	07 00 00 
	}
	popcli();	//enable interrupts
f010e6f2:	e8 8e 99 ff ff       	call   f0108085 <popcli>
}
f010e6f7:	90                   	nop
f010e6f8:	c9                   	leave  
f010e6f9:	c3                   	ret    

f010e6fa <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010e6fa:	55                   	push   %ebp
f010e6fb:	89 e5                	mov    %esp,%ebp
f010e6fd:	83 ec 18             	sub    $0x18,%esp
f010e700:	8b 45 08             	mov    0x8(%ebp),%eax
f010e703:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010e706:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010e70a:	83 ec 08             	sub    $0x8,%esp
f010e70d:	50                   	push   %eax
f010e70e:	68 77 0d 13 f0       	push   $0xf0130d77
f010e713:	e8 44 34 ff ff       	call   f0101b5c <cprintf>
f010e718:	83 c4 10             	add    $0x10,%esp
}
f010e71b:	90                   	nop
f010e71c:	c9                   	leave  
f010e71d:	c3                   	ret    

f010e71e <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010e71e:	55                   	push   %ebp
f010e71f:	89 e5                	mov    %esp,%ebp
f010e721:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e724:	9c                   	pushf  
f010e725:	58                   	pop    %eax
f010e726:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010e729:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010e72c:	25 00 02 00 00       	and    $0x200,%eax
f010e731:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010e734:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e738:	74 10                	je     f010e74a <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010e73a:	e8 13 32 ff ff       	call   f0101952 <cons_getc2>
f010e73f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e742:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e746:	74 f2                	je     f010e73a <sys_cgetc+0x1c>
f010e748:	eb 0e                	jmp    f010e758 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010e74a:	e8 a8 31 ff ff       	call   f01018f7 <cons_getc>
f010e74f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e752:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e756:	74 f2                	je     f010e74a <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010e758:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e75b:	c9                   	leave  
f010e75c:	c3                   	ret    

f010e75d <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010e75d:	55                   	push   %ebp
f010e75e:	89 e5                	mov    %esp,%ebp
f010e760:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010e763:	e8 19 33 ff ff       	call   f0101a81 <cons_lock>
}
f010e768:	90                   	nop
f010e769:	c9                   	leave  
f010e76a:	c3                   	ret    

f010e76b <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010e76b:	55                   	push   %ebp
f010e76c:	89 e5                	mov    %esp,%ebp
f010e76e:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010e771:	e8 52 33 ff ff       	call   f0101ac8 <cons_unlock>
}
f010e776:	90                   	nop
f010e777:	c9                   	leave  
f010e778:	c3                   	ret    

f010e779 <__sys_allocate_page>:
//	E_INVAL if va >= USER_TOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010e779:	55                   	push   %ebp
f010e77a:	89 e5                	mov    %esp,%ebp
f010e77c:	83 ec 18             	sub    $0x18,%esp
	//   map_frame() from kern/mem/memory_manager.c.
	//   Most of the new code you write should be to check the
	//   parameters for correctness.
	//   If map_frame() fails, remember to free the page you allocated!

	struct Env* cur_env = get_cpu_proc();
f010e77f:	e8 97 d2 ff ff       	call   f010ba1b <get_cpu_proc>
f010e784:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(cur_env == NULL)
f010e787:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e78b:	75 07                	jne    f010e794 <__sys_allocate_page+0x1b>
		return E_BAD_ENV;
f010e78d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010e792:	eb 5d                	jmp    f010e7f1 <__sys_allocate_page+0x78>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010e794:	8b 45 08             	mov    0x8(%ebp),%eax
f010e797:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010e79c:	77 0c                	ja     f010e7aa <__sys_allocate_page+0x31>
f010e79e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7a1:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e7a6:	85 c0                	test   %eax,%eax
f010e7a8:	74 07                	je     f010e7b1 <__sys_allocate_page+0x38>
		return E_INVAL;
f010e7aa:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e7af:	eb 40                	jmp    f010e7f1 <__sys_allocate_page+0x78>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010e7b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e7b4:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010e7b9:	83 f8 04             	cmp    $0x4,%eax
f010e7bc:	74 07                	je     f010e7c5 <__sys_allocate_page+0x4c>
		return E_INVAL;
f010e7be:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e7c3:	eb 2c                	jmp    f010e7f1 <__sys_allocate_page+0x78>

	int ret = alloc_page(cur_env->env_page_directory, (uint32)va, perm, 1);
f010e7c5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010e7c8:	8b 55 08             	mov    0x8(%ebp),%edx
f010e7cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e7ce:	8b 40 64             	mov    0x64(%eax),%eax
f010e7d1:	6a 01                	push   $0x1
f010e7d3:	51                   	push   %ecx
f010e7d4:	52                   	push   %edx
f010e7d5:	50                   	push   %eax
f010e7d6:	e8 76 b5 ff ff       	call   f0109d51 <alloc_page>
f010e7db:	83 c4 10             	add    $0x10,%esp
f010e7de:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret == E_NO_MEM)
f010e7e1:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e7e5:	75 05                	jne    f010e7ec <__sys_allocate_page+0x73>
		return ret ;
f010e7e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e7ea:	eb 05                	jmp    f010e7f1 <__sys_allocate_page+0x78>

	return 0 ;
f010e7ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e7f1:	c9                   	leave  
f010e7f2:	c3                   	ret    

f010e7f3 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010e7f3:	55                   	push   %ebp
f010e7f4:	89 e5                	mov    %esp,%ebp
f010e7f6:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010e7f9:	83 ec 04             	sub    $0x4,%esp
f010e7fc:	68 7a 0d 13 f0       	push   $0xf0130d7a
f010e801:	68 bb 00 00 00       	push   $0xbb
f010e806:	68 55 0d 13 f0       	push   $0xf0130d55
f010e80b:	e8 9f 26 ff ff       	call   f0100eaf <_panic>

f010e810 <__sys_unmap_frame>:
//
// Return 0 on success, < 0 on error.  Errors are:
//	E_BAD_ENV if environment doesn't currently exist,
//	E_INVAL if va >= USER_TOP, or va is not page-aligned.
static int __sys_unmap_frame(uint32 va)
{
f010e810:	55                   	push   %ebp
f010e811:	89 e5                	mov    %esp,%ebp
f010e813:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010e816:	e8 00 d2 ff ff       	call   f010ba1b <get_cpu_proc>
f010e81b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(cur_env == NULL)
f010e81e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e822:	75 07                	jne    f010e82b <__sys_unmap_frame+0x1b>
		return E_BAD_ENV;
f010e824:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010e829:	eb 36                	jmp    f010e861 <__sys_unmap_frame+0x51>

	if (va >= USER_TOP || va % PAGE_SIZE != 0)
f010e82b:	81 7d 08 ff ff bf ee 	cmpl   $0xeebfffff,0x8(%ebp)
f010e832:	77 0c                	ja     f010e840 <__sys_unmap_frame+0x30>
f010e834:	8b 45 08             	mov    0x8(%ebp),%eax
f010e837:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e83c:	85 c0                	test   %eax,%eax
f010e83e:	74 07                	je     f010e847 <__sys_unmap_frame+0x37>
		return E_INVAL;
f010e840:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e845:	eb 1a                	jmp    f010e861 <__sys_unmap_frame+0x51>

	unmap_frame(cur_env->env_page_directory, va);
f010e847:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e84a:	8b 40 64             	mov    0x64(%eax),%eax
f010e84d:	83 ec 08             	sub    $0x8,%esp
f010e850:	ff 75 08             	pushl  0x8(%ebp)
f010e853:	50                   	push   %eax
f010e854:	e8 f9 ad ff ff       	call   f0109652 <unmap_frame>
f010e859:	83 c4 10             	add    $0x10,%esp
	return 0;
f010e85c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e861:	c9                   	leave  
f010e862:	c3                   	ret    

f010e863 <sys_calculate_required_frames>:

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010e863:	55                   	push   %ebp
f010e864:	89 e5                	mov    %esp,%ebp
f010e866:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010e869:	e8 ad d1 ff ff       	call   f010ba1b <get_cpu_proc>
f010e86e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010e871:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e875:	75 19                	jne    f010e890 <sys_calculate_required_frames+0x2d>
f010e877:	68 30 0d 13 f0       	push   $0xf0130d30
f010e87c:	68 40 0d 13 f0       	push   $0xf0130d40
f010e881:	68 d6 00 00 00       	push   $0xd6
f010e886:	68 55 0d 13 f0       	push   $0xf0130d55
f010e88b:	e8 1f 26 ff ff       	call   f0100eaf <_panic>

	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010e890:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e893:	8b 40 64             	mov    0x64(%eax),%eax
f010e896:	83 ec 04             	sub    $0x4,%esp
f010e899:	ff 75 0c             	pushl  0xc(%ebp)
f010e89c:	ff 75 08             	pushl  0x8(%ebp)
f010e89f:	50                   	push   %eax
f010e8a0:	e8 79 c3 ff ff       	call   f010ac1e <calculate_required_frames>
f010e8a5:	83 c4 10             	add    $0x10,%esp
}
f010e8a8:	c9                   	leave  
f010e8a9:	c3                   	ret    

f010e8aa <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010e8aa:	55                   	push   %ebp
f010e8ab:	89 e5                	mov    %esp,%ebp
f010e8ad:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e8b0:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e8b3:	83 ec 0c             	sub    $0xc,%esp
f010e8b6:	50                   	push   %eax
f010e8b7:	e8 18 af ff ff       	call   f01097d4 <calculate_available_frames>
f010e8bc:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010e8bf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e8c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e8c5:	01 d0                	add    %edx,%eax
}
f010e8c7:	c9                   	leave  
f010e8c8:	c3                   	ret    

f010e8c9 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010e8c9:	55                   	push   %ebp
f010e8ca:	89 e5                	mov    %esp,%ebp
f010e8cc:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e8cf:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e8d2:	83 ec 0c             	sub    $0xc,%esp
f010e8d5:	50                   	push   %eax
f010e8d6:	e8 f9 ae ff ff       	call   f01097d4 <calculate_available_frames>
f010e8db:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010e8de:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e8e1:	c9                   	leave  
f010e8e2:	c3                   	ret    

f010e8e3 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010e8e3:	55                   	push   %ebp
f010e8e4:	89 e5                	mov    %esp,%ebp
f010e8e6:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e8e9:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e8ec:	83 ec 0c             	sub    $0xc,%esp
f010e8ef:	50                   	push   %eax
f010e8f0:	e8 df ae ff ff       	call   f01097d4 <calculate_available_frames>
f010e8f5:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010e8f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010e8fb:	c9                   	leave  
f010e8fc:	c3                   	ret    

f010e8fd <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010e8fd:	55                   	push   %ebp
f010e8fe:	89 e5                	mov    %esp,%ebp
f010e900:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010e903:	83 ec 0c             	sub    $0xc,%esp
f010e906:	ff 75 08             	pushl  0x8(%ebp)
f010e909:	e8 5e ae 00 00       	call   f011976c <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010e90e:	83 c4 10             	add    $0x10,%esp
}
f010e911:	c9                   	leave  
f010e912:	c3                   	ret    

f010e913 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010e913:	55                   	push   %ebp
f010e914:	89 e5                	mov    %esp,%ebp
f010e916:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010e919:	e8 79 ad 00 00       	call   f0119697 <scarce_memory>
}
f010e91e:	90                   	nop
f010e91f:	c9                   	leave  
f010e920:	c3                   	ret    

f010e921 <sys_clearFFL>:

void sys_clearFFL()
{
f010e921:	55                   	push   %ebp
f010e922:	89 e5                	mov    %esp,%ebp
f010e924:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_kspinlock(&MemFrameLists.mfllock);
f010e927:	83 ec 0c             	sub    $0xc,%esp
f010e92a:	68 40 de 83 f0       	push   $0xf083de40
f010e92f:	e8 49 14 00 00       	call   f010fd7d <acquire_kspinlock>
f010e934:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010e937:	a1 2c de 83 f0       	mov    0xf083de2c,%eax
f010e93c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e93f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010e946:	eb 12                	jmp    f010e95a <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010e948:	83 ec 0c             	sub    $0xc,%esp
f010e94b:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e94e:	50                   	push   %eax
f010e94f:	e8 f1 a6 ff ff       	call   f0109045 <allocate_frame>
f010e954:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_kspinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e957:	ff 45 f4             	incl   -0xc(%ebp)
f010e95a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e95d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010e960:	7c e6                	jl     f010e948 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_kspinlock(&MemFrameLists.mfllock);
f010e962:	83 ec 0c             	sub    $0xc,%esp
f010e965:	68 40 de 83 f0       	push   $0xf083de40
f010e96a:	e8 b3 14 00 00       	call   f010fe22 <release_kspinlock>
f010e96f:	83 c4 10             	add    $0x10,%esp
}
f010e972:	90                   	nop
f010e973:	c9                   	leave  
f010e974:	c3                   	ret    

f010e975 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010e975:	55                   	push   %ebp
f010e976:	89 e5                	mov    %esp,%ebp
f010e978:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010e97b:	e8 9b d0 ff ff       	call   f010ba1b <get_cpu_proc>
f010e980:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010e983:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e987:	75 19                	jne    f010e9a2 <sys_pf_calculate_allocated_pages+0x2d>
f010e989:	68 30 0d 13 f0       	push   $0xf0130d30
f010e98e:	68 40 0d 13 f0       	push   $0xf0130d40
f010e993:	68 0e 01 00 00       	push   $0x10e
f010e998:	68 55 0d 13 f0       	push   $0xf0130d55
f010e99d:	e8 0d 25 ff ff       	call   f0100eaf <_panic>

	return pf_calculate_allocated_pages(cur_env);
f010e9a2:	83 ec 0c             	sub    $0xc,%esp
f010e9a5:	ff 75 f4             	pushl  -0xc(%ebp)
f010e9a8:	e8 dc 6d ff ff       	call   f0105789 <pf_calculate_allocated_pages>
f010e9ad:	83 c4 10             	add    $0x10,%esp
}
f010e9b0:	c9                   	leave  
f010e9b1:	c3                   	ret    

f010e9b2 <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010e9b2:	55                   	push   %ebp
f010e9b3:	89 e5                	mov    %esp,%ebp
f010e9b5:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010e9b8:	e8 5e d0 ff ff       	call   f010ba1b <get_cpu_proc>
f010e9bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010e9c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e9c4:	75 19                	jne    f010e9df <sys_free_user_mem+0x2d>
f010e9c6:	68 30 0d 13 f0       	push   $0xf0130d30
f010e9cb:	68 40 0d 13 f0       	push   $0xf0130d40
f010e9d0:	68 19 01 00 00       	push   $0x119
f010e9d5:	68 55 0d 13 f0       	push   $0xf0130d55
f010e9da:	e8 d0 24 ff ff       	call   f0100eaf <_panic>

	if (virtual_address == 0 || (virtual_address >= USER_HEAP_MAX) || (virtual_address < USER_HEAP_START)
f010e9df:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e9e3:	74 2b                	je     f010ea10 <sys_free_user_mem+0x5e>
f010e9e5:	81 7d 08 ff ff ff 9f 	cmpl   $0x9fffffff,0x8(%ebp)
f010e9ec:	77 22                	ja     f010ea10 <sys_free_user_mem+0x5e>
f010e9ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9f1:	85 c0                	test   %eax,%eax
f010e9f3:	79 1b                	jns    f010ea10 <sys_free_user_mem+0x5e>
		|| (virtual_address + size >= USER_HEAP_MAX) || (virtual_address + size < USER_HEAP_START))
f010e9f5:	8b 55 08             	mov    0x8(%ebp),%edx
f010e9f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e9fb:	01 d0                	add    %edx,%eax
f010e9fd:	3d ff ff ff 9f       	cmp    $0x9fffffff,%eax
f010ea02:	77 0c                	ja     f010ea10 <sys_free_user_mem+0x5e>
f010ea04:	8b 55 08             	mov    0x8(%ebp),%edx
f010ea07:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ea0a:	01 d0                	add    %edx,%eax
f010ea0c:	85 c0                	test   %eax,%eax
f010ea0e:	78 15                	js     f010ea25 <sys_free_user_mem+0x73>
	{
		cprintf("\nsys_free_user_mem(): ILLEGAL ADDRESS! Process will be terminated...\n");
f010ea10:	83 ec 0c             	sub    $0xc,%esp
f010ea13:	68 98 0d 13 f0       	push   $0xf0130d98
f010ea18:	e8 3f 31 ff ff       	call   f0101b5c <cprintf>
f010ea1d:	83 c4 10             	add    $0x10,%esp
		env_exit();
f010ea20:	e8 b4 cf ff ff       	call   f010b9d9 <env_exit>
	}

	if(isBufferingEnabled())
f010ea25:	e8 d9 0e 00 00       	call   f010f903 <isBufferingEnabled>
f010ea2a:	84 c0                	test   %al,%al
f010ea2c:	74 16                	je     f010ea44 <sys_free_user_mem+0x92>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010ea2e:	83 ec 04             	sub    $0x4,%esp
f010ea31:	ff 75 0c             	pushl  0xc(%ebp)
f010ea34:	ff 75 08             	pushl  0x8(%ebp)
f010ea37:	ff 75 f4             	pushl  -0xc(%ebp)
f010ea3a:	e8 50 c2 ff ff       	call   f010ac8f <__free_user_mem_with_buffering>
f010ea3f:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010ea42:	eb 15                	jmp    f010ea59 <sys_free_user_mem+0xa7>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010ea44:	83 ec 04             	sub    $0x4,%esp
f010ea47:	ff 75 0c             	pushl  0xc(%ebp)
f010ea4a:	ff 75 08             	pushl  0x8(%ebp)
f010ea4d:	ff 75 f4             	pushl  -0xc(%ebp)
f010ea50:	e8 1d c2 ff ff       	call   f010ac72 <free_user_mem>
f010ea55:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010ea58:	90                   	nop
}
f010ea59:	c9                   	leave  
f010ea5a:	c3                   	ret    

f010ea5b <sys_allocate_user_mem>:

void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010ea5b:	55                   	push   %ebp
f010ea5c:	89 e5                	mov    %esp,%ebp
f010ea5e:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ea61:	e8 b5 cf ff ff       	call   f010ba1b <get_cpu_proc>
f010ea66:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ea69:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ea6d:	75 19                	jne    f010ea88 <sys_allocate_user_mem+0x2d>
f010ea6f:	68 30 0d 13 f0       	push   $0xf0130d30
f010ea74:	68 40 0d 13 f0       	push   $0xf0130d40
f010ea79:	68 30 01 00 00       	push   $0x130
f010ea7e:	68 55 0d 13 f0       	push   $0xf0130d55
f010ea83:	e8 27 24 ff ff       	call   f0100eaf <_panic>

	if (virtual_address == 0 || (virtual_address >= USER_HEAP_MAX) || (virtual_address < USER_HEAP_START)
f010ea88:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ea8c:	74 2b                	je     f010eab9 <sys_allocate_user_mem+0x5e>
f010ea8e:	81 7d 08 ff ff ff 9f 	cmpl   $0x9fffffff,0x8(%ebp)
f010ea95:	77 22                	ja     f010eab9 <sys_allocate_user_mem+0x5e>
f010ea97:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea9a:	85 c0                	test   %eax,%eax
f010ea9c:	79 1b                	jns    f010eab9 <sys_allocate_user_mem+0x5e>
		|| (virtual_address + size >= USER_HEAP_MAX) || (virtual_address + size < USER_HEAP_START))
f010ea9e:	8b 55 08             	mov    0x8(%ebp),%edx
f010eaa1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eaa4:	01 d0                	add    %edx,%eax
f010eaa6:	3d ff ff ff 9f       	cmp    $0x9fffffff,%eax
f010eaab:	77 0c                	ja     f010eab9 <sys_allocate_user_mem+0x5e>
f010eaad:	8b 55 08             	mov    0x8(%ebp),%edx
f010eab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eab3:	01 d0                	add    %edx,%eax
f010eab5:	85 c0                	test   %eax,%eax
f010eab7:	78 15                	js     f010eace <sys_allocate_user_mem+0x73>
	{
		cprintf("\nsys_free_user_mem(): ILLEGAL ADDRESS! Process will be terminated...\n");
f010eab9:	83 ec 0c             	sub    $0xc,%esp
f010eabc:	68 98 0d 13 f0       	push   $0xf0130d98
f010eac1:	e8 96 30 ff ff       	call   f0101b5c <cprintf>
f010eac6:	83 c4 10             	add    $0x10,%esp
		env_exit();
f010eac9:	e8 0b cf ff ff       	call   f010b9d9 <env_exit>
	}
	allocate_user_mem(cur_env, virtual_address, size);
f010eace:	83 ec 04             	sub    $0x4,%esp
f010ead1:	ff 75 0c             	pushl  0xc(%ebp)
f010ead4:	ff 75 08             	pushl  0x8(%ebp)
f010ead7:	ff 75 f4             	pushl  -0xc(%ebp)
f010eada:	e8 76 c1 ff ff       	call   f010ac55 <allocate_user_mem>
f010eadf:	83 c4 10             	add    $0x10,%esp
	return;
f010eae2:	90                   	nop
}
f010eae3:	c9                   	leave  
f010eae4:	c3                   	ret    

f010eae5 <sys_allocate_chunk>:

void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010eae5:	55                   	push   %ebp
f010eae6:	89 e5                	mov    %esp,%ebp
f010eae8:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010eaeb:	e8 2b cf ff ff       	call   f010ba1b <get_cpu_proc>
f010eaf0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010eaf3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eaf7:	75 19                	jne    f010eb12 <sys_allocate_chunk+0x2d>
f010eaf9:	68 30 0d 13 f0       	push   $0xf0130d30
f010eafe:	68 40 0d 13 f0       	push   $0xf0130d40
f010eb03:	68 3f 01 00 00       	push   $0x13f
f010eb08:	68 55 0d 13 f0       	push   $0xf0130d55
f010eb0d:	e8 9d 23 ff ff       	call   f0100eaf <_panic>

	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010eb12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eb15:	8b 40 64             	mov    0x64(%eax),%eax
f010eb18:	ff 75 10             	pushl  0x10(%ebp)
f010eb1b:	ff 75 0c             	pushl  0xc(%ebp)
f010eb1e:	ff 75 08             	pushl  0x8(%ebp)
f010eb21:	50                   	push   %eax
f010eb22:	e8 a9 c0 ff ff       	call   f010abd0 <allocate_chunk>
f010eb27:	83 c4 10             	add    $0x10,%esp
	return;
f010eb2a:	90                   	nop
}
f010eb2b:	c9                   	leave  
f010eb2c:	c3                   	ret    

f010eb2d <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010eb2d:	55                   	push   %ebp
f010eb2e:	89 e5                	mov    %esp,%ebp
f010eb30:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010eb33:	e8 e3 ce ff ff       	call   f010ba1b <get_cpu_proc>
f010eb38:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010eb3b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eb3f:	75 19                	jne    f010eb5a <sys_move_user_mem+0x2d>
f010eb41:	68 30 0d 13 f0       	push   $0xf0130d30
f010eb46:	68 40 0d 13 f0       	push   $0xf0130d40
f010eb4b:	68 49 01 00 00       	push   $0x149
f010eb50:	68 55 0d 13 f0       	push   $0xf0130d55
f010eb55:	e8 55 23 ff ff       	call   f0100eaf <_panic>

	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010eb5a:	ff 75 10             	pushl  0x10(%ebp)
f010eb5d:	ff 75 0c             	pushl  0xc(%ebp)
f010eb60:	ff 75 08             	pushl  0x8(%ebp)
f010eb63:	ff 75 f4             	pushl  -0xc(%ebp)
f010eb66:	e8 41 c1 ff ff       	call   f010acac <move_user_mem>
f010eb6b:	83 c4 10             	add    $0x10,%esp
	return;
f010eb6e:	90                   	nop
}
f010eb6f:	c9                   	leave  
f010eb70:	c3                   	ret    

f010eb71 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010eb71:	55                   	push   %ebp
f010eb72:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010eb74:	a1 48 61 85 f0       	mov    0xf0856148,%eax
}
f010eb79:	5d                   	pop    %ebp
f010eb7a:	c3                   	ret    

f010eb7b <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010eb7b:	55                   	push   %ebp
f010eb7c:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010eb7e:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb81:	a3 48 61 85 f0       	mov    %eax,0xf0856148
}
f010eb86:	90                   	nop
f010eb87:	5d                   	pop    %ebp
f010eb88:	c3                   	ret    

f010eb89 <sys_create_shared_object>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_create_shared_object(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010eb89:	55                   	push   %ebp
f010eb8a:	89 e5                	mov    %esp,%ebp
f010eb8c:	83 ec 28             	sub    $0x28,%esp
f010eb8f:	8b 45 10             	mov    0x10(%ebp),%eax
f010eb92:	88 45 e4             	mov    %al,-0x1c(%ebp)
	struct Env* cur_env = get_cpu_proc();
f010eb95:	e8 81 ce ff ff       	call   f010ba1b <get_cpu_proc>
f010eb9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010eb9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eba1:	75 19                	jne    f010ebbc <sys_create_shared_object+0x33>
f010eba3:	68 30 0d 13 f0       	push   $0xf0130d30
f010eba8:	68 40 0d 13 f0       	push   $0xf0130d40
f010ebad:	68 64 01 00 00       	push   $0x164
f010ebb2:	68 55 0d 13 f0       	push   $0xf0130d55
f010ebb7:	e8 f3 22 ff ff       	call   f0100eaf <_panic>

	return create_shared_object(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010ebbc:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
f010ebc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ebc3:	8b 40 10             	mov    0x10(%eax),%eax
f010ebc6:	83 ec 0c             	sub    $0xc,%esp
f010ebc9:	ff 75 14             	pushl  0x14(%ebp)
f010ebcc:	52                   	push   %edx
f010ebcd:	ff 75 0c             	pushl  0xc(%ebp)
f010ebd0:	ff 75 08             	pushl  0x8(%ebp)
f010ebd3:	50                   	push   %eax
f010ebd4:	e8 1f ae ff ff       	call   f01099f8 <create_shared_object>
f010ebd9:	83 c4 20             	add    $0x20,%esp
}
f010ebdc:	c9                   	leave  
f010ebdd:	c3                   	ret    

f010ebde <sys_size_of_shared_object>:

int sys_size_of_shared_object(int32 ownerID, char* shareName)
{
f010ebde:	55                   	push   %ebp
f010ebdf:	89 e5                	mov    %esp,%ebp
f010ebe1:	83 ec 08             	sub    $0x8,%esp
	return size_of_shared_object(ownerID, shareName);
f010ebe4:	83 ec 08             	sub    $0x8,%esp
f010ebe7:	ff 75 0c             	pushl  0xc(%ebp)
f010ebea:	ff 75 08             	pushl  0x8(%ebp)
f010ebed:	e8 b7 ad ff ff       	call   f01099a9 <size_of_shared_object>
f010ebf2:	83 c4 10             	add    $0x10,%esp
}
f010ebf5:	c9                   	leave  
f010ebf6:	c3                   	ret    

f010ebf7 <sys_get_shared_object>:

int sys_get_shared_object(int32 ownerID, char* shareName, void* virtual_address)
{
f010ebf7:	55                   	push   %ebp
f010ebf8:	89 e5                	mov    %esp,%ebp
f010ebfa:	83 ec 08             	sub    $0x8,%esp
	return get_shared_object(ownerID, shareName, virtual_address);
f010ebfd:	83 ec 04             	sub    $0x4,%esp
f010ec00:	ff 75 10             	pushl  0x10(%ebp)
f010ec03:	ff 75 0c             	pushl  0xc(%ebp)
f010ec06:	ff 75 08             	pushl  0x8(%ebp)
f010ec09:	e8 0a ae ff ff       	call   f0109a18 <get_shared_object>
f010ec0e:	83 c4 10             	add    $0x10,%esp
}
f010ec11:	c9                   	leave  
f010ec12:	c3                   	ret    

f010ec13 <sys_delete_shared_object>:

int sys_delete_shared_object(int32 sharedObjectID, void *startVA)
{
f010ec13:	55                   	push   %ebp
f010ec14:	89 e5                	mov    %esp,%ebp
f010ec16:	83 ec 08             	sub    $0x8,%esp
	return delete_shared_object(sharedObjectID, startVA);
f010ec19:	83 ec 08             	sub    $0x8,%esp
f010ec1c:	ff 75 0c             	pushl  0xc(%ebp)
f010ec1f:	ff 75 08             	pushl  0x8(%ebp)
f010ec22:	e8 2b ae ff ff       	call   f0109a52 <delete_shared_object>
f010ec27:	83 c4 10             	add    $0x10,%esp
}
f010ec2a:	c9                   	leave  
f010ec2b:	c3                   	ret    

f010ec2c <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010ec2c:	55                   	push   %ebp
f010ec2d:	89 e5                	mov    %esp,%ebp
f010ec2f:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ec32:	e8 e4 cd ff ff       	call   f010ba1b <get_cpu_proc>
f010ec37:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ec3a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec3e:	75 19                	jne    f010ec59 <sys_getenvid+0x2d>
f010ec40:	68 30 0d 13 f0       	push   $0xf0130d30
f010ec45:	68 40 0d 13 f0       	push   $0xf0130d40
f010ec4a:	68 80 01 00 00       	push   $0x180
f010ec4f:	68 55 0d 13 f0       	push   $0xf0130d55
f010ec54:	e8 56 22 ff ff       	call   f0100eaf <_panic>

	return cur_env->env_id;
f010ec59:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec5c:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ec5f:	c9                   	leave  
f010ec60:	c3                   	ret    

f010ec61 <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010ec61:	55                   	push   %ebp
f010ec62:	89 e5                	mov    %esp,%ebp
f010ec64:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ec67:	e8 af cd ff ff       	call   f010ba1b <get_cpu_proc>
f010ec6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ec6f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec73:	75 19                	jne    f010ec8e <sys_getenvindex+0x2d>
f010ec75:	68 30 0d 13 f0       	push   $0xf0130d30
f010ec7a:	68 40 0d 13 f0       	push   $0xf0130d40
f010ec7f:	68 89 01 00 00       	push   $0x189
f010ec84:	68 55 0d 13 f0       	push   $0xf0130d55
f010ec89:	e8 21 22 ff ff       	call   f0100eaf <_panic>

	//return cur_env->env_id;
	return (cur_env - envs) ;
f010ec8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec91:	8b 15 f0 51 81 f0    	mov    0xf08151f0,%edx
f010ec97:	29 d0                	sub    %edx,%eax
f010ec99:	c1 f8 02             	sar    $0x2,%eax
f010ec9c:	89 c1                	mov    %eax,%ecx
f010ec9e:	89 ca                	mov    %ecx,%edx
f010eca0:	c1 e2 02             	shl    $0x2,%edx
f010eca3:	01 ca                	add    %ecx,%edx
f010eca5:	c1 e2 02             	shl    $0x2,%edx
f010eca8:	01 ca                	add    %ecx,%edx
f010ecaa:	c1 e2 03             	shl    $0x3,%edx
f010ecad:	01 ca                	add    %ecx,%edx
f010ecaf:	89 d0                	mov    %edx,%eax
f010ecb1:	c1 e0 05             	shl    $0x5,%eax
f010ecb4:	29 d0                	sub    %edx,%eax
f010ecb6:	c1 e0 02             	shl    $0x2,%eax
f010ecb9:	01 c8                	add    %ecx,%eax
f010ecbb:	c1 e0 02             	shl    $0x2,%eax
f010ecbe:	01 c8                	add    %ecx,%eax
f010ecc0:	c1 e0 02             	shl    $0x2,%eax
f010ecc3:	01 c8                	add    %ecx,%eax
f010ecc5:	c1 e0 06             	shl    $0x6,%eax
f010ecc8:	29 c8                	sub    %ecx,%eax
f010ecca:	c1 e0 03             	shl    $0x3,%eax
f010eccd:	01 c8                	add    %ecx,%eax
f010eccf:	c1 e0 04             	shl    $0x4,%eax
f010ecd2:	01 c8                	add    %ecx,%eax
}
f010ecd4:	c9                   	leave  
f010ecd5:	c3                   	ret    

f010ecd6 <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010ecd6:	55                   	push   %ebp
f010ecd7:	89 e5                	mov    %esp,%ebp
f010ecd9:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ecdc:	e8 3a cd ff ff       	call   f010ba1b <get_cpu_proc>
f010ece1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ece4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ece8:	75 19                	jne    f010ed03 <sys_getparentenvid+0x2d>
f010ecea:	68 30 0d 13 f0       	push   $0xf0130d30
f010ecef:	68 40 0d 13 f0       	push   $0xf0130d40
f010ecf4:	68 93 01 00 00       	push   $0x193
f010ecf9:	68 55 0d 13 f0       	push   $0xf0130d55
f010ecfe:	e8 ac 21 ff ff       	call   f0100eaf <_panic>

	return cur_env->env_parent_id;
f010ed03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed06:	8b 40 14             	mov    0x14(%eax),%eax
}
f010ed09:	c9                   	leave  
f010ed0a:	c3                   	ret    

f010ed0b <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010ed0b:	55                   	push   %ebp
f010ed0c:	89 e5                	mov    %esp,%ebp
f010ed0e:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ed11:	e8 05 cd ff ff       	call   f010ba1b <get_cpu_proc>
f010ed16:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ed19:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ed1d:	75 19                	jne    f010ed38 <sys_destroy_env+0x2d>
f010ed1f:	68 30 0d 13 f0       	push   $0xf0130d30
f010ed24:	68 40 0d 13 f0       	push   $0xf0130d40
f010ed29:	68 a1 01 00 00       	push   $0x1a1
f010ed2e:	68 55 0d 13 f0       	push   $0xf0130d55
f010ed33:	e8 77 21 ff ff       	call   f0100eaf <_panic>

	int r;
	struct Env *e;
	if (envid == 0)
f010ed38:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ed3c:	75 08                	jne    f010ed46 <sys_destroy_env+0x3b>
	{
		e = cur_env ;
f010ed3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed41:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ed44:	eb 22                	jmp    f010ed68 <sys_destroy_env+0x5d>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010ed46:	83 ec 04             	sub    $0x4,%esp
f010ed49:	6a 00                	push   $0x0
f010ed4b:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ed4e:	50                   	push   %eax
f010ed4f:	ff 75 08             	pushl  0x8(%ebp)
f010ed52:	e8 14 cd ff ff       	call   f010ba6b <envid2env>
f010ed57:	83 c4 10             	add    $0x10,%esp
f010ed5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ed5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ed61:	79 05                	jns    f010ed68 <sys_destroy_env+0x5d>
	{
		return r;
f010ed63:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ed66:	eb 56                	jmp    f010edbe <sys_destroy_env+0xb3>
	}

	if (e == cur_env)
f010ed68:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ed6b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ed6e:	75 19                	jne    f010ed89 <sys_destroy_env+0x7e>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010ed70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed73:	8b 40 10             	mov    0x10(%eax),%eax
f010ed76:	83 ec 08             	sub    $0x8,%esp
f010ed79:	50                   	push   %eax
f010ed7a:	68 de 0d 13 f0       	push   $0xf0130dde
f010ed7f:	e8 d8 2d ff ff       	call   f0101b5c <cprintf>
f010ed84:	83 c4 10             	add    $0x10,%esp
f010ed87:	eb 1e                	jmp    f010eda7 <sys_destroy_env+0x9c>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010ed89:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ed8c:	8b 50 10             	mov    0x10(%eax),%edx
f010ed8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed92:	8b 40 10             	mov    0x10(%eax),%eax
f010ed95:	83 ec 04             	sub    $0x4,%esp
f010ed98:	52                   	push   %edx
f010ed99:	50                   	push   %eax
f010ed9a:	68 f9 0d 13 f0       	push   $0xf0130df9
f010ed9f:	e8 b8 2d ff ff       	call   f0101b5c <cprintf>
f010eda4:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010eda7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010edaa:	8b 40 10             	mov    0x10(%eax),%eax
f010edad:	83 ec 0c             	sub    $0xc,%esp
f010edb0:	50                   	push   %eax
f010edb1:	e8 6f 7c ff ff       	call   f0106a25 <sched_kill_env>
f010edb6:	83 c4 10             	add    $0x10,%esp

	return 0;
f010edb9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010edbe:	c9                   	leave  
f010edbf:	c3                   	ret    

f010edc0 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010edc0:	55                   	push   %ebp
f010edc1:	89 e5                	mov    %esp,%ebp
f010edc3:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010edc6:	e8 0e cc ff ff       	call   f010b9d9 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010edcb:	90                   	nop
f010edcc:	c9                   	leave  
f010edcd:	c3                   	ret    

f010edce <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010edce:	55                   	push   %ebp
f010edcf:	89 e5                	mov    %esp,%ebp
f010edd1:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010edd4:	ff 75 14             	pushl  0x14(%ebp)
f010edd7:	ff 75 10             	pushl  0x10(%ebp)
f010edda:	ff 75 0c             	pushl  0xc(%ebp)
f010eddd:	ff 75 08             	pushl  0x8(%ebp)
f010ede0:	e8 7f c0 ff ff       	call   f010ae64 <env_create>
f010ede5:	83 c4 10             	add    $0x10,%esp
f010ede8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010edeb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010edef:	75 07                	jne    f010edf8 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010edf1:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010edf6:	eb 14                	jmp    f010ee0c <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010edf8:	83 ec 0c             	sub    $0xc,%esp
f010edfb:	ff 75 f4             	pushl  -0xc(%ebp)
f010edfe:	e8 86 78 ff ff       	call   f0106689 <sched_new_env>
f010ee03:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010ee06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee09:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ee0c:	c9                   	leave  
f010ee0d:	c3                   	ret    

f010ee0e <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010ee0e:	55                   	push   %ebp
f010ee0f:	89 e5                	mov    %esp,%ebp
f010ee11:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010ee14:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee17:	83 ec 0c             	sub    $0xc,%esp
f010ee1a:	50                   	push   %eax
f010ee1b:	e8 bf 78 ff ff       	call   f01066df <sched_run_env>
f010ee20:	83 c4 10             	add    $0x10,%esp
}
f010ee23:	90                   	nop
f010ee24:	c9                   	leave  
f010ee25:	c3                   	ret    

f010ee26 <sys_get_optimal_num_faults>:

//Calculate the number of page faults for the OPTIMAL replacement
int sys_get_optimal_num_faults()
{
f010ee26:	55                   	push   %ebp
f010ee27:	89 e5                	mov    %esp,%ebp
f010ee29:	53                   	push   %ebx
f010ee2a:	83 ec 24             	sub    $0x24,%esp
#if USE_KHEAP
	struct Env* cur_env = get_cpu_proc();
f010ee2d:	e8 e9 cb ff ff       	call   f010ba1b <get_cpu_proc>
f010ee32:	89 45 ec             	mov    %eax,-0x14(%ebp)
	assert(cur_env != NULL);
f010ee35:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ee39:	75 19                	jne    f010ee54 <sys_get_optimal_num_faults+0x2e>
f010ee3b:	68 30 0d 13 f0       	push   $0xf0130d30
f010ee40:	68 40 0d 13 f0       	push   $0xf0130d40
f010ee45:	68 e8 01 00 00       	push   $0x1e8
f010ee4a:	68 55 0d 13 f0       	push   $0xf0130d55
f010ee4f:	e8 5b 20 ff ff       	call   f0100eaf <_panic>

	struct WorkingSetElement *ptrWSE ;
	int w = 0;
f010ee54:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	LIST_FOREACH(ptrWSE, &(cur_env->page_WS_list))
f010ee5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ee5e:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010ee64:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ee67:	eb 5d                	jmp    f010eec6 <sys_get_optimal_num_faults+0xa0>
	{
		if (ROUNDDOWN(ptrWSE->virtual_address, PAGE_SIZE) != ROUNDDOWN(cur_env->prepagedVAs[w++], PAGE_SIZE))
f010ee69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee6c:	8b 00                	mov    (%eax),%eax
f010ee6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010ee71:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ee74:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ee79:	89 c3                	mov    %eax,%ebx
f010ee7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ee7e:	8b 88 ac 00 00 00    	mov    0xac(%eax),%ecx
f010ee84:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ee87:	8d 50 01             	lea    0x1(%eax),%edx
f010ee8a:	89 55 f0             	mov    %edx,-0x10(%ebp)
f010ee8d:	c1 e0 02             	shl    $0x2,%eax
f010ee90:	01 c8                	add    %ecx,%eax
f010ee92:	8b 00                	mov    (%eax),%eax
f010ee94:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010ee97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ee9a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ee9f:	39 c3                	cmp    %eax,%ebx
f010eea1:	74 17                	je     f010eeba <sys_get_optimal_num_faults+0x94>
		{
			panic("sys_get_optimal_num_faults(): page working set is changed during the OPTIMAL replacement while it's not expected to");
f010eea3:	83 ec 04             	sub    $0x4,%esp
f010eea6:	68 14 0e 13 f0       	push   $0xf0130e14
f010eeab:	68 f0 01 00 00       	push   $0x1f0
f010eeb0:	68 55 0d 13 f0       	push   $0xf0130d55
f010eeb5:	e8 f5 1f ff ff       	call   f0100eaf <_panic>
	struct Env* cur_env = get_cpu_proc();
	assert(cur_env != NULL);

	struct WorkingSetElement *ptrWSE ;
	int w = 0;
	LIST_FOREACH(ptrWSE, &(cur_env->page_WS_list))
f010eeba:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eebd:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010eec3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010eec6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eeca:	74 08                	je     f010eed4 <sys_get_optimal_num_faults+0xae>
f010eecc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eecf:	8b 40 10             	mov    0x10(%eax),%eax
f010eed2:	eb 05                	jmp    f010eed9 <sys_get_optimal_num_faults+0xb3>
f010eed4:	b8 00 00 00 00       	mov    $0x0,%eax
f010eed9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010eedc:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010eee2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eee5:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010eeeb:	85 c0                	test   %eax,%eax
f010eeed:	0f 85 76 ff ff ff    	jne    f010ee69 <sys_get_optimal_num_faults+0x43>
f010eef3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eef7:	0f 85 6c ff ff ff    	jne    f010ee69 <sys_get_optimal_num_faults+0x43>
		if (ROUNDDOWN(ptrWSE->virtual_address, PAGE_SIZE) != ROUNDDOWN(cur_env->prepagedVAs[w++], PAGE_SIZE))
		{
			panic("sys_get_optimal_num_faults(): page working set is changed during the OPTIMAL replacement while it's not expected to");
		}
	}
	return get_optimal_num_faults(&(cur_env->page_WS_list), cur_env->page_WS_max_size, &(cur_env->referenceStreamList));
f010eefd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ef00:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
f010ef06:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ef09:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010ef0f:	89 c2                	mov    %eax,%edx
f010ef11:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ef14:	05 88 00 00 00       	add    $0x88,%eax
f010ef19:	83 ec 04             	sub    $0x4,%esp
f010ef1c:	51                   	push   %ecx
f010ef1d:	52                   	push   %edx
f010ef1e:	50                   	push   %eax
f010ef1f:	e8 25 0d 00 00       	call   f010fc49 <get_optimal_num_faults>
f010ef24:	83 c4 10             	add    $0x10,%esp
#else
	panic("MUST ENABLE KHEAP");
#endif
	return 0;
}
f010ef27:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ef2a:	c9                   	leave  
f010ef2b:	c3                   	ret    

f010ef2c <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010ef2c:	55                   	push   %ebp
f010ef2d:	89 e5                	mov    %esp,%ebp
f010ef2f:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010ef32:	0f 31                	rdtsc  
f010ef34:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ef37:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010ef3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ef3d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ef40:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010ef43:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010ef46:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ef49:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ef4c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ef4f:	89 01                	mov    %eax,(%ecx)
f010ef51:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010ef54:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef57:	c9                   	leave  
f010ef58:	c2 04 00             	ret    $0x4

f010ef5b <sys_rcr2>:

uint32 sys_rcr2()
{
f010ef5b:	55                   	push   %ebp
f010ef5c:	89 e5                	mov    %esp,%ebp
f010ef5e:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010ef61:	0f 20 d0             	mov    %cr2,%eax
f010ef64:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010ef67:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010ef6a:	90                   	nop
}
f010ef6b:	c9                   	leave  
f010ef6c:	c3                   	ret    

f010ef6d <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010ef6d:	55                   	push   %ebp
f010ef6e:	89 e5                	mov    %esp,%ebp
f010ef70:	83 ec 04             	sub    $0x4,%esp
f010ef73:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef76:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010ef79:	8a 45 fc             	mov    -0x4(%ebp),%al
f010ef7c:	a2 60 5a 81 f0       	mov    %al,0xf0815a60
}
f010ef81:	90                   	nop
f010ef82:	c9                   	leave  
f010ef83:	c3                   	ret    

f010ef84 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010ef84:	55                   	push   %ebp
f010ef85:	89 e5                	mov    %esp,%ebp
f010ef87:	56                   	push   %esi
f010ef88:	53                   	push   %ebx
f010ef89:	83 ec 20             	sub    $0x20,%esp
	struct Env* cur_env = get_cpu_proc();
f010ef8c:	e8 8a ca ff ff       	call   f010ba1b <get_cpu_proc>
f010ef91:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ef94:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ef98:	75 19                	jne    f010efb3 <syscall+0x2f>
f010ef9a:	68 30 0d 13 f0       	push   $0xf0130d30
f010ef9f:	68 40 0d 13 f0       	push   $0xf0130d40
f010efa4:	68 16 02 00 00       	push   $0x216
f010efa9:	68 55 0d 13 f0       	push   $0xf0130d55
f010efae:	e8 fc 1e ff ff       	call   f0100eaf <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010efb3:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010efb7:	0f 87 b5 03 00 00    	ja     f010f372 <syscall+0x3ee>
f010efbd:	8b 45 08             	mov    0x8(%ebp),%eax
f010efc0:	c1 e0 02             	shl    $0x2,%eax
f010efc3:	05 88 0e 13 f0       	add    $0xf0130e88,%eax
f010efc8:	8b 00                	mov    (%eax),%eax
f010efca:	ff e0                	jmp    *%eax
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 System Calls - Add suitable code here
	//Your code is here

	//=============================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3, a4);
f010efcc:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010efcf:	8b 45 14             	mov    0x14(%ebp),%eax
f010efd2:	0f b6 d0             	movzbl %al,%edx
f010efd5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efd8:	51                   	push   %ecx
f010efd9:	52                   	push   %edx
f010efda:	ff 75 10             	pushl  0x10(%ebp)
f010efdd:	50                   	push   %eax
f010efde:	e8 8e f6 ff ff       	call   f010e671 <sys_cputs>
f010efe3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010efe6:	b8 00 00 00 00       	mov    $0x0,%eax
f010efeb:	e9 87 03 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010eff0:	e8 29 f7 ff ff       	call   f010e71e <sys_cgetc>
f010eff5:	e9 7d 03 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_cputc:
		sys_cputc((const char)a1);
f010effa:	8b 45 0c             	mov    0xc(%ebp),%eax
f010effd:	0f be c0             	movsbl %al,%eax
f010f000:	83 ec 0c             	sub    $0xc,%esp
f010f003:	50                   	push   %eax
f010f004:	e8 f1 f6 ff ff       	call   f010e6fa <sys_cputc>
f010f009:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f00c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f011:	e9 61 03 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010f016:	e8 42 f7 ff ff       	call   f010e75d <sys_lock_cons>
		return 0;
f010f01b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f020:	e9 52 03 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010f025:	e8 41 f7 ff ff       	call   f010e76b <sys_unlock_cons>
		return 0;
f010f02a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f02f:	e9 43 03 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010f034:	83 ec 08             	sub    $0x8,%esp
f010f037:	ff 75 10             	pushl  0x10(%ebp)
f010f03a:	ff 75 0c             	pushl  0xc(%ebp)
f010f03d:	e8 21 f8 ff ff       	call   f010e863 <sys_calculate_required_frames>
f010f042:	83 c4 10             	add    $0x10,%esp
f010f045:	e9 2d 03 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010f04a:	e8 5b f8 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f010f04f:	e9 23 03 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010f054:	e8 70 f8 ff ff       	call   f010e8c9 <sys_calculate_modified_frames>
f010f059:	e9 19 03 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010f05e:	e8 80 f8 ff ff       	call   f010e8e3 <sys_calculate_notmod_frames>
f010f063:	e9 0f 03 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010f068:	e8 08 f9 ff ff       	call   f010e975 <sys_pf_calculate_allocated_pages>
f010f06d:	e9 05 03 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010f072:	83 ec 0c             	sub    $0xc,%esp
f010f075:	ff 75 0c             	pushl  0xc(%ebp)
f010f078:	e8 80 f8 ff ff       	call   f010e8fd <sys_calculate_pages_tobe_removed_ready_exit>
f010f07d:	83 c4 10             	add    $0x10,%esp
f010f080:	e9 f2 02 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010f085:	e8 89 f8 ff ff       	call   f010e913 <sys_scarce_memory>
		return 0;
f010f08a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f08f:	e9 e3 02 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010f094:	83 ec 04             	sub    $0x4,%esp
f010f097:	ff 75 14             	pushl  0x14(%ebp)
f010f09a:	ff 75 10             	pushl  0x10(%ebp)
f010f09d:	ff 75 0c             	pushl  0xc(%ebp)
f010f0a0:	e8 40 fa ff ff       	call   f010eae5 <sys_allocate_chunk>
f010f0a5:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f0a8:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0ad:	e9 c5 02 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;

		//======================
	case SYS_allocate_page:
		return __sys_allocate_page((void*)a1, a2);
f010f0b2:	8b 55 10             	mov    0x10(%ebp),%edx
f010f0b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0b8:	83 ec 08             	sub    $0x8,%esp
f010f0bb:	52                   	push   %edx
f010f0bc:	50                   	push   %eax
f010f0bd:	e8 b7 f6 ff ff       	call   f010e779 <__sys_allocate_page>
f010f0c2:	83 c4 10             	add    $0x10,%esp
f010f0c5:	e9 ad 02 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010f0ca:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010f0cd:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f0d0:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f0d3:	8b 55 10             	mov    0x10(%ebp),%edx
f010f0d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0d9:	83 ec 0c             	sub    $0xc,%esp
f010f0dc:	56                   	push   %esi
f010f0dd:	53                   	push   %ebx
f010f0de:	51                   	push   %ecx
f010f0df:	52                   	push   %edx
f010f0e0:	50                   	push   %eax
f010f0e1:	e8 0d f7 ff ff       	call   f010e7f3 <__sys_map_frame>
f010f0e6:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f0e9:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0ee:	e9 84 02 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_unmap_frame:
		return __sys_unmap_frame(a1);
f010f0f3:	83 ec 0c             	sub    $0xc,%esp
f010f0f6:	ff 75 0c             	pushl  0xc(%ebp)
f010f0f9:	e8 12 f7 ff ff       	call   f010e810 <__sys_unmap_frame>
f010f0fe:	83 c4 10             	add    $0x10,%esp
f010f101:	e9 71 02 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010f106:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f109:	0f be c0             	movsbl %al,%eax
f010f10c:	83 ec 0c             	sub    $0xc,%esp
f010f10f:	50                   	push   %eax
f010f110:	e8 0c f8 ff ff       	call   f010e921 <sys_clearFFL>
f010f115:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f118:	b8 00 00 00 00       	mov    $0x0,%eax
f010f11d:	e9 55 02 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;

	case SYS_create_shared_object:
		return sys_create_shared_object((char*)a1, a2, a3, (void*)a4);
f010f122:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f125:	8b 45 14             	mov    0x14(%ebp),%eax
f010f128:	0f b6 d0             	movzbl %al,%edx
f010f12b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f12e:	51                   	push   %ecx
f010f12f:	52                   	push   %edx
f010f130:	ff 75 10             	pushl  0x10(%ebp)
f010f133:	50                   	push   %eax
f010f134:	e8 50 fa ff ff       	call   f010eb89 <sys_create_shared_object>
f010f139:	83 c4 10             	add    $0x10,%esp
f010f13c:	e9 36 02 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;

	case SYS_get_shared_object:
		return sys_get_shared_object((int32)a1, (char*)a2, (void*)a3);
f010f141:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f144:	8b 55 10             	mov    0x10(%ebp),%edx
f010f147:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f14a:	83 ec 04             	sub    $0x4,%esp
f010f14d:	51                   	push   %ecx
f010f14e:	52                   	push   %edx
f010f14f:	50                   	push   %eax
f010f150:	e8 a2 fa ff ff       	call   f010ebf7 <sys_get_shared_object>
f010f155:	83 c4 10             	add    $0x10,%esp
f010f158:	e9 1a 02 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;

	case SYS_free_shared_object:
		return sys_delete_shared_object((int32)a1, (void *)a2);
f010f15d:	8b 55 10             	mov    0x10(%ebp),%edx
f010f160:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f163:	83 ec 08             	sub    $0x8,%esp
f010f166:	52                   	push   %edx
f010f167:	50                   	push   %eax
f010f168:	e8 a6 fa ff ff       	call   f010ec13 <sys_delete_shared_object>
f010f16d:	83 c4 10             	add    $0x10,%esp
f010f170:	e9 02 02 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;

	case SYS_get_size_of_shared_object:
		return sys_size_of_shared_object((int32)a1, (char*)a2);
f010f175:	8b 55 10             	mov    0x10(%ebp),%edx
f010f178:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f17b:	83 ec 08             	sub    $0x8,%esp
f010f17e:	52                   	push   %edx
f010f17f:	50                   	push   %eax
f010f180:	e8 59 fa ff ff       	call   f010ebde <sys_size_of_shared_object>
f010f185:	83 c4 10             	add    $0x10,%esp
f010f188:	e9 ea 01 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010f18d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f190:	ff 75 18             	pushl  0x18(%ebp)
f010f193:	ff 75 14             	pushl  0x14(%ebp)
f010f196:	ff 75 10             	pushl  0x10(%ebp)
f010f199:	50                   	push   %eax
f010f19a:	e8 2f fc ff ff       	call   f010edce <sys_create_env>
f010f19f:	83 c4 10             	add    $0x10,%esp
f010f1a2:	e9 d0 01 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010f1a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1aa:	83 ec 0c             	sub    $0xc,%esp
f010f1ad:	50                   	push   %eax
f010f1ae:	e8 5b fc ff ff       	call   f010ee0e <sys_run_env>
f010f1b3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1b6:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1bb:	e9 b7 01 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010f1c0:	e8 9c fa ff ff       	call   f010ec61 <sys_getenvindex>
f010f1c5:	e9 ad 01 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010f1ca:	e8 5d fa ff ff       	call   f010ec2c <sys_getenvid>
f010f1cf:	e9 a3 01 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010f1d4:	e8 fd fa ff ff       	call   f010ecd6 <sys_getparentenvid>
f010f1d9:	e9 99 01 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010f1de:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1e1:	83 ec 0c             	sub    $0xc,%esp
f010f1e4:	50                   	push   %eax
f010f1e5:	e8 21 fb ff ff       	call   f010ed0b <sys_destroy_env>
f010f1ea:	83 c4 10             	add    $0x10,%esp
f010f1ed:	e9 85 01 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010f1f2:	e8 c9 fb ff ff       	call   f010edc0 <sys_exit_env>
		return 0;
f010f1f7:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1fc:	e9 76 01 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010f201:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f010f204:	83 ec 0c             	sub    $0xc,%esp
f010f207:	50                   	push   %eax
f010f208:	e8 1f fd ff ff       	call   f010ef2c <sys_get_virtual_time>
f010f20d:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010f210:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f213:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010f216:	8b 45 10             	mov    0x10(%ebp),%eax
f010f219:	89 45 ec             	mov    %eax,-0x14(%ebp)
		*ptrlow = res.low;
f010f21c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f21f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f222:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010f224:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010f227:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f22a:	89 10                	mov    %edx,(%eax)
		return 0;
f010f22c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f231:	e9 41 01 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010f236:	83 ec 04             	sub    $0x4,%esp
f010f239:	ff 75 14             	pushl  0x14(%ebp)
f010f23c:	ff 75 10             	pushl  0x10(%ebp)
f010f23f:	ff 75 0c             	pushl  0xc(%ebp)
f010f242:	e8 e6 f8 ff ff       	call   f010eb2d <sys_move_user_mem>
f010f247:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f24a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f24f:	e9 23 01 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010f254:	e8 02 fd ff ff       	call   f010ef5b <sys_rcr2>
f010f259:	e9 19 01 00 00       	jmp    f010f377 <syscall+0x3f3>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010f25e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f261:	0f b6 c0             	movzbl %al,%eax
f010f264:	83 ec 0c             	sub    $0xc,%esp
f010f267:	50                   	push   %eax
f010f268:	e8 00 fd ff ff       	call   f010ef6d <sys_bypassPageFault>
f010f26d:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f270:	b8 00 00 00 00       	mov    $0x0,%eax
f010f275:	e9 fd 00 00 00       	jmp    f010f377 <syscall+0x3f3>

	case SYS_rsttst:
		rsttst();
f010f27a:	e8 b6 96 00 00       	call   f0118935 <rsttst>
		return 0;
f010f27f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f284:	e9 ee 00 00 00       	jmp    f010f377 <syscall+0x3f3>
	case SYS_inctst:
		inctst();
f010f289:	e8 ef 96 00 00       	call   f011897d <inctst>
		return 0;
f010f28e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f293:	e9 df 00 00 00       	jmp    f010f377 <syscall+0x3f3>
	case SYS_chktst:
		chktst(a1);
f010f298:	83 ec 0c             	sub    $0xc,%esp
f010f29b:	ff 75 0c             	pushl  0xc(%ebp)
f010f29e:	e8 1c 98 00 00       	call   f0118abf <chktst>
f010f2a3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f2a6:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2ab:	e9 c7 00 00 00       	jmp    f010f377 <syscall+0x3f3>
	case SYS_gettst:
		return gettst();
f010f2b0:	e8 fc 96 00 00       	call   f01189b1 <gettst>
f010f2b5:	e9 bd 00 00 00       	jmp    f010f377 <syscall+0x3f3>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010f2ba:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010f2bd:	8b 45 18             	mov    0x18(%ebp),%eax
f010f2c0:	0f be c0             	movsbl %al,%eax
f010f2c3:	83 ec 0c             	sub    $0xc,%esp
f010f2c6:	52                   	push   %edx
f010f2c7:	50                   	push   %eax
f010f2c8:	ff 75 14             	pushl  0x14(%ebp)
f010f2cb:	ff 75 10             	pushl  0x10(%ebp)
f010f2ce:	ff 75 0c             	pushl  0xc(%ebp)
f010f2d1:	e8 e5 96 00 00       	call   f01189bb <tst>
f010f2d6:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f2d9:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2de:	e9 94 00 00 00       	jmp    f010f377 <syscall+0x3f3>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010f2e3:	e8 89 f8 ff ff       	call   f010eb71 <sys_get_heap_strategy>
f010f2e8:	e9 8a 00 00 00       	jmp    f010f377 <syscall+0x3f3>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010f2ed:	83 ec 0c             	sub    $0xc,%esp
f010f2f0:	ff 75 0c             	pushl  0xc(%ebp)
f010f2f3:	e8 83 f8 ff ff       	call   f010eb7b <sys_set_uheap_strategy>
f010f2f8:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f2fb:	b8 00 00 00 00       	mov    $0x0,%eax
f010f300:	eb 75                	jmp    f010f377 <syscall+0x3f3>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010f302:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f305:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f308:	8b 55 10             	mov    0x10(%ebp),%edx
f010f30b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f30e:	53                   	push   %ebx
f010f30f:	51                   	push   %ecx
f010f310:	52                   	push   %edx
f010f311:	50                   	push   %eax
f010f312:	e8 62 1d 00 00       	call   f0111079 <sys_check_LRU_lists>
f010f317:	83 c4 10             	add    $0x10,%esp
f010f31a:	eb 5b                	jmp    f010f377 <syscall+0x3f3>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010f31c:	8b 55 10             	mov    0x10(%ebp),%edx
f010f31f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f322:	83 ec 08             	sub    $0x8,%esp
f010f325:	52                   	push   %edx
f010f326:	50                   	push   %eax
f010f327:	e8 0f 1f 00 00       	call   f011123b <sys_check_LRU_lists_free>
f010f32c:	83 c4 10             	add    $0x10,%esp
f010f32f:	eb 46                	jmp    f010f377 <syscall+0x3f3>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010f331:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f334:	8b 55 10             	mov    0x10(%ebp),%edx
f010f337:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f33a:	51                   	push   %ecx
f010f33b:	ff 75 14             	pushl  0x14(%ebp)
f010f33e:	52                   	push   %edx
f010f33f:	50                   	push   %eax
f010f340:	e8 83 20 00 00       	call   f01113c8 <sys_check_WS_list>
f010f345:	83 c4 10             	add    $0x10,%esp
f010f348:	eb 2d                	jmp    f010f377 <syscall+0x3f3>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010f34a:	8b 55 10             	mov    0x10(%ebp),%edx
f010f34d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f350:	83 ec 08             	sub    $0x8,%esp
f010f353:	52                   	push   %edx
f010f354:	50                   	push   %eax
f010f355:	e8 66 99 00 00       	call   f0118cc0 <sys_utilities>
f010f35a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f35d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f362:	eb 13                	jmp    f010f377 <syscall+0x3f3>

	case SYS_get_optimal_num_faults:
		return sys_get_optimal_num_faults();
f010f364:	e8 bd fa ff ff       	call   f010ee26 <sys_get_optimal_num_faults>
f010f369:	eb 0c                	jmp    f010f377 <syscall+0x3f3>

	case NSYSCALLS:
		return 	-E_INVAL;
f010f36b:	b8 03 00 00 00       	mov    $0x3,%eax
f010f370:	eb 05                	jmp    f010f377 <syscall+0x3f3>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010f372:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010f377:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f37a:	5b                   	pop    %ebx
f010f37b:	5e                   	pop    %esi
f010f37c:	5d                   	pop    %ebp
f010f37d:	c3                   	ret    

f010f37e <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010f37e:	55                   	push   %ebp
f010f37f:	89 e5                	mov    %esp,%ebp
f010f381:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010f384:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f387:	8b 00                	mov    (%eax),%eax
f010f389:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f38c:	8b 45 10             	mov    0x10(%ebp),%eax
f010f38f:	8b 00                	mov    (%eax),%eax
f010f391:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f394:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010f39b:	e9 ca 00 00 00       	jmp    f010f46a <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010f3a0:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f3a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f3a6:	01 d0                	add    %edx,%eax
f010f3a8:	89 c2                	mov    %eax,%edx
f010f3aa:	c1 ea 1f             	shr    $0x1f,%edx
f010f3ad:	01 d0                	add    %edx,%eax
f010f3af:	d1 f8                	sar    %eax
f010f3b1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f3b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f3b7:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f3ba:	eb 03                	jmp    f010f3bf <stab_binsearch+0x41>
			m--;
f010f3bc:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f3bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f3c2:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f3c5:	7c 1e                	jl     f010f3e5 <stab_binsearch+0x67>
f010f3c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f3ca:	89 d0                	mov    %edx,%eax
f010f3cc:	01 c0                	add    %eax,%eax
f010f3ce:	01 d0                	add    %edx,%eax
f010f3d0:	c1 e0 02             	shl    $0x2,%eax
f010f3d3:	89 c2                	mov    %eax,%edx
f010f3d5:	8b 45 08             	mov    0x8(%ebp),%eax
f010f3d8:	01 d0                	add    %edx,%eax
f010f3da:	8a 40 04             	mov    0x4(%eax),%al
f010f3dd:	0f b6 c0             	movzbl %al,%eax
f010f3e0:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f3e3:	75 d7                	jne    f010f3bc <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010f3e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f3e8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f3eb:	7d 09                	jge    f010f3f6 <stab_binsearch+0x78>
			l = true_m + 1;
f010f3ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f3f0:	40                   	inc    %eax
f010f3f1:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010f3f4:	eb 74                	jmp    f010f46a <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010f3f6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010f3fd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f400:	89 d0                	mov    %edx,%eax
f010f402:	01 c0                	add    %eax,%eax
f010f404:	01 d0                	add    %edx,%eax
f010f406:	c1 e0 02             	shl    $0x2,%eax
f010f409:	89 c2                	mov    %eax,%edx
f010f40b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f40e:	01 d0                	add    %edx,%eax
f010f410:	8b 40 08             	mov    0x8(%eax),%eax
f010f413:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f416:	73 11                	jae    f010f429 <stab_binsearch+0xab>
			*region_left = m;
f010f418:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f41b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f41e:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010f420:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f423:	40                   	inc    %eax
f010f424:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f427:	eb 41                	jmp    f010f46a <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010f429:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f42c:	89 d0                	mov    %edx,%eax
f010f42e:	01 c0                	add    %eax,%eax
f010f430:	01 d0                	add    %edx,%eax
f010f432:	c1 e0 02             	shl    $0x2,%eax
f010f435:	89 c2                	mov    %eax,%edx
f010f437:	8b 45 08             	mov    0x8(%ebp),%eax
f010f43a:	01 d0                	add    %edx,%eax
f010f43c:	8b 40 08             	mov    0x8(%eax),%eax
f010f43f:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f442:	76 14                	jbe    f010f458 <stab_binsearch+0xda>
			*region_right = m - 1;
f010f444:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f447:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f44a:	8b 45 10             	mov    0x10(%ebp),%eax
f010f44d:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010f44f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f452:	48                   	dec    %eax
f010f453:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f456:	eb 12                	jmp    f010f46a <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010f458:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f45b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f45e:	89 10                	mov    %edx,(%eax)
			l = m;
f010f460:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f463:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010f466:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010f46a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f46d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010f470:	0f 8e 2a ff ff ff    	jle    f010f3a0 <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010f476:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f47a:	75 0f                	jne    f010f48b <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010f47c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f47f:	8b 00                	mov    (%eax),%eax
f010f481:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f484:	8b 45 10             	mov    0x10(%ebp),%eax
f010f487:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010f489:	eb 3d                	jmp    f010f4c8 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f48b:	8b 45 10             	mov    0x10(%ebp),%eax
f010f48e:	8b 00                	mov    (%eax),%eax
f010f490:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f493:	eb 03                	jmp    f010f498 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010f495:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010f498:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f49b:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f49d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f4a0:	7d 1e                	jge    f010f4c0 <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010f4a2:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f4a5:	89 d0                	mov    %edx,%eax
f010f4a7:	01 c0                	add    %eax,%eax
f010f4a9:	01 d0                	add    %edx,%eax
f010f4ab:	c1 e0 02             	shl    $0x2,%eax
f010f4ae:	89 c2                	mov    %eax,%edx
f010f4b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010f4b3:	01 d0                	add    %edx,%eax
f010f4b5:	8a 40 04             	mov    0x4(%eax),%al
f010f4b8:	0f b6 c0             	movzbl %al,%eax
f010f4bb:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f4be:	75 d5                	jne    f010f495 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010f4c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4c3:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f4c6:	89 10                	mov    %edx,(%eax)
	}
}
f010f4c8:	90                   	nop
f010f4c9:	c9                   	leave  
f010f4ca:	c3                   	ret    

f010f4cb <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010f4cb:	55                   	push   %ebp
f010f4cc:	89 e5                	mov    %esp,%ebp
f010f4ce:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010f4d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4d4:	c7 00 44 0f 13 f0    	movl   $0xf0130f44,(%eax)
	info->eip_line = 0;
f010f4da:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4dd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010f4e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4e7:	c7 40 08 44 0f 13 f0 	movl   $0xf0130f44,0x8(%eax)
	info->eip_fn_namelen = 9;
f010f4ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4f1:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010f4f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4fb:	8b 55 08             	mov    0x8(%ebp),%edx
f010f4fe:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010f501:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f504:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010f50b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f50e:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010f513:	76 1e                	jbe    f010f533 <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010f515:	c7 45 f4 a4 61 13 f0 	movl   $0xf01361a4,-0xc(%ebp)
		stab_end = __STAB_END__;
f010f51c:	c7 45 f0 9c 36 16 f0 	movl   $0xf016369c,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010f523:	c7 45 ec 9d 36 16 f0 	movl   $0xf016369d,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010f52a:	c7 45 e8 a3 67 17 f0 	movl   $0xf01767a3,-0x18(%ebp)
f010f531:	eb 2a                	jmp    f010f55d <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010f533:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010f53a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f53d:	8b 00                	mov    (%eax),%eax
f010f53f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010f542:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f545:	8b 40 04             	mov    0x4(%eax),%eax
f010f548:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010f54b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f54e:	8b 40 08             	mov    0x8(%eax),%eax
f010f551:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010f554:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f557:	8b 40 0c             	mov    0xc(%eax),%eax
f010f55a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010f55d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f560:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f563:	76 0a                	jbe    f010f56f <debuginfo_eip+0xa4>
f010f565:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f568:	48                   	dec    %eax
f010f569:	8a 00                	mov    (%eax),%al
f010f56b:	84 c0                	test   %al,%al
f010f56d:	74 0a                	je     f010f579 <debuginfo_eip+0xae>
		return -1;
f010f56f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f574:	e9 01 02 00 00       	jmp    f010f77a <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010f579:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010f580:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f583:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f586:	29 c2                	sub    %eax,%edx
f010f588:	89 d0                	mov    %edx,%eax
f010f58a:	c1 f8 02             	sar    $0x2,%eax
f010f58d:	89 c2                	mov    %eax,%edx
f010f58f:	89 d0                	mov    %edx,%eax
f010f591:	c1 e0 02             	shl    $0x2,%eax
f010f594:	01 d0                	add    %edx,%eax
f010f596:	c1 e0 02             	shl    $0x2,%eax
f010f599:	01 d0                	add    %edx,%eax
f010f59b:	c1 e0 02             	shl    $0x2,%eax
f010f59e:	01 d0                	add    %edx,%eax
f010f5a0:	89 c1                	mov    %eax,%ecx
f010f5a2:	c1 e1 08             	shl    $0x8,%ecx
f010f5a5:	01 c8                	add    %ecx,%eax
f010f5a7:	89 c1                	mov    %eax,%ecx
f010f5a9:	c1 e1 10             	shl    $0x10,%ecx
f010f5ac:	01 c8                	add    %ecx,%eax
f010f5ae:	01 c0                	add    %eax,%eax
f010f5b0:	01 d0                	add    %edx,%eax
f010f5b2:	48                   	dec    %eax
f010f5b3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010f5b6:	ff 75 08             	pushl  0x8(%ebp)
f010f5b9:	6a 64                	push   $0x64
f010f5bb:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010f5be:	50                   	push   %eax
f010f5bf:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f5c2:	50                   	push   %eax
f010f5c3:	ff 75 f4             	pushl  -0xc(%ebp)
f010f5c6:	e8 b3 fd ff ff       	call   f010f37e <stab_binsearch>
f010f5cb:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010f5ce:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f5d1:	85 c0                	test   %eax,%eax
f010f5d3:	75 0a                	jne    f010f5df <debuginfo_eip+0x114>
		return -1;
f010f5d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f5da:	e9 9b 01 00 00       	jmp    f010f77a <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010f5df:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f5e2:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010f5e5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f5e8:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010f5eb:	ff 75 08             	pushl  0x8(%ebp)
f010f5ee:	6a 24                	push   $0x24
f010f5f0:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010f5f3:	50                   	push   %eax
f010f5f4:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010f5f7:	50                   	push   %eax
f010f5f8:	ff 75 f4             	pushl  -0xc(%ebp)
f010f5fb:	e8 7e fd ff ff       	call   f010f37e <stab_binsearch>
f010f600:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010f603:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010f606:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f609:	39 c2                	cmp    %eax,%edx
f010f60b:	0f 8f 86 00 00 00    	jg     f010f697 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010f611:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f614:	89 c2                	mov    %eax,%edx
f010f616:	89 d0                	mov    %edx,%eax
f010f618:	01 c0                	add    %eax,%eax
f010f61a:	01 d0                	add    %edx,%eax
f010f61c:	c1 e0 02             	shl    $0x2,%eax
f010f61f:	89 c2                	mov    %eax,%edx
f010f621:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f624:	01 d0                	add    %edx,%eax
f010f626:	8b 00                	mov    (%eax),%eax
f010f628:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f62b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f62e:	29 d1                	sub    %edx,%ecx
f010f630:	89 ca                	mov    %ecx,%edx
f010f632:	39 d0                	cmp    %edx,%eax
f010f634:	73 22                	jae    f010f658 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010f636:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f639:	89 c2                	mov    %eax,%edx
f010f63b:	89 d0                	mov    %edx,%eax
f010f63d:	01 c0                	add    %eax,%eax
f010f63f:	01 d0                	add    %edx,%eax
f010f641:	c1 e0 02             	shl    $0x2,%eax
f010f644:	89 c2                	mov    %eax,%edx
f010f646:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f649:	01 d0                	add    %edx,%eax
f010f64b:	8b 10                	mov    (%eax),%edx
f010f64d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f650:	01 c2                	add    %eax,%edx
f010f652:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f655:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010f658:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f65b:	89 c2                	mov    %eax,%edx
f010f65d:	89 d0                	mov    %edx,%eax
f010f65f:	01 c0                	add    %eax,%eax
f010f661:	01 d0                	add    %edx,%eax
f010f663:	c1 e0 02             	shl    $0x2,%eax
f010f666:	89 c2                	mov    %eax,%edx
f010f668:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f66b:	01 d0                	add    %edx,%eax
f010f66d:	8b 50 08             	mov    0x8(%eax),%edx
f010f670:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f673:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010f676:	8b 55 08             	mov    0x8(%ebp),%edx
f010f679:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f67c:	8b 40 10             	mov    0x10(%eax),%eax
f010f67f:	29 c2                	sub    %eax,%edx
f010f681:	89 d0                	mov    %edx,%eax
f010f683:	c1 f8 02             	sar    $0x2,%eax
f010f686:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010f689:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f68c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010f68f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f692:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010f695:	eb 15                	jmp    f010f6ac <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010f697:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f69a:	8b 55 08             	mov    0x8(%ebp),%edx
f010f69d:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010f6a0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f6a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010f6a6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f6a9:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010f6ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6af:	8b 40 08             	mov    0x8(%eax),%eax
f010f6b2:	83 ec 08             	sub    $0x8,%esp
f010f6b5:	6a 3a                	push   $0x3a
f010f6b7:	50                   	push   %eax
f010f6b8:	e8 82 b5 00 00       	call   f011ac3f <strfind>
f010f6bd:	83 c4 10             	add    $0x10,%esp
f010f6c0:	89 c2                	mov    %eax,%edx
f010f6c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6c5:	8b 40 08             	mov    0x8(%eax),%eax
f010f6c8:	29 c2                	sub    %eax,%edx
f010f6ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6cd:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f6d0:	eb 03                	jmp    f010f6d5 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010f6d2:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f6d5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f6d8:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f6db:	7c 4e                	jl     f010f72b <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010f6dd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f6e0:	89 d0                	mov    %edx,%eax
f010f6e2:	01 c0                	add    %eax,%eax
f010f6e4:	01 d0                	add    %edx,%eax
f010f6e6:	c1 e0 02             	shl    $0x2,%eax
f010f6e9:	89 c2                	mov    %eax,%edx
f010f6eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f6ee:	01 d0                	add    %edx,%eax
f010f6f0:	8a 40 04             	mov    0x4(%eax),%al
f010f6f3:	3c 84                	cmp    $0x84,%al
f010f6f5:	74 34                	je     f010f72b <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010f6f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f6fa:	89 d0                	mov    %edx,%eax
f010f6fc:	01 c0                	add    %eax,%eax
f010f6fe:	01 d0                	add    %edx,%eax
f010f700:	c1 e0 02             	shl    $0x2,%eax
f010f703:	89 c2                	mov    %eax,%edx
f010f705:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f708:	01 d0                	add    %edx,%eax
f010f70a:	8a 40 04             	mov    0x4(%eax),%al
f010f70d:	3c 64                	cmp    $0x64,%al
f010f70f:	75 c1                	jne    f010f6d2 <debuginfo_eip+0x207>
f010f711:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f714:	89 d0                	mov    %edx,%eax
f010f716:	01 c0                	add    %eax,%eax
f010f718:	01 d0                	add    %edx,%eax
f010f71a:	c1 e0 02             	shl    $0x2,%eax
f010f71d:	89 c2                	mov    %eax,%edx
f010f71f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f722:	01 d0                	add    %edx,%eax
f010f724:	8b 40 08             	mov    0x8(%eax),%eax
f010f727:	85 c0                	test   %eax,%eax
f010f729:	74 a7                	je     f010f6d2 <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010f72b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f72e:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f731:	7c 42                	jl     f010f775 <debuginfo_eip+0x2aa>
f010f733:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f736:	89 d0                	mov    %edx,%eax
f010f738:	01 c0                	add    %eax,%eax
f010f73a:	01 d0                	add    %edx,%eax
f010f73c:	c1 e0 02             	shl    $0x2,%eax
f010f73f:	89 c2                	mov    %eax,%edx
f010f741:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f744:	01 d0                	add    %edx,%eax
f010f746:	8b 00                	mov    (%eax),%eax
f010f748:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f74b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f74e:	29 d1                	sub    %edx,%ecx
f010f750:	89 ca                	mov    %ecx,%edx
f010f752:	39 d0                	cmp    %edx,%eax
f010f754:	73 1f                	jae    f010f775 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010f756:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f759:	89 d0                	mov    %edx,%eax
f010f75b:	01 c0                	add    %eax,%eax
f010f75d:	01 d0                	add    %edx,%eax
f010f75f:	c1 e0 02             	shl    $0x2,%eax
f010f762:	89 c2                	mov    %eax,%edx
f010f764:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f767:	01 d0                	add    %edx,%eax
f010f769:	8b 10                	mov    (%eax),%edx
f010f76b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f76e:	01 c2                	add    %eax,%edx
f010f770:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f773:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010f775:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f77a:	c9                   	leave  
f010f77b:	c3                   	ret    

f010f77c <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010f77c:	55                   	push   %ebp
f010f77d:	89 e5                	mov    %esp,%ebp
f010f77f:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010f782:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f786:	74 1c                	je     f010f7a4 <setPageReplacmentAlgorithmLRU+0x28>
f010f788:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f78c:	74 16                	je     f010f7a4 <setPageReplacmentAlgorithmLRU+0x28>
f010f78e:	68 50 0f 13 f0       	push   $0xf0130f50
f010f793:	68 9a 0f 13 f0       	push   $0xf0130f9a
f010f798:	6a 1a                	push   $0x1a
f010f79a:	68 af 0f 13 f0       	push   $0xf0130faf
f010f79f:	e8 0b 17 ff ff       	call   f0100eaf <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010f7a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7a7:	a3 c8 63 85 f0       	mov    %eax,0xf08563c8
}
f010f7ac:	90                   	nop
f010f7ad:	c9                   	leave  
f010f7ae:	c3                   	ret    

f010f7af <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010f7af:	55                   	push   %ebp
f010f7b0:	89 e5                	mov    %esp,%ebp
f010f7b2:	c7 05 c8 63 85 f0 03 	movl   $0x3,0xf08563c8
f010f7b9:	00 00 00 
f010f7bc:	90                   	nop
f010f7bd:	5d                   	pop    %ebp
f010f7be:	c3                   	ret    

f010f7bf <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010f7bf:	55                   	push   %ebp
f010f7c0:	89 e5                	mov    %esp,%ebp
f010f7c2:	c7 05 c8 63 85 f0 04 	movl   $0x4,0xf08563c8
f010f7c9:	00 00 00 
f010f7cc:	90                   	nop
f010f7cd:	5d                   	pop    %ebp
f010f7ce:	c3                   	ret    

f010f7cf <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010f7cf:	55                   	push   %ebp
f010f7d0:	89 e5                	mov    %esp,%ebp
f010f7d2:	c7 05 c8 63 85 f0 05 	movl   $0x5,0xf08563c8
f010f7d9:	00 00 00 
f010f7dc:	90                   	nop
f010f7dd:	5d                   	pop    %ebp
f010f7de:	c3                   	ret    

f010f7df <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010f7df:	55                   	push   %ebp
f010f7e0:	89 e5                	mov    %esp,%ebp
f010f7e2:	c7 05 c8 63 85 f0 07 	movl   $0x7,0xf08563c8
f010f7e9:	00 00 00 
f010f7ec:	90                   	nop
f010f7ed:	5d                   	pop    %ebp
f010f7ee:	c3                   	ret    

f010f7ef <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010f7ef:	55                   	push   %ebp
f010f7f0:	89 e5                	mov    %esp,%ebp
f010f7f2:	c7 05 c8 63 85 f0 06 	movl   $0x6,0xf08563c8
f010f7f9:	00 00 00 
f010f7fc:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7ff:	a3 14 de 83 f0       	mov    %eax,0xf083de14
f010f804:	90                   	nop
f010f805:	5d                   	pop    %ebp
f010f806:	c3                   	ret    

f010f807 <setFASTNchanceCLOCK>:
/*2024*/ void setFASTNchanceCLOCK(bool fast){ FASTNchanceCLOCK = fast; };
f010f807:	55                   	push   %ebp
f010f808:	89 e5                	mov    %esp,%ebp
f010f80a:	8b 45 08             	mov    0x8(%ebp),%eax
f010f80d:	a3 74 61 85 f0       	mov    %eax,0xf0856174
f010f812:	90                   	nop
f010f813:	5d                   	pop    %ebp
f010f814:	c3                   	ret    

f010f815 <setPageReplacmentAlgorithmOPTIMAL>:
/*2025*/ void setPageReplacmentAlgorithmOPTIMAL(){ _PageRepAlgoType = PG_REP_OPTIMAL; };
f010f815:	55                   	push   %ebp
f010f816:	89 e5                	mov    %esp,%ebp
f010f818:	c7 05 c8 63 85 f0 08 	movl   $0x8,0xf08563c8
f010f81f:	00 00 00 
f010f822:	90                   	nop
f010f823:	5d                   	pop    %ebp
f010f824:	c3                   	ret    

f010f825 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010f825:	55                   	push   %ebp
f010f826:	89 e5                	mov    %esp,%ebp
f010f828:	8b 15 c8 63 85 f0    	mov    0xf08563c8,%edx
f010f82e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f831:	39 c2                	cmp    %eax,%edx
f010f833:	0f 94 c0             	sete   %al
f010f836:	0f b6 c0             	movzbl %al,%eax
f010f839:	5d                   	pop    %ebp
f010f83a:	c3                   	ret    

f010f83b <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010f83b:	55                   	push   %ebp
f010f83c:	89 e5                	mov    %esp,%ebp
f010f83e:	a1 c8 63 85 f0       	mov    0xf08563c8,%eax
f010f843:	83 f8 03             	cmp    $0x3,%eax
f010f846:	75 07                	jne    f010f84f <isPageReplacmentAlgorithmCLOCK+0x14>
f010f848:	b8 01 00 00 00       	mov    $0x1,%eax
f010f84d:	eb 05                	jmp    f010f854 <isPageReplacmentAlgorithmCLOCK+0x19>
f010f84f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f854:	5d                   	pop    %ebp
f010f855:	c3                   	ret    

f010f856 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010f856:	55                   	push   %ebp
f010f857:	89 e5                	mov    %esp,%ebp
f010f859:	a1 c8 63 85 f0       	mov    0xf08563c8,%eax
f010f85e:	83 f8 04             	cmp    $0x4,%eax
f010f861:	75 07                	jne    f010f86a <isPageReplacmentAlgorithmFIFO+0x14>
f010f863:	b8 01 00 00 00       	mov    $0x1,%eax
f010f868:	eb 05                	jmp    f010f86f <isPageReplacmentAlgorithmFIFO+0x19>
f010f86a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f86f:	5d                   	pop    %ebp
f010f870:	c3                   	ret    

f010f871 <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010f871:	55                   	push   %ebp
f010f872:	89 e5                	mov    %esp,%ebp
f010f874:	a1 c8 63 85 f0       	mov    0xf08563c8,%eax
f010f879:	83 f8 05             	cmp    $0x5,%eax
f010f87c:	75 07                	jne    f010f885 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010f87e:	b8 01 00 00 00       	mov    $0x1,%eax
f010f883:	eb 05                	jmp    f010f88a <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010f885:	b8 00 00 00 00       	mov    $0x0,%eax
f010f88a:	5d                   	pop    %ebp
f010f88b:	c3                   	ret    

f010f88c <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010f88c:	55                   	push   %ebp
f010f88d:	89 e5                	mov    %esp,%ebp
f010f88f:	a1 c8 63 85 f0       	mov    0xf08563c8,%eax
f010f894:	83 f8 07             	cmp    $0x7,%eax
f010f897:	75 07                	jne    f010f8a0 <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010f899:	b8 01 00 00 00       	mov    $0x1,%eax
f010f89e:	eb 05                	jmp    f010f8a5 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010f8a0:	b8 00 00 00 00       	mov    $0x0,%eax
f010f8a5:	5d                   	pop    %ebp
f010f8a6:	c3                   	ret    

f010f8a7 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010f8a7:	55                   	push   %ebp
f010f8a8:	89 e5                	mov    %esp,%ebp
f010f8aa:	a1 c8 63 85 f0       	mov    0xf08563c8,%eax
f010f8af:	83 f8 06             	cmp    $0x6,%eax
f010f8b2:	75 07                	jne    f010f8bb <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010f8b4:	b8 01 00 00 00       	mov    $0x1,%eax
f010f8b9:	eb 05                	jmp    f010f8c0 <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010f8bb:	b8 00 00 00 00       	mov    $0x0,%eax
f010f8c0:	5d                   	pop    %ebp
f010f8c1:	c3                   	ret    

f010f8c2 <isPageReplacmentAlgorithmOPTIMAL>:
/*2021*/ uint32 isPageReplacmentAlgorithmOPTIMAL(){if(_PageRepAlgoType == PG_REP_OPTIMAL) return 1; return 0;}
f010f8c2:	55                   	push   %ebp
f010f8c3:	89 e5                	mov    %esp,%ebp
f010f8c5:	a1 c8 63 85 f0       	mov    0xf08563c8,%eax
f010f8ca:	83 f8 08             	cmp    $0x8,%eax
f010f8cd:	75 07                	jne    f010f8d6 <isPageReplacmentAlgorithmOPTIMAL+0x14>
f010f8cf:	b8 01 00 00 00       	mov    $0x1,%eax
f010f8d4:	eb 05                	jmp    f010f8db <isPageReplacmentAlgorithmOPTIMAL+0x19>
f010f8d6:	b8 00 00 00 00       	mov    $0x0,%eax
f010f8db:	5d                   	pop    %ebp
f010f8dc:	c3                   	ret    

f010f8dd <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010f8dd:	55                   	push   %ebp
f010f8de:	89 e5                	mov    %esp,%ebp
f010f8e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8e3:	a3 60 61 85 f0       	mov    %eax,0xf0856160
f010f8e8:	90                   	nop
f010f8e9:	5d                   	pop    %ebp
f010f8ea:	c3                   	ret    

f010f8eb <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010f8eb:	55                   	push   %ebp
f010f8ec:	89 e5                	mov    %esp,%ebp
f010f8ee:	a1 60 61 85 f0       	mov    0xf0856160,%eax
f010f8f3:	5d                   	pop    %ebp
f010f8f4:	c3                   	ret    

f010f8f5 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010f8f5:	55                   	push   %ebp
f010f8f6:	89 e5                	mov    %esp,%ebp
f010f8f8:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8fb:	a3 34 64 85 f0       	mov    %eax,0xf0856434
f010f900:	90                   	nop
f010f901:	5d                   	pop    %ebp
f010f902:	c3                   	ret    

f010f903 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010f903:	55                   	push   %ebp
f010f904:	89 e5                	mov    %esp,%ebp
f010f906:	a1 34 64 85 f0       	mov    0xf0856434,%eax
f010f90b:	5d                   	pop    %ebp
f010f90c:	c3                   	ret    

f010f90d <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010f90d:	55                   	push   %ebp
f010f90e:	89 e5                	mov    %esp,%ebp
f010f910:	8b 45 08             	mov    0x8(%ebp),%eax
f010f913:	a3 d0 64 85 f0       	mov    %eax,0xf08564d0
f010f918:	90                   	nop
f010f919:	5d                   	pop    %ebp
f010f91a:	c3                   	ret    

f010f91b <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010f91b:	55                   	push   %ebp
f010f91c:	89 e5                	mov    %esp,%ebp
f010f91e:	a1 d0 64 85 f0       	mov    0xf08564d0,%eax
f010f923:	5d                   	pop    %ebp
f010f924:	c3                   	ret    

f010f925 <fault_handler_init>:

//==================
// [0] INIT HANDLER:
//==================
void fault_handler_init()
{
f010f925:	55                   	push   %ebp
f010f926:	89 e5                	mov    %esp,%ebp
	//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
	//setPageReplacmentAlgorithmOPTIMAL();
	setPageReplacmentAlgorithmCLOCK();
f010f928:	e8 82 fe ff ff       	call   f010f7af <setPageReplacmentAlgorithmCLOCK>
	//setPageReplacmentAlgorithmModifiedCLOCK();
	enableBuffering(0);
f010f92d:	6a 00                	push   $0x0
f010f92f:	e8 c1 ff ff ff       	call   f010f8f5 <enableBuffering>
f010f934:	83 c4 04             	add    $0x4,%esp
	enableModifiedBuffer(0) ;
f010f937:	6a 00                	push   $0x0
f010f939:	e8 9f ff ff ff       	call   f010f8dd <enableModifiedBuffer>
f010f93e:	83 c4 04             	add    $0x4,%esp
	setModifiedBufferLength(1000);
f010f941:	68 e8 03 00 00       	push   $0x3e8
f010f946:	e8 c2 ff ff ff       	call   f010f90d <setModifiedBufferLength>
f010f94b:	83 c4 04             	add    $0x4,%esp
}
f010f94e:	90                   	nop
f010f94f:	c9                   	leave  
f010f950:	c3                   	ret    

f010f951 <fault_handler>:
int8 num_repeated_fault  = 0;
extern uint32 sys_calculate_free_frames() ;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010f951:	55                   	push   %ebp
f010f952:	89 e5                	mov    %esp,%ebp
f010f954:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f957:	0f 20 d0             	mov    %cr2,%eax
f010f95a:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010f95d:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010f960:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010f963:	e8 b3 c0 ff ff       	call   f010ba1b <get_cpu_proc>
f010f968:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010f96b:	a1 6c 5a 81 f0       	mov    0xf0815a6c,%eax
f010f970:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f973:	75 50                	jne    f010f9c5 <fault_handler+0x74>
f010f975:	a1 78 5a 81 f0       	mov    0xf0815a78,%eax
f010f97a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f97d:	75 46                	jne    f010f9c5 <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010f97f:	a0 74 5a 81 f0       	mov    0xf0815a74,%al
f010f984:	40                   	inc    %eax
f010f985:	a2 74 5a 81 f0       	mov    %al,0xf0815a74
		if (num_repeated_fault == 3)
f010f98a:	a0 74 5a 81 f0       	mov    0xf0815a74,%al
f010f98f:	3c 03                	cmp    $0x3,%al
f010f991:	75 4d                	jne    f010f9e0 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010f993:	83 ec 0c             	sub    $0xc,%esp
f010f996:	ff 75 08             	pushl  0x8(%ebp)
f010f999:	e8 42 e6 ff ff       	call   f010dfe0 <print_trapframe>
f010f99e:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010f9a1:	8b 15 68 5a 81 f0    	mov    0xf0815a68,%edx
f010f9a7:	a1 70 5a 81 f0       	mov    0xf0815a70,%eax
f010f9ac:	83 ec 08             	sub    $0x8,%esp
f010f9af:	ff 75 ec             	pushl  -0x14(%ebp)
f010f9b2:	52                   	push   %edx
f010f9b3:	50                   	push   %eax
f010f9b4:	68 cc 0f 13 f0       	push   $0xf0130fcc
f010f9b9:	6a 69                	push   $0x69
f010f9bb:	68 af 0f 13 f0       	push   $0xf0130faf
f010f9c0:	e8 ea 14 ff ff       	call   f0100eaf <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010f9c5:	a1 6c 5a 81 f0       	mov    0xf0815a6c,%eax
f010f9ca:	a3 70 5a 81 f0       	mov    %eax,0xf0815a70
		before_last_eip = last_eip;
f010f9cf:	a1 64 5a 81 f0       	mov    0xf0815a64,%eax
f010f9d4:	a3 68 5a 81 f0       	mov    %eax,0xf0815a68
		num_repeated_fault = 0;
f010f9d9:	c6 05 74 5a 81 f0 00 	movb   $0x0,0xf0815a74
	}
	last_eip = (uint32)tf->tf_eip;
f010f9e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9e3:	8b 40 30             	mov    0x30(%eax),%eax
f010f9e6:	a3 64 5a 81 f0       	mov    %eax,0xf0815a64
	last_fault_va = fault_va ;
f010f9eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f9ee:	a3 6c 5a 81 f0       	mov    %eax,0xf0815a6c
	last_faulted_env = cur_env;
f010f9f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f9f6:	a3 78 5a 81 f0       	mov    %eax,0xf0815a78
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010f9fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010fa02:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa05:	8b 40 34             	mov    0x34(%eax),%eax
f010fa08:	0f b7 c0             	movzwl %ax,%eax
f010fa0b:	83 e0 03             	and    $0x3,%eax
f010fa0e:	83 f8 03             	cmp    $0x3,%eax
f010fa11:	75 07                	jne    f010fa1a <fault_handler+0xc9>
		userTrap = 1;
f010fa13:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010fa1a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fa1e:	0f 85 cb 00 00 00    	jne    f010faef <fault_handler+0x19e>
	{
		struct cpu* c = mycpu();
f010fa24:	e8 47 85 ff ff       	call   f0107f70 <mycpu>
f010fa29:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010fa2c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010fa30:	74 32                	je     f010fa64 <fault_handler+0x113>
f010fa32:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fa35:	8b 40 70             	mov    0x70(%eax),%eax
f010fa38:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa3b:	77 27                	ja     f010fa64 <fault_handler+0x113>
f010fa3d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fa40:	8b 40 70             	mov    0x70(%eax),%eax
f010fa43:	05 00 10 00 00       	add    $0x1000,%eax
f010fa48:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa4b:	76 17                	jbe    f010fa64 <fault_handler+0x113>
			panic("User Kernel Stack: overflow exception!");
f010fa4d:	83 ec 04             	sub    $0x4,%esp
f010fa50:	68 3c 10 13 f0       	push   $0xf013103c
f010fa55:	68 80 00 00 00       	push   $0x80
f010fa5a:	68 af 0f 13 f0       	push   $0xf0130faf
f010fa5f:	e8 4b 14 ff ff       	call   f0100eaf <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010fa64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa67:	8b 40 08             	mov    0x8(%eax),%eax
f010fa6a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa6d:	77 60                	ja     f010facf <fault_handler+0x17e>
f010fa6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa72:	8b 40 08             	mov    0x8(%eax),%eax
f010fa75:	05 00 10 00 00       	add    $0x1000,%eax
f010fa7a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa7d:	76 50                	jbe    f010facf <fault_handler+0x17e>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010fa7f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa82:	ba 60 df 83 f0       	mov    $0xf083df60,%edx
f010fa87:	29 d0                	sub    %edx,%eax
f010fa89:	c1 f8 03             	sar    $0x3,%eax
f010fa8c:	89 c2                	mov    %eax,%edx
f010fa8e:	89 d0                	mov    %edx,%eax
f010fa90:	c1 e0 02             	shl    $0x2,%eax
f010fa93:	01 d0                	add    %edx,%eax
f010fa95:	01 c0                	add    %eax,%eax
f010fa97:	01 d0                	add    %edx,%eax
f010fa99:	c1 e0 03             	shl    $0x3,%eax
f010fa9c:	01 d0                	add    %edx,%eax
f010fa9e:	89 c1                	mov    %eax,%ecx
f010faa0:	c1 e1 0b             	shl    $0xb,%ecx
f010faa3:	01 c8                	add    %ecx,%eax
f010faa5:	c1 e0 05             	shl    $0x5,%eax
f010faa8:	01 d0                	add    %edx,%eax
f010faaa:	c1 e0 02             	shl    $0x2,%eax
f010faad:	01 d0                	add    %edx,%eax
f010faaf:	01 c0                	add    %eax,%eax
f010fab1:	01 d0                	add    %edx,%eax
f010fab3:	c1 e0 03             	shl    $0x3,%eax
f010fab6:	01 d0                	add    %edx,%eax
f010fab8:	f7 d8                	neg    %eax
f010faba:	50                   	push   %eax
f010fabb:	68 64 10 13 f0       	push   $0xf0131064
f010fac0:	68 82 00 00 00       	push   $0x82
f010fac5:	68 af 0f 13 f0       	push   $0xf0130faf
f010faca:	e8 e0 13 ff ff       	call   f0100eaf <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010facf:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010fad6:	76 40                	jbe    f010fb18 <fault_handler+0x1c7>
			panic("Kernel: heap overflow exception!");
f010fad8:	83 ec 04             	sub    $0x4,%esp
f010fadb:	68 98 10 13 f0       	push   $0xf0131098
f010fae0:	68 85 00 00 00       	push   $0x85
f010fae5:	68 af 0f 13 f0       	push   $0xf0130faf
f010faea:	e8 c0 13 ff ff       	call   f0100eaf <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010faef:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010faf6:	76 20                	jbe    f010fb18 <fault_handler+0x1c7>
f010faf8:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010faff:	77 17                	ja     f010fb18 <fault_handler+0x1c7>
			panic("User: stack underflow exception!");
f010fb01:	83 ec 04             	sub    $0x4,%esp
f010fb04:	68 bc 10 13 f0       	push   $0xf01310bc
f010fb09:	68 8d 00 00 00       	push   $0x8d
f010fb0e:	68 af 0f 13 f0       	push   $0xf0130faf
f010fb13:	e8 97 13 ff ff       	call   f0100eaf <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010fb18:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fb1b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010fb1e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fb22:	75 38                	jne    f010fb5c <fault_handler+0x20b>
	{
		cprintf("\nFaulted VA = %x\n", fault_va);
f010fb24:	83 ec 08             	sub    $0x8,%esp
f010fb27:	ff 75 ec             	pushl  -0x14(%ebp)
f010fb2a:	68 dd 10 13 f0       	push   $0xf01310dd
f010fb2f:	e8 28 20 ff ff       	call   f0101b5c <cprintf>
f010fb34:	83 c4 10             	add    $0x10,%esp
		print_trapframe(tf);
f010fb37:	83 ec 0c             	sub    $0xc,%esp
f010fb3a:	ff 75 08             	pushl  0x8(%ebp)
f010fb3d:	e8 9e e4 ff ff       	call   f010dfe0 <print_trapframe>
f010fb42:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010fb45:	83 ec 04             	sub    $0x4,%esp
f010fb48:	68 ef 10 13 f0       	push   $0xf01310ef
f010fb4d:	68 97 00 00 00       	push   $0x97
f010fb52:	68 af 0f 13 f0       	push   $0xf0130faf
f010fb57:	e8 53 13 ff ff       	call   f0100eaf <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010fb5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fb5f:	8b 40 64             	mov    0x64(%eax),%eax
f010fb62:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fb65:	c1 ea 16             	shr    $0x16,%edx
f010fb68:	c1 e2 02             	shl    $0x2,%edx
f010fb6b:	01 d0                	add    %edx,%eax
f010fb6d:	8b 00                	mov    (%eax),%eax
f010fb6f:	83 e0 01             	and    $0x1,%eax
f010fb72:	85 c0                	test   %eax,%eax
f010fb74:	75 28                	jne    f010fb9e <fault_handler+0x24d>
	{
		faulted_env->tableFaultsCounter ++ ;
f010fb76:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fb79:	8b 80 9c 05 00 00    	mov    0x59c(%eax),%eax
f010fb7f:	8d 50 01             	lea    0x1(%eax),%edx
f010fb82:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fb85:	89 90 9c 05 00 00    	mov    %edx,0x59c(%eax)
		table_fault_handler(faulted_env, fault_va);
f010fb8b:	83 ec 08             	sub    $0x8,%esp
f010fb8e:	ff 75 ec             	pushl  -0x14(%ebp)
f010fb91:	ff 75 e0             	pushl  -0x20(%ebp)
f010fb94:	e8 8f 00 00 00       	call   f010fc28 <table_fault_handler>
f010fb99:	83 c4 10             	add    $0x10,%esp
f010fb9c:	eb 7b                	jmp    f010fc19 <fault_handler+0x2c8>

			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010fb9e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fba1:	8b 40 64             	mov    0x64(%eax),%eax
f010fba4:	83 ec 08             	sub    $0x8,%esp
f010fba7:	ff 75 ec             	pushl  -0x14(%ebp)
f010fbaa:	50                   	push   %eax
f010fbab:	e8 17 a1 ff ff       	call   f0109cc7 <pt_get_page_permissions>
f010fbb0:	83 c4 10             	add    $0x10,%esp
f010fbb3:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010fbb6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fbb9:	83 e0 01             	and    $0x1,%eax
f010fbbc:	85 c0                	test   %eax,%eax
f010fbbe:	74 17                	je     f010fbd7 <fault_handler+0x286>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010fbc0:	ff 75 ec             	pushl  -0x14(%ebp)
f010fbc3:	68 04 11 13 f0       	push   $0xf0131104
f010fbc8:	68 af 00 00 00       	push   $0xaf
f010fbcd:	68 af 0f 13 f0       	push   $0xf0130faf
f010fbd2:	e8 d8 12 ff ff       	call   f0100eaf <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010fbd7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fbda:	8b 80 98 05 00 00    	mov    0x598(%eax),%eax
f010fbe0:	8d 50 01             	lea    0x1(%eax),%edx
f010fbe3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fbe6:	89 90 98 05 00 00    	mov    %edx,0x598(%eax)
//				cprintf("[%08s] user PAGE fault va %08x\n", faulted_env->prog_name, fault_va);
//				cprintf("\nPage working set BEFORE fault handler...\n");
//				env_page_ws_print(faulted_env);
		//int ffb = sys_calculate_free_frames();

		if(isBufferingEnabled())
f010fbec:	e8 12 fd ff ff       	call   f010f903 <isBufferingEnabled>
f010fbf1:	84 c0                	test   %al,%al
f010fbf3:	74 13                	je     f010fc08 <fault_handler+0x2b7>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010fbf5:	83 ec 08             	sub    $0x8,%esp
f010fbf8:	ff 75 ec             	pushl  -0x14(%ebp)
f010fbfb:	ff 75 e0             	pushl  -0x20(%ebp)
f010fbfe:	e8 2c 01 00 00       	call   f010fd2f <__page_fault_handler_with_buffering>
f010fc03:	83 c4 10             	add    $0x10,%esp
f010fc06:	eb 11                	jmp    f010fc19 <fault_handler+0x2c8>
		}
		else
		{
			page_fault_handler(faulted_env, fault_va);
f010fc08:	83 ec 08             	sub    $0x8,%esp
f010fc0b:	ff 75 ec             	pushl  -0x14(%ebp)
f010fc0e:	ff 75 e0             	pushl  -0x20(%ebp)
f010fc11:	e8 50 00 00 00       	call   f010fc66 <page_fault_handler>
f010fc16:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010fc19:	0f 20 d8             	mov    %cr3,%eax
f010fc1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010fc1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fc22:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010fc25:	90                   	nop
f010fc26:	c9                   	leave  
f010fc27:	c3                   	ret    

f010fc28 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010fc28:	55                   	push   %ebp
f010fc29:	89 e5                	mov    %esp,%ebp
f010fc2b:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010fc2e:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc31:	8b 40 64             	mov    0x64(%eax),%eax
f010fc34:	83 ec 08             	sub    $0x8,%esp
f010fc37:	ff 75 0c             	pushl  0xc(%ebp)
f010fc3a:	50                   	push   %eax
f010fc3b:	e8 6c 97 ff ff       	call   f01093ac <create_page_table>
f010fc40:	83 c4 10             	add    $0x10,%esp
f010fc43:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010fc46:	90                   	nop
f010fc47:	c9                   	leave  
f010fc48:	c3                   	ret    

f010fc49 <get_optimal_num_faults>:
 * 	3. Page References List (contains the stream of referenced VAs till the process finished)
 *
 * 	IMPORTANT: This function SHOULD NOT change any of the given lists
 */
int get_optimal_num_faults(struct WS_List *initWorkingSet, int maxWSSize, struct PageRef_List *pageReferences)
{
f010fc49:	55                   	push   %ebp
f010fc4a:	89 e5                	mov    %esp,%ebp
f010fc4c:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #2 get_optimal_num_faults
	//Your code is here
	//Comment the following line
	panic("get_optimal_num_faults() is not implemented yet...!!");
f010fc4f:	83 ec 04             	sub    $0x4,%esp
f010fc52:	68 48 11 13 f0       	push   $0xf0131148
f010fc57:	68 f4 00 00 00       	push   $0xf4
f010fc5c:	68 af 0f 13 f0       	push   $0xf0130faf
f010fc61:	e8 49 12 ff ff       	call   f0100eaf <_panic>

f010fc66 <page_fault_handler>:
}

void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010fc66:	55                   	push   %ebp
f010fc67:	89 e5                	mov    %esp,%ebp
f010fc69:	83 ec 18             	sub    $0x18,%esp
#if USE_KHEAP
	struct WorkingSetElement *victimWSElement = NULL;
f010fc6c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010fc73:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc76:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010fc7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
	int iWS =faulted_env->page_last_WS_index;
	uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif
	if(wsSize < (faulted_env->page_WS_max_size))
f010fc7f:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc82:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010fc88:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010fc8b:	76 17                	jbe    f010fca4 <page_fault_handler+0x3e>
	{
		//TODO: [PROJECT'25.GM#3] FAULT HANDLER I - #3 placement
		//Your code is here
		//Comment the following line
		panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
f010fc8d:	83 ec 04             	sub    $0x4,%esp
f010fc90:	68 80 11 13 f0       	push   $0xf0131180
f010fc95:	68 05 01 00 00       	push   $0x105
f010fc9a:	68 af 0f 13 f0       	push   $0xf0130faf
f010fc9f:	e8 0b 12 ff ff       	call   f0100eaf <_panic>
	}
	else
	{
		if (isPageReplacmentAlgorithmOPTIMAL())
f010fca4:	e8 19 fc ff ff       	call   f010f8c2 <isPageReplacmentAlgorithmOPTIMAL>
f010fca9:	85 c0                	test   %eax,%eax
f010fcab:	74 17                	je     f010fcc4 <page_fault_handler+0x5e>
		{
			//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #1 Optimal Reference Stream
			//Your code is here
			//Comment the following line
			panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
f010fcad:	83 ec 04             	sub    $0x4,%esp
f010fcb0:	68 bc 11 13 f0       	push   $0xf01311bc
f010fcb5:	68 0e 01 00 00       	push   $0x10e
f010fcba:	68 af 0f 13 f0       	push   $0xf0130faf
f010fcbf:	e8 eb 11 ff ff       	call   f0100eaf <_panic>
		}
		else if (isPageReplacmentAlgorithmOPTIMAL())
f010fcc4:	e8 f9 fb ff ff       	call   f010f8c2 <isPageReplacmentAlgorithmOPTIMAL>
f010fcc9:	85 c0                	test   %eax,%eax
f010fccb:	74 17                	je     f010fce4 <page_fault_handler+0x7e>
		{
			//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #3 Clock Replacement
			//Your code is here
			//Comment the following line
			panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
f010fccd:	83 ec 04             	sub    $0x4,%esp
f010fcd0:	68 bc 11 13 f0       	push   $0xf01311bc
f010fcd5:	68 15 01 00 00       	push   $0x115
f010fcda:	68 af 0f 13 f0       	push   $0xf0130faf
f010fcdf:	e8 cb 11 ff ff       	call   f0100eaf <_panic>
		}
		else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010fce4:	83 ec 0c             	sub    $0xc,%esp
f010fce7:	6a 01                	push   $0x1
f010fce9:	e8 37 fb ff ff       	call   f010f825 <isPageReplacmentAlgorithmLRU>
f010fcee:	83 c4 10             	add    $0x10,%esp
f010fcf1:	85 c0                	test   %eax,%eax
f010fcf3:	74 17                	je     f010fd0c <page_fault_handler+0xa6>
		{
			//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #2 LRU Aging Replacement
			//Your code is here
			//Comment the following line
			panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
f010fcf5:	83 ec 04             	sub    $0x4,%esp
f010fcf8:	68 bc 11 13 f0       	push   $0xf01311bc
f010fcfd:	68 1c 01 00 00       	push   $0x11c
f010fd02:	68 af 0f 13 f0       	push   $0xf0130faf
f010fd07:	e8 a3 11 ff ff       	call   f0100eaf <_panic>
		}
		else if (isPageReplacmentAlgorithmModifiedCLOCK())
f010fd0c:	e8 60 fb ff ff       	call   f010f871 <isPageReplacmentAlgorithmModifiedCLOCK>
f010fd11:	85 c0                	test   %eax,%eax
f010fd13:	74 17                	je     f010fd2c <page_fault_handler+0xc6>
		{
			//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #3 Modified Clock Replacement
			//Your code is here
			//Comment the following line
			panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
f010fd15:	83 ec 04             	sub    $0x4,%esp
f010fd18:	68 bc 11 13 f0       	push   $0xf01311bc
f010fd1d:	68 23 01 00 00       	push   $0x123
f010fd22:	68 af 0f 13 f0       	push   $0xf0130faf
f010fd27:	e8 83 11 ff ff       	call   f0100eaf <_panic>
		}
	}
}
f010fd2c:	90                   	nop
f010fd2d:	c9                   	leave  
f010fd2e:	c3                   	ret    

f010fd2f <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010fd2f:	55                   	push   %ebp
f010fd30:	89 e5                	mov    %esp,%ebp
f010fd32:	83 ec 08             	sub    $0x8,%esp
	panic("this function is not required...!!");
f010fd35:	83 ec 04             	sub    $0x4,%esp
f010fd38:	68 fc 11 13 f0       	push   $0xf01311fc
f010fd3d:	68 2a 01 00 00       	push   $0x12a
f010fd42:	68 af 0f 13 f0       	push   $0xf0130faf
f010fd47:	e8 63 11 ff ff       	call   f0100eaf <_panic>

f010fd4c <init_kspinlock>:
#include "inc/assert.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_kspinlock(struct kspinlock *lk, char *name)
{
f010fd4c:	55                   	push   %ebp
f010fd4d:	89 e5                	mov    %esp,%ebp
f010fd4f:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010fd52:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd55:	83 c0 04             	add    $0x4,%eax
f010fd58:	83 ec 08             	sub    $0x8,%esp
f010fd5b:	ff 75 0c             	pushl  0xc(%ebp)
f010fd5e:	50                   	push   %eax
f010fd5f:	e8 68 ad 00 00       	call   f011aacc <strcpy>
f010fd64:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010fd67:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd6a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010fd70:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd73:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010fd7a:	90                   	nop
f010fd7b:	c9                   	leave  
f010fd7c:	c3                   	ret    

f010fd7d <acquire_kspinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_kspinlock(struct kspinlock *lk)
{
f010fd7d:	55                   	push   %ebp
f010fd7e:	89 e5                	mov    %esp,%ebp
f010fd80:	53                   	push   %ebx
f010fd81:	83 ec 24             	sub    $0x24,%esp
	if(holding_kspinlock(lk))
f010fd84:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd87:	83 ec 0c             	sub    $0xc,%esp
f010fd8a:	50                   	push   %eax
f010fd8b:	e8 42 02 00 00       	call   f010ffd2 <holding_kspinlock>
f010fd90:	83 c4 10             	add    $0x10,%esp
f010fd93:	85 c0                	test   %eax,%eax
f010fd95:	74 18                	je     f010fdaf <acquire_kspinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010fd97:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd9a:	83 c0 04             	add    $0x4,%eax
f010fd9d:	50                   	push   %eax
f010fd9e:	68 20 12 13 f0       	push   $0xf0131220
f010fda3:	6a 1f                	push   $0x1f
f010fda5:	68 5d 12 13 f0       	push   $0xf013125d
f010fdaa:	e8 00 11 ff ff       	call   f0100eaf <_panic>

	/*disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler)
	 * just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
	 */
	pushcli();
f010fdaf:	e8 7f 82 ff ff       	call   f0108033 <pushcli>

	int envID = 0;
f010fdb4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *e = get_cpu_proc() ;
f010fdbb:	e8 5b bc ff ff       	call   f010ba1b <get_cpu_proc>
f010fdc0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (e) envID = e->env_id;
f010fdc3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fdc7:	74 09                	je     f010fdd2 <acquire_kspinlock+0x55>
f010fdc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fdcc:	8b 40 10             	mov    0x10(%eax),%eax
f010fdcf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%d] try to acquire spinlock [%s]\n", envID, lk->name);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010fdd2:	90                   	nop
f010fdd3:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdd6:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fdd9:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010fde0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fde3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fde6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010fde9:	f0 87 02             	lock xchg %eax,(%edx)
f010fdec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010fdef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fdf2:	85 c0                	test   %eax,%eax
f010fdf4:	75 dd                	jne    f010fdd3 <acquire_kspinlock+0x56>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, envID);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010fdf6:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010fdfb:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010fdfe:	e8 6d 81 ff ff       	call   f0107f70 <mycpu>
f010fe03:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010fe06:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe09:	83 c0 48             	add    $0x48,%eax
f010fe0c:	83 ec 08             	sub    $0x8,%esp
f010fe0f:	50                   	push   %eax
f010fe10:	8d 45 08             	lea    0x8(%ebp),%eax
f010fe13:	50                   	push   %eax
f010fe14:	e8 92 00 00 00       	call   f010feab <getcallerpcs>
f010fe19:	83 c4 10             	add    $0x10,%esp

}
f010fe1c:	90                   	nop
f010fe1d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010fe20:	c9                   	leave  
f010fe21:	c3                   	ret    

f010fe22 <release_kspinlock>:

// Release the lock.
void release_kspinlock(struct kspinlock *lk)
{
f010fe22:	55                   	push   %ebp
f010fe23:	89 e5                	mov    %esp,%ebp
f010fe25:	83 ec 18             	sub    $0x18,%esp
	if(!holding_kspinlock(lk))
f010fe28:	83 ec 0c             	sub    $0xc,%esp
f010fe2b:	ff 75 08             	pushl  0x8(%ebp)
f010fe2e:	e8 9f 01 00 00       	call   f010ffd2 <holding_kspinlock>
f010fe33:	83 c4 10             	add    $0x10,%esp
f010fe36:	85 c0                	test   %eax,%eax
f010fe38:	75 26                	jne    f010fe60 <release_kspinlock+0x3e>
	{
		printcallstack(lk);
f010fe3a:	83 ec 0c             	sub    $0xc,%esp
f010fe3d:	ff 75 08             	pushl  0x8(%ebp)
f010fe40:	e8 26 01 00 00       	call   f010ff6b <printcallstack>
f010fe45:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010fe48:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe4b:	83 c0 04             	add    $0x4,%eax
f010fe4e:	50                   	push   %eax
f010fe4f:	68 74 12 13 f0       	push   $0xf0131274
f010fe54:	6a 41                	push   $0x41
f010fe56:	68 5d 12 13 f0       	push   $0xf013125d
f010fe5b:	e8 4f 10 ff ff       	call   f0100eaf <_panic>
	}
	lk->pcs[0] = 0;
f010fe60:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe63:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010fe6a:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe6d:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010fe74:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010fe79:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe7c:	8b 55 08             	mov    0x8(%ebp),%edx
f010fe7f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	int envID = 0;
f010fe85:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *e = get_cpu_proc() ;
f010fe8c:	e8 8a bb ff ff       	call   f010ba1b <get_cpu_proc>
f010fe91:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (e) envID = e->env_id;
f010fe94:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fe98:	74 09                	je     f010fea3 <release_kspinlock+0x81>
f010fe9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fe9d:	8b 40 10             	mov    0x10(%eax),%eax
f010fea0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%d] release spinlock [%s]\n", envID, lk->name);

	popcli();
f010fea3:	e8 dd 81 ff ff       	call   f0108085 <popcli>

}
f010fea8:	90                   	nop
f010fea9:	c9                   	leave  
f010feaa:	c3                   	ret    

f010feab <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010feab:	55                   	push   %ebp
f010feac:	89 e5                	mov    %esp,%ebp
f010feae:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010feb1:	e8 65 bb ff ff       	call   f010ba1b <get_cpu_proc>
f010feb6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010feb9:	e8 b2 80 ff ff       	call   f0107f70 <mycpu>
f010febe:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010fec1:	8b 45 08             	mov    0x8(%ebp),%eax
f010fec4:	83 e8 08             	sub    $0x8,%eax
f010fec7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010feca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010fed1:	eb 67                	jmp    f010ff3a <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010fed3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fed7:	74 67                	je     f010ff40 <getcallerpcs+0x95>
f010fed9:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010fee0:	76 5e                	jbe    f010ff40 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fee2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fee5:	8b 40 08             	mov    0x8(%eax),%eax
f010fee8:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010feed:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fef0:	77 10                	ja     f010ff02 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fef2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fef5:	8b 40 08             	mov    0x8(%eax),%eax
f010fef8:	05 00 90 00 00       	add    $0x9000,%eax
f010fefd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ff00:	77 3e                	ja     f010ff40 <getcallerpcs+0x95>
f010ff02:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ff06:	74 10                	je     f010ff18 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010ff08:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ff0b:	8b 40 70             	mov    0x70(%eax),%eax
f010ff0e:	05 00 80 00 00       	add    $0x8000,%eax
f010ff13:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ff16:	76 28                	jbe    f010ff40 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010ff18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ff1b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ff22:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff25:	01 c2                	add    %eax,%edx
f010ff27:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ff2a:	8b 40 04             	mov    0x4(%eax),%eax
f010ff2d:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010ff2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ff32:	8b 00                	mov    (%eax),%eax
f010ff34:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010ff37:	ff 45 f0             	incl   -0x10(%ebp)
f010ff3a:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010ff3e:	7e 93                	jle    f010fed3 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010ff40:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ff43:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010ff46:	eb 18                	jmp    f010ff60 <getcallerpcs+0xb5>
		pcs[i] = 0;
f010ff48:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ff4b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ff52:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff55:	01 d0                	add    %edx,%eax
f010ff57:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010ff5d:	ff 45 f0             	incl   -0x10(%ebp)
f010ff60:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010ff64:	7e e2                	jle    f010ff48 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010ff66:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010ff69:	c9                   	leave  
f010ff6a:	c3                   	ret    

f010ff6b <printcallstack>:

void printcallstack(struct kspinlock *lk)
{
f010ff6b:	55                   	push   %ebp
f010ff6c:	89 e5                	mov    %esp,%ebp
f010ff6e:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010ff71:	83 ec 0c             	sub    $0xc,%esp
f010ff74:	68 b2 12 13 f0       	push   $0xf01312b2
f010ff79:	e8 de 1b ff ff       	call   f0101b5c <cprintf>
f010ff7e:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010ff81:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff84:	83 c0 48             	add    $0x48,%eax
f010ff87:	83 ec 08             	sub    $0x8,%esp
f010ff8a:	50                   	push   %eax
f010ff8b:	8d 45 08             	lea    0x8(%ebp),%eax
f010ff8e:	50                   	push   %eax
f010ff8f:	e8 17 ff ff ff       	call   f010feab <getcallerpcs>
f010ff94:	83 c4 10             	add    $0x10,%esp
f010ff97:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010ff9a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ffa1:	eb 24                	jmp    f010ffc7 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010ffa3:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffa6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ffa9:	83 c2 10             	add    $0x10,%edx
f010ffac:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010ffb0:	83 ec 04             	sub    $0x4,%esp
f010ffb3:	50                   	push   %eax
f010ffb4:	ff 75 f4             	pushl  -0xc(%ebp)
f010ffb7:	68 c2 12 13 f0       	push   $0xf01312c2
f010ffbc:	e8 9b 1b ff ff       	call   f0101b5c <cprintf>
f010ffc1:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct kspinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010ffc4:	ff 45 f4             	incl   -0xc(%ebp)
f010ffc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ffca:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ffcd:	7c d4                	jl     f010ffa3 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010ffcf:	90                   	nop
f010ffd0:	c9                   	leave  
f010ffd1:	c3                   	ret    

f010ffd2 <holding_kspinlock>:
// Check whether this cpu is holding the lock.
int holding_kspinlock(struct kspinlock *lock)
{
f010ffd2:	55                   	push   %ebp
f010ffd3:	89 e5                	mov    %esp,%ebp
f010ffd5:	53                   	push   %ebx
f010ffd6:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010ffd9:	e8 55 80 ff ff       	call   f0108033 <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010ffde:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffe1:	8b 00                	mov    (%eax),%eax
f010ffe3:	85 c0                	test   %eax,%eax
f010ffe5:	74 16                	je     f010fffd <holding_kspinlock+0x2b>
f010ffe7:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffea:	8b 58 44             	mov    0x44(%eax),%ebx
f010ffed:	e8 7e 7f ff ff       	call   f0107f70 <mycpu>
f010fff2:	39 c3                	cmp    %eax,%ebx
f010fff4:	75 07                	jne    f010fffd <holding_kspinlock+0x2b>
f010fff6:	b8 01 00 00 00       	mov    $0x1,%eax
f010fffb:	eb 05                	jmp    f0110002 <holding_kspinlock+0x30>
f010fffd:	b8 00 00 00 00       	mov    $0x0,%eax
f0110002:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f0110005:	e8 7b 80 ff ff       	call   f0108085 <popcli>
	return r;
f011000a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011000d:	83 c4 14             	add    $0x14,%esp
f0110010:	5b                   	pop    %ebx
f0110011:	5d                   	pop    %ebp
f0110012:	c3                   	ret    

f0110013 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f0110013:	55                   	push   %ebp
f0110014:	89 e5                	mov    %esp,%ebp
f0110016:	57                   	push   %edi
f0110017:	56                   	push   %esi
f0110018:	53                   	push   %ebx
f0110019:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	init_channel(&(lk->chan), "sleep lock channel");
f011001f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110022:	83 c0 74             	add    $0x74,%eax
f0110025:	83 ec 08             	sub    $0x8,%esp
f0110028:	68 d4 12 13 f0       	push   $0xf01312d4
f011002d:	50                   	push   %eax
f011002e:	e8 22 01 00 00       	call   f0110155 <init_channel>
f0110033:	83 c4 10             	add    $0x10,%esp
	char prefix[30] = "lock of sleeplock - ";
f0110036:	8d 45 ca             	lea    -0x36(%ebp),%eax
f0110039:	bb e7 12 13 f0       	mov    $0xf01312e7,%ebx
f011003e:	ba 15 00 00 00       	mov    $0x15,%edx
f0110043:	89 c7                	mov    %eax,%edi
f0110045:	89 de                	mov    %ebx,%esi
f0110047:	89 d1                	mov    %edx,%ecx
f0110049:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011004b:	8d 55 df             	lea    -0x21(%ebp),%edx
f011004e:	b9 09 00 00 00       	mov    $0x9,%ecx
f0110053:	b0 00                	mov    $0x0,%al
f0110055:	89 d7                	mov    %edx,%edi
f0110057:	f3 aa                	rep stos %al,%es:(%edi)
	char guardName[30+NAMELEN];
	strcconcat(prefix, name, guardName);
f0110059:	83 ec 04             	sub    $0x4,%esp
f011005c:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0110062:	50                   	push   %eax
f0110063:	ff 75 0c             	pushl  0xc(%ebp)
f0110066:	8d 45 ca             	lea    -0x36(%ebp),%eax
f0110069:	50                   	push   %eax
f011006a:	e8 3c b0 00 00       	call   f011b0ab <strcconcat>
f011006f:	83 c4 10             	add    $0x10,%esp
	init_kspinlock(&(lk->lk), guardName);
f0110072:	8b 45 08             	mov    0x8(%ebp),%eax
f0110075:	8d 50 04             	lea    0x4(%eax),%edx
f0110078:	83 ec 08             	sub    $0x8,%esp
f011007b:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0110081:	50                   	push   %eax
f0110082:	52                   	push   %edx
f0110083:	e8 c4 fc ff ff       	call   f010fd4c <init_kspinlock>
f0110088:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f011008b:	8b 45 08             	mov    0x8(%ebp),%eax
f011008e:	05 c4 00 00 00       	add    $0xc4,%eax
f0110093:	83 ec 08             	sub    $0x8,%esp
f0110096:	ff 75 0c             	pushl  0xc(%ebp)
f0110099:	50                   	push   %eax
f011009a:	e8 2d aa 00 00       	call   f011aacc <strcpy>
f011009f:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f01100a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01100a5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f01100ab:	8b 45 08             	mov    0x8(%ebp),%eax
f01100ae:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f01100b5:	00 00 00 
}
f01100b8:	90                   	nop
f01100b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01100bc:	5b                   	pop    %ebx
f01100bd:	5e                   	pop    %esi
f01100be:	5f                   	pop    %edi
f01100bf:	5d                   	pop    %ebp
f01100c0:	c3                   	ret    

f01100c1 <acquire_sleeplock>:

void acquire_sleeplock(struct sleeplock *lk)
{
f01100c1:	55                   	push   %ebp
f01100c2:	89 e5                	mov    %esp,%ebp
f01100c4:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #4 SLEEP LOCK - acquire_sleeplock
	//Your code is here
	//Comment the following line
	panic("acquire_sleeplock() is not implemented yet...!!");
f01100c7:	83 ec 04             	sub    $0x4,%esp
f01100ca:	68 08 13 13 f0       	push   $0xf0131308
f01100cf:	6a 20                	push   $0x20
f01100d1:	68 38 13 13 f0       	push   $0xf0131338
f01100d6:	e8 d4 0d ff ff       	call   f0100eaf <_panic>

f01100db <release_sleeplock>:
}

void release_sleeplock(struct sleeplock *lk)
{
f01100db:	55                   	push   %ebp
f01100dc:	89 e5                	mov    %esp,%ebp
f01100de:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #5 SLEEP LOCK - release_sleeplock
	//Your code is here
	//Comment the following line
	panic("release_sleeplock() is not implemented yet...!!");
f01100e1:	83 ec 04             	sub    $0x4,%esp
f01100e4:	68 50 13 13 f0       	push   $0xf0131350
f01100e9:	6a 28                	push   $0x28
f01100eb:	68 38 13 13 f0       	push   $0xf0131338
f01100f0:	e8 ba 0d ff ff       	call   f0100eaf <_panic>

f01100f5 <holding_sleeplock>:
}

int holding_sleeplock(struct sleeplock *lk)
{
f01100f5:	55                   	push   %ebp
f01100f6:	89 e5                	mov    %esp,%ebp
f01100f8:	53                   	push   %ebx
f01100f9:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_kspinlock(&(lk->lk));
f01100fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01100ff:	83 c0 04             	add    $0x4,%eax
f0110102:	83 ec 0c             	sub    $0xc,%esp
f0110105:	50                   	push   %eax
f0110106:	e8 72 fc ff ff       	call   f010fd7d <acquire_kspinlock>
f011010b:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f011010e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110111:	8b 00                	mov    (%eax),%eax
f0110113:	85 c0                	test   %eax,%eax
f0110115:	74 1c                	je     f0110133 <holding_sleeplock+0x3e>
f0110117:	8b 45 08             	mov    0x8(%ebp),%eax
f011011a:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f0110120:	e8 f6 b8 ff ff       	call   f010ba1b <get_cpu_proc>
f0110125:	8b 40 10             	mov    0x10(%eax),%eax
f0110128:	39 c3                	cmp    %eax,%ebx
f011012a:	75 07                	jne    f0110133 <holding_sleeplock+0x3e>
f011012c:	b8 01 00 00 00       	mov    $0x1,%eax
f0110131:	eb 05                	jmp    f0110138 <holding_sleeplock+0x43>
f0110133:	b8 00 00 00 00       	mov    $0x0,%eax
f0110138:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_kspinlock(&(lk->lk));
f011013b:	8b 45 08             	mov    0x8(%ebp),%eax
f011013e:	83 c0 04             	add    $0x4,%eax
f0110141:	83 ec 0c             	sub    $0xc,%esp
f0110144:	50                   	push   %eax
f0110145:	e8 d8 fc ff ff       	call   f010fe22 <release_kspinlock>
f011014a:	83 c4 10             	add    $0x10,%esp
	return r;
f011014d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110150:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0110153:	c9                   	leave  
f0110154:	c3                   	ret    

f0110155 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f0110155:	55                   	push   %ebp
f0110156:	89 e5                	mov    %esp,%ebp
f0110158:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f011015b:	8b 45 08             	mov    0x8(%ebp),%eax
f011015e:	83 c0 10             	add    $0x10,%eax
f0110161:	83 ec 08             	sub    $0x8,%esp
f0110164:	ff 75 0c             	pushl  0xc(%ebp)
f0110167:	50                   	push   %eax
f0110168:	e8 5f a9 00 00       	call   f011aacc <strcpy>
f011016d:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f0110170:	8b 45 08             	mov    0x8(%ebp),%eax
f0110173:	83 ec 0c             	sub    $0xc,%esp
f0110176:	50                   	push   %eax
f0110177:	e8 4e 5d ff ff       	call   f0105eca <init_queue>
f011017c:	83 c4 10             	add    $0x10,%esp
}
f011017f:	90                   	nop
f0110180:	c9                   	leave  
f0110181:	c3                   	ret    

f0110182 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct kspinlock* lk)
{
f0110182:	55                   	push   %ebp
f0110183:	89 e5                	mov    %esp,%ebp
f0110185:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #1 CHANNEL - sleep
	//Your code is here
	//Comment the following line
	panic("sleep() is not implemented yet...!!");
f0110188:	83 ec 04             	sub    $0x4,%esp
f011018b:	68 80 13 13 f0       	push   $0xf0131380
f0110190:	6a 22                	push   $0x22
f0110192:	68 a4 13 13 f0       	push   $0xf01313a4
f0110197:	e8 13 0d ff ff       	call   f0100eaf <_panic>

f011019c <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f011019c:	55                   	push   %ebp
f011019d:	89 e5                	mov    %esp,%ebp
f011019f:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #2 CHANNEL - wakeup_one
	//Your code is here
	//Comment the following line
	panic("wakeup_one() is not implemented yet...!!");
f01101a2:	83 ec 04             	sub    $0x4,%esp
f01101a5:	68 b8 13 13 f0       	push   $0xf01313b8
f01101aa:	6a 31                	push   $0x31
f01101ac:	68 a4 13 13 f0       	push   $0xf01313a4
f01101b1:	e8 f9 0c ff ff       	call   f0100eaf <_panic>

f01101b6 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f01101b6:	55                   	push   %ebp
f01101b7:	89 e5                	mov    %esp,%ebp
f01101b9:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #3 CHANNEL - wakeup_all
	//Your code is here
	//Comment the following line
	panic("wakeup_all() is not implemented yet...!!");
f01101bc:	83 ec 04             	sub    $0x4,%esp
f01101bf:	68 e4 13 13 f0       	push   $0xf01313e4
f01101c4:	6a 41                	push   $0x41
f01101c6:	68 a4 13 13 f0       	push   $0xf01313a4
f01101cb:	e8 df 0c ff ff       	call   f0100eaf <_panic>

f01101d0 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f01101d0:	55                   	push   %ebp
f01101d1:	89 e5                	mov    %esp,%ebp
f01101d3:	83 ec 08             	sub    $0x8,%esp
	init_channel(&(ksem->chan), "ksemaphore channel");
f01101d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01101d9:	83 c0 74             	add    $0x74,%eax
f01101dc:	83 ec 08             	sub    $0x8,%esp
f01101df:	68 10 14 13 f0       	push   $0xf0131410
f01101e4:	50                   	push   %eax
f01101e5:	e8 6b ff ff ff       	call   f0110155 <init_channel>
f01101ea:	83 c4 10             	add    $0x10,%esp
	init_kspinlock(&(ksem->lk), "lock of ksemaphore");
f01101ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01101f0:	83 c0 04             	add    $0x4,%eax
f01101f3:	83 ec 08             	sub    $0x8,%esp
f01101f6:	68 23 14 13 f0       	push   $0xf0131423
f01101fb:	50                   	push   %eax
f01101fc:	e8 4b fb ff ff       	call   f010fd4c <init_kspinlock>
f0110201:	83 c4 10             	add    $0x10,%esp
	strcpy(ksem->name, name);
f0110204:	8b 45 08             	mov    0x8(%ebp),%eax
f0110207:	05 c4 00 00 00       	add    $0xc4,%eax
f011020c:	83 ec 08             	sub    $0x8,%esp
f011020f:	ff 75 10             	pushl  0x10(%ebp)
f0110212:	50                   	push   %eax
f0110213:	e8 b4 a8 00 00       	call   f011aacc <strcpy>
f0110218:	83 c4 10             	add    $0x10,%esp
	ksem->count = value;
f011021b:	8b 45 08             	mov    0x8(%ebp),%eax
f011021e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0110221:	89 10                	mov    %edx,(%eax)
}
f0110223:	90                   	nop
f0110224:	c9                   	leave  
f0110225:	c3                   	ret    

f0110226 <wait_ksemaphore>:

void wait_ksemaphore(struct ksemaphore *ksem)
{
f0110226:	55                   	push   %ebp
f0110227:	89 e5                	mov    %esp,%ebp
f0110229:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #6 SEMAPHORE - wait_ksemaphore
	//Your code is here
	//Comment the following line
	panic("wait_ksemaphore() is not implemented yet...!!");
f011022c:	83 ec 04             	sub    $0x4,%esp
f011022f:	68 38 14 13 f0       	push   $0xf0131438
f0110234:	6a 1c                	push   $0x1c
f0110236:	68 66 14 13 f0       	push   $0xf0131466
f011023b:	e8 6f 0c ff ff       	call   f0100eaf <_panic>

f0110240 <signal_ksemaphore>:

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f0110240:	55                   	push   %ebp
f0110241:	89 e5                	mov    %esp,%ebp
f0110243:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #7 SEMAPHORE - signal_ksemaphore
	//Your code is here
	//Comment the following line
	panic("signal_ksemaphore() is not implemented yet...!!");
f0110246:	83 ec 04             	sub    $0x4,%esp
f0110249:	68 80 14 13 f0       	push   $0xf0131480
f011024e:	6a 25                	push   $0x25
f0110250:	68 66 14 13 f0       	push   $0xf0131466
f0110255:	e8 55 0c ff ff       	call   f0100eaf <_panic>

f011025a <set_kheap_strategy>:
uint32 kheapPageAllocStart ;
uint32 kheapPageAllocBreak ;
uint32 kheapPlacementStrategy;

/*2025*/ //Replaced by setter & getter function
static inline void set_kheap_strategy(uint32 strategy){kheapPlacementStrategy = strategy;}
f011025a:	55                   	push   %ebp
f011025b:	89 e5                	mov    %esp,%ebp
f011025d:	8b 45 08             	mov    0x8(%ebp),%eax
f0110260:	a3 24 60 85 f0       	mov    %eax,0xf0856024
f0110265:	90                   	nop
f0110266:	5d                   	pop    %ebp
f0110267:	c3                   	ret    

f0110268 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f0110268:	55                   	push   %ebp
f0110269:	89 e5                	mov    %esp,%ebp
f011026b:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f011026e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110275:	eb 26                	jmp    f011029d <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f0110277:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011027a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110281:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110284:	01 c2                	add    %eax,%edx
f0110286:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110289:	40                   	inc    %eax
f011028a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110291:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110294:	01 c8                	add    %ecx,%eax
f0110296:	8b 00                	mov    (%eax),%eax
f0110298:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f011029a:	ff 45 f4             	incl   -0xc(%ebp)
f011029d:	8b 45 08             	mov    0x8(%ebp),%eax
f01102a0:	48                   	dec    %eax
f01102a1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01102a4:	7f d1                	jg     f0110277 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f01102a6:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f01102a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f01102b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01102b7:	eb 35                	jmp    f01102ee <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f01102b9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01102bc:	89 d0                	mov    %edx,%eax
f01102be:	01 c0                	add    %eax,%eax
f01102c0:	01 d0                	add    %edx,%eax
f01102c2:	c1 e0 02             	shl    $0x2,%eax
f01102c5:	05 c0 00 18 f0       	add    $0xf01800c0,%eax
f01102ca:	8b 10                	mov    (%eax),%edx
f01102cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102cf:	8b 00                	mov    (%eax),%eax
f01102d1:	83 ec 08             	sub    $0x8,%esp
f01102d4:	52                   	push   %edx
f01102d5:	50                   	push   %eax
f01102d6:	e8 ae a8 00 00       	call   f011ab89 <strcmp>
f01102db:	83 c4 10             	add    $0x10,%esp
f01102de:	85 c0                	test   %eax,%eax
f01102e0:	75 09                	jne    f01102eb <tst_handler+0x83>
		{
			test_found = 1;
f01102e2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f01102e9:	eb 0f                	jmp    f01102fa <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f01102eb:	ff 45 ec             	incl   -0x14(%ebp)
f01102ee:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01102f1:	a1 80 01 18 f0       	mov    0xf0180180,%eax
f01102f6:	39 c2                	cmp    %eax,%edx
f01102f8:	72 bf                	jb     f01102b9 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f01102fa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01102fe:	74 29                	je     f0110329 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f0110300:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110303:	89 d0                	mov    %edx,%eax
f0110305:	01 c0                	add    %eax,%eax
f0110307:	01 d0                	add    %edx,%eax
f0110309:	c1 e0 02             	shl    $0x2,%eax
f011030c:	05 c8 00 18 f0       	add    $0xf01800c8,%eax
f0110311:	8b 00                	mov    (%eax),%eax
f0110313:	83 ec 08             	sub    $0x8,%esp
f0110316:	ff 75 0c             	pushl  0xc(%ebp)
f0110319:	ff 75 08             	pushl  0x8(%ebp)
f011031c:	ff d0                	call   *%eax
f011031e:	83 c4 10             	add    $0x10,%esp
f0110321:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f0110324:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110327:	eb 1b                	jmp    f0110344 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f0110329:	8b 45 0c             	mov    0xc(%ebp),%eax
f011032c:	8b 00                	mov    (%eax),%eax
f011032e:	83 ec 08             	sub    $0x8,%esp
f0110331:	50                   	push   %eax
f0110332:	68 40 18 13 f0       	push   $0xf0131840
f0110337:	e8 20 18 ff ff       	call   f0101b5c <cprintf>
f011033c:	83 c4 10             	add    $0x10,%esp
		return 0;
f011033f:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0110344:	c9                   	leave  
f0110345:	c3                   	ret    

f0110346 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f0110346:	55                   	push   %ebp
f0110347:	89 e5                	mov    %esp,%ebp
f0110349:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f011034c:	e8 25 78 00 00       	call   f0117b76 <test_three_creation_functions>
	return 0;
f0110351:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110356:	c9                   	leave  
f0110357:	c3                   	ret    

f0110358 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f0110358:	55                   	push   %ebp
f0110359:	89 e5                	mov    %esp,%ebp
f011035b:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f011035e:	e8 3a 6e 00 00       	call   f011719d <test_priority_normal_and_higher>
	return 0;
f0110363:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110368:	c9                   	leave  
f0110369:	c3                   	ret    

f011036a <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f011036a:	55                   	push   %ebp
f011036b:	89 e5                	mov    %esp,%ebp
f011036d:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f0110370:	e8 42 6e 00 00       	call   f01171b7 <test_priority_normal_and_lower>
	return 0;
f0110375:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011037a:	c9                   	leave  
f011037b:	c3                   	ret    

f011037c <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f011037c:	55                   	push   %ebp
f011037d:	89 e5                	mov    %esp,%ebp
f011037f:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f0110382:	e8 a2 79 00 00       	call   f0117d29 <test_kfreeall>
	return 0;
f0110387:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011038c:	c9                   	leave  
f011038d:	c3                   	ret    

f011038e <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f011038e:	55                   	push   %ebp
f011038f:	89 e5                	mov    %esp,%ebp
f0110391:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f0110394:	e8 ad 79 00 00       	call   f0117d46 <test_kexpand>
	return 0;
f0110399:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011039e:	c9                   	leave  
f011039f:	c3                   	ret    

f01103a0 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f01103a0:	55                   	push   %ebp
f01103a1:	89 e5                	mov    %esp,%ebp
f01103a3:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f01103a6:	e8 b8 79 00 00       	call   f0117d63 <test_kshrink>
	return 0;
f01103ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01103b0:	c9                   	leave  
f01103b1:	c3                   	ret    

f01103b2 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f01103b2:	55                   	push   %ebp
f01103b3:	89 e5                	mov    %esp,%ebp
f01103b5:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f01103b8:	e8 c3 79 00 00       	call   f0117d80 <test_kfreelast>
	return 0;
f01103bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01103c2:	c9                   	leave  
f01103c3:	c3                   	ret    

f01103c4 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f01103c4:	55                   	push   %ebp
f01103c5:	89 e5                	mov    %esp,%ebp
f01103c7:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f01103ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f01103cd:	83 c0 04             	add    $0x4,%eax
f01103d0:	8b 00                	mov    (%eax),%eax
f01103d2:	83 ec 04             	sub    $0x4,%esp
f01103d5:	6a 0a                	push   $0xa
f01103d7:	6a 00                	push   $0x0
f01103d9:	50                   	push   %eax
f01103da:	e8 ad aa 00 00       	call   f011ae8c <strtol>
f01103df:	83 c4 10             	add    $0x10,%esp
f01103e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f01103e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f01103ec:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_kspinlock(&ProcessQueues.qlock);
f01103f3:	83 ec 0c             	sub    $0xc,%esp
f01103f6:	68 80 dd 83 f0       	push   $0xf083dd80
f01103fb:	e8 7d f9 ff ff       	call   f010fd7d <acquire_kspinlock>
f0110400:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0110403:	a1 00 de 83 f0       	mov    0xf083de00,%eax
f0110408:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011040b:	eb 3b                	jmp    f0110448 <tst_sc_MLFQ+0x84>
									{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f011040d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110410:	83 c0 20             	add    $0x20,%eax
f0110413:	83 ec 08             	sub    $0x8,%esp
f0110416:	68 53 18 13 f0       	push   $0xf0131853
f011041b:	50                   	push   %eax
f011041c:	e8 68 a7 00 00       	call   f011ab89 <strcmp>
f0110421:	83 c4 10             	add    $0x10,%esp
f0110424:	85 c0                	test   %eax,%eax
f0110426:	75 12                	jne    f011043a <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f0110428:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011042c:	74 07                	je     f0110435 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f011042e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f0110435:	ff 45 f4             	incl   -0xc(%ebp)
f0110438:	eb 06                	jmp    f0110440 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f011043a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011043e:	74 31                	je     f0110471 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_kspinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0110440:	a1 08 de 83 f0       	mov    0xf083de08,%eax
f0110445:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110448:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011044c:	74 08                	je     f0110456 <tst_sc_MLFQ+0x92>
f011044e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110451:	8b 40 08             	mov    0x8(%eax),%eax
f0110454:	eb 05                	jmp    f011045b <tst_sc_MLFQ+0x97>
f0110456:	b8 00 00 00 00       	mov    $0x0,%eax
f011045b:	a3 08 de 83 f0       	mov    %eax,0xf083de08
f0110460:	a1 08 de 83 f0       	mov    0xf083de08,%eax
f0110465:	85 c0                	test   %eax,%eax
f0110467:	75 a4                	jne    f011040d <tst_sc_MLFQ+0x49>
f0110469:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011046d:	75 9e                	jne    f011040d <tst_sc_MLFQ+0x49>
f011046f:	eb 01                	jmp    f0110472 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f0110471:	90                   	nop
									}
		if(cnt == numOfSlave2)
f0110472:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110475:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0110478:	75 12                	jne    f011048c <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f011047a:	83 ec 0c             	sub    $0xc,%esp
f011047d:	68 5c 18 13 f0       	push   $0xf013185c
f0110482:	e8 d5 16 ff ff       	call   f0101b5c <cprintf>
f0110487:	83 c4 10             	add    $0x10,%esp
f011048a:	eb 17                	jmp    f01104a3 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f011048c:	83 ec 04             	sub    $0x4,%esp
f011048f:	68 95 18 13 f0       	push   $0xf0131895
f0110494:	68 9c 00 00 00       	push   $0x9c
f0110499:	68 ab 18 13 f0       	push   $0xf01318ab
f011049e:	e8 0c 0a ff ff       	call   f0100eaf <_panic>
		}
	}
	release_kspinlock(&ProcessQueues.qlock);
f01104a3:	83 ec 0c             	sub    $0xc,%esp
f01104a6:	68 80 dd 83 f0       	push   $0xf083dd80
f01104ab:	e8 72 f9 ff ff       	call   f010fe22 <release_kspinlock>
f01104b0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01104b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01104b8:	c9                   	leave  
f01104b9:	c3                   	ret    

f01104ba <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f01104ba:	55                   	push   %ebp
f01104bb:	89 e5                	mov    %esp,%ebp
f01104bd:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f01104c0:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01104c4:	74 17                	je     f01104dd <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f01104c6:	83 ec 0c             	sub    $0xc,%esp
f01104c9:	68 c4 18 13 f0       	push   $0xf01318c4
f01104ce:	e8 89 16 ff ff       	call   f0101b5c <cprintf>
f01104d3:	83 c4 10             	add    $0x10,%esp
		return 0;
f01104d6:	b8 00 00 00 00       	mov    $0x0,%eax
f01104db:	eb 45                	jmp    f0110522 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f01104dd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01104e0:	83 c0 04             	add    $0x4,%eax
f01104e3:	8b 00                	mov    (%eax),%eax
f01104e5:	83 ec 04             	sub    $0x4,%esp
f01104e8:	6a 0a                	push   $0xa
f01104ea:	6a 00                	push   $0x0
f01104ec:	50                   	push   %eax
f01104ed:	e8 9a a9 00 00       	call   f011ae8c <strtol>
f01104f2:	83 c4 10             	add    $0x10,%esp
f01104f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f01104f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01104fb:	83 f8 01             	cmp    $0x1,%eax
f01104fe:	74 10                	je     f0110510 <tst_bsd_nice+0x56>
f0110500:	83 f8 02             	cmp    $0x2,%eax
f0110503:	74 12                	je     f0110517 <tst_bsd_nice+0x5d>
f0110505:	85 c0                	test   %eax,%eax
f0110507:	75 14                	jne    f011051d <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f0110509:	e8 e4 79 00 00       	call   f0117ef2 <test_bsd_nice_0>
		break;
f011050e:	eb 0d                	jmp    f011051d <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f0110510:	e8 f7 79 00 00       	call   f0117f0c <test_bsd_nice_1>
		break;
f0110515:	eb 06                	jmp    f011051d <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f0110517:	e8 0a 7a 00 00       	call   f0117f26 <test_bsd_nice_2>
		break;
f011051c:	90                   	nop
	}
	return 0;
f011051d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110522:	c9                   	leave  
f0110523:	c3                   	ret    

f0110524 <tst_priorityRR>:

/*2024*/
int tst_priorityRR(int number_of_arguments, char **arguments)
{
f0110524:	55                   	push   %ebp
f0110525:	89 e5                	mov    %esp,%ebp
f0110527:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f011052a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011052e:	74 17                	je     f0110547 <tst_priorityRR+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst priorityRR <testnumber>\n");
f0110530:	83 ec 0c             	sub    $0xc,%esp
f0110533:	68 04 19 13 f0       	push   $0xf0131904
f0110538:	e8 1f 16 ff ff       	call   f0101b5c <cprintf>
f011053d:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110540:	b8 00 00 00 00       	mov    $0x0,%eax
f0110545:	eb 45                	jmp    f011058c <tst_priorityRR+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f0110547:	8b 45 0c             	mov    0xc(%ebp),%eax
f011054a:	83 c0 04             	add    $0x4,%eax
f011054d:	8b 00                	mov    (%eax),%eax
f011054f:	83 ec 04             	sub    $0x4,%esp
f0110552:	6a 0a                	push   $0xa
f0110554:	6a 00                	push   $0x0
f0110556:	50                   	push   %eax
f0110557:	e8 30 a9 00 00       	call   f011ae8c <strtol>
f011055c:	83 c4 10             	add    $0x10,%esp
f011055f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f0110562:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110565:	83 f8 01             	cmp    $0x1,%eax
f0110568:	74 10                	je     f011057a <tst_priorityRR+0x56>
f011056a:	83 f8 02             	cmp    $0x2,%eax
f011056d:	74 12                	je     f0110581 <tst_priorityRR+0x5d>
f011056f:	85 c0                	test   %eax,%eax
f0110571:	75 14                	jne    f0110587 <tst_priorityRR+0x63>
	{
	case 0:
		test_priorityRR_0();
f0110573:	e8 c8 79 00 00       	call   f0117f40 <test_priorityRR_0>
		break;
f0110578:	eb 0d                	jmp    f0110587 <tst_priorityRR+0x63>
	case 1:
		test_priorityRR_1();
f011057a:	e8 70 7c 00 00       	call   f01181ef <test_priorityRR_1>
		break;
f011057f:	eb 06                	jmp    f0110587 <tst_priorityRR+0x63>
	case 2:
		test_priorityRR_2();
f0110581:	e8 fc 7e 00 00       	call   f0118482 <test_priorityRR_2>
		break;
f0110586:	90                   	nop
	}
	return 0;
f0110587:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011058c:	c9                   	leave  
f011058d:	c3                   	ret    

f011058e <tst_str2lower>:
int tst_str2lower(int number_of_arguments, char **arguments)
{
f011058e:	55                   	push   %ebp
f011058f:	89 e5                	mov    %esp,%ebp
f0110591:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f0110594:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0110598:	74 17                	je     f01105b1 <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f011059a:	83 ec 0c             	sub    $0xc,%esp
f011059d:	68 48 19 13 f0       	push   $0xf0131948
f01105a2:	e8 b5 15 ff ff       	call   f0101b5c <cprintf>
f01105a7:	83 c4 10             	add    $0x10,%esp
		return 0;
f01105aa:	b8 00 00 00 00       	mov    $0x0,%eax
f01105af:	eb 0a                	jmp    f01105bb <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f01105b1:	e8 7e 16 00 00       	call   f0111c34 <test_str2lower_function>
	return 0;
f01105b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105bb:	c9                   	leave  
f01105bc:	c3                   	ret    

f01105bd <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f01105bd:	55                   	push   %ebp
f01105be:	89 e5                	mov    %esp,%ebp
f01105c0:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f01105c3:	e8 51 12 00 00       	call   f0111819 <TestAutoCompleteCommand>
f01105c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f01105cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105d0:	c9                   	leave  
f01105d1:	c3                   	ret    

f01105d2 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f01105d2:	55                   	push   %ebp
f01105d3:	89 e5                	mov    %esp,%ebp
f01105d5:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f01105d8:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01105dc:	74 1a                	je     f01105f8 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f01105de:	83 ec 0c             	sub    $0xc,%esp
f01105e1:	68 7c 19 13 f0       	push   $0xf013197c
f01105e6:	e8 71 15 ff ff       	call   f0101b5c <cprintf>
f01105eb:	83 c4 10             	add    $0x10,%esp
		return 0;
f01105ee:	b8 00 00 00 00       	mov    $0x0,%eax
f01105f3:	e9 93 00 00 00       	jmp    f011068b <tst_dyn_alloc+0xb9>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f01105f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105fb:	83 c0 04             	add    $0x4,%eax
f01105fe:	8b 00                	mov    (%eax),%eax
f0110600:	83 ec 08             	sub    $0x8,%esp
f0110603:	68 b9 19 13 f0       	push   $0xf01319b9
f0110608:	50                   	push   %eax
f0110609:	e8 7b a5 00 00       	call   f011ab89 <strcmp>
f011060e:	83 c4 10             	add    $0x10,%esp
f0110611:	85 c0                	test   %eax,%eax
f0110613:	75 07                	jne    f011061c <tst_dyn_alloc+0x4a>
	{
		test_initialize_dynamic_allocator();
f0110615:	e8 d1 09 00 00       	call   f0110feb <test_initialize_dynamic_allocator>
f011061a:	eb 6a                	jmp    f0110686 <tst_dyn_alloc+0xb4>
	}
	// Test 2 Example for alloc_block: tst dynalloc alloc
	else if(strcmp(arguments[1], "alloc") == 0)
f011061c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011061f:	83 c0 04             	add    $0x4,%eax
f0110622:	8b 00                	mov    (%eax),%eax
f0110624:	83 ec 08             	sub    $0x8,%esp
f0110627:	68 be 19 13 f0       	push   $0xf01319be
f011062c:	50                   	push   %eax
f011062d:	e8 57 a5 00 00       	call   f011ab89 <strcmp>
f0110632:	83 c4 10             	add    $0x10,%esp
f0110635:	85 c0                	test   %eax,%eax
f0110637:	75 07                	jne    f0110640 <tst_dyn_alloc+0x6e>
	{
		test_alloc_block();
f0110639:	e8 e4 09 00 00       	call   f0111022 <test_alloc_block>
f011063e:	eb 46                	jmp    f0110686 <tst_dyn_alloc+0xb4>
	{
		test_alloc_block_NF();
	}
	 */
	// Test 5 Example for free_block: tst dynalloc free
	else if(strcmp(arguments[1], "free") == 0)
f0110640:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110643:	83 c0 04             	add    $0x4,%eax
f0110646:	8b 00                	mov    (%eax),%eax
f0110648:	83 ec 08             	sub    $0x8,%esp
f011064b:	68 c4 19 13 f0       	push   $0xf01319c4
f0110650:	50                   	push   %eax
f0110651:	e8 33 a5 00 00       	call   f011ab89 <strcmp>
f0110656:	83 c4 10             	add    $0x10,%esp
f0110659:	85 c0                	test   %eax,%eax
f011065b:	75 07                	jne    f0110664 <tst_dyn_alloc+0x92>
	{
		test_free_block();
f011065d:	e8 dd 09 00 00       	call   f011103f <test_free_block>
f0110662:	eb 22                	jmp    f0110686 <tst_dyn_alloc+0xb4>
	else if(strcmp(arguments[1], "freenf") == 0)
	{
		test_free_block_NF();
	}*/
	// Test 8 Example for realloc_block: tst dynalloc realloc
	else if(strcmp(arguments[1], "realloc") == 0)
f0110664:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110667:	83 c0 04             	add    $0x4,%eax
f011066a:	8b 00                	mov    (%eax),%eax
f011066c:	83 ec 08             	sub    $0x8,%esp
f011066f:	68 c9 19 13 f0       	push   $0xf01319c9
f0110674:	50                   	push   %eax
f0110675:	e8 0f a5 00 00       	call   f011ab89 <strcmp>
f011067a:	83 c4 10             	add    $0x10,%esp
f011067d:	85 c0                	test   %eax,%eax
f011067f:	75 05                	jne    f0110686 <tst_dyn_alloc+0xb4>
	{
		test_realloc_block();
f0110681:	e8 d6 09 00 00       	call   f011105c <test_realloc_block>
	}
	return 0;
f0110686:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011068b:	c9                   	leave  
f011068c:	c3                   	ret    

f011068d <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f011068d:	55                   	push   %ebp
f011068e:	89 e5                	mov    %esp,%ebp
f0110690:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110693:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110697:	74 1a                	je     f01106b3 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst chunks <testname>\n") ;
f0110699:	83 ec 0c             	sub    $0xc,%esp
f011069c:	68 d4 19 13 f0       	push   $0xf01319d4
f01106a1:	e8 b6 14 ff ff       	call   f0101b5c <cprintf>
f01106a6:	83 c4 10             	add    $0x10,%esp
		return 0;
f01106a9:	b8 00 00 00 00       	mov    $0x0,%eax
f01106ae:	e9 e1 00 00 00       	jmp    f0110794 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f01106b3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106b6:	83 c0 04             	add    $0x4,%eax
f01106b9:	8b 00                	mov    (%eax),%eax
f01106bb:	83 ec 08             	sub    $0x8,%esp
f01106be:	68 0f 1a 13 f0       	push   $0xf0131a0f
f01106c3:	50                   	push   %eax
f01106c4:	e8 c0 a4 00 00       	call   f011ab89 <strcmp>
f01106c9:	83 c4 10             	add    $0x10,%esp
f01106cc:	85 c0                	test   %eax,%eax
f01106ce:	75 0a                	jne    f01106da <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f01106d0:	e8 00 22 00 00       	call   f01128d5 <test_cut_paste_pages>
f01106d5:	e9 b5 00 00 00       	jmp    f011078f <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f01106da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106dd:	83 c0 04             	add    $0x4,%eax
f01106e0:	8b 00                	mov    (%eax),%eax
f01106e2:	83 ec 08             	sub    $0x8,%esp
f01106e5:	68 18 1a 13 f0       	push   $0xf0131a18
f01106ea:	50                   	push   %eax
f01106eb:	e8 99 a4 00 00       	call   f011ab89 <strcmp>
f01106f0:	83 c4 10             	add    $0x10,%esp
f01106f3:	85 c0                	test   %eax,%eax
f01106f5:	75 0a                	jne    f0110701 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f01106f7:	e8 24 2c 00 00       	call   f0113320 <test_copy_paste_chunk>
f01106fc:	e9 8e 00 00 00       	jmp    f011078f <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f0110701:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110704:	83 c0 04             	add    $0x4,%eax
f0110707:	8b 00                	mov    (%eax),%eax
f0110709:	83 ec 08             	sub    $0x8,%esp
f011070c:	68 22 1a 13 f0       	push   $0xf0131a22
f0110711:	50                   	push   %eax
f0110712:	e8 72 a4 00 00       	call   f011ab89 <strcmp>
f0110717:	83 c4 10             	add    $0x10,%esp
f011071a:	85 c0                	test   %eax,%eax
f011071c:	75 07                	jne    f0110725 <tst_chunks+0x98>
	{
		test_share_chunk();
f011071e:	e8 fb 3c 00 00       	call   f011441e <test_share_chunk>
f0110723:	eb 6a                	jmp    f011078f <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f0110725:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110728:	83 c0 04             	add    $0x4,%eax
f011072b:	8b 00                	mov    (%eax),%eax
f011072d:	83 ec 08             	sub    $0x8,%esp
f0110730:	68 28 1a 13 f0       	push   $0xf0131a28
f0110735:	50                   	push   %eax
f0110736:	e8 4e a4 00 00       	call   f011ab89 <strcmp>
f011073b:	83 c4 10             	add    $0x10,%esp
f011073e:	85 c0                	test   %eax,%eax
f0110740:	75 07                	jne    f0110749 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f0110742:	e8 ff 46 00 00       	call   f0114e46 <test_allocate_chunk>
f0110747:	eb 46                	jmp    f011078f <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f0110749:	8b 45 0c             	mov    0xc(%ebp),%eax
f011074c:	83 c0 04             	add    $0x4,%eax
f011074f:	8b 00                	mov    (%eax),%eax
f0110751:	83 ec 08             	sub    $0x8,%esp
f0110754:	68 31 1a 13 f0       	push   $0xf0131a31
f0110759:	50                   	push   %eax
f011075a:	e8 2a a4 00 00       	call   f011ab89 <strcmp>
f011075f:	83 c4 10             	add    $0x10,%esp
f0110762:	85 c0                	test   %eax,%eax
f0110764:	75 07                	jne    f011076d <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f0110766:	e8 e2 4f 00 00       	call   f011574d <test_calculate_required_frames>
f011076b:	eb 22                	jmp    f011078f <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f011076d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110770:	83 c0 04             	add    $0x4,%eax
f0110773:	8b 00                	mov    (%eax),%eax
f0110775:	83 ec 08             	sub    $0x8,%esp
f0110778:	68 40 1a 13 f0       	push   $0xf0131a40
f011077d:	50                   	push   %eax
f011077e:	e8 06 a4 00 00       	call   f011ab89 <strcmp>
f0110783:	83 c4 10             	add    $0x10,%esp
f0110786:	85 c0                	test   %eax,%eax
f0110788:	75 05                	jne    f011078f <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f011078a:	e8 32 58 00 00       	call   f0115fc1 <test_calculate_allocated_space>
	}
	return 0;
f011078f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110794:	c9                   	leave  
f0110795:	c3                   	ret    

f0110796 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f0110796:	55                   	push   %ebp
f0110797:	89 e5                	mov    %esp,%ebp
f0110799:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f011079c:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01107a0:	74 1a                	je     f01107bc <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst pg <testname>\n") ;
f01107a2:	83 ec 0c             	sub    $0xc,%esp
f01107a5:	68 50 1a 13 f0       	push   $0xf0131a50
f01107aa:	e8 ad 13 ff ff       	call   f0101b5c <cprintf>
f01107af:	83 c4 10             	add    $0x10,%esp
		return 0;
f01107b2:	b8 00 00 00 00       	mov    $0x0,%eax
f01107b7:	e9 e1 00 00 00       	jmp    f011089d <tst_paging_manipulation+0x107>
	}
	// Test 1.1-Set/Clear permissions: tst pg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f01107bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107bf:	83 c0 04             	add    $0x4,%eax
f01107c2:	8b 00                	mov    (%eax),%eax
f01107c4:	83 ec 08             	sub    $0x8,%esp
f01107c7:	68 87 1a 13 f0       	push   $0xf0131a87
f01107cc:	50                   	push   %eax
f01107cd:	e8 b7 a3 00 00       	call   f011ab89 <strcmp>
f01107d2:	83 c4 10             	add    $0x10,%esp
f01107d5:	85 c0                	test   %eax,%eax
f01107d7:	75 0a                	jne    f01107e3 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f01107d9:	e8 dc 17 00 00       	call   f0111fba <test_pt_set_page_permissions>
f01107de:	e9 b5 00 00 00       	jmp    f0110898 <tst_paging_manipulation+0x102>
	}
	// Test 1.2-Set/Clear permissions: tst pg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f01107e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107e6:	83 c0 04             	add    $0x4,%eax
f01107e9:	8b 00                	mov    (%eax),%eax
f01107eb:	83 ec 08             	sub    $0x8,%esp
f01107ee:	68 8f 1a 13 f0       	push   $0xf0131a8f
f01107f3:	50                   	push   %eax
f01107f4:	e8 90 a3 00 00       	call   f011ab89 <strcmp>
f01107f9:	83 c4 10             	add    $0x10,%esp
f01107fc:	85 c0                	test   %eax,%eax
f01107fe:	75 0a                	jne    f011080a <tst_paging_manipulation+0x74>
	{
		test_pt_set_page_permissions_invalid_va();
f0110800:	e8 24 1a 00 00       	call   f0112229 <test_pt_set_page_permissions_invalid_va>
f0110805:	e9 8e 00 00 00       	jmp    f0110898 <tst_paging_manipulation+0x102>
	}
	// Test 2-Get permissions: tst pg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f011080a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011080d:	83 c0 04             	add    $0x4,%eax
f0110810:	8b 00                	mov    (%eax),%eax
f0110812:	83 ec 08             	sub    $0x8,%esp
f0110815:	68 97 1a 13 f0       	push   $0xf0131a97
f011081a:	50                   	push   %eax
f011081b:	e8 69 a3 00 00       	call   f011ab89 <strcmp>
f0110820:	83 c4 10             	add    $0x10,%esp
f0110823:	85 c0                	test   %eax,%eax
f0110825:	75 07                	jne    f011082e <tst_paging_manipulation+0x98>
	{
		test_pt_get_page_permissions();
f0110827:	e8 46 1a 00 00       	call   f0112272 <test_pt_get_page_permissions>
f011082c:	eb 6a                	jmp    f0110898 <tst_paging_manipulation+0x102>
	}
	// Test 3.1-Clear entry: tst pg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f011082e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110831:	83 c0 04             	add    $0x4,%eax
f0110834:	8b 00                	mov    (%eax),%eax
f0110836:	83 ec 08             	sub    $0x8,%esp
f0110839:	68 9f 1a 13 f0       	push   $0xf0131a9f
f011083e:	50                   	push   %eax
f011083f:	e8 45 a3 00 00       	call   f011ab89 <strcmp>
f0110844:	83 c4 10             	add    $0x10,%esp
f0110847:	85 c0                	test   %eax,%eax
f0110849:	75 07                	jne    f0110852 <tst_paging_manipulation+0xbc>
	{
		test_pt_clear_page_table_entry();
f011084b:	e8 66 1b 00 00       	call   f01123b6 <test_pt_clear_page_table_entry>
f0110850:	eb 46                	jmp    f0110898 <tst_paging_manipulation+0x102>
	}
	// Test 3.2-Clear entry: tst pg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f0110852:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110855:	83 c0 04             	add    $0x4,%eax
f0110858:	8b 00                	mov    (%eax),%eax
f011085a:	83 ec 08             	sub    $0x8,%esp
f011085d:	68 a6 1a 13 f0       	push   $0xf0131aa6
f0110862:	50                   	push   %eax
f0110863:	e8 21 a3 00 00       	call   f011ab89 <strcmp>
f0110868:	83 c4 10             	add    $0x10,%esp
f011086b:	85 c0                	test   %eax,%eax
f011086d:	75 07                	jne    f0110876 <tst_paging_manipulation+0xe0>
	{
		test_pt_clear_page_table_entry_invalid_va();
f011086f:	e8 9b 1c 00 00       	call   f011250f <test_pt_clear_page_table_entry_invalid_va>
f0110874:	eb 22                	jmp    f0110898 <tst_paging_manipulation+0x102>
	}
	// Test 4-Convert virtual to physical: tst pg v2p
	else if(strcmp(arguments[1], "v2p") == 0)
f0110876:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110879:	83 c0 04             	add    $0x4,%eax
f011087c:	8b 00                	mov    (%eax),%eax
f011087e:	83 ec 08             	sub    $0x8,%esp
f0110881:	68 ad 1a 13 f0       	push   $0xf0131aad
f0110886:	50                   	push   %eax
f0110887:	e8 fd a2 00 00       	call   f011ab89 <strcmp>
f011088c:	83 c4 10             	add    $0x10,%esp
f011088f:	85 c0                	test   %eax,%eax
f0110891:	75 05                	jne    f0110898 <tst_paging_manipulation+0x102>
	{
		test_virtual_to_physical();
f0110893:	e8 af 1c 00 00       	call   f0112547 <test_virtual_to_physical>
	}
	return 0;
f0110898:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011089d:	c9                   	leave  
f011089e:	c3                   	ret    

f011089f <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f011089f:	55                   	push   %ebp
f01108a0:	89 e5                	mov    %esp,%ebp
f01108a2:	83 ec 18             	sub    $0x18,%esp
#if !USE_KHEAP
	panic("MUST ENABLE KHEAP");
	return 0;
#endif
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f01108a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108a8:	83 c0 08             	add    $0x8,%eax
f01108ab:	8b 00                	mov    (%eax),%eax
f01108ad:	83 ec 08             	sub    $0x8,%esp
f01108b0:	68 b1 1a 13 f0       	push   $0xf0131ab1
f01108b5:	50                   	push   %eax
f01108b6:	e8 ce a2 00 00       	call   f011ab89 <strcmp>
f01108bb:	83 c4 10             	add    $0x10,%esp
f01108be:	85 c0                	test   %eax,%eax
f01108c0:	75 20                	jne    f01108e2 <tst_kheap+0x43>
f01108c2:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f01108c6:	74 1a                	je     f01108e2 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <both or blk or page>\n") ;
f01108c8:	83 ec 0c             	sub    $0xc,%esp
f01108cb:	68 bc 1a 13 f0       	push   $0xf0131abc
f01108d0:	e8 87 12 ff ff       	call   f0101b5c <cprintf>
f01108d5:	83 c4 10             	add    $0x10,%esp
		return 0;
f01108d8:	b8 00 00 00 00       	mov    $0x0,%eax
f01108dd:	e9 b1 04 00 00       	jmp    f0110d93 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "fast") == 0 && number_of_arguments != 3)
f01108e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108e5:	83 c0 08             	add    $0x8,%eax
f01108e8:	8b 00                	mov    (%eax),%eax
f01108ea:	83 ec 08             	sub    $0x8,%esp
f01108ed:	68 14 1b 13 f0       	push   $0xf0131b14
f01108f2:	50                   	push   %eax
f01108f3:	e8 91 a2 00 00       	call   f011ab89 <strcmp>
f01108f8:	83 c4 10             	add    $0x10,%esp
f01108fb:	85 c0                	test   %eax,%eax
f01108fd:	75 20                	jne    f011091f <tst_kheap+0x80>
f01108ff:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0110903:	74 1a                	je     f011091f <tst_kheap+0x80>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> fast\n") ;
f0110905:	83 ec 0c             	sub    $0xc,%esp
f0110908:	68 1c 1b 13 f0       	push   $0xf0131b1c
f011090d:	e8 4a 12 ff ff       	call   f0101b5c <cprintf>
f0110912:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110915:	b8 00 00 00 00       	mov    $0x0,%eax
f011091a:	e9 74 04 00 00       	jmp    f0110d93 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "kfree") == 0 && number_of_arguments != 4)
f011091f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110922:	83 c0 08             	add    $0x8,%eax
f0110925:	8b 00                	mov    (%eax),%eax
f0110927:	83 ec 08             	sub    $0x8,%esp
f011092a:	68 5b 1b 13 f0       	push   $0xf0131b5b
f011092f:	50                   	push   %eax
f0110930:	e8 54 a2 00 00       	call   f011ab89 <strcmp>
f0110935:	83 c4 10             	add    $0x10,%esp
f0110938:	85 c0                	test   %eax,%eax
f011093a:	75 20                	jne    f011095c <tst_kheap+0xbd>
f011093c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110940:	74 1a                	je     f011095c <tst_kheap+0xbd>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kfree <both or blk or page>\n") ;
f0110942:	83 ec 0c             	sub    $0xc,%esp
f0110945:	68 64 1b 13 f0       	push   $0xf0131b64
f011094a:	e8 0d 12 ff ff       	call   f0101b5c <cprintf>
f011094f:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110952:	b8 00 00 00 00       	mov    $0x0,%eax
f0110957:	e9 37 04 00 00       	jmp    f0110d93 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "kvirtaddr") == 0 && number_of_arguments != 2)
f011095c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011095f:	83 c0 08             	add    $0x8,%eax
f0110962:	8b 00                	mov    (%eax),%eax
f0110964:	83 ec 08             	sub    $0x8,%esp
f0110967:	68 ba 1b 13 f0       	push   $0xf0131bba
f011096c:	50                   	push   %eax
f011096d:	e8 17 a2 00 00       	call   f011ab89 <strcmp>
f0110972:	83 c4 10             	add    $0x10,%esp
f0110975:	85 c0                	test   %eax,%eax
f0110977:	75 20                	jne    f0110999 <tst_kheap+0xfa>
f0110979:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011097d:	74 1a                	je     f0110999 <tst_kheap+0xfa>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap kvirtaddr\n") ;
f011097f:	83 ec 0c             	sub    $0xc,%esp
f0110982:	68 c4 1b 13 f0       	push   $0xf0131bc4
f0110987:	e8 d0 11 ff ff       	call   f0101b5c <cprintf>
f011098c:	83 c4 10             	add    $0x10,%esp
		return 0;
f011098f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110994:	e9 fa 03 00 00       	jmp    f0110d93 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "kphysaddr") == 0 && number_of_arguments != 2)
f0110999:	8b 45 0c             	mov    0xc(%ebp),%eax
f011099c:	83 c0 08             	add    $0x8,%eax
f011099f:	8b 00                	mov    (%eax),%eax
f01109a1:	83 ec 08             	sub    $0x8,%esp
f01109a4:	68 fd 1b 13 f0       	push   $0xf0131bfd
f01109a9:	50                   	push   %eax
f01109aa:	e8 da a1 00 00       	call   f011ab89 <strcmp>
f01109af:	83 c4 10             	add    $0x10,%esp
f01109b2:	85 c0                	test   %eax,%eax
f01109b4:	75 20                	jne    f01109d6 <tst_kheap+0x137>
f01109b6:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01109ba:	74 1a                	je     f01109d6 <tst_kheap+0x137>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap kphysaddr\n") ;
f01109bc:	83 ec 0c             	sub    $0xc,%esp
f01109bf:	68 08 1c 13 f0       	push   $0xf0131c08
f01109c4:	e8 93 11 ff ff       	call   f0101b5c <cprintf>
f01109c9:	83 c4 10             	add    $0x10,%esp
		return 0;
f01109cc:	b8 00 00 00 00       	mov    $0x0,%eax
f01109d1:	e9 bd 03 00 00       	jmp    f0110d93 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "krealloc") == 0 && number_of_arguments != 4)
f01109d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109d9:	83 c0 08             	add    $0x8,%eax
f01109dc:	8b 00                	mov    (%eax),%eax
f01109de:	83 ec 08             	sub    $0x8,%esp
f01109e1:	68 41 1c 13 f0       	push   $0xf0131c41
f01109e6:	50                   	push   %eax
f01109e7:	e8 9d a1 00 00       	call   f011ab89 <strcmp>
f01109ec:	83 c4 10             	add    $0x10,%esp
f01109ef:	85 c0                	test   %eax,%eax
f01109f1:	75 20                	jne    f0110a13 <tst_kheap+0x174>
f01109f3:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f01109f7:	74 1a                	je     f0110a13 <tst_kheap+0x174>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> krealloc <both or blk or page>\n") ;
f01109f9:	83 ec 0c             	sub    $0xc,%esp
f01109fc:	68 4c 1c 13 f0       	push   $0xf0131c4c
f0110a01:	e8 56 11 ff ff       	call   f0101b5c <cprintf>
f0110a06:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110a09:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a0e:	e9 80 03 00 00       	jmp    f0110d93 <tst_kheap+0x4f4>
	}

	// Specify Test Type [ig any]
	uint32 testType = 0;
f0110a13:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (number_of_arguments == 4)
f0110a1a:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110a1e:	0f 85 8c 00 00 00    	jne    f0110ab0 <tst_kheap+0x211>
	{
		if (strcmp(arguments[3], "page") == 0)
f0110a24:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a27:	83 c0 0c             	add    $0xc,%eax
f0110a2a:	8b 00                	mov    (%eax),%eax
f0110a2c:	83 ec 08             	sub    $0x8,%esp
f0110a2f:	68 a5 1c 13 f0       	push   $0xf0131ca5
f0110a34:	50                   	push   %eax
f0110a35:	e8 4f a1 00 00       	call   f011ab89 <strcmp>
f0110a3a:	83 c4 10             	add    $0x10,%esp
f0110a3d:	85 c0                	test   %eax,%eax
f0110a3f:	75 09                	jne    f0110a4a <tst_kheap+0x1ab>
		{
			testType = TST_PAGE_ALLOC;
f0110a41:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0110a48:	eb 66                	jmp    f0110ab0 <tst_kheap+0x211>
		}
		else if (strcmp(arguments[3], "blk") == 0)
f0110a4a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a4d:	83 c0 0c             	add    $0xc,%eax
f0110a50:	8b 00                	mov    (%eax),%eax
f0110a52:	83 ec 08             	sub    $0x8,%esp
f0110a55:	68 aa 1c 13 f0       	push   $0xf0131caa
f0110a5a:	50                   	push   %eax
f0110a5b:	e8 29 a1 00 00       	call   f011ab89 <strcmp>
f0110a60:	83 c4 10             	add    $0x10,%esp
f0110a63:	85 c0                	test   %eax,%eax
f0110a65:	75 09                	jne    f0110a70 <tst_kheap+0x1d1>
		{
			testType = TST_BLOCK_ALLOC;
f0110a67:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0110a6e:	eb 40                	jmp    f0110ab0 <tst_kheap+0x211>
		}
		else if (strcmp(arguments[3], "both") == 0)
f0110a70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a73:	83 c0 0c             	add    $0xc,%eax
f0110a76:	8b 00                	mov    (%eax),%eax
f0110a78:	83 ec 08             	sub    $0x8,%esp
f0110a7b:	68 ae 1c 13 f0       	push   $0xf0131cae
f0110a80:	50                   	push   %eax
f0110a81:	e8 03 a1 00 00       	call   f011ab89 <strcmp>
f0110a86:	83 c4 10             	add    $0x10,%esp
f0110a89:	85 c0                	test   %eax,%eax
f0110a8b:	75 09                	jne    f0110a96 <tst_kheap+0x1f7>
		{
			testType = TST_BOTH_ALLOC;
f0110a8d:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0110a94:	eb 1a                	jmp    f0110ab0 <tst_kheap+0x211>
		}
		else
		{
			cprintf("Invalid Allocator Type! <both or blk or page>\n") ;
f0110a96:	83 ec 0c             	sub    $0xc,%esp
f0110a99:	68 b4 1c 13 f0       	push   $0xf0131cb4
f0110a9e:	e8 b9 10 ff ff       	call   f0101b5c <cprintf>
f0110aa3:	83 c4 10             	add    $0x10,%esp
			return 0;
f0110aa6:	b8 00 00 00 00       	mov    $0x0,%eax
f0110aab:	e9 e3 02 00 00       	jmp    f0110d93 <tst_kheap+0x4f4>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f0110ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ab3:	83 c0 04             	add    $0x4,%eax
f0110ab6:	8b 00                	mov    (%eax),%eax
f0110ab8:	83 ec 08             	sub    $0x8,%esp
f0110abb:	68 e3 1c 13 f0       	push   $0xf0131ce3
f0110ac0:	50                   	push   %eax
f0110ac1:	e8 c3 a0 00 00       	call   f011ab89 <strcmp>
f0110ac6:	83 c4 10             	add    $0x10,%esp
f0110ac9:	85 c0                	test   %eax,%eax
f0110acb:	74 1d                	je     f0110aea <tst_kheap+0x24b>
f0110acd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ad0:	83 c0 04             	add    $0x4,%eax
f0110ad3:	8b 00                	mov    (%eax),%eax
f0110ad5:	83 ec 08             	sub    $0x8,%esp
f0110ad8:	68 e6 1c 13 f0       	push   $0xf0131ce6
f0110add:	50                   	push   %eax
f0110ade:	e8 a6 a0 00 00       	call   f011ab89 <strcmp>
f0110ae3:	83 c4 10             	add    $0x10,%esp
f0110ae6:	85 c0                	test   %eax,%eax
f0110ae8:	75 22                	jne    f0110b0c <tst_kheap+0x26d>
	{
		set_kheap_strategy(KHP_PLACE_FIRSTFIT);
f0110aea:	83 ec 0c             	sub    $0xc,%esp
f0110aed:	6a 01                	push   $0x1
f0110aef:	e8 66 f7 ff ff       	call   f011025a <set_kheap_strategy>
f0110af4:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0110af7:	83 ec 0c             	sub    $0xc,%esp
f0110afa:	68 ec 1c 13 f0       	push   $0xf0131cec
f0110aff:	e8 58 10 ff ff       	call   f0101b5c <cprintf>
f0110b04:	83 c4 10             	add    $0x10,%esp
f0110b07:	e9 68 01 00 00       	jmp    f0110c74 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f0110b0c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b0f:	83 c0 04             	add    $0x4,%eax
f0110b12:	8b 00                	mov    (%eax),%eax
f0110b14:	83 ec 08             	sub    $0x8,%esp
f0110b17:	68 19 1d 13 f0       	push   $0xf0131d19
f0110b1c:	50                   	push   %eax
f0110b1d:	e8 67 a0 00 00       	call   f011ab89 <strcmp>
f0110b22:	83 c4 10             	add    $0x10,%esp
f0110b25:	85 c0                	test   %eax,%eax
f0110b27:	74 1d                	je     f0110b46 <tst_kheap+0x2a7>
f0110b29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b2c:	83 c0 04             	add    $0x4,%eax
f0110b2f:	8b 00                	mov    (%eax),%eax
f0110b31:	83 ec 08             	sub    $0x8,%esp
f0110b34:	68 1c 1d 13 f0       	push   $0xf0131d1c
f0110b39:	50                   	push   %eax
f0110b3a:	e8 4a a0 00 00       	call   f011ab89 <strcmp>
f0110b3f:	83 c4 10             	add    $0x10,%esp
f0110b42:	85 c0                	test   %eax,%eax
f0110b44:	75 22                	jne    f0110b68 <tst_kheap+0x2c9>
	{
		set_kheap_strategy(KHP_PLACE_BESTFIT);
f0110b46:	83 ec 0c             	sub    $0xc,%esp
f0110b49:	6a 02                	push   $0x2
f0110b4b:	e8 0a f7 ff ff       	call   f011025a <set_kheap_strategy>
f0110b50:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0110b53:	83 ec 0c             	sub    $0xc,%esp
f0110b56:	68 20 1d 13 f0       	push   $0xf0131d20
f0110b5b:	e8 fc 0f ff ff       	call   f0101b5c <cprintf>
f0110b60:	83 c4 10             	add    $0x10,%esp
f0110b63:	e9 0c 01 00 00       	jmp    f0110c74 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f0110b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b6b:	83 c0 04             	add    $0x4,%eax
f0110b6e:	8b 00                	mov    (%eax),%eax
f0110b70:	83 ec 08             	sub    $0x8,%esp
f0110b73:	68 4c 1d 13 f0       	push   $0xf0131d4c
f0110b78:	50                   	push   %eax
f0110b79:	e8 0b a0 00 00       	call   f011ab89 <strcmp>
f0110b7e:	83 c4 10             	add    $0x10,%esp
f0110b81:	85 c0                	test   %eax,%eax
f0110b83:	74 1d                	je     f0110ba2 <tst_kheap+0x303>
f0110b85:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b88:	83 c0 04             	add    $0x4,%eax
f0110b8b:	8b 00                	mov    (%eax),%eax
f0110b8d:	83 ec 08             	sub    $0x8,%esp
f0110b90:	68 4f 1d 13 f0       	push   $0xf0131d4f
f0110b95:	50                   	push   %eax
f0110b96:	e8 ee 9f 00 00       	call   f011ab89 <strcmp>
f0110b9b:	83 c4 10             	add    $0x10,%esp
f0110b9e:	85 c0                	test   %eax,%eax
f0110ba0:	75 22                	jne    f0110bc4 <tst_kheap+0x325>
	{
		set_kheap_strategy(KHP_PLACE_NEXTFIT);
f0110ba2:	83 ec 0c             	sub    $0xc,%esp
f0110ba5:	6a 03                	push   $0x3
f0110ba7:	e8 ae f6 ff ff       	call   f011025a <set_kheap_strategy>
f0110bac:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0110baf:	83 ec 0c             	sub    $0xc,%esp
f0110bb2:	68 54 1d 13 f0       	push   $0xf0131d54
f0110bb7:	e8 a0 0f ff ff       	call   f0101b5c <cprintf>
f0110bbc:	83 c4 10             	add    $0x10,%esp
f0110bbf:	e9 b0 00 00 00       	jmp    f0110c74 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "WF") == 0 || strcmp(arguments[1], "wf") == 0)
f0110bc4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bc7:	83 c0 04             	add    $0x4,%eax
f0110bca:	8b 00                	mov    (%eax),%eax
f0110bcc:	83 ec 08             	sub    $0x8,%esp
f0110bcf:	68 80 1d 13 f0       	push   $0xf0131d80
f0110bd4:	50                   	push   %eax
f0110bd5:	e8 af 9f 00 00       	call   f011ab89 <strcmp>
f0110bda:	83 c4 10             	add    $0x10,%esp
f0110bdd:	85 c0                	test   %eax,%eax
f0110bdf:	74 1d                	je     f0110bfe <tst_kheap+0x35f>
f0110be1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110be4:	83 c0 04             	add    $0x4,%eax
f0110be7:	8b 00                	mov    (%eax),%eax
f0110be9:	83 ec 08             	sub    $0x8,%esp
f0110bec:	68 83 1d 13 f0       	push   $0xf0131d83
f0110bf1:	50                   	push   %eax
f0110bf2:	e8 92 9f 00 00       	call   f011ab89 <strcmp>
f0110bf7:	83 c4 10             	add    $0x10,%esp
f0110bfa:	85 c0                	test   %eax,%eax
f0110bfc:	75 1f                	jne    f0110c1d <tst_kheap+0x37e>
	{
		set_kheap_strategy(KHP_PLACE_WORSTFIT);
f0110bfe:	83 ec 0c             	sub    $0xc,%esp
f0110c01:	6a 04                	push   $0x4
f0110c03:	e8 52 f6 ff ff       	call   f011025a <set_kheap_strategy>
f0110c08:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f0110c0b:	83 ec 0c             	sub    $0xc,%esp
f0110c0e:	68 88 1d 13 f0       	push   $0xf0131d88
f0110c13:	e8 44 0f ff ff       	call   f0101b5c <cprintf>
f0110c18:	83 c4 10             	add    $0x10,%esp
f0110c1b:	eb 57                	jmp    f0110c74 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "CF") == 0 || strcmp(arguments[1], "cf") == 0)
f0110c1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c20:	83 c0 04             	add    $0x4,%eax
f0110c23:	8b 00                	mov    (%eax),%eax
f0110c25:	83 ec 08             	sub    $0x8,%esp
f0110c28:	68 b5 1d 13 f0       	push   $0xf0131db5
f0110c2d:	50                   	push   %eax
f0110c2e:	e8 56 9f 00 00       	call   f011ab89 <strcmp>
f0110c33:	83 c4 10             	add    $0x10,%esp
f0110c36:	85 c0                	test   %eax,%eax
f0110c38:	74 1d                	je     f0110c57 <tst_kheap+0x3b8>
f0110c3a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c3d:	83 c0 04             	add    $0x4,%eax
f0110c40:	8b 00                	mov    (%eax),%eax
f0110c42:	83 ec 08             	sub    $0x8,%esp
f0110c45:	68 b8 1d 13 f0       	push   $0xf0131db8
f0110c4a:	50                   	push   %eax
f0110c4b:	e8 39 9f 00 00       	call   f011ab89 <strcmp>
f0110c50:	83 c4 10             	add    $0x10,%esp
f0110c53:	85 c0                	test   %eax,%eax
f0110c55:	75 1d                	jne    f0110c74 <tst_kheap+0x3d5>
	{
		set_kheap_strategy(KHP_PLACE_CUSTOMFIT);
f0110c57:	83 ec 0c             	sub    $0xc,%esp
f0110c5a:	6a 05                	push   $0x5
f0110c5c:	e8 f9 f5 ff ff       	call   f011025a <set_kheap_strategy>
f0110c61:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is CUSTOM FIT\n");
f0110c64:	83 ec 0c             	sub    $0xc,%esp
f0110c67:	68 bc 1d 13 f0       	push   $0xf0131dbc
f0110c6c:	e8 eb 0e ff ff       	call   f0101b5c <cprintf>
f0110c71:	83 c4 10             	add    $0x10,%esp
	}
	// Test 1-kmalloc: tst kheap <Strategy> kmalloc <allocator>
	if(strcmp(arguments[2], "kmalloc") == 0)
f0110c74:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c77:	83 c0 08             	add    $0x8,%eax
f0110c7a:	8b 00                	mov    (%eax),%eax
f0110c7c:	83 ec 08             	sub    $0x8,%esp
f0110c7f:	68 b1 1a 13 f0       	push   $0xf0131ab1
f0110c84:	50                   	push   %eax
f0110c85:	e8 ff 9e 00 00       	call   f011ab89 <strcmp>
f0110c8a:	83 c4 10             	add    $0x10,%esp
f0110c8d:	85 c0                	test   %eax,%eax
f0110c8f:	75 18                	jne    f0110ca9 <tst_kheap+0x40a>
	{
		test_kmalloc(testType);
f0110c91:	83 ec 0c             	sub    $0xc,%esp
f0110c94:	ff 75 f4             	pushl  -0xc(%ebp)
f0110c97:	e8 42 65 00 00       	call   f01171de <test_kmalloc>
f0110c9c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110c9f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ca4:	e9 ea 00 00 00       	jmp    f0110d93 <tst_kheap+0x4f4>
	}
	// Test Fast Implementation of kmalloc/kfree: tst kheap <Startegy> fast
	else if(strcmp(arguments[2], "fast") == 0)
f0110ca9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cac:	83 c0 08             	add    $0x8,%eax
f0110caf:	8b 00                	mov    (%eax),%eax
f0110cb1:	83 ec 08             	sub    $0x8,%esp
f0110cb4:	68 14 1b 13 f0       	push   $0xf0131b14
f0110cb9:	50                   	push   %eax
f0110cba:	e8 ca 9e 00 00       	call   f011ab89 <strcmp>
f0110cbf:	83 c4 10             	add    $0x10,%esp
f0110cc2:	85 c0                	test   %eax,%eax
f0110cc4:	75 0f                	jne    f0110cd5 <tst_kheap+0x436>
	{
		test_fast_page_alloc();
f0110cc6:	e8 61 68 00 00       	call   f011752c <test_fast_page_alloc>
		return 0;
f0110ccb:	b8 00 00 00 00       	mov    $0x0,%eax
f0110cd0:	e9 be 00 00 00       	jmp    f0110d93 <tst_kheap+0x4f4>
	}
	// Test 2-kfree: tst kheap <Strategy> kfree <allocator>
	else if(strcmp(arguments[2], "kfree") == 0)
f0110cd5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cd8:	83 c0 08             	add    $0x8,%eax
f0110cdb:	8b 00                	mov    (%eax),%eax
f0110cdd:	83 ec 08             	sub    $0x8,%esp
f0110ce0:	68 5b 1b 13 f0       	push   $0xf0131b5b
f0110ce5:	50                   	push   %eax
f0110ce6:	e8 9e 9e 00 00       	call   f011ab89 <strcmp>
f0110ceb:	83 c4 10             	add    $0x10,%esp
f0110cee:	85 c0                	test   %eax,%eax
f0110cf0:	75 18                	jne    f0110d0a <tst_kheap+0x46b>
	{
		test_kfree(testType);
f0110cf2:	83 ec 0c             	sub    $0xc,%esp
f0110cf5:	ff 75 f4             	pushl  -0xc(%ebp)
f0110cf8:	e8 fb 65 00 00       	call   f01172f8 <test_kfree>
f0110cfd:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110d00:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d05:	e9 89 00 00 00       	jmp    f0110d93 <tst_kheap+0x4f4>
	}
	// Test 3-kphysaddr: tst kheap kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f0110d0a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d0d:	83 c0 08             	add    $0x8,%eax
f0110d10:	8b 00                	mov    (%eax),%eax
f0110d12:	83 ec 08             	sub    $0x8,%esp
f0110d15:	68 fd 1b 13 f0       	push   $0xf0131bfd
f0110d1a:	50                   	push   %eax
f0110d1b:	e8 69 9e 00 00       	call   f011ab89 <strcmp>
f0110d20:	83 c4 10             	add    $0x10,%esp
f0110d23:	85 c0                	test   %eax,%eax
f0110d25:	75 0c                	jne    f0110d33 <tst_kheap+0x494>
	{
		test_kheap_phys_addr();
f0110d27:	e8 60 68 00 00       	call   f011758c <test_kheap_phys_addr>
		return 0;
f0110d2c:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d31:	eb 60                	jmp    f0110d93 <tst_kheap+0x4f4>
	}
	// Test 4-kvirtaddr: tst kheap kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f0110d33:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d36:	83 c0 08             	add    $0x8,%eax
f0110d39:	8b 00                	mov    (%eax),%eax
f0110d3b:	83 ec 08             	sub    $0x8,%esp
f0110d3e:	68 ba 1b 13 f0       	push   $0xf0131bba
f0110d43:	50                   	push   %eax
f0110d44:	e8 40 9e 00 00       	call   f011ab89 <strcmp>
f0110d49:	83 c4 10             	add    $0x10,%esp
f0110d4c:	85 c0                	test   %eax,%eax
f0110d4e:	75 0c                	jne    f0110d5c <tst_kheap+0x4bd>
	{
		test_kheap_virt_addr();
f0110d50:	e8 57 68 00 00       	call   f01175ac <test_kheap_virt_addr>
		return 0;
f0110d55:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d5a:	eb 37                	jmp    f0110d93 <tst_kheap+0x4f4>
	}
	// Test 5-krealloc: tst kheap <Strategy> krealloc <allocator>
	else if(strcmp(arguments[2], "krealloc") == 0)
f0110d5c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d5f:	83 c0 08             	add    $0x8,%eax
f0110d62:	8b 00                	mov    (%eax),%eax
f0110d64:	83 ec 08             	sub    $0x8,%esp
f0110d67:	68 41 1c 13 f0       	push   $0xf0131c41
f0110d6c:	50                   	push   %eax
f0110d6d:	e8 17 9e 00 00       	call   f011ab89 <strcmp>
f0110d72:	83 c4 10             	add    $0x10,%esp
f0110d75:	85 c0                	test   %eax,%eax
f0110d77:	75 15                	jne    f0110d8e <tst_kheap+0x4ef>
	{
		test_krealloc(testType);
f0110d79:	83 ec 0c             	sub    $0xc,%esp
f0110d7c:	ff 75 f4             	pushl  -0xc(%ebp)
f0110d7f:	e8 8e 66 00 00       	call   f0117412 <test_krealloc>
f0110d84:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110d87:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d8c:	eb 05                	jmp    f0110d93 <tst_kheap+0x4f4>
	/*	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
	{
		test_ksbrk();
	}*/
	return 0;
f0110d8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110d93:	c9                   	leave  
f0110d94:	c3                   	ret    

f0110d95 <IDX>:

short* startVAsInit[DYN_ALLOC_MAX_BLOCK_SIZE + 1] ;
short* endVAsInit[DYN_ALLOC_MAX_BLOCK_SIZE + 1] ;

__inline__ uint8 IDX(uint32 size)
{
f0110d95:	55                   	push   %ebp
f0110d96:	89 e5                	mov    %esp,%ebp
f0110d98:	83 ec 10             	sub    $0x10,%esp
	size>>= LOG2_MIN_SIZE;
f0110d9b:	c1 6d 08 03          	shrl   $0x3,0x8(%ebp)
	int index = 0;
f0110d9f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while ((size>>=1) != 0)
f0110da6:	eb 03                	jmp    f0110dab <IDX+0x16>
	{
		index++;
f0110da8:	ff 45 fc             	incl   -0x4(%ebp)

__inline__ uint8 IDX(uint32 size)
{
	size>>= LOG2_MIN_SIZE;
	int index = 0;
	while ((size>>=1) != 0)
f0110dab:	d1 6d 08             	shrl   0x8(%ebp)
f0110dae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0110db2:	75 f4                	jne    f0110da8 <IDX+0x13>
	{
		index++;
	}
	return index;
f0110db4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0110db7:	c9                   	leave  
f0110db8:	c3                   	ret    

f0110db9 <check_dynalloc_datastruct>:

int check_dynalloc_datastruct(uint32 curSize, uint32 numOfBlksAtCurSize)
{
f0110db9:	55                   	push   %ebp
f0110dba:	89 e5                	mov    %esp,%ebp
f0110dbc:	53                   	push   %ebx
f0110dbd:	83 ec 44             	sub    $0x44,%esp
	int maxNumOfBlksPerPage = PAGE_SIZE / curSize;
f0110dc0:	b8 00 10 00 00       	mov    $0x1000,%eax
f0110dc5:	ba 00 00 00 00       	mov    $0x0,%edx
f0110dca:	f7 75 08             	divl   0x8(%ebp)
f0110dcd:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int expectedNumOfCompletePages = numOfBlksAtCurSize / maxNumOfBlksPerPage;
f0110dd0:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f0110dd3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110dd6:	ba 00 00 00 00       	mov    $0x0,%edx
f0110ddb:	f7 f3                	div    %ebx
f0110ddd:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int expectedNumOfInCompletePages = numOfBlksAtCurSize % maxNumOfBlksPerPage != 0? 1 : 0;
f0110de0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0110de3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110de6:	ba 00 00 00 00       	mov    $0x0,%edx
f0110deb:	f7 f1                	div    %ecx
f0110ded:	89 d0                	mov    %edx,%eax
f0110def:	85 c0                	test   %eax,%eax
f0110df1:	0f 95 c0             	setne  %al
f0110df4:	0f b6 c0             	movzbl %al,%eax
f0110df7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	int expectedNumOfFreeBlks = expectedNumOfInCompletePages * (maxNumOfBlksPerPage - numOfBlksAtCurSize % maxNumOfBlksPerPage);
f0110dfa:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0110dfd:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f0110e00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e03:	ba 00 00 00 00       	mov    $0x0,%edx
f0110e08:	f7 f3                	div    %ebx
f0110e0a:	89 d0                	mov    %edx,%eax
f0110e0c:	29 c1                	sub    %eax,%ecx
f0110e0e:	89 ca                	mov    %ecx,%edx
f0110e10:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110e13:	0f af c2             	imul   %edx,%eax
f0110e16:	89 45 d0             	mov    %eax,-0x30(%ebp)

	//[1] Check PageBlkInfoArr
	int numOfPages = DYN_ALLOC_MAX_SIZE / PAGE_SIZE;
f0110e19:	c7 45 cc 00 20 00 00 	movl   $0x2000,-0x34(%ebp)
	int actualNumOfCompletePages = 0;
f0110e20:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int actualNumOfInCompletePages = 0;
f0110e27:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int actualNumOfFreeBlks = 0;
f0110e2e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfPages; ++i)
f0110e35:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110e3c:	eb 59                	jmp    f0110e97 <check_dynalloc_datastruct+0xde>
	{
		if (pageBlockInfoArr[i].block_size == curSize)
f0110e3e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0110e41:	89 d0                	mov    %edx,%eax
f0110e43:	01 c0                	add    %eax,%eax
f0110e45:	01 d0                	add    %edx,%eax
f0110e47:	c1 e0 02             	shl    $0x2,%eax
f0110e4a:	05 28 e0 83 f0       	add    $0xf083e028,%eax
f0110e4f:	8b 00                	mov    (%eax),%eax
f0110e51:	0f b7 c0             	movzwl %ax,%eax
f0110e54:	3b 45 08             	cmp    0x8(%ebp),%eax
f0110e57:	75 3b                	jne    f0110e94 <check_dynalloc_datastruct+0xdb>
		{
			if (pageBlockInfoArr[i].num_of_free_blocks == 0)
f0110e59:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0110e5c:	89 d0                	mov    %edx,%eax
f0110e5e:	01 c0                	add    %eax,%eax
f0110e60:	01 d0                	add    %edx,%eax
f0110e62:	c1 e0 02             	shl    $0x2,%eax
f0110e65:	05 2a e0 83 f0       	add    $0xf083e02a,%eax
f0110e6a:	66 8b 00             	mov    (%eax),%ax
f0110e6d:	66 85 c0             	test   %ax,%ax
f0110e70:	75 05                	jne    f0110e77 <check_dynalloc_datastruct+0xbe>
			{
				actualNumOfCompletePages++;
f0110e72:	ff 45 f4             	incl   -0xc(%ebp)
f0110e75:	eb 1d                	jmp    f0110e94 <check_dynalloc_datastruct+0xdb>
			}
			else
			{
				actualNumOfInCompletePages++;
f0110e77:	ff 45 f0             	incl   -0x10(%ebp)
				actualNumOfFreeBlks += pageBlockInfoArr[i].num_of_free_blocks;
f0110e7a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0110e7d:	89 d0                	mov    %edx,%eax
f0110e7f:	01 c0                	add    %eax,%eax
f0110e81:	01 d0                	add    %edx,%eax
f0110e83:	c1 e0 02             	shl    $0x2,%eax
f0110e86:	05 2a e0 83 f0       	add    $0xf083e02a,%eax
f0110e8b:	66 8b 00             	mov    (%eax),%ax
f0110e8e:	0f b7 c0             	movzwl %ax,%eax
f0110e91:	01 45 ec             	add    %eax,-0x14(%ebp)
	//[1] Check PageBlkInfoArr
	int numOfPages = DYN_ALLOC_MAX_SIZE / PAGE_SIZE;
	int actualNumOfCompletePages = 0;
	int actualNumOfInCompletePages = 0;
	int actualNumOfFreeBlks = 0;
	for (int i = 0; i < numOfPages; ++i)
f0110e94:	ff 45 e8             	incl   -0x18(%ebp)
f0110e97:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110e9a:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f0110e9d:	7c 9f                	jl     f0110e3e <check_dynalloc_datastruct+0x85>
				actualNumOfInCompletePages++;
				actualNumOfFreeBlks += pageBlockInfoArr[i].num_of_free_blocks;
			}
		}
	}
	if (actualNumOfCompletePages != expectedNumOfCompletePages ||
f0110e9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110ea2:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0110ea5:	75 10                	jne    f0110eb7 <check_dynalloc_datastruct+0xfe>
f0110ea7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110eaa:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0110ead:	75 08                	jne    f0110eb7 <check_dynalloc_datastruct+0xfe>
			actualNumOfInCompletePages != expectedNumOfInCompletePages ||
f0110eaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110eb2:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0110eb5:	74 1c                	je     f0110ed3 <check_dynalloc_datastruct+0x11a>
			actualNumOfFreeBlks != expectedNumOfFreeBlks)
	{
		cprintf_colored(TEXT_TESTERR_CLR, "PageBlkInfoArr is not set/updated correctly!\n");
f0110eb7:	83 ec 08             	sub    $0x8,%esp
f0110eba:	68 ec 1d 13 f0       	push   $0xf0131dec
f0110ebf:	6a 0c                	push   $0xc
f0110ec1:	e8 c6 0c ff ff       	call   f0101b8c <cprintf_colored>
f0110ec6:	83 c4 10             	add    $0x10,%esp
		//		cprintf("actualNumOfCompletePages = %d, expectedNumOfCompletePages = %d\n", actualNumOfCompletePages, expectedNumOfCompletePages);
		//		cprintf("actualNumOfInCompletePages = %d, expectedNumOfInCompletePages = %d\n", actualNumOfInCompletePages, expectedNumOfInCompletePages);
		//		cprintf("actualNumOfFreeBlks = %d, expectedNumOfFreeBlks = %d\n", actualNumOfFreeBlks, expectedNumOfFreeBlks);
		return 0;
f0110ec9:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ece:	e9 9d 00 00 00       	jmp    f0110f70 <check_dynalloc_datastruct+0x1b7>
	}

	//[2] Check freeBlkLists
	int index = IDX(curSize);
f0110ed3:	83 ec 0c             	sub    $0xc,%esp
f0110ed6:	ff 75 08             	pushl  0x8(%ebp)
f0110ed9:	e8 b7 fe ff ff       	call   f0110d95 <IDX>
f0110ede:	83 c4 10             	add    $0x10,%esp
f0110ee1:	0f b6 c0             	movzbl %al,%eax
f0110ee4:	89 45 c8             	mov    %eax,-0x38(%ebp)
	struct BlockElement_List *ptrList = &freeBlockLists[index];
f0110ee7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110eea:	c1 e0 04             	shl    $0x4,%eax
f0110eed:	05 a0 62 85 f0       	add    $0xf08562a0,%eax
f0110ef2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	int n = 0;
f0110ef5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	struct BlockElement *ptrBlk;
	LIST_FOREACH(ptrBlk, ptrList)
f0110efc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110eff:	8b 00                	mov    (%eax),%eax
f0110f01:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0110f04:	eb 0c                	jmp    f0110f12 <check_dynalloc_datastruct+0x159>
	{
		n++;
f0110f06:	ff 45 e4             	incl   -0x1c(%ebp)
	//[2] Check freeBlkLists
	int index = IDX(curSize);
	struct BlockElement_List *ptrList = &freeBlockLists[index];
	int n = 0;
	struct BlockElement *ptrBlk;
	LIST_FOREACH(ptrBlk, ptrList)
f0110f09:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110f0c:	8b 40 08             	mov    0x8(%eax),%eax
f0110f0f:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0110f12:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110f16:	74 07                	je     f0110f1f <check_dynalloc_datastruct+0x166>
f0110f18:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110f1b:	8b 00                	mov    (%eax),%eax
f0110f1d:	eb 05                	jmp    f0110f24 <check_dynalloc_datastruct+0x16b>
f0110f1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f24:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0110f27:	89 42 08             	mov    %eax,0x8(%edx)
f0110f2a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110f2d:	8b 40 08             	mov    0x8(%eax),%eax
f0110f30:	85 c0                	test   %eax,%eax
f0110f32:	75 d2                	jne    f0110f06 <check_dynalloc_datastruct+0x14d>
f0110f34:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110f38:	75 cc                	jne    f0110f06 <check_dynalloc_datastruct+0x14d>
	{
		n++;
	}
	if (LIST_SIZE(ptrList) != expectedNumOfFreeBlks || n != expectedNumOfFreeBlks)
f0110f3a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110f3d:	8b 50 0c             	mov    0xc(%eax),%edx
f0110f40:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110f43:	39 c2                	cmp    %eax,%edx
f0110f45:	75 08                	jne    f0110f4f <check_dynalloc_datastruct+0x196>
f0110f47:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110f4a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0110f4d:	74 1c                	je     f0110f6b <check_dynalloc_datastruct+0x1b2>
	{
		cprintf_colored(TEXT_TESTERR_CLR,"freeBlockLists[%d] is not updated correctly!", index);
f0110f4f:	83 ec 04             	sub    $0x4,%esp
f0110f52:	ff 75 c8             	pushl  -0x38(%ebp)
f0110f55:	68 1c 1e 13 f0       	push   $0xf0131e1c
f0110f5a:	6a 0c                	push   $0xc
f0110f5c:	e8 2b 0c ff ff       	call   f0101b8c <cprintf_colored>
f0110f61:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110f64:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f69:	eb 05                	jmp    f0110f70 <check_dynalloc_datastruct+0x1b7>
	}
	return 1;
f0110f6b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110f70:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0110f73:	c9                   	leave  
f0110f74:	c3                   	ret    

f0110f75 <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f0110f75:	55                   	push   %ebp
f0110f76:	89 e5                	mov    %esp,%ebp
f0110f78:	83 ec 08             	sub    $0x8,%esp
	panic("update is required!!");
f0110f7b:	83 ec 04             	sub    $0x4,%esp
f0110f7e:	68 49 1e 13 f0       	push   $0xf0131e49
f0110f83:	6a 64                	push   $0x64
f0110f85:	68 60 1e 13 f0       	push   $0xf0131e60
f0110f8a:	e8 20 ff fe ff       	call   f0100eaf <_panic>

f0110f8f <remove_current_mappings>:
extern uint32* ptr_page_directory;
extern void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address);
extern uint32 sys_calculate_free_frames() ;

void remove_current_mappings(uint32 startVA, uint32 endVA)
{
f0110f8f:	55                   	push   %ebp
f0110f90:	89 e5                	mov    %esp,%ebp
f0110f92:	83 ec 18             	sub    $0x18,%esp
	assert(startVA >= KERNEL_HEAP_START && endVA >= KERNEL_HEAP_START);
f0110f95:	81 7d 08 ff ff ff f5 	cmpl   $0xf5ffffff,0x8(%ebp)
f0110f9c:	76 09                	jbe    f0110fa7 <remove_current_mappings+0x18>
f0110f9e:	81 7d 0c ff ff ff f5 	cmpl   $0xf5ffffff,0xc(%ebp)
f0110fa5:	77 16                	ja     f0110fbd <remove_current_mappings+0x2e>
f0110fa7:	68 84 1e 13 f0       	push   $0xf0131e84
f0110fac:	68 bf 1e 13 f0       	push   $0xf0131ebf
f0110fb1:	6a 73                	push   $0x73
f0110fb3:	68 60 1e 13 f0       	push   $0xf0131e60
f0110fb8:	e8 f2 fe fe ff       	call   f0100eaf <_panic>
	for (uint32 va = startVA; va < endVA; va+=PAGE_SIZE)
f0110fbd:	8b 45 08             	mov    0x8(%ebp),%eax
f0110fc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110fc3:	eb 1b                	jmp    f0110fe0 <remove_current_mappings+0x51>
	{
		unmap_frame(ptr_page_directory, va);
f0110fc5:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0110fca:	83 ec 08             	sub    $0x8,%esp
f0110fcd:	ff 75 f4             	pushl  -0xc(%ebp)
f0110fd0:	50                   	push   %eax
f0110fd1:	e8 7c 86 ff ff       	call   f0109652 <unmap_frame>
f0110fd6:	83 c4 10             	add    $0x10,%esp
extern uint32 sys_calculate_free_frames() ;

void remove_current_mappings(uint32 startVA, uint32 endVA)
{
	assert(startVA >= KERNEL_HEAP_START && endVA >= KERNEL_HEAP_START);
	for (uint32 va = startVA; va < endVA; va+=PAGE_SIZE)
f0110fd9:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0110fe0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110fe3:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110fe6:	72 dd                	jb     f0110fc5 <remove_current_mappings+0x36>
	{
		unmap_frame(ptr_page_directory, va);
	}
}
f0110fe8:	90                   	nop
f0110fe9:	c9                   	leave  
f0110fea:	c3                   	ret    

f0110feb <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f0110feb:	55                   	push   %ebp
f0110fec:	89 e5                	mov    %esp,%ebp
f0110fee:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110ff1:	83 ec 04             	sub    $0x4,%esp
f0110ff4:	68 d4 1e 13 f0       	push   $0xf0131ed4
f0110ff9:	6a 7e                	push   $0x7e
f0110ffb:	68 60 1e 13 f0       	push   $0xf0131e60
f0111000:	e8 aa fe fe ff       	call   f0100eaf <_panic>

f0111005 <test_initial_alloc>:
			"\nCongratulations!! test initialize_dynamic_allocator completed successfully.\n"
			"=============================================================================\n");
}

int test_initial_alloc()
{
f0111005:	55                   	push   %ebp
f0111006:	89 e5                	mov    %esp,%ebp
f0111008:	83 ec 58             	sub    $0x58,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f011100b:	83 ec 04             	sub    $0x4,%esp
f011100e:	68 34 1f 13 f0       	push   $0xf0131f34
f0111013:	68 b8 00 00 00       	push   $0xb8
f0111018:	68 60 1e 13 f0       	push   $0xf0131e60
f011101d:	e8 8d fe fe ff       	call   f0100eaf <_panic>

f0111022 <test_alloc_block>:

	return eval;
}

void test_alloc_block()
{
f0111022:	55                   	push   %ebp
f0111023:	89 e5                	mov    %esp,%ebp
f0111025:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_alloc_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111028:	83 ec 04             	sub    $0x4,%esp
f011102b:	68 84 1f 13 f0       	push   $0xf0131f84
f0111030:	68 6f 01 00 00       	push   $0x16f
f0111035:	68 60 1e 13 f0       	push   $0xf0131e60
f011103a:	e8 70 fe fe ff       	call   f0100eaf <_panic>

f011103f <test_free_block>:
	cprintf("test alloc_block Evaluation = %d%\n", eval);
	return ;
}

void test_free_block()
{
f011103f:	55                   	push   %ebp
f0111040:	89 e5                	mov    %esp,%ebp
f0111042:	83 ec 08             	sub    $0x8,%esp
	panic("update is required!!");
f0111045:	83 ec 04             	sub    $0x4,%esp
f0111048:	68 49 1e 13 f0       	push   $0xf0131e49
f011104d:	68 84 01 00 00       	push   $0x184
f0111052:	68 60 1e 13 f0       	push   $0xf0131e60
f0111057:	e8 53 fe fe ff       	call   f0100eaf <_panic>

f011105c <test_realloc_block>:
	cprintf("===========================================================\n") ;
	void*expected_va ;
}

void test_realloc_block()
{
f011105c:	55                   	push   %ebp
f011105d:	89 e5                	mov    %esp,%ebp
f011105f:	83 ec 08             	sub    $0x8,%esp
	panic("update is required!!");
f0111062:	83 ec 04             	sub    $0x4,%esp
f0111065:	68 49 1e 13 f0       	push   $0xf0131e49
f011106a:	68 93 01 00 00       	push   $0x193
f011106f:	68 60 1e 13 f0       	push   $0xf0131e60
f0111074:	e8 36 fe fe ff       	call   f0100eaf <_panic>

f0111079 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0111079:	55                   	push   %ebp
f011107a:	89 e5                	mov    %esp,%ebp
f011107c:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f011107f:	e8 97 a9 ff ff       	call   f010ba1b <get_cpu_proc>
f0111084:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0111087:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011108b:	75 16                	jne    f01110a3 <sys_check_LRU_lists+0x2a>
f011108d:	68 d4 1f 13 f0       	push   $0xf0131fd4
f0111092:	68 e4 1f 13 f0       	push   $0xf0131fe4
f0111097:	6a 10                	push   $0x10
f0111099:	68 f9 1f 13 f0       	push   $0xf0131ff9
f011109e:	e8 0c fe fe ff       	call   f0100eaf <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f01110a3:	83 ec 0c             	sub    $0xc,%esp
f01110a6:	68 18 20 13 f0       	push   $0xf0132018
f01110ab:	e8 ac 0a ff ff       	call   f0101b5c <cprintf>
f01110b0:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f01110b3:	83 ec 0c             	sub    $0xc,%esp
f01110b6:	ff 75 e0             	pushl  -0x20(%ebp)
f01110b9:	e8 24 94 ff ff       	call   f010a4e2 <env_page_ws_print>
f01110be:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f01110c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01110c4:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f01110c7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f01110ce:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f01110d5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01110d9:	0f 84 a5 00 00 00    	je     f0111184 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f01110df:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01110e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01110e9:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01110ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01110f2:	eb 4a                	jmp    f011113e <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f01110f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01110f7:	8b 00                	mov    (%eax),%eax
f01110f9:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01110fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01110ff:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111104:	89 c2                	mov    %eax,%edx
f0111106:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111109:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111110:	8b 45 08             	mov    0x8(%ebp),%eax
f0111113:	01 c8                	add    %ecx,%eax
f0111115:	8b 00                	mov    (%eax),%eax
f0111117:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011111a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011111d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111122:	39 c2                	cmp    %eax,%edx
f0111124:	74 09                	je     f011112f <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f0111126:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f011112d:	eb 3e                	jmp    f011116d <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f011112f:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111132:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111135:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f011113b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011113e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111142:	74 08                	je     f011114c <sys_check_LRU_lists+0xd3>
f0111144:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111147:	8b 40 10             	mov    0x10(%eax),%eax
f011114a:	eb 05                	jmp    f0111151 <sys_check_LRU_lists+0xd8>
f011114c:	b8 00 00 00 00       	mov    $0x0,%eax
f0111151:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111154:	89 82 70 05 00 00    	mov    %eax,0x570(%edx)
f011115a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011115d:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0111163:	85 c0                	test   %eax,%eax
f0111165:	75 8d                	jne    f01110f4 <sys_check_LRU_lists+0x7b>
f0111167:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011116b:	75 87                	jne    f01110f4 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f011116d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111170:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f0111176:	8b 45 10             	mov    0x10(%ebp),%eax
f0111179:	39 c2                	cmp    %eax,%edx
f011117b:	74 07                	je     f0111184 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f011117d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0111184:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0111188:	0f 84 a5 00 00 00    	je     f0111233 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f011118e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111195:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111198:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f011119e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01111a1:	eb 4a                	jmp    f01111ed <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f01111a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01111a6:	8b 00                	mov    (%eax),%eax
f01111a8:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01111ab:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01111ae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01111b3:	89 c2                	mov    %eax,%edx
f01111b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01111b8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01111bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01111c2:	01 c8                	add    %ecx,%eax
f01111c4:	8b 00                	mov    (%eax),%eax
f01111c6:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01111c9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01111cc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01111d1:	39 c2                	cmp    %eax,%edx
f01111d3:	74 09                	je     f01111de <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f01111d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f01111dc:	eb 3e                	jmp    f011121c <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f01111de:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01111e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01111e4:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f01111ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01111ed:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01111f1:	74 08                	je     f01111fb <sys_check_LRU_lists+0x182>
f01111f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01111f6:	8b 40 10             	mov    0x10(%eax),%eax
f01111f9:	eb 05                	jmp    f0111200 <sys_check_LRU_lists+0x187>
f01111fb:	b8 00 00 00 00       	mov    $0x0,%eax
f0111200:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111203:	89 82 80 05 00 00    	mov    %eax,0x580(%edx)
f0111209:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011120c:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f0111212:	85 c0                	test   %eax,%eax
f0111214:	75 8d                	jne    f01111a3 <sys_check_LRU_lists+0x12a>
f0111216:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011121a:	75 87                	jne    f01111a3 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f011121c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011121f:	8b 90 84 05 00 00    	mov    0x584(%eax),%edx
f0111225:	8b 45 14             	mov    0x14(%ebp),%eax
f0111228:	39 c2                	cmp    %eax,%edx
f011122a:	74 07                	je     f0111233 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f011122c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f0111233:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111236:	23 45 f0             	and    -0x10(%ebp),%eax
}
f0111239:	c9                   	leave  
f011123a:	c3                   	ret    

f011123b <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f011123b:	55                   	push   %ebp
f011123c:	89 e5                	mov    %esp,%ebp
f011123e:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0111241:	e8 d5 a7 ff ff       	call   f010ba1b <get_cpu_proc>
f0111246:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0111249:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011124d:	75 16                	jne    f0111265 <sys_check_LRU_lists_free+0x2a>
f011124f:	68 d4 1f 13 f0       	push   $0xf0131fd4
f0111254:	68 e4 1f 13 f0       	push   $0xf0131fe4
f0111259:	6a 45                	push   $0x45
f011125b:	68 f9 1f 13 f0       	push   $0xf0131ff9
f0111260:	e8 4a fc fe ff       	call   f0100eaf <_panic>
	struct Env* env = cur_env;
f0111265:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111268:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f011126b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111272:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111275:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f011127b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011127e:	eb 65                	jmp    f01112e5 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f0111280:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0111287:	eb 3a                	jmp    f01112c3 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111289:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011128c:	8b 00                	mov    (%eax),%eax
f011128e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0111291:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111294:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111299:	89 c2                	mov    %eax,%edx
f011129b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011129e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01112a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01112a8:	01 c8                	add    %ecx,%eax
f01112aa:	8b 00                	mov    (%eax),%eax
f01112ac:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01112af:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01112b2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112b7:	39 c2                	cmp    %eax,%edx
f01112b9:	75 05                	jne    f01112c0 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f01112bb:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f01112be:	eb 0b                	jmp    f01112cb <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f01112c0:	ff 45 ec             	incl   -0x14(%ebp)
f01112c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01112c6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01112c9:	7c be                	jl     f0111289 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f01112cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01112cf:	7e 08                	jle    f01112d9 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f01112d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01112d4:	e9 ed 00 00 00       	jmp    f01113c6 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01112d9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01112dc:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01112e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01112e5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01112e9:	74 08                	je     f01112f3 <sys_check_LRU_lists_free+0xb8>
f01112eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01112ee:	8b 40 10             	mov    0x10(%eax),%eax
f01112f1:	eb 05                	jmp    f01112f8 <sys_check_LRU_lists_free+0xbd>
f01112f3:	b8 00 00 00 00       	mov    $0x0,%eax
f01112f8:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01112fb:	89 82 70 05 00 00    	mov    %eax,0x570(%edx)
f0111301:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111304:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f011130a:	85 c0                	test   %eax,%eax
f011130c:	0f 85 6e ff ff ff    	jne    f0111280 <sys_check_LRU_lists_free+0x45>
f0111312:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111316:	0f 85 64 ff ff ff    	jne    f0111280 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011131c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011131f:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0111325:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111328:	eb 62                	jmp    f011138c <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f011132a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0111331:	eb 3a                	jmp    f011136d <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111333:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111336:	8b 00                	mov    (%eax),%eax
f0111338:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011133b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011133e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111343:	89 c2                	mov    %eax,%edx
f0111345:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111348:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011134f:	8b 45 08             	mov    0x8(%ebp),%eax
f0111352:	01 c8                	add    %ecx,%eax
f0111354:	8b 00                	mov    (%eax),%eax
f0111356:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0111359:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011135c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111361:	39 c2                	cmp    %eax,%edx
f0111363:	75 05                	jne    f011136a <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f0111365:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0111368:	eb 0b                	jmp    f0111375 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f011136a:	ff 45 e8             	incl   -0x18(%ebp)
f011136d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111370:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111373:	7c be                	jl     f0111333 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0111375:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111379:	7e 05                	jle    f0111380 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f011137b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011137e:	eb 46                	jmp    f01113c6 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111380:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111383:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f0111389:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011138c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111390:	74 08                	je     f011139a <sys_check_LRU_lists_free+0x15f>
f0111392:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111395:	8b 40 10             	mov    0x10(%eax),%eax
f0111398:	eb 05                	jmp    f011139f <sys_check_LRU_lists_free+0x164>
f011139a:	b8 00 00 00 00       	mov    $0x0,%eax
f011139f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01113a2:	89 82 80 05 00 00    	mov    %eax,0x580(%edx)
f01113a8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01113ab:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f01113b1:	85 c0                	test   %eax,%eax
f01113b3:	0f 85 71 ff ff ff    	jne    f011132a <sys_check_LRU_lists_free+0xef>
f01113b9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01113bd:	0f 85 67 ff ff ff    	jne    f011132a <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f01113c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01113c6:	c9                   	leave  
f01113c7:	c3                   	ret    

f01113c8 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f01113c8:	55                   	push   %ebp
f01113c9:	89 e5                	mov    %esp,%ebp
f01113cb:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
//	env_page_ws_print(get_cpu_proc());
	struct Env* cur_env = get_cpu_proc();
f01113ce:	e8 48 a6 ff ff       	call   f010ba1b <get_cpu_proc>
f01113d3:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f01113d6:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01113da:	75 16                	jne    f01113f2 <sys_check_WS_list+0x2a>
f01113dc:	68 d4 1f 13 f0       	push   $0xf0131fd4
f01113e1:	68 e4 1f 13 f0       	push   $0xf0131fe4
f01113e6:	6a 79                	push   $0x79
f01113e8:	68 f9 1f 13 f0       	push   $0xf0131ff9
f01113ed:	e8 bd fa fe ff       	call   f0100eaf <_panic>
	struct Env* env = cur_env;
f01113f2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01113f5:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f01113f8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f01113ff:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0111403:	74 06                	je     f011140b <sys_check_WS_list+0x43>
f0111405:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0111409:	75 1f                	jne    f011142a <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f011140b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011140e:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f0111414:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111417:	39 c2                	cmp    %eax,%edx
f0111419:	74 0f                	je     f011142a <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f011141b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111422:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111425:	e9 ec 02 00 00       	jmp    f0111716 <sys_check_WS_list+0x34e>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f011142a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011142e:	74 39                	je     f0111469 <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0111430:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111433:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f0111439:	8b 00                	mov    (%eax),%eax
f011143b:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011143e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111441:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111446:	89 c2                	mov    %eax,%edx
f0111448:	8b 45 10             	mov    0x10(%ebp),%eax
f011144b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011144e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0111451:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111456:	39 c2                	cmp    %eax,%edx
f0111458:	74 0f                	je     f0111469 <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f011145a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111461:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111464:	e9 ad 02 00 00       	jmp    f0111716 <sys_check_WS_list+0x34e>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f0111469:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f011146d:	0f 85 13 01 00 00    	jne    f0111586 <sys_check_WS_list+0x1be>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f0111473:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f011147a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011147e:	74 4c                	je     f01114cc <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0111480:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0111487:	eb 3b                	jmp    f01114c4 <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0111489:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011148c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111493:	8b 45 08             	mov    0x8(%ebp),%eax
f0111496:	01 d0                	add    %edx,%eax
f0111498:	8b 00                	mov    (%eax),%eax
f011149a:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011149d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01114a0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01114a5:	89 c2                	mov    %eax,%edx
f01114a7:	8b 45 10             	mov    0x10(%ebp),%eax
f01114aa:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01114ad:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01114b0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01114b5:	39 c2                	cmp    %eax,%edx
f01114b7:	75 08                	jne    f01114c1 <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f01114b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01114bc:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f01114bf:	eb 0b                	jmp    f01114cc <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f01114c1:	ff 45 e8             	incl   -0x18(%ebp)
f01114c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01114c7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01114ca:	7c bd                	jl     f0111489 <sys_check_WS_list+0xc1>
				}
			}
		}
		//cprintf("index of last WS element = %d\n",idx_WS_list);
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f01114cc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114cf:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01114d5:	85 c0                	test   %eax,%eax
f01114d7:	74 0e                	je     f01114e7 <sys_check_WS_list+0x11f>
			ptr_WS_element = env->page_last_WS_element;
f01114d9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114dc:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01114e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01114e5:	eb 0c                	jmp    f01114f3 <sys_check_WS_list+0x12b>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f01114e7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114ea:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01114f0:	89 45 f0             	mov    %eax,-0x10(%ebp)

		//cprintf("comparison start from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f01114f3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01114fa:	eb 79                	jmp    f0111575 <sys_check_WS_list+0x1ad>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f01114fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01114ff:	8b 00                	mov    (%eax),%eax
f0111501:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0111504:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111507:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011150c:	89 c2                	mov    %eax,%edx
f011150e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111511:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111518:	8b 45 08             	mov    0x8(%ebp),%eax
f011151b:	01 c8                	add    %ecx,%eax
f011151d:	8b 00                	mov    (%eax),%eax
f011151f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0111522:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111525:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011152a:	39 c2                	cmp    %eax,%edx
f011152c:	74 0c                	je     f011153a <sys_check_WS_list+0x172>
			{
				WS_list_validation = 0;
f011152e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111535:	e9 d9 01 00 00       	jmp    f0111713 <sys_check_WS_list+0x34b>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f011153a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011153d:	40                   	inc    %eax
f011153e:	89 c2                	mov    %eax,%edx
f0111540:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111543:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f0111549:	89 d0                	mov    %edx,%eax
f011154b:	ba 00 00 00 00       	mov    $0x0,%edx
f0111550:	f7 f1                	div    %ecx
f0111552:	89 d0                	mov    %edx,%eax
f0111554:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f0111557:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011155a:	8b 40 10             	mov    0x10(%eax),%eax
f011155d:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f0111560:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111564:	75 0c                	jne    f0111572 <sys_check_WS_list+0x1aa>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0111566:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111569:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f011156f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		//cprintf("comparison start from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111572:	ff 45 e4             	incl   -0x1c(%ebp)
f0111575:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111578:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011157b:	0f 8c 7b ff ff ff    	jl     f01114fc <sys_check_WS_list+0x134>
f0111581:	e9 8d 01 00 00       	jmp    f0111713 <sys_check_WS_list+0x34b>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f0111586:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f011158a:	74 0a                	je     f0111596 <sys_check_WS_list+0x1ce>
f011158c:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f0111590:	0f 85 be 00 00 00    	jne    f0111654 <sys_check_WS_list+0x28c>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111596:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011159d:	e9 a1 00 00 00       	jmp    f0111643 <sys_check_WS_list+0x27b>
		{
			bool found = 0;
f01115a2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01115a9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115ac:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01115b2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01115b5:	eb 47                	jmp    f01115fe <sys_check_WS_list+0x236>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f01115b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01115ba:	8b 00                	mov    (%eax),%eax
f01115bc:	89 45 a8             	mov    %eax,-0x58(%ebp)
f01115bf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01115c2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115c7:	89 c2                	mov    %eax,%edx
f01115c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01115cc:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01115d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01115d6:	01 c8                	add    %ecx,%eax
f01115d8:	8b 00                	mov    (%eax),%eax
f01115da:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f01115dd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01115e0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115e5:	39 c2                	cmp    %eax,%edx
f01115e7:	75 09                	jne    f01115f2 <sys_check_WS_list+0x22a>
				{
					found = 1;
f01115e9:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f01115f0:	eb 3b                	jmp    f011162d <sys_check_WS_list+0x265>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01115f2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115f5:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01115fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01115fe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111602:	74 08                	je     f011160c <sys_check_WS_list+0x244>
f0111604:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111607:	8b 40 10             	mov    0x10(%eax),%eax
f011160a:	eb 05                	jmp    f0111611 <sys_check_WS_list+0x249>
f011160c:	b8 00 00 00 00       	mov    $0x0,%eax
f0111611:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0111614:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f011161a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011161d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0111623:	85 c0                	test   %eax,%eax
f0111625:	75 90                	jne    f01115b7 <sys_check_WS_list+0x1ef>
f0111627:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011162b:	75 8a                	jne    f01115b7 <sys_check_WS_list+0x1ef>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f011162d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0111631:	75 0d                	jne    f0111640 <sys_check_WS_list+0x278>
			{
				WS_list_validation = 0;
f0111633:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f011163a:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011163b:	e9 d3 00 00 00       	jmp    f0111713 <sys_check_WS_list+0x34b>
f0111640:	ff 45 e0             	incl   -0x20(%ebp)
f0111643:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111646:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111649:	0f 8c 53 ff ff ff    	jl     f01115a2 <sys_check_WS_list+0x1da>
f011164f:	e9 bf 00 00 00       	jmp    f0111713 <sys_check_WS_list+0x34b>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f0111654:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f0111658:	0f 85 b5 00 00 00    	jne    f0111713 <sys_check_WS_list+0x34b>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011165e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0111665:	e9 9d 00 00 00       	jmp    f0111707 <sys_check_WS_list+0x33f>
		{
			bool found = 0;
f011166a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111671:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111674:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f011167a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011167d:	eb 47                	jmp    f01116c6 <sys_check_WS_list+0x2fe>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f011167f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111682:	8b 00                	mov    (%eax),%eax
f0111684:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0111687:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011168a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011168f:	89 c2                	mov    %eax,%edx
f0111691:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111694:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011169b:	8b 45 08             	mov    0x8(%ebp),%eax
f011169e:	01 c8                	add    %ecx,%eax
f01116a0:	8b 00                	mov    (%eax),%eax
f01116a2:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01116a5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01116a8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01116ad:	39 c2                	cmp    %eax,%edx
f01116af:	75 09                	jne    f01116ba <sys_check_WS_list+0x2f2>
				{
					found = 1;
f01116b1:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f01116b8:	eb 3b                	jmp    f01116f5 <sys_check_WS_list+0x32d>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01116ba:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01116bd:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01116c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01116c6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01116ca:	74 08                	je     f01116d4 <sys_check_WS_list+0x30c>
f01116cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01116cf:	8b 40 10             	mov    0x10(%eax),%eax
f01116d2:	eb 05                	jmp    f01116d9 <sys_check_WS_list+0x311>
f01116d4:	b8 00 00 00 00       	mov    $0x0,%eax
f01116d9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01116dc:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f01116e2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01116e5:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01116eb:	85 c0                	test   %eax,%eax
f01116ed:	75 90                	jne    f011167f <sys_check_WS_list+0x2b7>
f01116ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01116f3:	75 8a                	jne    f011167f <sys_check_WS_list+0x2b7>
				{
					found = 1;
					break;
				}
			}
			if (found)
f01116f5:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01116f9:	74 09                	je     f0111704 <sys_check_WS_list+0x33c>
			{
				WS_list_validation = 0;
f01116fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111702:	eb 0f                	jmp    f0111713 <sys_check_WS_list+0x34b>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111704:	ff 45 d8             	incl   -0x28(%ebp)
f0111707:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011170a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011170d:	0f 8c 57 ff ff ff    	jl     f011166a <sys_check_WS_list+0x2a2>
				break;
			}
		}
	}

	return WS_list_validation;
f0111713:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f0111716:	c9                   	leave  
f0111717:	c3                   	ret    

f0111718 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f0111718:	55                   	push   %ebp
f0111719:	89 e5                	mov    %esp,%ebp
f011171b:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f011171e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0111725:	8b 15 d8 63 85 f0    	mov    0xf08563d8,%edx
f011172b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011172e:	39 c2                	cmp    %eax,%edx
f0111730:	74 0a                	je     f011173c <hasExpectedCommands+0x24>
		return 0;
f0111732:	b8 00 00 00 00       	mov    $0x0,%eax
f0111737:	e9 8b 00 00 00       	jmp    f01117c7 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f011173c:	a1 cc 63 85 f0       	mov    0xf08563cc,%eax
f0111741:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111744:	eb 55                	jmp    f011179b <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111746:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011174d:	eb 2a                	jmp    f0111779 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f011174f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111752:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111759:	8b 45 08             	mov    0x8(%ebp),%eax
f011175c:	01 d0                	add    %edx,%eax
f011175e:	8b 10                	mov    (%eax),%edx
f0111760:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111763:	8b 00                	mov    (%eax),%eax
f0111765:	83 ec 08             	sub    $0x8,%esp
f0111768:	52                   	push   %edx
f0111769:	50                   	push   %eax
f011176a:	e8 1a 94 00 00       	call   f011ab89 <strcmp>
f011176f:	83 c4 10             	add    $0x10,%esp
f0111772:	85 c0                	test   %eax,%eax
f0111774:	74 0d                	je     f0111783 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111776:	ff 45 f0             	incl   -0x10(%ebp)
f0111779:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011177c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011177f:	7c ce                	jl     f011174f <hasExpectedCommands+0x37>
f0111781:	eb 01                	jmp    f0111784 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f0111783:	90                   	nop
		if (i == commandsCount)
f0111784:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111787:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011178a:	75 07                	jne    f0111793 <hasExpectedCommands+0x7b>
			return 0;
f011178c:	b8 00 00 00 00       	mov    $0x0,%eax
f0111791:	eb 34                	jmp    f01117c7 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f0111793:	a1 d4 63 85 f0       	mov    0xf08563d4,%eax
f0111798:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011179b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011179f:	74 08                	je     f01117a9 <hasExpectedCommands+0x91>
f01117a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01117a4:	8b 40 10             	mov    0x10(%eax),%eax
f01117a7:	eb 05                	jmp    f01117ae <hasExpectedCommands+0x96>
f01117a9:	b8 00 00 00 00       	mov    $0x0,%eax
f01117ae:	a3 d4 63 85 f0       	mov    %eax,0xf08563d4
f01117b3:	a1 d4 63 85 f0       	mov    0xf08563d4,%eax
f01117b8:	85 c0                	test   %eax,%eax
f01117ba:	75 8a                	jne    f0111746 <hasExpectedCommands+0x2e>
f01117bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01117c0:	75 84                	jne    f0111746 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f01117c2:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01117c7:	c9                   	leave  
f01117c8:	c3                   	ret    

f01117c9 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f01117c9:	55                   	push   %ebp
f01117ca:	89 e5                	mov    %esp,%ebp
f01117cc:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01117cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01117d6:	eb 2e                	jmp    f0111806 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f01117d8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01117db:	89 d0                	mov    %edx,%eax
f01117dd:	01 c0                	add    %eax,%eax
f01117df:	01 d0                	add    %edx,%eax
f01117e1:	c1 e0 03             	shl    $0x3,%eax
f01117e4:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f01117e9:	8b 00                	mov    (%eax),%eax
f01117eb:	83 ec 08             	sub    $0x8,%esp
f01117ee:	ff 75 08             	pushl  0x8(%ebp)
f01117f1:	50                   	push   %eax
f01117f2:	e8 92 93 00 00       	call   f011ab89 <strcmp>
f01117f7:	83 c4 10             	add    $0x10,%esp
f01117fa:	85 c0                	test   %eax,%eax
f01117fc:	75 05                	jne    f0111803 <getIndexOfCommand+0x3a>
			return i;
f01117fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111801:	eb 14                	jmp    f0111817 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111803:	ff 45 f4             	incl   -0xc(%ebp)
f0111806:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111809:	a1 a8 fb 17 f0       	mov    0xf017fba8,%eax
f011180e:	39 c2                	cmp    %eax,%edx
f0111810:	72 c6                	jb     f01117d8 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f0111812:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0111817:	c9                   	leave  
f0111818:	c3                   	ret    

f0111819 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0111819:	55                   	push   %ebp
f011181a:	89 e5                	mov    %esp,%ebp
f011181c:	57                   	push   %edi
f011181d:	56                   	push   %esi
f011181e:	53                   	push   %ebx
f011181f:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0111825:	83 ec 0c             	sub    $0xc,%esp
f0111828:	68 40 20 13 f0       	push   $0xf0132040
f011182d:	e8 2a 03 ff ff       	call   f0101b5c <cprintf>
f0111832:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0111835:	83 ec 0c             	sub    $0xc,%esp
f0111838:	68 64 20 13 f0       	push   $0xf0132064
f011183d:	e8 1a 03 ff ff       	call   f0101b5c <cprintf>
f0111842:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0111845:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f011184c:	c7 45 8c 7f 20 13 f0 	movl   $0xf013207f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0111853:	83 ec 08             	sub    $0x8,%esp
f0111856:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0111859:	50                   	push   %eax
f011185a:	6a 01                	push   $0x1
f011185c:	e8 8f 08 ff ff       	call   f01020f0 <process_command>
f0111861:	83 c4 10             	add    $0x10,%esp
f0111864:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f0111867:	83 ec 0c             	sub    $0xc,%esp
f011186a:	68 8c 20 13 f0       	push   $0xf013208c
f011186f:	e8 e8 02 ff ff       	call   f0101b5c <cprintf>
f0111874:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f0111877:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011187a:	83 ec 0c             	sub    $0xc,%esp
f011187d:	50                   	push   %eax
f011187e:	e8 46 ff ff ff       	call   f01117c9 <getIndexOfCommand>
f0111883:	83 c4 10             	add    $0x10,%esp
f0111886:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111889:	75 0f                	jne    f011189a <TestAutoCompleteCommand+0x81>
f011188b:	a1 cc 63 85 f0       	mov    0xf08563cc,%eax
f0111890:	85 c0                	test   %eax,%eax
f0111892:	75 06                	jne    f011189a <TestAutoCompleteCommand+0x81>
		eval += 5;
f0111894:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
f0111898:	eb 10                	jmp    f01118aa <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011189a:	83 ec 0c             	sub    $0xc,%esp
f011189d:	68 bc 20 13 f0       	push   $0xf01320bc
f01118a2:	e8 b5 02 ff ff       	call   f0101b5c <cprintf>
f01118a7:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f01118aa:	83 ec 0c             	sub    $0xc,%esp
f01118ad:	68 0c 21 13 f0       	push   $0xf013210c
f01118b2:	e8 a5 02 ff ff       	call   f0101b5c <cprintf>
f01118b7:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f01118ba:	c7 45 88 32 21 13 f0 	movl   $0xf0132132,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f01118c1:	83 ec 08             	sub    $0x8,%esp
f01118c4:	8d 45 88             	lea    -0x78(%ebp),%eax
f01118c7:	50                   	push   %eax
f01118c8:	6a 01                	push   $0x1
f01118ca:	e8 21 08 ff ff       	call   f01020f0 <process_command>
f01118cf:	83 c4 10             	add    $0x10,%esp
f01118d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f01118d5:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01118d9:	75 30                	jne    f011190b <TestAutoCompleteCommand+0xf2>
f01118db:	8d 45 90             	lea    -0x70(%ebp),%eax
f01118de:	bb 4c 25 13 f0       	mov    $0xf013254c,%ebx
f01118e3:	ba 03 00 00 00       	mov    $0x3,%edx
f01118e8:	89 c7                	mov    %eax,%edi
f01118ea:	89 de                	mov    %ebx,%esi
f01118ec:	89 d1                	mov    %edx,%ecx
f01118ee:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01118f0:	83 ec 08             	sub    $0x8,%esp
f01118f3:	6a 03                	push   $0x3
f01118f5:	8d 45 90             	lea    -0x70(%ebp),%eax
f01118f8:	50                   	push   %eax
f01118f9:	e8 1a fe ff ff       	call   f0111718 <hasExpectedCommands>
f01118fe:	83 c4 10             	add    $0x10,%esp
f0111901:	85 c0                	test   %eax,%eax
f0111903:	74 06                	je     f011190b <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111905:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111909:	eb 10                	jmp    f011191b <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011190b:	83 ec 0c             	sub    $0xc,%esp
f011190e:	68 38 21 13 f0       	push   $0xf0132138
f0111913:	e8 44 02 ff ff       	call   f0101b5c <cprintf>
f0111918:	83 c4 10             	add    $0x10,%esp

	// CASE3.1: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f011191b:	83 ec 0c             	sub    $0xc,%esp
f011191e:	68 88 21 13 f0       	push   $0xf0132188
f0111923:	e8 34 02 ff ff       	call   f0101b5c <cprintf>
f0111928:	83 c4 10             	add    $0x10,%esp
	char *args3_1[] = {"wm"};
f011192b:	c7 45 84 ad 21 13 f0 	movl   $0xf01321ad,-0x7c(%ebp)
	ret = process_command(ARRAY_LENGTH(args3_1), args3_1);
f0111932:	83 ec 08             	sub    $0x8,%esp
f0111935:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111938:	50                   	push   %eax
f0111939:	6a 01                	push   $0x1
f011193b:	e8 b0 07 ff ff       	call   f01020f0 <process_command>
f0111940:	83 c4 10             	add    $0x10,%esp
f0111943:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3_1, 1))
f0111946:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f011194a:	75 1b                	jne    f0111967 <TestAutoCompleteCommand+0x14e>
f011194c:	83 ec 08             	sub    $0x8,%esp
f011194f:	6a 01                	push   $0x1
f0111951:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111954:	50                   	push   %eax
f0111955:	e8 be fd ff ff       	call   f0111718 <hasExpectedCommands>
f011195a:	83 c4 10             	add    $0x10,%esp
f011195d:	85 c0                	test   %eax,%eax
f011195f:	74 06                	je     f0111967 <TestAutoCompleteCommand+0x14e>
		eval += 15;
f0111961:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111965:	eb 10                	jmp    f0111977 <TestAutoCompleteCommand+0x15e>
	else
		cprintf("#3.1: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0111967:	83 ec 0c             	sub    $0xc,%esp
f011196a:	68 b0 21 13 f0       	push   $0xf01321b0
f011196f:	e8 e8 01 ff ff       	call   f0101b5c <cprintf>
f0111974:	83 c4 10             	add    $0x10,%esp

	// CASE3.2: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: lru\n");
f0111977:	83 ec 0c             	sub    $0xc,%esp
f011197a:	68 0c 22 13 f0       	push   $0xf013220c
f011197f:	e8 d8 01 ff ff       	call   f0101b5c <cprintf>
f0111984:	83 c4 10             	add    $0x10,%esp
	char *args3_2[] = {"lru", "2", "1"};
f0111987:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f011198d:	bb 60 25 13 f0       	mov    $0xf0132560,%ebx
f0111992:	ba 03 00 00 00       	mov    $0x3,%edx
f0111997:	89 c7                	mov    %eax,%edi
f0111999:	89 de                	mov    %ebx,%esi
f011199b:	89 d1                	mov    %edx,%ecx
f011199d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args3_2), args3_2);
f011199f:	83 ec 08             	sub    $0x8,%esp
f01119a2:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01119a8:	50                   	push   %eax
f01119a9:	6a 03                	push   $0x3
f01119ab:	e8 40 07 ff ff       	call   f01020f0 <process_command>
f01119b0:	83 c4 10             	add    $0x10,%esp
f01119b3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3_2, 1))
f01119b6:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f01119ba:	75 1e                	jne    f01119da <TestAutoCompleteCommand+0x1c1>
f01119bc:	83 ec 08             	sub    $0x8,%esp
f01119bf:	6a 01                	push   $0x1
f01119c1:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01119c7:	50                   	push   %eax
f01119c8:	e8 4b fd ff ff       	call   f0111718 <hasExpectedCommands>
f01119cd:	83 c4 10             	add    $0x10,%esp
f01119d0:	85 c0                	test   %eax,%eax
f01119d2:	74 06                	je     f01119da <TestAutoCompleteCommand+0x1c1>
		eval += 15;
f01119d4:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01119d8:	eb 10                	jmp    f01119ea <TestAutoCompleteCommand+0x1d1>
	else
		cprintf("#3.2: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f01119da:	83 ec 0c             	sub    $0xc,%esp
f01119dd:	68 34 22 13 f0       	push   $0xf0132234
f01119e2:	e8 75 01 ff ff       	call   f0101b5c <cprintf>
f01119e7:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f01119ea:	83 ec 0c             	sub    $0xc,%esp
f01119ed:	68 90 22 13 f0       	push   $0xf0132290
f01119f2:	e8 65 01 ff ff       	call   f0101b5c <cprintf>
f01119f7:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f01119fa:	c7 85 74 ff ff ff b6 	movl   $0xf01322b6,-0x8c(%ebp)
f0111a01:	22 13 f0 
	ret = process_command(ARRAY_LENGTH(args4), args4);
f0111a04:	83 ec 08             	sub    $0x8,%esp
f0111a07:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0111a0d:	50                   	push   %eax
f0111a0e:	6a 01                	push   $0x1
f0111a10:	e8 db 06 ff ff       	call   f01020f0 <process_command>
f0111a15:	83 c4 10             	add    $0x10,%esp
f0111a18:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f0111a1b:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0111a1f:	75 0f                	jne    f0111a30 <TestAutoCompleteCommand+0x217>
f0111a21:	a1 d8 63 85 f0       	mov    0xf08563d8,%eax
f0111a26:	85 c0                	test   %eax,%eax
f0111a28:	75 06                	jne    f0111a30 <TestAutoCompleteCommand+0x217>
		eval += 10;
f0111a2a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111a2e:	eb 10                	jmp    f0111a40 <TestAutoCompleteCommand+0x227>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111a30:	83 ec 0c             	sub    $0xc,%esp
f0111a33:	68 bc 22 13 f0       	push   $0xf01322bc
f0111a38:	e8 1f 01 ff ff       	call   f0101b5c <cprintf>
f0111a3d:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that contains he
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f0111a40:	83 ec 0c             	sub    $0xc,%esp
f0111a43:	68 0c 23 13 f0       	push   $0xf013230c
f0111a48:	e8 0f 01 ff ff       	call   f0101b5c <cprintf>
f0111a4d:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f0111a50:	c7 85 70 ff ff ff 31 	movl   $0xf0132331,-0x90(%ebp)
f0111a57:	23 13 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0111a5a:	83 ec 08             	sub    $0x8,%esp
f0111a5d:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0111a63:	50                   	push   %eax
f0111a64:	6a 01                	push   $0x1
f0111a66:	e8 85 06 ff ff       	call   f01020f0 <process_command>
f0111a6b:	83 c4 10             	add    $0x10,%esp
f0111a6e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f0111a71:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111a75:	75 30                	jne    f0111aa7 <TestAutoCompleteCommand+0x28e>
f0111a77:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111a7a:	bb e0 25 13 f0       	mov    $0xf01325e0,%ebx
f0111a7f:	ba 0c 00 00 00       	mov    $0xc,%edx
f0111a84:	89 c7                	mov    %eax,%edi
f0111a86:	89 de                	mov    %ebx,%esi
f0111a88:	89 d1                	mov    %edx,%ecx
f0111a8a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111a8c:	83 ec 08             	sub    $0x8,%esp
f0111a8f:	6a 0c                	push   $0xc
f0111a91:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111a94:	50                   	push   %eax
f0111a95:	e8 7e fc ff ff       	call   f0111718 <hasExpectedCommands>
f0111a9a:	83 c4 10             	add    $0x10,%esp
f0111a9d:	85 c0                	test   %eax,%eax
f0111a9f:	74 06                	je     f0111aa7 <TestAutoCompleteCommand+0x28e>
		eval += 15;
f0111aa1:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111aa5:	eb 10                	jmp    f0111ab7 <TestAutoCompleteCommand+0x29e>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0111aa7:	83 ec 0c             	sub    $0xc,%esp
f0111aaa:	68 34 23 13 f0       	push   $0xf0132334
f0111aaf:	e8 a8 00 ff ff       	call   f0101b5c <cprintf>
f0111ab4:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that contains ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0111ab7:	83 ec 0c             	sub    $0xc,%esp
f0111aba:	68 8c 23 13 f0       	push   $0xf013238c
f0111abf:	e8 98 00 ff ff       	call   f0101b5c <cprintf>
f0111ac4:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f0111ac7:	c7 85 6c ff ff ff b1 	movl   $0xf01323b1,-0x94(%ebp)
f0111ace:	23 13 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f0111ad1:	83 ec 08             	sub    $0x8,%esp
f0111ad4:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0111ada:	50                   	push   %eax
f0111adb:	6a 01                	push   $0x1
f0111add:	e8 0e 06 ff ff       	call   f01020f0 <process_command>
f0111ae2:	83 c4 10             	add    $0x10,%esp
f0111ae5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f0111ae8:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111aec:	75 30                	jne    f0111b1e <TestAutoCompleteCommand+0x305>
f0111aee:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111af1:	bb 24 26 13 f0       	mov    $0xf0132624,%ebx
f0111af6:	ba 05 00 00 00       	mov    $0x5,%edx
f0111afb:	89 c7                	mov    %eax,%edi
f0111afd:	89 de                	mov    %ebx,%esi
f0111aff:	89 d1                	mov    %edx,%ecx
f0111b01:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111b03:	83 ec 08             	sub    $0x8,%esp
f0111b06:	6a 05                	push   $0x5
f0111b08:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111b0b:	50                   	push   %eax
f0111b0c:	e8 07 fc ff ff       	call   f0111718 <hasExpectedCommands>
f0111b11:	83 c4 10             	add    $0x10,%esp
f0111b14:	85 c0                	test   %eax,%eax
f0111b16:	74 06                	je     f0111b1e <TestAutoCompleteCommand+0x305>
		eval += 10;
f0111b18:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111b1c:	eb 10                	jmp    f0111b2e <TestAutoCompleteCommand+0x315>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f0111b1e:	83 ec 0c             	sub    $0xc,%esp
f0111b21:	68 b4 23 13 f0       	push   $0xf01323b4
f0111b26:	e8 31 00 ff ff       	call   f0101b5c <cprintf>
f0111b2b:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f0111b2e:	83 ec 0c             	sub    $0xc,%esp
f0111b31:	68 0c 24 13 f0       	push   $0xf013240c
f0111b36:	e8 21 00 ff ff       	call   f0101b5c <cprintf>
f0111b3b:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0111b3e:	c7 85 64 ff ff ff 38 	movl   $0xf0132438,-0x9c(%ebp)
f0111b45:	24 13 f0 
f0111b48:	c7 85 68 ff ff ff 3d 	movl   $0xf013243d,-0x98(%ebp)
f0111b4f:	24 13 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f0111b52:	83 ec 08             	sub    $0x8,%esp
f0111b55:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111b5b:	50                   	push   %eax
f0111b5c:	6a 02                	push   $0x2
f0111b5e:	e8 8d 05 ff ff       	call   f01020f0 <process_command>
f0111b63:	83 c4 10             	add    $0x10,%esp
f0111b66:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111b69:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0111b6f:	83 ec 0c             	sub    $0xc,%esp
f0111b72:	50                   	push   %eax
f0111b73:	e8 51 fc ff ff       	call   f01117c9 <getIndexOfCommand>
f0111b78:	83 c4 10             	add    $0x10,%esp
f0111b7b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111b7e:	75 0f                	jne    f0111b8f <TestAutoCompleteCommand+0x376>
f0111b80:	a1 cc 63 85 f0       	mov    0xf08563cc,%eax
f0111b85:	85 c0                	test   %eax,%eax
f0111b87:	75 06                	jne    f0111b8f <TestAutoCompleteCommand+0x376>
		eval += 5;
f0111b89:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
f0111b8d:	eb 10                	jmp    f0111b9f <TestAutoCompleteCommand+0x386>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111b8f:	83 ec 0c             	sub    $0xc,%esp
f0111b92:	68 44 24 13 f0       	push   $0xf0132444
f0111b97:	e8 c0 ff fe ff       	call   f0101b5c <cprintf>
f0111b9c:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f0111b9f:	83 ec 0c             	sub    $0xc,%esp
f0111ba2:	68 94 24 13 f0       	push   $0xf0132494
f0111ba7:	e8 b0 ff fe ff       	call   f0101b5c <cprintf>
f0111bac:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f0111baf:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
f0111bb5:	bb 4c 26 13 f0       	mov    $0xf013264c,%ebx
f0111bba:	ba 03 00 00 00       	mov    $0x3,%edx
f0111bbf:	89 c7                	mov    %eax,%edi
f0111bc1:	89 de                	mov    %ebx,%esi
f0111bc3:	89 d1                	mov    %edx,%ecx
f0111bc5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0111bc7:	83 ec 08             	sub    $0x8,%esp
f0111bca:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
f0111bd0:	50                   	push   %eax
f0111bd1:	6a 03                	push   $0x3
f0111bd3:	e8 18 05 ff ff       	call   f01020f0 <process_command>
f0111bd8:	83 c4 10             	add    $0x10,%esp
f0111bdb:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f0111bde:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0111be4:	83 ec 0c             	sub    $0xc,%esp
f0111be7:	50                   	push   %eax
f0111be8:	e8 dc fb ff ff       	call   f01117c9 <getIndexOfCommand>
f0111bed:	83 c4 10             	add    $0x10,%esp
f0111bf0:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111bf3:	75 0f                	jne    f0111c04 <TestAutoCompleteCommand+0x3eb>
f0111bf5:	a1 cc 63 85 f0       	mov    0xf08563cc,%eax
f0111bfa:	85 c0                	test   %eax,%eax
f0111bfc:	75 06                	jne    f0111c04 <TestAutoCompleteCommand+0x3eb>
		eval += 10;
f0111bfe:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111c02:	eb 10                	jmp    f0111c14 <TestAutoCompleteCommand+0x3fb>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111c04:	83 ec 0c             	sub    $0xc,%esp
f0111c07:	68 c8 24 13 f0       	push   $0xf01324c8
f0111c0c:	e8 4b ff fe ff       	call   f0101b5c <cprintf>
f0111c11:	83 c4 10             	add    $0x10,%esp

//	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
//	cprintf("=================\n\n");
	cprintf("[AUTO_GR@DING_PARTIAL]%d\n", eval);
f0111c14:	83 ec 08             	sub    $0x8,%esp
f0111c17:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111c1a:	68 17 25 13 f0       	push   $0xf0132517
f0111c1f:	e8 38 ff fe ff       	call   f0101b5c <cprintf>
f0111c24:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111c27:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111c2c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111c2f:	5b                   	pop    %ebx
f0111c30:	5e                   	pop    %esi
f0111c31:	5f                   	pop    %edi
f0111c32:	5d                   	pop    %ebp
f0111c33:	c3                   	ret    

f0111c34 <test_str2lower_function>:

int test_str2lower_function()
{
f0111c34:	55                   	push   %ebp
f0111c35:	89 e5                	mov    %esp,%ebp
f0111c37:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111c3d:	83 ec 0c             	sub    $0xc,%esp
f0111c40:	68 58 26 13 f0       	push   $0xf0132658
f0111c45:	e8 12 ff fe ff       	call   f0101b5c <cprintf>
f0111c4a:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111c4d:	83 ec 0c             	sub    $0xc,%esp
f0111c50:	68 79 26 13 f0       	push   $0xf0132679
f0111c55:	e8 02 ff fe ff       	call   f0101b5c <cprintf>
f0111c5a:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111c5d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111c64:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111c6b:	c7 45 ec 93 26 13 f0 	movl   $0xf0132693,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0111c72:	83 ec 08             	sub    $0x8,%esp
f0111c75:	ff 75 ec             	pushl  -0x14(%ebp)
f0111c78:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0111c7e:	50                   	push   %eax
f0111c7f:	e8 91 95 00 00       	call   f011b215 <str2lower>
f0111c84:	83 c4 10             	add    $0x10,%esp
f0111c87:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111c8a:	83 ec 0c             	sub    $0xc,%esp
f0111c8d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c90:	e8 e8 8d 00 00       	call   f011aa7d <strlen>
f0111c95:	83 c4 10             	add    $0x10,%esp
f0111c98:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111c9b:	83 ec 08             	sub    $0x8,%esp
f0111c9e:	68 9e 26 13 f0       	push   $0xf013269e
f0111ca3:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ca6:	e8 de 8e 00 00       	call   f011ab89 <strcmp>
f0111cab:	83 c4 10             	add    $0x10,%esp
f0111cae:	85 c0                	test   %eax,%eax
f0111cb0:	75 13                	jne    f0111cc5 <test_str2lower_function+0x91>
f0111cb2:	83 ec 0c             	sub    $0xc,%esp
f0111cb5:	ff 75 ec             	pushl  -0x14(%ebp)
f0111cb8:	e8 c0 8d 00 00       	call   f011aa7d <strlen>
f0111cbd:	83 c4 10             	add    $0x10,%esp
f0111cc0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111cc3:	74 15                	je     f0111cda <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0111cc5:	83 ec 08             	sub    $0x8,%esp
f0111cc8:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ccb:	68 ac 26 13 f0       	push   $0xf01326ac
f0111cd0:	e8 87 fe fe ff       	call   f0101b5c <cprintf>
f0111cd5:	83 c4 10             	add    $0x10,%esp
f0111cd8:	eb 04                	jmp    f0111cde <test_str2lower_function+0xaa>
	else
		eval += 10;
f0111cda:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0111cde:	c7 45 e0 0e 27 13 f0 	movl   $0xf013270e,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0111ce5:	83 ec 08             	sub    $0x8,%esp
f0111ce8:	ff 75 e0             	pushl  -0x20(%ebp)
f0111ceb:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111cf1:	50                   	push   %eax
f0111cf2:	e8 1e 95 00 00       	call   f011b215 <str2lower>
f0111cf7:	83 c4 10             	add    $0x10,%esp
f0111cfa:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111cfd:	83 ec 0c             	sub    $0xc,%esp
f0111d00:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d03:	e8 75 8d 00 00       	call   f011aa7d <strlen>
f0111d08:	83 c4 10             	add    $0x10,%esp
f0111d0b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0111d0e:	83 ec 08             	sub    $0x8,%esp
f0111d11:	68 0e 27 13 f0       	push   $0xf013270e
f0111d16:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d19:	e8 6b 8e 00 00       	call   f011ab89 <strcmp>
f0111d1e:	83 c4 10             	add    $0x10,%esp
f0111d21:	85 c0                	test   %eax,%eax
f0111d23:	75 13                	jne    f0111d38 <test_str2lower_function+0x104>
f0111d25:	83 ec 0c             	sub    $0xc,%esp
f0111d28:	ff 75 e0             	pushl  -0x20(%ebp)
f0111d2b:	e8 4d 8d 00 00       	call   f011aa7d <strlen>
f0111d30:	83 c4 10             	add    $0x10,%esp
f0111d33:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111d36:	74 15                	je     f0111d4d <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111d38:	83 ec 08             	sub    $0x8,%esp
f0111d3b:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d3e:	68 10 27 13 f0       	push   $0xf0132710
f0111d43:	e8 14 fe fe ff       	call   f0101b5c <cprintf>
f0111d48:	83 c4 10             	add    $0x10,%esp
f0111d4b:	eb 04                	jmp    f0111d51 <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111d4d:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0111d51:	c7 45 dc 68 27 13 f0 	movl   $0xf0132768,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111d58:	83 ec 08             	sub    $0x8,%esp
f0111d5b:	ff 75 dc             	pushl  -0x24(%ebp)
f0111d5e:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111d64:	50                   	push   %eax
f0111d65:	e8 ab 94 00 00       	call   f011b215 <str2lower>
f0111d6a:	83 c4 10             	add    $0x10,%esp
f0111d6d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111d70:	83 ec 0c             	sub    $0xc,%esp
f0111d73:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d76:	e8 02 8d 00 00       	call   f011aa7d <strlen>
f0111d7b:	83 c4 10             	add    $0x10,%esp
f0111d7e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0111d81:	83 ec 08             	sub    $0x8,%esp
f0111d84:	68 68 27 13 f0       	push   $0xf0132768
f0111d89:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d8c:	e8 f8 8d 00 00       	call   f011ab89 <strcmp>
f0111d91:	83 c4 10             	add    $0x10,%esp
f0111d94:	85 c0                	test   %eax,%eax
f0111d96:	75 13                	jne    f0111dab <test_str2lower_function+0x177>
f0111d98:	83 ec 0c             	sub    $0xc,%esp
f0111d9b:	ff 75 dc             	pushl  -0x24(%ebp)
f0111d9e:	e8 da 8c 00 00       	call   f011aa7d <strlen>
f0111da3:	83 c4 10             	add    $0x10,%esp
f0111da6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111da9:	74 15                	je     f0111dc0 <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0111dab:	83 ec 08             	sub    $0x8,%esp
f0111dae:	ff 75 e8             	pushl  -0x18(%ebp)
f0111db1:	68 74 27 13 f0       	push   $0xf0132774
f0111db6:	e8 a1 fd fe ff       	call   f0101b5c <cprintf>
f0111dbb:	83 c4 10             	add    $0x10,%esp
f0111dbe:	eb 04                	jmp    f0111dc4 <test_str2lower_function+0x190>
	else
		eval += 15;
f0111dc0:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0111dc4:	c7 45 d8 d7 27 13 f0 	movl   $0xf01327d7,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0111dcb:	83 ec 08             	sub    $0x8,%esp
f0111dce:	ff 75 d8             	pushl  -0x28(%ebp)
f0111dd1:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f0111dd7:	50                   	push   %eax
f0111dd8:	e8 38 94 00 00       	call   f011b215 <str2lower>
f0111ddd:	83 c4 10             	add    $0x10,%esp
f0111de0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111de3:	83 ec 0c             	sub    $0xc,%esp
f0111de6:	ff 75 e8             	pushl  -0x18(%ebp)
f0111de9:	e8 8f 8c 00 00       	call   f011aa7d <strlen>
f0111dee:	83 c4 10             	add    $0x10,%esp
f0111df1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0111df4:	83 ec 08             	sub    $0x8,%esp
f0111df7:	68 d7 27 13 f0       	push   $0xf01327d7
f0111dfc:	ff 75 e8             	pushl  -0x18(%ebp)
f0111dff:	e8 85 8d 00 00       	call   f011ab89 <strcmp>
f0111e04:	83 c4 10             	add    $0x10,%esp
f0111e07:	85 c0                	test   %eax,%eax
f0111e09:	75 13                	jne    f0111e1e <test_str2lower_function+0x1ea>
f0111e0b:	83 ec 0c             	sub    $0xc,%esp
f0111e0e:	ff 75 d8             	pushl  -0x28(%ebp)
f0111e11:	e8 67 8c 00 00       	call   f011aa7d <strlen>
f0111e16:	83 c4 10             	add    $0x10,%esp
f0111e19:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111e1c:	74 15                	je     f0111e33 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0111e1e:	83 ec 08             	sub    $0x8,%esp
f0111e21:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e24:	68 e4 27 13 f0       	push   $0xf01327e4
f0111e29:	e8 2e fd fe ff       	call   f0101b5c <cprintf>
f0111e2e:	83 c4 10             	add    $0x10,%esp
f0111e31:	eb 04                	jmp    f0111e37 <test_str2lower_function+0x203>
	else
		eval += 15;
f0111e33:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111e37:	c7 45 d4 46 28 13 f0 	movl   $0xf0132846,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0111e3e:	83 ec 08             	sub    $0x8,%esp
f0111e41:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111e44:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111e4a:	50                   	push   %eax
f0111e4b:	e8 c5 93 00 00       	call   f011b215 <str2lower>
f0111e50:	83 c4 10             	add    $0x10,%esp
f0111e53:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111e56:	83 ec 0c             	sub    $0xc,%esp
f0111e59:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e5c:	e8 1c 8c 00 00       	call   f011aa7d <strlen>
f0111e61:	83 c4 10             	add    $0x10,%esp
f0111e64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111e67:	83 ec 08             	sub    $0x8,%esp
f0111e6a:	68 5c 28 13 f0       	push   $0xf013285c
f0111e6f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e72:	e8 12 8d 00 00       	call   f011ab89 <strcmp>
f0111e77:	83 c4 10             	add    $0x10,%esp
f0111e7a:	85 c0                	test   %eax,%eax
f0111e7c:	75 13                	jne    f0111e91 <test_str2lower_function+0x25d>
f0111e7e:	83 ec 0c             	sub    $0xc,%esp
f0111e81:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111e84:	e8 f4 8b 00 00       	call   f011aa7d <strlen>
f0111e89:	83 c4 10             	add    $0x10,%esp
f0111e8c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111e8f:	74 15                	je     f0111ea6 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0111e91:	83 ec 08             	sub    $0x8,%esp
f0111e94:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e97:	68 74 28 13 f0       	push   $0xf0132874
f0111e9c:	e8 bb fc fe ff       	call   f0101b5c <cprintf>
f0111ea1:	83 c4 10             	add    $0x10,%esp
f0111ea4:	eb 04                	jmp    f0111eaa <test_str2lower_function+0x276>
	else
		eval += 15;
f0111ea6:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0111eaa:	c7 45 d0 e1 28 13 f0 	movl   $0xf01328e1,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0111eb1:	83 ec 08             	sub    $0x8,%esp
f0111eb4:	ff 75 d0             	pushl  -0x30(%ebp)
f0111eb7:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0111ebd:	50                   	push   %eax
f0111ebe:	e8 52 93 00 00       	call   f011b215 <str2lower>
f0111ec3:	83 c4 10             	add    $0x10,%esp
f0111ec6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111ec9:	83 ec 0c             	sub    $0xc,%esp
f0111ecc:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ecf:	e8 a9 8b 00 00       	call   f011aa7d <strlen>
f0111ed4:	83 c4 10             	add    $0x10,%esp
f0111ed7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0111eda:	83 ec 08             	sub    $0x8,%esp
f0111edd:	68 ed 28 13 f0       	push   $0xf01328ed
f0111ee2:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ee5:	e8 9f 8c 00 00       	call   f011ab89 <strcmp>
f0111eea:	83 c4 10             	add    $0x10,%esp
f0111eed:	85 c0                	test   %eax,%eax
f0111eef:	75 13                	jne    f0111f04 <test_str2lower_function+0x2d0>
f0111ef1:	83 ec 0c             	sub    $0xc,%esp
f0111ef4:	ff 75 d0             	pushl  -0x30(%ebp)
f0111ef7:	e8 81 8b 00 00       	call   f011aa7d <strlen>
f0111efc:	83 c4 10             	add    $0x10,%esp
f0111eff:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111f02:	74 15                	je     f0111f19 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0111f04:	83 ec 08             	sub    $0x8,%esp
f0111f07:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f0a:	68 fc 28 13 f0       	push   $0xf01328fc
f0111f0f:	e8 48 fc fe ff       	call   f0101b5c <cprintf>
f0111f14:	83 c4 10             	add    $0x10,%esp
f0111f17:	eb 04                	jmp    f0111f1d <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0111f19:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0111f1d:	c7 45 cc 5f 29 13 f0 	movl   $0xf013295f,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0111f24:	83 ec 08             	sub    $0x8,%esp
f0111f27:	ff 75 cc             	pushl  -0x34(%ebp)
f0111f2a:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0111f30:	50                   	push   %eax
f0111f31:	e8 df 92 00 00       	call   f011b215 <str2lower>
f0111f36:	83 c4 10             	add    $0x10,%esp
f0111f39:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111f3c:	83 ec 0c             	sub    $0xc,%esp
f0111f3f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f42:	e8 36 8b 00 00       	call   f011aa7d <strlen>
f0111f47:	83 c4 10             	add    $0x10,%esp
f0111f4a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0111f4d:	83 ec 08             	sub    $0x8,%esp
f0111f50:	68 7a 29 13 f0       	push   $0xf013297a
f0111f55:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f58:	e8 2c 8c 00 00       	call   f011ab89 <strcmp>
f0111f5d:	83 c4 10             	add    $0x10,%esp
f0111f60:	85 c0                	test   %eax,%eax
f0111f62:	75 13                	jne    f0111f77 <test_str2lower_function+0x343>
f0111f64:	83 ec 0c             	sub    $0xc,%esp
f0111f67:	ff 75 cc             	pushl  -0x34(%ebp)
f0111f6a:	e8 0e 8b 00 00       	call   f011aa7d <strlen>
f0111f6f:	83 c4 10             	add    $0x10,%esp
f0111f72:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111f75:	74 15                	je     f0111f8c <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0111f77:	83 ec 08             	sub    $0x8,%esp
f0111f7a:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f7d:	68 98 29 13 f0       	push   $0xf0132998
f0111f82:	e8 d5 fb fe ff       	call   f0101b5c <cprintf>
f0111f87:	83 c4 10             	add    $0x10,%esp
f0111f8a:	eb 04                	jmp    f0111f90 <test_str2lower_function+0x35c>
	else
		eval += 20;
f0111f8c:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0111f90:	83 ec 08             	sub    $0x8,%esp
f0111f93:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f96:	68 0c 2a 13 f0       	push   $0xf0132a0c
f0111f9b:	e8 bc fb fe ff       	call   f0101b5c <cprintf>
f0111fa0:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111fa3:	83 ec 0c             	sub    $0xc,%esp
f0111fa6:	68 39 2a 13 f0       	push   $0xf0132a39
f0111fab:	e8 ac fb fe ff       	call   f0101b5c <cprintf>
f0111fb0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111fb3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111fb8:	c9                   	leave  
f0111fb9:	c3                   	ret    

f0111fba <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0111fba:	55                   	push   %ebp
f0111fbb:	89 e5                	mov    %esp,%ebp
f0111fbd:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0111fc0:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111fc7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0111fce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111fd5:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0111fda:	ff 75 ec             	pushl  -0x14(%ebp)
f0111fdd:	ff 75 f0             	pushl  -0x10(%ebp)
f0111fe0:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fe3:	50                   	push   %eax
f0111fe4:	e8 19 7c ff ff       	call   f0109c02 <pt_set_page_permissions>
f0111fe9:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111fec:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0111ff1:	ff 75 ec             	pushl  -0x14(%ebp)
f0111ff4:	ff 75 f0             	pushl  -0x10(%ebp)
f0111ff7:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ffa:	50                   	push   %eax
f0111ffb:	e8 02 4f 00 00       	call   f0116f02 <CP>
f0112000:	83 c4 10             	add    $0x10,%esp
f0112003:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112006:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011200a:	74 17                	je     f0112023 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f011200c:	83 ec 04             	sub    $0x4,%esp
f011200f:	68 50 2a 13 f0       	push   $0xf0132a50
f0112014:	68 2c 01 00 00       	push   $0x12c
f0112019:	68 72 2a 13 f0       	push   $0xf0132a72
f011201e:	e8 8c ee fe ff       	call   f0100eaf <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0112023:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f011202a:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0112031:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112038:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011203d:	ff 75 ec             	pushl  -0x14(%ebp)
f0112040:	ff 75 f0             	pushl  -0x10(%ebp)
f0112043:	ff 75 f4             	pushl  -0xc(%ebp)
f0112046:	50                   	push   %eax
f0112047:	e8 b6 7b ff ff       	call   f0109c02 <pt_set_page_permissions>
f011204c:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011204f:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112054:	ff 75 ec             	pushl  -0x14(%ebp)
f0112057:	ff 75 f0             	pushl  -0x10(%ebp)
f011205a:	ff 75 f4             	pushl  -0xc(%ebp)
f011205d:	50                   	push   %eax
f011205e:	e8 9f 4e 00 00       	call   f0116f02 <CP>
f0112063:	83 c4 10             	add    $0x10,%esp
f0112066:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112069:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011206d:	74 17                	je     f0112086 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f011206f:	83 ec 04             	sub    $0x4,%esp
f0112072:	68 90 2a 13 f0       	push   $0xf0132a90
f0112077:	68 38 01 00 00       	push   $0x138
f011207c:	68 72 2a 13 f0       	push   $0xf0132a72
f0112081:	e8 29 ee fe ff       	call   f0100eaf <_panic>
	}

	va = 0xEF800000;
f0112086:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f011208d:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0112094:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011209b:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01120a0:	ff 75 ec             	pushl  -0x14(%ebp)
f01120a3:	ff 75 f0             	pushl  -0x10(%ebp)
f01120a6:	ff 75 f4             	pushl  -0xc(%ebp)
f01120a9:	50                   	push   %eax
f01120aa:	e8 53 7b ff ff       	call   f0109c02 <pt_set_page_permissions>
f01120af:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01120b2:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01120b7:	ff 75 ec             	pushl  -0x14(%ebp)
f01120ba:	ff 75 f0             	pushl  -0x10(%ebp)
f01120bd:	ff 75 f4             	pushl  -0xc(%ebp)
f01120c0:	50                   	push   %eax
f01120c1:	e8 3c 4e 00 00       	call   f0116f02 <CP>
f01120c6:	83 c4 10             	add    $0x10,%esp
f01120c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01120cc:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01120d0:	74 17                	je     f01120e9 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f01120d2:	83 ec 04             	sub    $0x4,%esp
f01120d5:	68 b4 2a 13 f0       	push   $0xf0132ab4
f01120da:	68 43 01 00 00       	push   $0x143
f01120df:	68 72 2a 13 f0       	push   $0xf0132a72
f01120e4:	e8 c6 ed fe ff       	call   f0100eaf <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f01120e9:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f01120f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f01120f7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01120fe:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112103:	ff 75 ec             	pushl  -0x14(%ebp)
f0112106:	ff 75 f0             	pushl  -0x10(%ebp)
f0112109:	ff 75 f4             	pushl  -0xc(%ebp)
f011210c:	50                   	push   %eax
f011210d:	e8 f0 7a ff ff       	call   f0109c02 <pt_set_page_permissions>
f0112112:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112115:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011211a:	ff 75 ec             	pushl  -0x14(%ebp)
f011211d:	ff 75 f0             	pushl  -0x10(%ebp)
f0112120:	ff 75 f4             	pushl  -0xc(%ebp)
f0112123:	50                   	push   %eax
f0112124:	e8 d9 4d 00 00       	call   f0116f02 <CP>
f0112129:	83 c4 10             	add    $0x10,%esp
f011212c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011212f:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112133:	74 17                	je     f011214c <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0112135:	83 ec 04             	sub    $0x4,%esp
f0112138:	68 d8 2a 13 f0       	push   $0xf0132ad8
f011213d:	68 4f 01 00 00       	push   $0x14f
f0112142:	68 72 2a 13 f0       	push   $0xf0132a72
f0112147:	e8 63 ed fe ff       	call   f0100eaf <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f011214c:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0112153:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f011215a:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112161:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112166:	ff 75 ec             	pushl  -0x14(%ebp)
f0112169:	ff 75 f0             	pushl  -0x10(%ebp)
f011216c:	ff 75 f4             	pushl  -0xc(%ebp)
f011216f:	50                   	push   %eax
f0112170:	e8 8d 7a ff ff       	call   f0109c02 <pt_set_page_permissions>
f0112175:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112178:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011217d:	ff 75 ec             	pushl  -0x14(%ebp)
f0112180:	ff 75 f0             	pushl  -0x10(%ebp)
f0112183:	ff 75 f4             	pushl  -0xc(%ebp)
f0112186:	50                   	push   %eax
f0112187:	e8 76 4d 00 00       	call   f0116f02 <CP>
f011218c:	83 c4 10             	add    $0x10,%esp
f011218f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112192:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112196:	74 17                	je     f01121af <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0112198:	83 ec 04             	sub    $0x4,%esp
f011219b:	68 fc 2a 13 f0       	push   $0xf0132afc
f01121a0:	68 5b 01 00 00       	push   $0x15b
f01121a5:	68 72 2a 13 f0       	push   $0xf0132a72
f01121aa:	e8 00 ed fe ff       	call   f0100eaf <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f01121af:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f01121b6:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f01121bd:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01121c4:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01121c9:	ff 75 ec             	pushl  -0x14(%ebp)
f01121cc:	ff 75 f0             	pushl  -0x10(%ebp)
f01121cf:	ff 75 f4             	pushl  -0xc(%ebp)
f01121d2:	50                   	push   %eax
f01121d3:	e8 2a 7a ff ff       	call   f0109c02 <pt_set_page_permissions>
f01121d8:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01121db:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01121e0:	ff 75 ec             	pushl  -0x14(%ebp)
f01121e3:	ff 75 f0             	pushl  -0x10(%ebp)
f01121e6:	ff 75 f4             	pushl  -0xc(%ebp)
f01121e9:	50                   	push   %eax
f01121ea:	e8 13 4d 00 00       	call   f0116f02 <CP>
f01121ef:	83 c4 10             	add    $0x10,%esp
f01121f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01121f5:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01121f9:	74 17                	je     f0112212 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f01121fb:	83 ec 04             	sub    $0x4,%esp
f01121fe:	68 20 2b 13 f0       	push   $0xf0132b20
f0112203:	68 67 01 00 00       	push   $0x167
f0112208:	68 72 2a 13 f0       	push   $0xf0132a72
f011220d:	e8 9d ec fe ff       	call   f0100eaf <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0112212:	83 ec 0c             	sub    $0xc,%esp
f0112215:	68 4c 2b 13 f0       	push   $0xf0132b4c
f011221a:	e8 3d f9 fe ff       	call   f0101b5c <cprintf>
f011221f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112222:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112227:	c9                   	leave  
f0112228:	c3                   	ret    

f0112229 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0112229:	55                   	push   %ebp
f011222a:	89 e5                	mov    %esp,%ebp
f011222c:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f011222f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0112236:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f011223d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112244:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112249:	ff 75 ec             	pushl  -0x14(%ebp)
f011224c:	ff 75 f0             	pushl  -0x10(%ebp)
f011224f:	ff 75 f4             	pushl  -0xc(%ebp)
f0112252:	50                   	push   %eax
f0112253:	e8 aa 79 ff ff       	call   f0109c02 <pt_set_page_permissions>
f0112258:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f011225b:	83 ec 04             	sub    $0x4,%esp
f011225e:	68 9c 2b 13 f0       	push   $0xf0132b9c
f0112263:	68 74 01 00 00       	push   $0x174
f0112268:	68 72 2a 13 f0       	push   $0xf0132a72
f011226d:	e8 3d ec fe ff       	call   f0100eaf <_panic>

f0112272 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0112272:	55                   	push   %ebp
f0112273:	89 e5                	mov    %esp,%ebp
f0112275:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0112278:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f011227f:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112284:	83 ec 08             	sub    $0x8,%esp
f0112287:	ff 75 f4             	pushl  -0xc(%ebp)
f011228a:	50                   	push   %eax
f011228b:	e8 37 7a ff ff       	call   f0109cc7 <pt_get_page_permissions>
f0112290:	83 c4 10             	add    $0x10,%esp
f0112293:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0112296:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f011229a:	74 17                	je     f01122b3 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f011229c:	83 ec 04             	sub    $0x4,%esp
f011229f:	68 38 2c 13 f0       	push   $0xf0132c38
f01122a4:	68 82 01 00 00       	push   $0x182
f01122a9:	68 72 2a 13 f0       	push   $0xf0132a72
f01122ae:	e8 fc eb fe ff       	call   f0100eaf <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f01122b3:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01122ba:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01122bf:	83 ec 08             	sub    $0x8,%esp
f01122c2:	ff 75 f4             	pushl  -0xc(%ebp)
f01122c5:	50                   	push   %eax
f01122c6:	e8 fc 79 ff ff       	call   f0109cc7 <pt_get_page_permissions>
f01122cb:	83 c4 10             	add    $0x10,%esp
f01122ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f01122d1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01122d5:	74 17                	je     f01122ee <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f01122d7:	83 ec 04             	sub    $0x4,%esp
f01122da:	68 5c 2c 13 f0       	push   $0xf0132c5c
f01122df:	68 8a 01 00 00       	push   $0x18a
f01122e4:	68 72 2a 13 f0       	push   $0xf0132a72
f01122e9:	e8 c1 eb fe ff       	call   f0100eaf <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f01122ee:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01122f5:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01122fa:	83 ec 08             	sub    $0x8,%esp
f01122fd:	ff 75 f4             	pushl  -0xc(%ebp)
f0112300:	50                   	push   %eax
f0112301:	e8 c1 79 ff ff       	call   f0109cc7 <pt_get_page_permissions>
f0112306:	83 c4 10             	add    $0x10,%esp
f0112309:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f011230c:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0112310:	74 17                	je     f0112329 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0112312:	83 ec 04             	sub    $0x4,%esp
f0112315:	68 80 2c 13 f0       	push   $0xf0132c80
f011231a:	68 92 01 00 00       	push   $0x192
f011231f:	68 72 2a 13 f0       	push   $0xf0132a72
f0112324:	e8 86 eb fe ff       	call   f0100eaf <_panic>
	}

	va = 0xF1000000;
f0112329:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112330:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112335:	83 ec 08             	sub    $0x8,%esp
f0112338:	ff 75 f4             	pushl  -0xc(%ebp)
f011233b:	50                   	push   %eax
f011233c:	e8 86 79 ff ff       	call   f0109cc7 <pt_get_page_permissions>
f0112341:	83 c4 10             	add    $0x10,%esp
f0112344:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0112347:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f011234b:	74 17                	je     f0112364 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f011234d:	83 ec 04             	sub    $0x4,%esp
f0112350:	68 a4 2c 13 f0       	push   $0xf0132ca4
f0112355:	68 99 01 00 00       	push   $0x199
f011235a:	68 72 2a 13 f0       	push   $0xf0132a72
f011235f:	e8 4b eb fe ff       	call   f0100eaf <_panic>
	}

	va = 0xF0001000;
f0112364:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f011236b:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112370:	83 ec 08             	sub    $0x8,%esp
f0112373:	ff 75 f4             	pushl  -0xc(%ebp)
f0112376:	50                   	push   %eax
f0112377:	e8 4b 79 ff ff       	call   f0109cc7 <pt_get_page_permissions>
f011237c:	83 c4 10             	add    $0x10,%esp
f011237f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0112382:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0112386:	74 17                	je     f011239f <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0112388:	83 ec 04             	sub    $0x4,%esp
f011238b:	68 c8 2c 13 f0       	push   $0xf0132cc8
f0112390:	68 a0 01 00 00       	push   $0x1a0
f0112395:	68 72 2a 13 f0       	push   $0xf0132a72
f011239a:	e8 10 eb fe ff       	call   f0100eaf <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f011239f:	83 ec 0c             	sub    $0xc,%esp
f01123a2:	68 ec 2c 13 f0       	push   $0xf0132cec
f01123a7:	e8 b0 f7 fe ff       	call   f0101b5c <cprintf>
f01123ac:	83 c4 10             	add    $0x10,%esp
	return 0;
f01123af:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01123b4:	c9                   	leave  
f01123b5:	c3                   	ret    

f01123b6 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f01123b6:	55                   	push   %ebp
f01123b7:	89 e5                	mov    %esp,%ebp
f01123b9:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f01123bc:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01123c3:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01123c8:	83 ec 08             	sub    $0x8,%esp
f01123cb:	ff 75 f4             	pushl  -0xc(%ebp)
f01123ce:	50                   	push   %eax
f01123cf:	e8 0d 79 ff ff       	call   f0109ce1 <pt_clear_page_table_entry>
f01123d4:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f01123d7:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01123dc:	83 ec 08             	sub    $0x8,%esp
f01123df:	ff 75 f4             	pushl  -0xc(%ebp)
f01123e2:	50                   	push   %eax
f01123e3:	e8 76 4a 00 00       	call   f0116e5e <CE>
f01123e8:	83 c4 10             	add    $0x10,%esp
f01123eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01123ee:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01123f2:	74 17                	je     f011240b <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f01123f4:	83 ec 04             	sub    $0x4,%esp
f01123f7:	68 34 2d 13 f0       	push   $0xf0132d34
f01123fc:	68 b0 01 00 00       	push   $0x1b0
f0112401:	68 72 2a 13 f0       	push   $0xf0132a72
f0112406:	e8 a4 ea fe ff       	call   f0100eaf <_panic>
	}

	va = 0xF0001000;
f011240b:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112412:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112417:	83 ec 08             	sub    $0x8,%esp
f011241a:	ff 75 f4             	pushl  -0xc(%ebp)
f011241d:	50                   	push   %eax
f011241e:	e8 be 78 ff ff       	call   f0109ce1 <pt_clear_page_table_entry>
f0112423:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112426:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011242b:	83 ec 08             	sub    $0x8,%esp
f011242e:	ff 75 f4             	pushl  -0xc(%ebp)
f0112431:	50                   	push   %eax
f0112432:	e8 27 4a 00 00       	call   f0116e5e <CE>
f0112437:	83 c4 10             	add    $0x10,%esp
f011243a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011243d:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112441:	74 17                	je     f011245a <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0112443:	83 ec 04             	sub    $0x4,%esp
f0112446:	68 60 2d 13 f0       	push   $0xf0132d60
f011244b:	68 b8 01 00 00       	push   $0x1b8
f0112450:	68 72 2a 13 f0       	push   $0xf0132a72
f0112455:	e8 55 ea fe ff       	call   f0100eaf <_panic>
	}

	va = 0xEF800000;
f011245a:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112461:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112466:	83 ec 08             	sub    $0x8,%esp
f0112469:	ff 75 f4             	pushl  -0xc(%ebp)
f011246c:	50                   	push   %eax
f011246d:	e8 6f 78 ff ff       	call   f0109ce1 <pt_clear_page_table_entry>
f0112472:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112475:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011247a:	83 ec 08             	sub    $0x8,%esp
f011247d:	ff 75 f4             	pushl  -0xc(%ebp)
f0112480:	50                   	push   %eax
f0112481:	e8 d8 49 00 00       	call   f0116e5e <CE>
f0112486:	83 c4 10             	add    $0x10,%esp
f0112489:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011248c:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112490:	74 17                	je     f01124a9 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0112492:	83 ec 04             	sub    $0x4,%esp
f0112495:	68 8c 2d 13 f0       	push   $0xf0132d8c
f011249a:	68 c0 01 00 00       	push   $0x1c0
f011249f:	68 72 2a 13 f0       	push   $0xf0132a72
f01124a4:	e8 06 ea fe ff       	call   f0100eaf <_panic>
	}

	va = 0xF0000000;
f01124a9:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01124b0:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01124b5:	83 ec 08             	sub    $0x8,%esp
f01124b8:	ff 75 f4             	pushl  -0xc(%ebp)
f01124bb:	50                   	push   %eax
f01124bc:	e8 20 78 ff ff       	call   f0109ce1 <pt_clear_page_table_entry>
f01124c1:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01124c4:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01124c9:	83 ec 08             	sub    $0x8,%esp
f01124cc:	ff 75 f4             	pushl  -0xc(%ebp)
f01124cf:	50                   	push   %eax
f01124d0:	e8 89 49 00 00       	call   f0116e5e <CE>
f01124d5:	83 c4 10             	add    $0x10,%esp
f01124d8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01124db:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01124df:	74 17                	je     f01124f8 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f01124e1:	83 ec 04             	sub    $0x4,%esp
f01124e4:	68 b8 2d 13 f0       	push   $0xf0132db8
f01124e9:	68 c8 01 00 00       	push   $0x1c8
f01124ee:	68 72 2a 13 f0       	push   $0xf0132a72
f01124f3:	e8 b7 e9 fe ff       	call   f0100eaf <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f01124f8:	83 ec 0c             	sub    $0xc,%esp
f01124fb:	68 e4 2d 13 f0       	push   $0xf0132de4
f0112500:	e8 57 f6 fe ff       	call   f0101b5c <cprintf>
f0112505:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112508:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011250d:	c9                   	leave  
f011250e:	c3                   	ret    

f011250f <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f011250f:	55                   	push   %ebp
f0112510:	89 e5                	mov    %esp,%ebp
f0112512:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0112515:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011251c:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112521:	83 ec 08             	sub    $0x8,%esp
f0112524:	ff 75 f4             	pushl  -0xc(%ebp)
f0112527:	50                   	push   %eax
f0112528:	e8 b4 77 ff ff       	call   f0109ce1 <pt_clear_page_table_entry>
f011252d:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0112530:	83 ec 04             	sub    $0x4,%esp
f0112533:	68 30 2e 13 f0       	push   $0xf0132e30
f0112538:	68 d3 01 00 00       	push   $0x1d3
f011253d:	68 72 2a 13 f0       	push   $0xf0132a72
f0112542:	e8 68 e9 fe ff       	call   f0100eaf <_panic>

f0112547 <test_virtual_to_physical>:

//=====================================
// 4) TEST CONVERTING VA 2 PA:
//=====================================
int test_virtual_to_physical()
{
f0112547:	55                   	push   %ebp
f0112548:	89 e5                	mov    %esp,%ebp
f011254a:	57                   	push   %edi
f011254b:	56                   	push   %esi
f011254c:	53                   	push   %ebx
f011254d:	81 ec ac 01 00 00    	sub    $0x1ac,%esp
	int kilo = 1024 ;
f0112553:	c7 45 e4 00 04 00 00 	movl   $0x400,-0x1c(%ebp)
	int mega = 1024*1024 ;
f011255a:	c7 45 e0 00 00 10 00 	movl   $0x100000,-0x20(%ebp)
	uint32 va;
	ClearUserSpace(ptr_page_directory);
f0112561:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112566:	83 ec 0c             	sub    $0xc,%esp
f0112569:	50                   	push   %eax
f011256a:	e8 d1 49 00 00       	call   f0116f40 <ClearUserSpace>
f011256f:	83 c4 10             	add    $0x10,%esp

	//============================
	//Case 1: Check getting pa of a va with NO table
	va = 0xeebfe000;
f0112572:	c7 45 dc 00 e0 bf ee 	movl   $0xeebfe000,-0x24(%ebp)
	int pa = virtual_to_physical(ptr_page_directory, va);
f0112579:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011257e:	83 ec 08             	sub    $0x8,%esp
f0112581:	ff 75 dc             	pushl  -0x24(%ebp)
f0112584:	50                   	push   %eax
f0112585:	e8 71 77 ff ff       	call   f0109cfb <virtual_to_physical>
f011258a:	83 c4 10             	add    $0x10,%esp
f011258d:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %d\n", va, CA(ptr_page_directory, va), pa);
	if(pa != -1)
f0112590:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
f0112594:	74 17                	je     f01125ad <test_virtual_to_physical+0x66>
		panic("[EVAL] #1 Test of virtual_to_physical Entry Failed.\n");
f0112596:	83 ec 04             	sub    $0x4,%esp
f0112599:	68 c8 2e 13 f0       	push   $0xf0132ec8
f011259e:	68 e8 01 00 00       	push   $0x1e8
f01125a3:	68 72 2a 13 f0       	push   $0xf0132a72
f01125a8:	e8 02 e9 fe ff       	call   f0100eaf <_panic>

	//============================
	//Case 2: Check getting pa of a va with a table
	va = 0xf0000000;
f01125ad:	c7 45 dc 00 00 00 f0 	movl   $0xf0000000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f01125b4:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01125b9:	83 ec 08             	sub    $0x8,%esp
f01125bc:	ff 75 dc             	pushl  -0x24(%ebp)
f01125bf:	50                   	push   %eax
f01125c0:	e8 36 77 ff ff       	call   f0109cfb <virtual_to_physical>
f01125c5:	83 c4 10             	add    $0x10,%esp
f01125c8:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01125cb:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01125d0:	83 ec 08             	sub    $0x8,%esp
f01125d3:	ff 75 dc             	pushl  -0x24(%ebp)
f01125d6:	50                   	push   %eax
f01125d7:	e8 63 48 00 00       	call   f0116e3f <CA>
f01125dc:	83 c4 10             	add    $0x10,%esp
f01125df:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01125e2:	74 17                	je     f01125fb <test_virtual_to_physical+0xb4>
		panic("[EVAL] #2 Test of virtual_to_physical Entry Failed.\n");
f01125e4:	83 ec 04             	sub    $0x4,%esp
f01125e7:	68 00 2f 13 f0       	push   $0xf0132f00
f01125ec:	68 f1 01 00 00       	push   $0x1f1
f01125f1:	68 72 2a 13 f0       	push   $0xf0132a72
f01125f6:	e8 b4 e8 fe ff       	call   f0100eaf <_panic>

	//============================
	char ap1[100] = "ap 0x2800000";execute_command(ap1);
f01125fb:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0112601:	bb cc 30 13 f0       	mov    $0xf01330cc,%ebx
f0112606:	ba 0d 00 00 00       	mov    $0xd,%edx
f011260b:	89 c7                	mov    %eax,%edi
f011260d:	89 de                	mov    %ebx,%esi
f011260f:	89 d1                	mov    %edx,%ecx
f0112611:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112613:	8d 55 81             	lea    -0x7f(%ebp),%edx
f0112616:	b9 57 00 00 00       	mov    $0x57,%ecx
f011261b:	b0 00                	mov    $0x0,%al
f011261d:	89 d7                	mov    %edx,%edi
f011261f:	f3 aa                	rep stos %al,%es:(%edi)
f0112621:	83 ec 0c             	sub    $0xc,%esp
f0112624:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011262a:	50                   	push   %eax
f011262b:	e8 eb f7 fe ff       	call   f0101e1b <execute_command>
f0112630:	83 c4 10             	add    $0x10,%esp
	va = 0x2800000;
f0112633:	c7 45 dc 00 00 80 02 	movl   $0x2800000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f011263a:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011263f:	83 ec 08             	sub    $0x8,%esp
f0112642:	ff 75 dc             	pushl  -0x24(%ebp)
f0112645:	50                   	push   %eax
f0112646:	e8 b0 76 ff ff       	call   f0109cfb <virtual_to_physical>
f011264b:	83 c4 10             	add    $0x10,%esp
f011264e:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f0112651:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112656:	83 ec 08             	sub    $0x8,%esp
f0112659:	ff 75 dc             	pushl  -0x24(%ebp)
f011265c:	50                   	push   %eax
f011265d:	e8 dd 47 00 00       	call   f0116e3f <CA>
f0112662:	83 c4 10             	add    $0x10,%esp
f0112665:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0112668:	74 17                	je     f0112681 <test_virtual_to_physical+0x13a>
		panic("[EVAL] #3 Test of virtual_to_physical Entry Failed.\n");
f011266a:	83 ec 04             	sub    $0x4,%esp
f011266d:	68 38 2f 13 f0       	push   $0xf0132f38
f0112672:	68 fa 01 00 00       	push   $0x1fa
f0112677:	68 72 2a 13 f0       	push   $0xf0132a72
f011267c:	e8 2e e8 fe ff       	call   f0100eaf <_panic>

	//============================
	char ap2[100] = "ap 0x2801000";execute_command(ap2);
f0112681:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
f0112687:	bb 30 31 13 f0       	mov    $0xf0133130,%ebx
f011268c:	ba 0d 00 00 00       	mov    $0xd,%edx
f0112691:	89 c7                	mov    %eax,%edi
f0112693:	89 de                	mov    %ebx,%esi
f0112695:	89 d1                	mov    %edx,%ecx
f0112697:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112699:	8d 95 1d ff ff ff    	lea    -0xe3(%ebp),%edx
f011269f:	b9 57 00 00 00       	mov    $0x57,%ecx
f01126a4:	b0 00                	mov    $0x0,%al
f01126a6:	89 d7                	mov    %edx,%edi
f01126a8:	f3 aa                	rep stos %al,%es:(%edi)
f01126aa:	83 ec 0c             	sub    $0xc,%esp
f01126ad:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
f01126b3:	50                   	push   %eax
f01126b4:	e8 62 f7 fe ff       	call   f0101e1b <execute_command>
f01126b9:	83 c4 10             	add    $0x10,%esp
	va = 0x2801000;
f01126bc:	c7 45 dc 00 10 80 02 	movl   $0x2801000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f01126c3:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01126c8:	83 ec 08             	sub    $0x8,%esp
f01126cb:	ff 75 dc             	pushl  -0x24(%ebp)
f01126ce:	50                   	push   %eax
f01126cf:	e8 27 76 ff ff       	call   f0109cfb <virtual_to_physical>
f01126d4:	83 c4 10             	add    $0x10,%esp
f01126d7:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01126da:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01126df:	83 ec 08             	sub    $0x8,%esp
f01126e2:	ff 75 dc             	pushl  -0x24(%ebp)
f01126e5:	50                   	push   %eax
f01126e6:	e8 54 47 00 00       	call   f0116e3f <CA>
f01126eb:	83 c4 10             	add    $0x10,%esp
f01126ee:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01126f1:	74 17                	je     f011270a <test_virtual_to_physical+0x1c3>
		panic("[EVAL] #4 Test of virtual_to_physical Entry Failed.\n");
f01126f3:	83 ec 04             	sub    $0x4,%esp
f01126f6:	68 70 2f 13 f0       	push   $0xf0132f70
f01126fb:	68 03 02 00 00       	push   $0x203
f0112700:	68 72 2a 13 f0       	push   $0xf0132a72
f0112705:	e8 a5 e7 fe ff       	call   f0100eaf <_panic>

	//============================
	char ap3[100] = "ap 0x2802000";execute_command(ap3);
f011270a:	8d 85 ac fe ff ff    	lea    -0x154(%ebp),%eax
f0112710:	bb 94 31 13 f0       	mov    $0xf0133194,%ebx
f0112715:	ba 0d 00 00 00       	mov    $0xd,%edx
f011271a:	89 c7                	mov    %eax,%edi
f011271c:	89 de                	mov    %ebx,%esi
f011271e:	89 d1                	mov    %edx,%ecx
f0112720:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112722:	8d 95 b9 fe ff ff    	lea    -0x147(%ebp),%edx
f0112728:	b9 57 00 00 00       	mov    $0x57,%ecx
f011272d:	b0 00                	mov    $0x0,%al
f011272f:	89 d7                	mov    %edx,%edi
f0112731:	f3 aa                	rep stos %al,%es:(%edi)
f0112733:	83 ec 0c             	sub    $0xc,%esp
f0112736:	8d 85 ac fe ff ff    	lea    -0x154(%ebp),%eax
f011273c:	50                   	push   %eax
f011273d:	e8 d9 f6 fe ff       	call   f0101e1b <execute_command>
f0112742:	83 c4 10             	add    $0x10,%esp
	va = 0x2802000;
f0112745:	c7 45 dc 00 20 80 02 	movl   $0x2802000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f011274c:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112751:	83 ec 08             	sub    $0x8,%esp
f0112754:	ff 75 dc             	pushl  -0x24(%ebp)
f0112757:	50                   	push   %eax
f0112758:	e8 9e 75 ff ff       	call   f0109cfb <virtual_to_physical>
f011275d:	83 c4 10             	add    $0x10,%esp
f0112760:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f0112763:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112768:	83 ec 08             	sub    $0x8,%esp
f011276b:	ff 75 dc             	pushl  -0x24(%ebp)
f011276e:	50                   	push   %eax
f011276f:	e8 cb 46 00 00       	call   f0116e3f <CA>
f0112774:	83 c4 10             	add    $0x10,%esp
f0112777:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011277a:	74 17                	je     f0112793 <test_virtual_to_physical+0x24c>
		panic("[EVAL] #5 Test of virtual_to_physical Entry Failed.\n");
f011277c:	83 ec 04             	sub    $0x4,%esp
f011277f:	68 a8 2f 13 f0       	push   $0xf0132fa8
f0112784:	68 0c 02 00 00       	push   $0x20c
f0112789:	68 72 2a 13 f0       	push   $0xf0132a72
f011278e:	e8 1c e7 fe ff       	call   f0100eaf <_panic>

	//============================
	va = 0xF0001000;
f0112793:	c7 45 dc 00 10 00 f0 	movl   $0xf0001000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f011279a:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011279f:	83 ec 08             	sub    $0x8,%esp
f01127a2:	ff 75 dc             	pushl  -0x24(%ebp)
f01127a5:	50                   	push   %eax
f01127a6:	e8 50 75 ff ff       	call   f0109cfb <virtual_to_physical>
f01127ab:	83 c4 10             	add    $0x10,%esp
f01127ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01127b1:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01127b6:	83 ec 08             	sub    $0x8,%esp
f01127b9:	ff 75 dc             	pushl  -0x24(%ebp)
f01127bc:	50                   	push   %eax
f01127bd:	e8 7d 46 00 00       	call   f0116e3f <CA>
f01127c2:	83 c4 10             	add    $0x10,%esp
f01127c5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01127c8:	74 17                	je     f01127e1 <test_virtual_to_physical+0x29a>
		panic("[EVAL] #6 Test of virtual_to_physical Entry Failed.\n");
f01127ca:	83 ec 04             	sub    $0x4,%esp
f01127cd:	68 e0 2f 13 f0       	push   $0xf0132fe0
f01127d2:	68 14 02 00 00       	push   $0x214
f01127d7:	68 72 2a 13 f0       	push   $0xf0132a72
f01127dc:	e8 ce e6 fe ff       	call   f0100eaf <_panic>

	//============================
	va = 0xF0001005;
f01127e1:	c7 45 dc 05 10 00 f0 	movl   $0xf0001005,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f01127e8:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f01127ed:	83 ec 08             	sub    $0x8,%esp
f01127f0:	ff 75 dc             	pushl  -0x24(%ebp)
f01127f3:	50                   	push   %eax
f01127f4:	e8 02 75 ff ff       	call   f0109cfb <virtual_to_physical>
f01127f9:	83 c4 10             	add    $0x10,%esp
f01127fc:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01127ff:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112804:	83 ec 08             	sub    $0x8,%esp
f0112807:	ff 75 dc             	pushl  -0x24(%ebp)
f011280a:	50                   	push   %eax
f011280b:	e8 2f 46 00 00       	call   f0116e3f <CA>
f0112810:	83 c4 10             	add    $0x10,%esp
f0112813:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0112816:	74 17                	je     f011282f <test_virtual_to_physical+0x2e8>
		panic("[EVAL] #7 Test of virtual_to_physical Entry Failed.\n");
f0112818:	83 ec 04             	sub    $0x4,%esp
f011281b:	68 18 30 13 f0       	push   $0xf0133018
f0112820:	68 1c 02 00 00       	push   $0x21c
f0112825:	68 72 2a 13 f0       	push   $0xf0132a72
f011282a:	e8 80 e6 fe ff       	call   f0100eaf <_panic>

	//============================
	char ap4[100] = "ap 0xeebfe000";execute_command(ap4);
f011282f:	8d 85 48 fe ff ff    	lea    -0x1b8(%ebp),%eax
f0112835:	bb f8 31 13 f0       	mov    $0xf01331f8,%ebx
f011283a:	ba 0e 00 00 00       	mov    $0xe,%edx
f011283f:	89 c7                	mov    %eax,%edi
f0112841:	89 de                	mov    %ebx,%esi
f0112843:	89 d1                	mov    %edx,%ecx
f0112845:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112847:	8d 95 56 fe ff ff    	lea    -0x1aa(%ebp),%edx
f011284d:	b9 56 00 00 00       	mov    $0x56,%ecx
f0112852:	b0 00                	mov    $0x0,%al
f0112854:	89 d7                	mov    %edx,%edi
f0112856:	f3 aa                	rep stos %al,%es:(%edi)
f0112858:	83 ec 0c             	sub    $0xc,%esp
f011285b:	8d 85 48 fe ff ff    	lea    -0x1b8(%ebp),%eax
f0112861:	50                   	push   %eax
f0112862:	e8 b4 f5 fe ff       	call   f0101e1b <execute_command>
f0112867:	83 c4 10             	add    $0x10,%esp
	va = 0xeebfe000;
f011286a:	c7 45 dc 00 e0 bf ee 	movl   $0xeebfe000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f0112871:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0112876:	83 ec 08             	sub    $0x8,%esp
f0112879:	ff 75 dc             	pushl  -0x24(%ebp)
f011287c:	50                   	push   %eax
f011287d:	e8 79 74 ff ff       	call   f0109cfb <virtual_to_physical>
f0112882:	83 c4 10             	add    $0x10,%esp
f0112885:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f0112888:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011288d:	83 ec 08             	sub    $0x8,%esp
f0112890:	ff 75 dc             	pushl  -0x24(%ebp)
f0112893:	50                   	push   %eax
f0112894:	e8 a6 45 00 00       	call   f0116e3f <CA>
f0112899:	83 c4 10             	add    $0x10,%esp
f011289c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011289f:	74 17                	je     f01128b8 <test_virtual_to_physical+0x371>
		panic("[EVAL] #8 Test of virtual_to_physical Entry Failed.\n");
f01128a1:	83 ec 04             	sub    $0x4,%esp
f01128a4:	68 50 30 13 f0       	push   $0xf0133050
f01128a9:	68 25 02 00 00       	push   $0x225
f01128ae:	68 72 2a 13 f0       	push   $0xf0132a72
f01128b3:	e8 f7 e5 fe ff       	call   f0100eaf <_panic>

	//============================
	cprintf("Congratulations!! test virtual_to_physical completed successfully.\n");
f01128b8:	83 ec 0c             	sub    $0xc,%esp
f01128bb:	68 88 30 13 f0       	push   $0xf0133088
f01128c0:	e8 97 f2 fe ff       	call   f0101b5c <cprintf>
f01128c5:	83 c4 10             	add    $0x10,%esp

	return 0;
f01128c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01128cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01128d0:	5b                   	pop    %ebx
f01128d1:	5e                   	pop    %esi
f01128d2:	5f                   	pop    %edi
f01128d3:	5d                   	pop    %ebp
f01128d4:	c3                   	ret    

f01128d5 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f01128d5:	55                   	push   %ebp
f01128d6:	89 e5                	mov    %esp,%ebp
f01128d8:	57                   	push   %edi
f01128d9:	56                   	push   %esi
f01128da:	53                   	push   %ebx
f01128db:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01128e1:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01128e7:	bb 0c 35 13 f0       	mov    $0xf013350c,%ebx
f01128ec:	ba 0f 00 00 00       	mov    $0xf,%edx
f01128f1:	89 c7                	mov    %eax,%edi
f01128f3:	89 de                	mov    %ebx,%esi
f01128f5:	89 d1                	mov    %edx,%ecx
f01128f7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01128f9:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01128ff:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112904:	b0 00                	mov    $0x0,%al
f0112906:	89 d7                	mov    %edx,%edi
f0112908:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011290a:	6a 00                	push   $0x0
f011290c:	6a 0a                	push   $0xa
f011290e:	6a 14                	push   $0x14
f0112910:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112916:	50                   	push   %eax
f0112917:	e8 48 85 ff ff       	call   f010ae64 <env_create>
f011291c:	83 c4 10             	add    $0x10,%esp
f011291f:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112922:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112925:	8b 40 64             	mov    0x64(%eax),%eax
f0112928:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f011292b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011292e:	8b 40 68             	mov    0x68(%eax),%eax
f0112931:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0112934:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112937:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011293a:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f0112941:	75 70 20 
f0112944:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f011294b:	00 00 00 
f011294e:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0112954:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112959:	b8 00 00 00 00       	mov    $0x0,%eax
f011295e:	89 d7                	mov    %edx,%edi
f0112960:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112962:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112965:	8b 40 10             	mov    0x10(%eax),%eax
f0112968:	83 ec 08             	sub    $0x8,%esp
f011296b:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112971:	52                   	push   %edx
f0112972:	50                   	push   %eax
f0112973:	e8 5a 86 00 00       	call   f011afd2 <ltostr>
f0112978:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f011297b:	83 ec 04             	sub    $0x4,%esp
f011297e:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112984:	50                   	push   %eax
f0112985:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f011298b:	50                   	push   %eax
f011298c:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0112992:	50                   	push   %eax
f0112993:	e8 13 87 00 00       	call   f011b0ab <strcconcat>
f0112998:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f011299b:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f01129a2:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f01129a9:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f01129b0:	83 ec 0c             	sub    $0xc,%esp
f01129b3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129b6:	e8 85 45 00 00       	call   f0116f40 <ClearUserSpace>
f01129bb:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f01129be:	83 ec 04             	sub    $0x4,%esp
f01129c1:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f01129c7:	50                   	push   %eax
f01129c8:	68 5c 32 13 f0       	push   $0xf013325c
f01129cd:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01129d3:	50                   	push   %eax
f01129d4:	e8 d2 86 00 00       	call   f011b0ab <strcconcat>
f01129d9:	83 c4 10             	add    $0x10,%esp
f01129dc:	83 ec 0c             	sub    $0xc,%esp
f01129df:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f01129e5:	50                   	push   %eax
f01129e6:	e8 30 f4 fe ff       	call   f0101e1b <execute_command>
f01129eb:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f01129ee:	83 ec 04             	sub    $0x4,%esp
f01129f1:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01129f7:	50                   	push   %eax
f01129f8:	68 67 32 13 f0       	push   $0xf0133267
f01129fd:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112a03:	50                   	push   %eax
f0112a04:	e8 a2 86 00 00       	call   f011b0ab <strcconcat>
f0112a09:	83 c4 10             	add    $0x10,%esp
f0112a0c:	83 ec 0c             	sub    $0xc,%esp
f0112a0f:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112a15:	50                   	push   %eax
f0112a16:	e8 00 f4 fe ff       	call   f0101e1b <execute_command>
f0112a1b:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f0112a1e:	83 ec 04             	sub    $0x4,%esp
f0112a21:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112a27:	50                   	push   %eax
f0112a28:	68 72 32 13 f0       	push   $0xf0133272
f0112a2d:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112a33:	50                   	push   %eax
f0112a34:	e8 72 86 00 00       	call   f011b0ab <strcconcat>
f0112a39:	83 c4 10             	add    $0x10,%esp
f0112a3c:	83 ec 0c             	sub    $0xc,%esp
f0112a3f:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112a45:	50                   	push   %eax
f0112a46:	e8 d0 f3 fe ff       	call   f0101e1b <execute_command>
f0112a4b:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0112a4e:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f0112a55:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a58:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0112a5b:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f0112a62:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a65:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f0112a68:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0112a6f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a72:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f0112a75:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a78:	83 ec 08             	sub    $0x8,%esp
f0112a7b:	50                   	push   %eax
f0112a7c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a7f:	e8 9d 44 00 00       	call   f0116f21 <GP>
f0112a84:	83 c4 10             	add    $0x10,%esp
f0112a87:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0112a8a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0112a91:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0112a98:	e8 0d be ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0112a9d:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0112aa0:	83 ec 0c             	sub    $0xc,%esp
f0112aa3:	68 80 32 13 f0       	push   $0xf0133280
f0112aa8:	e8 af f0 fe ff       	call   f0101b5c <cprintf>
f0112aad:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0112ab0:	6a 03                	push   $0x3
f0112ab2:	68 00 00 90 02       	push   $0x2900000
f0112ab7:	68 00 00 80 02       	push   $0x2800000
f0112abc:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112abf:	e8 be 80 ff ff       	call   f010ab82 <cut_paste_pages>
f0112ac4:	83 c4 10             	add    $0x10,%esp
f0112ac7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0112aca:	e8 db bd ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0112acf:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0112ad2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f0112ad9:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112add:	75 08                	jne    f0112ae7 <test_cut_paste_pages+0x212>
f0112adf:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112ae2:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112ae5:	74 2b                	je     f0112b12 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112ae7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112aea:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112aed:	83 ec 0c             	sub    $0xc,%esp
f0112af0:	50                   	push   %eax
f0112af1:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112af4:	68 b0 32 13 f0       	push   $0xf01332b0
f0112af9:	68 63 02 00 00       	push   $0x263
f0112afe:	68 72 2a 13 f0       	push   $0xf0132a72
f0112b03:	e8 4c e5 fe ff       	call   f0101054 <_warn>
f0112b08:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112b0b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f0112b12:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b16:	74 04                	je     f0112b1c <test_cut_paste_pages+0x247>
f0112b18:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112b1c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112b23:	83 ec 08             	sub    $0x8,%esp
f0112b26:	6a 00                	push   $0x0
f0112b28:	6a 01                	push   $0x1
f0112b2a:	6a 00                	push   $0x0
f0112b2c:	68 ff 0f 00 00       	push   $0xfff
f0112b31:	ff 75 bc             	pushl  -0x44(%ebp)
f0112b34:	6a 01                	push   $0x1
f0112b36:	68 00 30 00 00       	push   $0x3000
f0112b3b:	68 00 00 90 02       	push   $0x2900000
f0112b40:	68 00 00 80 02       	push   $0x2800000
f0112b45:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b48:	e8 27 44 00 00       	call   f0116f74 <CCP>
f0112b4d:	83 c4 30             	add    $0x30,%esp
f0112b50:	83 f8 01             	cmp    $0x1,%eax
f0112b53:	74 21                	je     f0112b76 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112b55:	83 ec 04             	sub    $0x4,%esp
f0112b58:	68 04 33 13 f0       	push   $0xf0133304
f0112b5d:	68 6b 02 00 00       	push   $0x26b
f0112b62:	68 72 2a 13 f0       	push   $0xf0132a72
f0112b67:	e8 e8 e4 fe ff       	call   f0101054 <_warn>
f0112b6c:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112b6f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0112b76:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b7a:	74 04                	je     f0112b80 <test_cut_paste_pages+0x2ab>
f0112b7c:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f0112b80:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0112b87:	83 ec 04             	sub    $0x4,%esp
f0112b8a:	6a 00                	push   $0x0
f0112b8c:	68 00 00 90 02       	push   $0x2900000
f0112b91:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b94:	e8 b7 41 00 00       	call   f0116d50 <CB>
f0112b99:	83 c4 10             	add    $0x10,%esp
f0112b9c:	85 c0                	test   %eax,%eax
f0112b9e:	0f 84 f6 00 00 00    	je     f0112c9a <test_cut_paste_pages+0x3c5>
f0112ba4:	83 ec 04             	sub    $0x4,%esp
f0112ba7:	6a 00                	push   $0x0
f0112ba9:	68 00 10 90 02       	push   $0x2901000
f0112bae:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112bb1:	e8 9a 41 00 00       	call   f0116d50 <CB>
f0112bb6:	83 c4 10             	add    $0x10,%esp
f0112bb9:	85 c0                	test   %eax,%eax
f0112bbb:	0f 84 d9 00 00 00    	je     f0112c9a <test_cut_paste_pages+0x3c5>
f0112bc1:	83 ec 04             	sub    $0x4,%esp
f0112bc4:	6a 00                	push   $0x0
f0112bc6:	68 00 20 90 02       	push   $0x2902000
f0112bcb:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112bce:	e8 7d 41 00 00       	call   f0116d50 <CB>
f0112bd3:	83 c4 10             	add    $0x10,%esp
f0112bd6:	85 c0                	test   %eax,%eax
f0112bd8:	0f 84 bc 00 00 00    	je     f0112c9a <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f0112bde:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0112be5:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f0112bec:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f0112bf3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112bf6:	8a 00                	mov    (%eax),%al
f0112bf8:	3c 61                	cmp    $0x61,%al
f0112bfa:	75 12                	jne    f0112c0e <test_cut_paste_pages+0x339>
f0112bfc:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112bff:	8a 00                	mov    (%eax),%al
f0112c01:	3c 62                	cmp    $0x62,%al
f0112c03:	75 09                	jne    f0112c0e <test_cut_paste_pages+0x339>
f0112c05:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112c08:	8a 00                	mov    (%eax),%al
f0112c0a:	3c 63                	cmp    $0x63,%al
f0112c0c:	74 21                	je     f0112c2f <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112c0e:	83 ec 04             	sub    $0x4,%esp
f0112c11:	68 50 33 13 f0       	push   $0xf0133350
f0112c16:	68 78 02 00 00       	push   $0x278
f0112c1b:	68 72 2a 13 f0       	push   $0xf0132a72
f0112c20:	e8 2f e4 fe ff       	call   f0101054 <_warn>
f0112c25:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112c28:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112c2f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c33:	74 04                	je     f0112c39 <test_cut_paste_pages+0x364>
f0112c35:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112c39:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f0112c40:	83 ec 04             	sub    $0x4,%esp
f0112c43:	6a 01                	push   $0x1
f0112c45:	68 00 10 90 02       	push   $0x2901000
f0112c4a:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c4d:	e8 fe 40 00 00       	call   f0116d50 <CB>
f0112c52:	83 c4 10             	add    $0x10,%esp
f0112c55:	85 c0                	test   %eax,%eax
f0112c57:	74 41                	je     f0112c9a <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f0112c59:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112c5c:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0112c5f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112c62:	8a 00                	mov    (%eax),%al
f0112c64:	3c 79                	cmp    $0x79,%al
f0112c66:	74 21                	je     f0112c89 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112c68:	83 ec 04             	sub    $0x4,%esp
f0112c6b:	68 50 33 13 f0       	push   $0xf0133350
f0112c70:	68 83 02 00 00       	push   $0x283
f0112c75:	68 72 2a 13 f0       	push   $0xf0132a72
f0112c7a:	e8 d5 e3 fe ff       	call   f0101054 <_warn>
f0112c7f:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112c82:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0112c89:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c8d:	74 04                	je     f0112c93 <test_cut_paste_pages+0x3be>
f0112c8f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112c93:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f0112c9a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112c9d:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f0112ca0:	6a 02                	push   $0x2
f0112ca2:	68 00 f0 bf 02       	push   $0x2bff000
f0112ca7:	68 00 10 90 02       	push   $0x2901000
f0112cac:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112caf:	e8 ce 7e ff ff       	call   f010ab82 <cut_paste_pages>
f0112cb4:	83 c4 10             	add    $0x10,%esp
f0112cb7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112cba:	e8 eb bb ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0112cbf:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0112cc2:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112cc6:	75 0b                	jne    f0112cd3 <test_cut_paste_pages+0x3fe>
f0112cc8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112ccb:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112cce:	83 f8 01             	cmp    $0x1,%eax
f0112cd1:	74 2b                	je     f0112cfe <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112cd3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112cd6:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112cd9:	83 ec 0c             	sub    $0xc,%esp
f0112cdc:	50                   	push   %eax
f0112cdd:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112ce0:	68 b0 32 13 f0       	push   $0xf01332b0
f0112ce5:	68 94 02 00 00       	push   $0x294
f0112cea:	68 72 2a 13 f0       	push   $0xf0132a72
f0112cef:	e8 60 e3 fe ff       	call   f0101054 <_warn>
f0112cf4:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112cf7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112cfe:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d02:	74 04                	je     f0112d08 <test_cut_paste_pages+0x433>
f0112d04:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112d08:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112d0f:	83 ec 08             	sub    $0x8,%esp
f0112d12:	6a 00                	push   $0x0
f0112d14:	6a 01                	push   $0x1
f0112d16:	6a 00                	push   $0x0
f0112d18:	68 ff 0f 00 00       	push   $0xfff
f0112d1d:	ff 75 bc             	pushl  -0x44(%ebp)
f0112d20:	6a 01                	push   $0x1
f0112d22:	68 00 20 00 00       	push   $0x2000
f0112d27:	68 00 f0 bf 02       	push   $0x2bff000
f0112d2c:	68 00 10 90 02       	push   $0x2901000
f0112d31:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d34:	e8 3b 42 00 00       	call   f0116f74 <CCP>
f0112d39:	83 c4 30             	add    $0x30,%esp
f0112d3c:	83 f8 01             	cmp    $0x1,%eax
f0112d3f:	74 21                	je     f0112d62 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112d41:	83 ec 04             	sub    $0x4,%esp
f0112d44:	68 04 33 13 f0       	push   $0xf0133304
f0112d49:	68 9c 02 00 00       	push   $0x29c
f0112d4e:	68 72 2a 13 f0       	push   $0xf0132a72
f0112d53:	e8 fc e2 fe ff       	call   f0101054 <_warn>
f0112d58:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112d5b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112d62:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d66:	74 04                	je     f0112d6c <test_cut_paste_pages+0x497>
f0112d68:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112d6c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f0112d73:	83 ec 04             	sub    $0x4,%esp
f0112d76:	6a 00                	push   $0x0
f0112d78:	68 ff f7 bf 02       	push   $0x2bff7ff
f0112d7d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d80:	e8 cb 3f 00 00       	call   f0116d50 <CB>
f0112d85:	83 c4 10             	add    $0x10,%esp
f0112d88:	85 c0                	test   %eax,%eax
f0112d8a:	74 6b                	je     f0112df7 <test_cut_paste_pages+0x522>
f0112d8c:	83 ec 04             	sub    $0x4,%esp
f0112d8f:	6a 00                	push   $0x0
f0112d91:	68 ff 0f c0 02       	push   $0x2c00fff
f0112d96:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d99:	e8 b2 3f 00 00       	call   f0116d50 <CB>
f0112d9e:	83 c4 10             	add    $0x10,%esp
f0112da1:	85 c0                	test   %eax,%eax
f0112da3:	74 52                	je     f0112df7 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112da5:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f0112dac:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112db3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112db6:	8a 00                	mov    (%eax),%al
f0112db8:	3c 79                	cmp    $0x79,%al
f0112dba:	75 09                	jne    f0112dc5 <test_cut_paste_pages+0x4f0>
f0112dbc:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112dbf:	8a 00                	mov    (%eax),%al
f0112dc1:	3c 63                	cmp    $0x63,%al
f0112dc3:	74 21                	je     f0112de6 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112dc5:	83 ec 04             	sub    $0x4,%esp
f0112dc8:	68 50 33 13 f0       	push   $0xf0133350
f0112dcd:	68 a8 02 00 00       	push   $0x2a8
f0112dd2:	68 72 2a 13 f0       	push   $0xf0132a72
f0112dd7:	e8 78 e2 fe ff       	call   f0101054 <_warn>
f0112ddc:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112ddf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112de6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112dea:	74 04                	je     f0112df0 <test_cut_paste_pages+0x51b>
f0112dec:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112df0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112df7:	83 ec 0c             	sub    $0xc,%esp
f0112dfa:	68 89 33 13 f0       	push   $0xf0133389
f0112dff:	e8 58 ed fe ff       	call   f0101b5c <cprintf>
f0112e04:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112e07:	83 ec 0c             	sub    $0xc,%esp
f0112e0a:	68 98 33 13 f0       	push   $0xf0133398
f0112e0f:	e8 48 ed fe ff       	call   f0101b5c <cprintf>
f0112e14:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0112e17:	83 ec 04             	sub    $0x4,%esp
f0112e1a:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112e20:	50                   	push   %eax
f0112e21:	68 c1 33 13 f0       	push   $0xf01333c1
f0112e26:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112e2c:	50                   	push   %eax
f0112e2d:	e8 79 82 00 00       	call   f011b0ab <strcconcat>
f0112e32:	83 c4 10             	add    $0x10,%esp
f0112e35:	83 ec 0c             	sub    $0xc,%esp
f0112e38:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112e3e:	50                   	push   %eax
f0112e3f:	e8 d7 ef fe ff       	call   f0101e1b <execute_command>
f0112e44:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f0112e47:	83 ec 04             	sub    $0x4,%esp
f0112e4a:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112e50:	50                   	push   %eax
f0112e51:	68 cc 33 13 f0       	push   $0xf01333cc
f0112e56:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112e5c:	50                   	push   %eax
f0112e5d:	e8 49 82 00 00       	call   f011b0ab <strcconcat>
f0112e62:	83 c4 10             	add    $0x10,%esp
f0112e65:	83 ec 0c             	sub    $0xc,%esp
f0112e68:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112e6e:	50                   	push   %eax
f0112e6f:	e8 a7 ef fe ff       	call   f0101e1b <execute_command>
f0112e74:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0112e77:	83 ec 04             	sub    $0x4,%esp
f0112e7a:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112e80:	50                   	push   %eax
f0112e81:	68 d7 33 13 f0       	push   $0xf01333d7
f0112e86:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112e8c:	50                   	push   %eax
f0112e8d:	e8 19 82 00 00       	call   f011b0ab <strcconcat>
f0112e92:	83 c4 10             	add    $0x10,%esp
f0112e95:	83 ec 0c             	sub    $0xc,%esp
f0112e98:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112e9e:	50                   	push   %eax
f0112e9f:	e8 77 ef fe ff       	call   f0101e1b <execute_command>
f0112ea4:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112ea7:	83 ec 04             	sub    $0x4,%esp
f0112eaa:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112eb0:	50                   	push   %eax
f0112eb1:	68 e2 33 13 f0       	push   $0xf01333e2
f0112eb6:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112ebc:	50                   	push   %eax
f0112ebd:	e8 e9 81 00 00       	call   f011b0ab <strcconcat>
f0112ec2:	83 c4 10             	add    $0x10,%esp
f0112ec5:	83 ec 0c             	sub    $0xc,%esp
f0112ec8:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112ece:	50                   	push   %eax
f0112ecf:	e8 47 ef fe ff       	call   f0101e1b <execute_command>
f0112ed4:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112ed7:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f0112ede:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112ee1:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112ee4:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0112eeb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112eee:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f0112ef1:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112ef8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112efb:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f0112efe:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112f05:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112f08:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0112f0b:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0112f12:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112f15:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0112f18:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f0112f1f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112f22:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0112f25:	83 ec 08             	sub    $0x8,%esp
f0112f28:	68 00 00 c0 01       	push   $0x1c00000
f0112f2d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f30:	e8 ec 3f 00 00       	call   f0116f21 <GP>
f0112f35:	83 c4 10             	add    $0x10,%esp
f0112f38:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f0112f3b:	83 ec 08             	sub    $0x8,%esp
f0112f3e:	68 00 00 40 01       	push   $0x1400000
f0112f43:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f46:	e8 d6 3f 00 00       	call   f0116f21 <GP>
f0112f4b:	83 c4 10             	add    $0x10,%esp
f0112f4e:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0112f51:	e8 54 b9 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0112f56:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0112f59:	6a 01                	push   $0x1
f0112f5b:	68 00 00 40 01       	push   $0x1400000
f0112f60:	68 00 00 c0 01       	push   $0x1c00000
f0112f65:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f68:	e8 15 7c ff ff       	call   f010ab82 <cut_paste_pages>
f0112f6d:	83 c4 10             	add    $0x10,%esp
f0112f70:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112f73:	e8 32 b9 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0112f78:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112f7b:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112f7f:	75 08                	jne    f0112f89 <test_cut_paste_pages+0x6b4>
f0112f81:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112f84:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112f87:	74 2b                	je     f0112fb4 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112f89:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112f8c:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112f8f:	83 ec 0c             	sub    $0xc,%esp
f0112f92:	50                   	push   %eax
f0112f93:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112f96:	68 f0 33 13 f0       	push   $0xf01333f0
f0112f9b:	68 cb 02 00 00       	push   $0x2cb
f0112fa0:	68 72 2a 13 f0       	push   $0xf0132a72
f0112fa5:	e8 aa e0 fe ff       	call   f0101054 <_warn>
f0112faa:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112fad:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112fb4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112fb8:	74 04                	je     f0112fbe <test_cut_paste_pages+0x6e9>
f0112fba:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112fbe:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112fc5:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0112fcc:	83 ec 08             	sub    $0x8,%esp
f0112fcf:	6a 00                	push   $0x0
f0112fd1:	68 ff 0f 00 00       	push   $0xfff
f0112fd6:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112fd9:	68 ff 0f 00 00       	push   $0xfff
f0112fde:	ff 75 a0             	pushl  -0x60(%ebp)
f0112fe1:	6a 01                	push   $0x1
f0112fe3:	68 00 10 00 00       	push   $0x1000
f0112fe8:	68 00 00 40 01       	push   $0x1400000
f0112fed:	68 00 00 c0 01       	push   $0x1c00000
f0112ff2:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ff5:	e8 7a 3f 00 00       	call   f0116f74 <CCP>
f0112ffa:	83 c4 30             	add    $0x30,%esp
f0112ffd:	83 f8 01             	cmp    $0x1,%eax
f0113000:	74 28                	je     f011302a <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0113002:	83 ec 04             	sub    $0x4,%esp
f0113005:	68 04 33 13 f0       	push   $0xf0133304
f011300a:	68 d4 02 00 00       	push   $0x2d4
f011300f:	68 72 2a 13 f0       	push   $0xf0132a72
f0113014:	e8 3b e0 fe ff       	call   f0101054 <_warn>
f0113019:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011301c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0113023:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f011302a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011302e:	74 04                	je     f0113034 <test_cut_paste_pages+0x75f>
f0113030:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0113034:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f011303b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011303f:	0f 84 92 00 00 00    	je     f01130d7 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0113045:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f011304c:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0113053:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f011305a:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0113061:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0113068:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011306f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113072:	8a 00                	mov    (%eax),%al
f0113074:	3c 61                	cmp    $0x61,%al
f0113076:	75 2d                	jne    f01130a5 <test_cut_paste_pages+0x7d0>
f0113078:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011307b:	8a 00                	mov    (%eax),%al
f011307d:	3c 78                	cmp    $0x78,%al
f011307f:	75 24                	jne    f01130a5 <test_cut_paste_pages+0x7d0>
f0113081:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113084:	8a 00                	mov    (%eax),%al
f0113086:	3c 62                	cmp    $0x62,%al
f0113088:	75 1b                	jne    f01130a5 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f011308a:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011308d:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011308f:	3c 79                	cmp    $0x79,%al
f0113091:	75 12                	jne    f01130a5 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0113093:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113096:	8a 00                	mov    (%eax),%al
f0113098:	3c 63                	cmp    $0x63,%al
f011309a:	75 09                	jne    f01130a5 <test_cut_paste_pages+0x7d0>
f011309c:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011309f:	8a 00                	mov    (%eax),%al
f01130a1:	3c 7a                	cmp    $0x7a,%al
f01130a3:	74 21                	je     f01130c6 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01130a5:	83 ec 04             	sub    $0x4,%esp
f01130a8:	68 50 33 13 f0       	push   $0xf0133350
f01130ad:	68 e6 02 00 00       	push   $0x2e6
f01130b2:	68 72 2a 13 f0       	push   $0xf0132a72
f01130b7:	e8 98 df fe ff       	call   f0101054 <_warn>
f01130bc:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01130bf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01130c6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01130ca:	74 04                	je     f01130d0 <test_cut_paste_pages+0x7fb>
f01130cc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01130d0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f01130d7:	e8 ce b7 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f01130dc:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f01130df:	6a 03                	push   $0x3
f01130e1:	68 00 f0 bf 01       	push   $0x1bff000
f01130e6:	68 00 00 40 01       	push   $0x1400000
f01130eb:	ff 75 d4             	pushl  -0x2c(%ebp)
f01130ee:	e8 8f 7a ff ff       	call   f010ab82 <cut_paste_pages>
f01130f3:	83 c4 10             	add    $0x10,%esp
f01130f6:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01130f9:	e8 ac b7 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f01130fe:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0113101:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0113105:	75 08                	jne    f011310f <test_cut_paste_pages+0x83a>
f0113107:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011310a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011310d:	74 2b                	je     f011313a <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f011310f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113112:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0113115:	83 ec 0c             	sub    $0xc,%esp
f0113118:	50                   	push   %eax
f0113119:	ff 75 b4             	pushl  -0x4c(%ebp)
f011311c:	68 f0 33 13 f0       	push   $0xf01333f0
f0113121:	68 f5 02 00 00       	push   $0x2f5
f0113126:	68 72 2a 13 f0       	push   $0xf0132a72
f011312b:	e8 24 df fe ff       	call   f0101054 <_warn>
f0113130:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0113133:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011313a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011313e:	74 04                	je     f0113144 <test_cut_paste_pages+0x86f>
f0113140:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0113144:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f011314b:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0113152:	83 ec 04             	sub    $0x4,%esp
f0113155:	6a 00                	push   $0x0
f0113157:	68 00 00 40 01       	push   $0x1400000
f011315c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011315f:	e8 ec 3b 00 00       	call   f0116d50 <CB>
f0113164:	83 c4 10             	add    $0x10,%esp
f0113167:	83 f8 01             	cmp    $0x1,%eax
f011316a:	0f 85 80 00 00 00    	jne    f01131f0 <test_cut_paste_pages+0x91b>
f0113170:	83 ec 04             	sub    $0x4,%esp
f0113173:	6a 00                	push   $0x0
f0113175:	68 00 10 40 01       	push   $0x1401000
f011317a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011317d:	e8 ce 3b 00 00       	call   f0116d50 <CB>
f0113182:	83 c4 10             	add    $0x10,%esp
f0113185:	83 f8 01             	cmp    $0x1,%eax
f0113188:	75 66                	jne    f01131f0 <test_cut_paste_pages+0x91b>
f011318a:	83 ec 04             	sub    $0x4,%esp
f011318d:	6a 00                	push   $0x0
f011318f:	68 00 20 40 01       	push   $0x1402000
f0113194:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113197:	e8 b4 3b 00 00       	call   f0116d50 <CB>
f011319c:	83 c4 10             	add    $0x10,%esp
f011319f:	83 f8 01             	cmp    $0x1,%eax
f01131a2:	75 4c                	jne    f01131f0 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f01131a4:	83 ec 04             	sub    $0x4,%esp
f01131a7:	6a 00                	push   $0x0
f01131a9:	68 00 f0 bf 01       	push   $0x1bff000
f01131ae:	ff 75 d4             	pushl  -0x2c(%ebp)
f01131b1:	e8 9a 3b 00 00       	call   f0116d50 <CB>
f01131b6:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f01131b9:	85 c0                	test   %eax,%eax
f01131bb:	75 33                	jne    f01131f0 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f01131bd:	83 ec 04             	sub    $0x4,%esp
f01131c0:	6a 00                	push   $0x0
f01131c2:	68 00 00 c0 01       	push   $0x1c00000
f01131c7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01131ca:	e8 81 3b 00 00       	call   f0116d50 <CB>
f01131cf:	83 c4 10             	add    $0x10,%esp
f01131d2:	83 f8 01             	cmp    $0x1,%eax
f01131d5:	75 19                	jne    f01131f0 <test_cut_paste_pages+0x91b>
f01131d7:	83 ec 04             	sub    $0x4,%esp
f01131da:	6a 00                	push   $0x0
f01131dc:	68 00 10 c0 01       	push   $0x1c01000
f01131e1:	ff 75 d4             	pushl  -0x2c(%ebp)
f01131e4:	e8 67 3b 00 00       	call   f0116d50 <CB>
f01131e9:	83 c4 10             	add    $0x10,%esp
f01131ec:	85 c0                	test   %eax,%eax
f01131ee:	74 28                	je     f0113218 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f01131f0:	83 ec 04             	sub    $0x4,%esp
f01131f3:	68 50 34 13 f0       	push   $0xf0133450
f01131f8:	68 fe 02 00 00       	push   $0x2fe
f01131fd:	68 72 2a 13 f0       	push   $0xf0132a72
f0113202:	e8 4d de fe ff       	call   f0101054 <_warn>
f0113207:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011320a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0113211:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0113218:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011321c:	74 04                	je     f0113222 <test_cut_paste_pages+0x94d>
f011321e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0113222:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0113229:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011322d:	0f 84 99 00 00 00    	je     f01132cc <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0113233:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f011323a:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0113241:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0113248:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f011324f:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0113256:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011325d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113260:	8a 00                	mov    (%eax),%al
f0113262:	3c 61                	cmp    $0x61,%al
f0113264:	75 2d                	jne    f0113293 <test_cut_paste_pages+0x9be>
f0113266:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113269:	8a 00                	mov    (%eax),%al
f011326b:	3c 78                	cmp    $0x78,%al
f011326d:	75 24                	jne    f0113293 <test_cut_paste_pages+0x9be>
f011326f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113272:	8a 00                	mov    (%eax),%al
f0113274:	3c 62                	cmp    $0x62,%al
f0113276:	75 1b                	jne    f0113293 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0113278:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011327b:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011327d:	3c 79                	cmp    $0x79,%al
f011327f:	75 12                	jne    f0113293 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0113281:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113284:	8a 00                	mov    (%eax),%al
f0113286:	3c 63                	cmp    $0x63,%al
f0113288:	75 09                	jne    f0113293 <test_cut_paste_pages+0x9be>
f011328a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011328d:	8a 00                	mov    (%eax),%al
f011328f:	3c 7a                	cmp    $0x7a,%al
f0113291:	74 28                	je     f01132bb <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0113293:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f011329a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01132a1:	83 ec 04             	sub    $0x4,%esp
f01132a4:	68 50 33 13 f0       	push   $0xf0133350
f01132a9:	68 12 03 00 00       	push   $0x312
f01132ae:	68 72 2a 13 f0       	push   $0xf0132a72
f01132b3:	e8 9c dd fe ff       	call   f0101054 <_warn>
f01132b8:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f01132bb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01132bf:	74 04                	je     f01132c5 <test_cut_paste_pages+0x9f0>
f01132c1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01132c5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f01132cc:	83 ec 0c             	sub    $0xc,%esp
f01132cf:	68 89 34 13 f0       	push   $0xf0133489
f01132d4:	e8 83 e8 fe ff       	call   f0101b5c <cprintf>
f01132d9:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f01132dc:	83 ec 08             	sub    $0x8,%esp
f01132df:	ff 75 e4             	pushl  -0x1c(%ebp)
f01132e2:	68 98 34 13 f0       	push   $0xf0133498
f01132e7:	e8 70 e8 fe ff       	call   f0101b5c <cprintf>
f01132ec:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01132ef:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01132f3:	75 10                	jne    f0113305 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f01132f5:	83 ec 0c             	sub    $0xc,%esp
f01132f8:	68 cc 34 13 f0       	push   $0xf01334cc
f01132fd:	e8 5a e8 fe ff       	call   f0101b5c <cprintf>
f0113302:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113305:	a1 40 64 85 f0       	mov    0xf0856440,%eax
f011330a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011330d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113310:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113313:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113318:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011331b:	5b                   	pop    %ebx
f011331c:	5e                   	pop    %esi
f011331d:	5f                   	pop    %edi
f011331e:	5d                   	pop    %ebp
f011331f:	c3                   	ret    

f0113320 <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0113320:	55                   	push   %ebp
f0113321:	89 e5                	mov    %esp,%ebp
f0113323:	57                   	push   %edi
f0113324:	56                   	push   %esi
f0113325:	53                   	push   %ebx
f0113326:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011332c:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0113332:	bb 0c 35 13 f0       	mov    $0xf013350c,%ebx
f0113337:	ba 0f 00 00 00       	mov    $0xf,%edx
f011333c:	89 c7                	mov    %eax,%edi
f011333e:	89 de                	mov    %ebx,%esi
f0113340:	89 d1                	mov    %edx,%ecx
f0113342:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113344:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f011334a:	b9 23 00 00 00       	mov    $0x23,%ecx
f011334f:	b0 00                	mov    $0x0,%al
f0113351:	89 d7                	mov    %edx,%edi
f0113353:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113355:	6a 00                	push   $0x0
f0113357:	6a 0a                	push   $0xa
f0113359:	6a 14                	push   $0x14
f011335b:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0113361:	50                   	push   %eax
f0113362:	e8 fd 7a ff ff       	call   f010ae64 <env_create>
f0113367:	83 c4 10             	add    $0x10,%esp
f011336a:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011336d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0113370:	8b 40 64             	mov    0x64(%eax),%eax
f0113373:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0113376:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0113379:	8b 40 68             	mov    0x68(%eax),%eax
f011337c:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0113382:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0113388:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011338b:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0113392:	75 70 20 
f0113395:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f011339c:	00 00 00 
f011339f:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f01133a5:	b9 03 00 00 00       	mov    $0x3,%ecx
f01133aa:	b8 00 00 00 00       	mov    $0x0,%eax
f01133af:	89 d7                	mov    %edx,%edi
f01133b1:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01133b3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01133b6:	8b 40 10             	mov    0x10(%eax),%eax
f01133b9:	83 ec 08             	sub    $0x8,%esp
f01133bc:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f01133c2:	52                   	push   %edx
f01133c3:	50                   	push   %eax
f01133c4:	e8 09 7c 00 00       	call   f011afd2 <ltostr>
f01133c9:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01133cc:	83 ec 04             	sub    $0x4,%esp
f01133cf:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01133d5:	50                   	push   %eax
f01133d6:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f01133dc:	50                   	push   %eax
f01133dd:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f01133e3:	50                   	push   %eax
f01133e4:	e8 c2 7c 00 00       	call   f011b0ab <strcconcat>
f01133e9:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f01133ec:	83 ec 0c             	sub    $0xc,%esp
f01133ef:	ff 75 d4             	pushl  -0x2c(%ebp)
f01133f2:	e8 49 3b 00 00       	call   f0116f40 <ClearUserSpace>
f01133f7:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f01133fa:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0113401:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0113408:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011340f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0113416:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f011341d:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0113424:	83 ec 0c             	sub    $0xc,%esp
f0113427:	68 40 35 13 f0       	push   $0xf0133540
f011342c:	e8 2b e7 fe ff       	call   f0101b5c <cprintf>
f0113431:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0113434:	83 ec 04             	sub    $0x4,%esp
f0113437:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011343d:	50                   	push   %eax
f011343e:	68 76 35 13 f0       	push   $0xf0133576
f0113443:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113449:	50                   	push   %eax
f011344a:	e8 5c 7c 00 00       	call   f011b0ab <strcconcat>
f011344f:	83 c4 10             	add    $0x10,%esp
f0113452:	83 ec 0c             	sub    $0xc,%esp
f0113455:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011345b:	50                   	push   %eax
f011345c:	e8 ba e9 fe ff       	call   f0101e1b <execute_command>
f0113461:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0113464:	83 ec 04             	sub    $0x4,%esp
f0113467:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011346d:	50                   	push   %eax
f011346e:	68 7b 35 13 f0       	push   $0xf013357b
f0113473:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113479:	50                   	push   %eax
f011347a:	e8 2c 7c 00 00       	call   f011b0ab <strcconcat>
f011347f:	83 c4 10             	add    $0x10,%esp
f0113482:	83 ec 0c             	sub    $0xc,%esp
f0113485:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011348b:	50                   	push   %eax
f011348c:	e8 8a e9 fe ff       	call   f0101e1b <execute_command>
f0113491:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0113494:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f011349a:	bb 81 38 13 f0       	mov    $0xf0133881,%ebx
f011349f:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134a4:	89 c7                	mov    %eax,%edi
f01134a6:	89 de                	mov    %ebx,%esi
f01134a8:	89 d1                	mov    %edx,%ecx
f01134aa:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134ac:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f01134b2:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134b7:	b0 00                	mov    $0x0,%al
f01134b9:	89 d7                	mov    %edx,%edi
f01134bb:	f3 aa                	rep stos %al,%es:(%edi)
f01134bd:	83 ec 0c             	sub    $0xc,%esp
f01134c0:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01134c6:	50                   	push   %eax
f01134c7:	e8 4f e9 fe ff       	call   f0101e1b <execute_command>
f01134cc:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f01134cf:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01134d5:	bb e5 38 13 f0       	mov    $0xf01338e5,%ebx
f01134da:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134df:	89 c7                	mov    %eax,%edi
f01134e1:	89 de                	mov    %ebx,%esi
f01134e3:	89 d1                	mov    %edx,%ecx
f01134e5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134e7:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f01134ed:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134f2:	b0 00                	mov    $0x0,%al
f01134f4:	89 d7                	mov    %edx,%edi
f01134f6:	f3 aa                	rep stos %al,%es:(%edi)
f01134f8:	83 ec 0c             	sub    $0xc,%esp
f01134fb:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113501:	50                   	push   %eax
f0113502:	e8 14 e9 fe ff       	call   f0101e1b <execute_command>
f0113507:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f011350a:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113510:	bb 49 39 13 f0       	mov    $0xf0133949,%ebx
f0113515:	ba 0f 00 00 00       	mov    $0xf,%edx
f011351a:	89 c7                	mov    %eax,%edi
f011351c:	89 de                	mov    %ebx,%esi
f011351e:	89 d1                	mov    %edx,%ecx
f0113520:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113522:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113528:	b9 55 00 00 00       	mov    $0x55,%ecx
f011352d:	b0 00                	mov    $0x0,%al
f011352f:	89 d7                	mov    %edx,%edi
f0113531:	f3 aa                	rep stos %al,%es:(%edi)
f0113533:	83 ec 0c             	sub    $0xc,%esp
f0113536:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011353c:	50                   	push   %eax
f011353d:	e8 d9 e8 fe ff       	call   f0101e1b <execute_command>
f0113542:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0113545:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f011354b:	bb ad 39 13 f0       	mov    $0xf01339ad,%ebx
f0113550:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113555:	89 c7                	mov    %eax,%edi
f0113557:	89 de                	mov    %ebx,%esi
f0113559:	89 d1                	mov    %edx,%ecx
f011355b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011355d:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0113563:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113568:	b0 00                	mov    $0x0,%al
f011356a:	89 d7                	mov    %edx,%edi
f011356c:	f3 aa                	rep stos %al,%es:(%edi)
f011356e:	83 ec 0c             	sub    $0xc,%esp
f0113571:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113577:	50                   	push   %eax
f0113578:	e8 9e e8 fe ff       	call   f0101e1b <execute_command>
f011357d:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0113580:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113586:	bb 11 3a 13 f0       	mov    $0xf0133a11,%ebx
f011358b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113590:	89 c7                	mov    %eax,%edi
f0113592:	89 de                	mov    %ebx,%esi
f0113594:	89 d1                	mov    %edx,%ecx
f0113596:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113598:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f011359e:	b9 55 00 00 00       	mov    $0x55,%ecx
f01135a3:	b0 00                	mov    $0x0,%al
f01135a5:	89 d7                	mov    %edx,%edi
f01135a7:	f3 aa                	rep stos %al,%es:(%edi)
f01135a9:	83 ec 0c             	sub    $0xc,%esp
f01135ac:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01135b2:	50                   	push   %eax
f01135b3:	e8 63 e8 fe ff       	call   f0101e1b <execute_command>
f01135b8:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f01135bb:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01135c1:	bb 75 3a 13 f0       	mov    $0xf0133a75,%ebx
f01135c6:	ba 0f 00 00 00       	mov    $0xf,%edx
f01135cb:	89 c7                	mov    %eax,%edi
f01135cd:	89 de                	mov    %ebx,%esi
f01135cf:	89 d1                	mov    %edx,%ecx
f01135d1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01135d3:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f01135d9:	b9 55 00 00 00       	mov    $0x55,%ecx
f01135de:	b0 00                	mov    $0x0,%al
f01135e0:	89 d7                	mov    %edx,%edi
f01135e2:	f3 aa                	rep stos %al,%es:(%edi)
f01135e4:	83 ec 0c             	sub    $0xc,%esp
f01135e7:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01135ed:	50                   	push   %eax
f01135ee:	e8 28 e8 fe ff       	call   f0101e1b <execute_command>
f01135f3:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f01135f6:	83 ec 04             	sub    $0x4,%esp
f01135f9:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01135ff:	50                   	push   %eax
f0113600:	68 83 35 13 f0       	push   $0xf0133583
f0113605:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011360b:	50                   	push   %eax
f011360c:	e8 9a 7a 00 00       	call   f011b0ab <strcconcat>
f0113611:	83 c4 10             	add    $0x10,%esp
f0113614:	83 ec 0c             	sub    $0xc,%esp
f0113617:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011361d:	50                   	push   %eax
f011361e:	e8 f8 e7 fe ff       	call   f0101e1b <execute_command>
f0113623:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0113626:	83 ec 04             	sub    $0x4,%esp
f0113629:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011362f:	50                   	push   %eax
f0113630:	68 8d 35 13 f0       	push   $0xf013358d
f0113635:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011363b:	50                   	push   %eax
f011363c:	e8 6a 7a 00 00       	call   f011b0ab <strcconcat>
f0113641:	83 c4 10             	add    $0x10,%esp
f0113644:	83 ec 0c             	sub    $0xc,%esp
f0113647:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011364d:	50                   	push   %eax
f011364e:	e8 c8 e7 fe ff       	call   f0101e1b <execute_command>
f0113653:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0113656:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011365c:	bb d9 3a 13 f0       	mov    $0xf0133ad9,%ebx
f0113661:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113666:	89 c7                	mov    %eax,%edi
f0113668:	89 de                	mov    %ebx,%esi
f011366a:	89 d1                	mov    %edx,%ecx
f011366c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011366e:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113674:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113679:	b0 00                	mov    $0x0,%al
f011367b:	89 d7                	mov    %edx,%edi
f011367d:	f3 aa                	rep stos %al,%es:(%edi)
f011367f:	83 ec 0c             	sub    $0xc,%esp
f0113682:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113688:	50                   	push   %eax
f0113689:	e8 8d e7 fe ff       	call   f0101e1b <execute_command>
f011368e:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0113691:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113697:	bb 3d 3b 13 f0       	mov    $0xf0133b3d,%ebx
f011369c:	ba 0f 00 00 00       	mov    $0xf,%edx
f01136a1:	89 c7                	mov    %eax,%edi
f01136a3:	89 de                	mov    %ebx,%esi
f01136a5:	89 d1                	mov    %edx,%ecx
f01136a7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01136a9:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01136af:	b9 55 00 00 00       	mov    $0x55,%ecx
f01136b4:	b0 00                	mov    $0x0,%al
f01136b6:	89 d7                	mov    %edx,%edi
f01136b8:	f3 aa                	rep stos %al,%es:(%edi)
f01136ba:	83 ec 0c             	sub    $0xc,%esp
f01136bd:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01136c3:	50                   	push   %eax
f01136c4:	e8 52 e7 fe ff       	call   f0101e1b <execute_command>
f01136c9:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f01136cc:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01136d2:	bb a1 3b 13 f0       	mov    $0xf0133ba1,%ebx
f01136d7:	ba 0f 00 00 00       	mov    $0xf,%edx
f01136dc:	89 c7                	mov    %eax,%edi
f01136de:	89 de                	mov    %ebx,%esi
f01136e0:	89 d1                	mov    %edx,%ecx
f01136e2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01136e4:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01136ea:	b9 55 00 00 00       	mov    $0x55,%ecx
f01136ef:	b0 00                	mov    $0x0,%al
f01136f1:	89 d7                	mov    %edx,%edi
f01136f3:	f3 aa                	rep stos %al,%es:(%edi)
f01136f5:	83 ec 0c             	sub    $0xc,%esp
f01136f8:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01136fe:	50                   	push   %eax
f01136ff:	e8 17 e7 fe ff       	call   f0101e1b <execute_command>
f0113704:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0113707:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f011370e:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0113715:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f011371c:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0113723:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f011372a:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0113731:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0113738:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f011373f:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0113746:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f011374d:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0113754:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f011375b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011375e:	8a 00                	mov    (%eax),%al
f0113760:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0113766:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113769:	8a 00                	mov    (%eax),%al
f011376b:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0113771:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113774:	8a 00                	mov    (%eax),%al
f0113776:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f011377c:	e8 29 b1 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0113781:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0113784:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113787:	89 d0                	mov    %edx,%eax
f0113789:	01 c0                	add    %eax,%eax
f011378b:	01 d0                	add    %edx,%eax
f011378d:	01 c0                	add    %eax,%eax
f011378f:	50                   	push   %eax
f0113790:	68 00 00 10 00       	push   $0x100000
f0113795:	6a 00                	push   $0x0
f0113797:	ff 75 d4             	pushl  -0x2c(%ebp)
f011379a:	e8 fd 73 ff ff       	call   f010ab9c <copy_paste_chunk>
f011379f:	83 c4 10             	add    $0x10,%esp
f01137a2:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01137a5:	e8 00 b1 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f01137aa:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01137ad:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01137b4:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f01137b8:	75 08                	jne    f01137c2 <test_copy_paste_chunk+0x4a2>
f01137ba:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01137bd:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01137c0:	74 2b                	je     f01137ed <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01137c2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01137c5:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01137c8:	83 ec 0c             	sub    $0xc,%esp
f01137cb:	50                   	push   %eax
f01137cc:	ff 75 88             	pushl  -0x78(%ebp)
f01137cf:	68 9c 35 13 f0       	push   $0xf013359c
f01137d4:	68 65 03 00 00       	push   $0x365
f01137d9:	68 72 2a 13 f0       	push   $0xf0132a72
f01137de:	e8 71 d8 fe ff       	call   f0101054 <_warn>
f01137e3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01137e6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01137ed:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01137f1:	74 04                	je     f01137f7 <test_copy_paste_chunk+0x4d7>
f01137f3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01137f7:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f01137fe:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113801:	8a 00                	mov    (%eax),%al
f0113803:	3c 61                	cmp    $0x61,%al
f0113805:	75 75                	jne    f011387c <test_copy_paste_chunk+0x55c>
f0113807:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011380a:	8a 00                	mov    (%eax),%al
f011380c:	3c 78                	cmp    $0x78,%al
f011380e:	75 6c                	jne    f011387c <test_copy_paste_chunk+0x55c>
f0113810:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113813:	8a 00                	mov    (%eax),%al
f0113815:	3c 62                	cmp    $0x62,%al
f0113817:	75 63                	jne    f011387c <test_copy_paste_chunk+0x55c>
f0113819:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011381c:	8a 00                	mov    (%eax),%al
f011381e:	3c 79                	cmp    $0x79,%al
f0113820:	75 5a                	jne    f011387c <test_copy_paste_chunk+0x55c>
f0113822:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113825:	8a 00                	mov    (%eax),%al
f0113827:	3c 63                	cmp    $0x63,%al
f0113829:	75 51                	jne    f011387c <test_copy_paste_chunk+0x55c>
f011382b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011382e:	8a 00                	mov    (%eax),%al
f0113830:	3c 7a                	cmp    $0x7a,%al
f0113832:	75 48                	jne    f011387c <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0113834:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113837:	8a 00                	mov    (%eax),%al
f0113839:	3c 64                	cmp    $0x64,%al
f011383b:	75 3f                	jne    f011387c <test_copy_paste_chunk+0x55c>
f011383d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113840:	8a 10                	mov    (%eax),%dl
f0113842:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0113848:	38 c2                	cmp    %al,%dl
f011384a:	75 30                	jne    f011387c <test_copy_paste_chunk+0x55c>
f011384c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011384f:	8a 00                	mov    (%eax),%al
f0113851:	3c 65                	cmp    $0x65,%al
f0113853:	75 27                	jne    f011387c <test_copy_paste_chunk+0x55c>
f0113855:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113858:	8a 10                	mov    (%eax),%dl
f011385a:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0113860:	38 c2                	cmp    %al,%dl
f0113862:	75 18                	jne    f011387c <test_copy_paste_chunk+0x55c>
f0113864:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113867:	8a 00                	mov    (%eax),%al
f0113869:	3c 66                	cmp    $0x66,%al
f011386b:	75 0f                	jne    f011387c <test_copy_paste_chunk+0x55c>
f011386d:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113870:	8a 10                	mov    (%eax),%dl
f0113872:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113878:	38 c2                	cmp    %al,%dl
f011387a:	74 21                	je     f011389d <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f011387c:	83 ec 04             	sub    $0x4,%esp
f011387f:	68 00 36 13 f0       	push   $0xf0133600
f0113884:	68 6e 03 00 00       	push   $0x36e
f0113889:	68 72 2a 13 f0       	push   $0xf0132a72
f011388e:	e8 c1 d7 fe ff       	call   f0101054 <_warn>
f0113893:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113896:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011389d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01138a1:	74 04                	je     f01138a7 <test_copy_paste_chunk+0x587>
f01138a3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01138a7:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f01138ae:	83 ec 0c             	sub    $0xc,%esp
f01138b1:	68 3a 36 13 f0       	push   $0xf013363a
f01138b6:	e8 a1 e2 fe ff       	call   f0101b5c <cprintf>
f01138bb:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f01138be:	83 ec 0c             	sub    $0xc,%esp
f01138c1:	68 4c 36 13 f0       	push   $0xf013364c
f01138c6:	e8 91 e2 fe ff       	call   f0101b5c <cprintf>
f01138cb:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f01138ce:	83 ec 04             	sub    $0x4,%esp
f01138d1:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01138d7:	50                   	push   %eax
f01138d8:	68 82 36 13 f0       	push   $0xf0133682
f01138dd:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01138e3:	50                   	push   %eax
f01138e4:	e8 c2 77 00 00       	call   f011b0ab <strcconcat>
f01138e9:	83 c4 10             	add    $0x10,%esp
f01138ec:	83 ec 0c             	sub    $0xc,%esp
f01138ef:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01138f5:	50                   	push   %eax
f01138f6:	e8 20 e5 fe ff       	call   f0101e1b <execute_command>
f01138fb:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f01138fe:	83 ec 04             	sub    $0x4,%esp
f0113901:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113907:	50                   	push   %eax
f0113908:	68 8c 36 13 f0       	push   $0xf013368c
f011390d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113913:	50                   	push   %eax
f0113914:	e8 92 77 00 00       	call   f011b0ab <strcconcat>
f0113919:	83 c4 10             	add    $0x10,%esp
f011391c:	83 ec 0c             	sub    $0xc,%esp
f011391f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113925:	50                   	push   %eax
f0113926:	e8 f0 e4 fe ff       	call   f0101e1b <execute_command>
f011392b:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f011392e:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113934:	bb 05 3c 13 f0       	mov    $0xf0133c05,%ebx
f0113939:	ba 0f 00 00 00       	mov    $0xf,%edx
f011393e:	89 c7                	mov    %eax,%edi
f0113940:	89 de                	mov    %ebx,%esi
f0113942:	89 d1                	mov    %edx,%ecx
f0113944:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113946:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f011394c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113951:	b0 00                	mov    $0x0,%al
f0113953:	89 d7                	mov    %edx,%edi
f0113955:	f3 aa                	rep stos %al,%es:(%edi)
f0113957:	83 ec 0c             	sub    $0xc,%esp
f011395a:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113960:	50                   	push   %eax
f0113961:	e8 b5 e4 fe ff       	call   f0101e1b <execute_command>
f0113966:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f0113969:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011396f:	bb 69 3c 13 f0       	mov    $0xf0133c69,%ebx
f0113974:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113979:	89 c7                	mov    %eax,%edi
f011397b:	89 de                	mov    %ebx,%esi
f011397d:	89 d1                	mov    %edx,%ecx
f011397f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113981:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0113987:	b9 55 00 00 00       	mov    $0x55,%ecx
f011398c:	b0 00                	mov    $0x0,%al
f011398e:	89 d7                	mov    %edx,%edi
f0113990:	f3 aa                	rep stos %al,%es:(%edi)
f0113992:	83 ec 0c             	sub    $0xc,%esp
f0113995:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011399b:	50                   	push   %eax
f011399c:	e8 7a e4 fe ff       	call   f0101e1b <execute_command>
f01139a1:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f01139a4:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01139aa:	bb cd 3c 13 f0       	mov    $0xf0133ccd,%ebx
f01139af:	ba 0f 00 00 00       	mov    $0xf,%edx
f01139b4:	89 c7                	mov    %eax,%edi
f01139b6:	89 de                	mov    %ebx,%esi
f01139b8:	89 d1                	mov    %edx,%ecx
f01139ba:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01139bc:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f01139c2:	b9 55 00 00 00       	mov    $0x55,%ecx
f01139c7:	b0 00                	mov    $0x0,%al
f01139c9:	89 d7                	mov    %edx,%edi
f01139cb:	f3 aa                	rep stos %al,%es:(%edi)
f01139cd:	83 ec 0c             	sub    $0xc,%esp
f01139d0:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01139d6:	50                   	push   %eax
f01139d7:	e8 3f e4 fe ff       	call   f0101e1b <execute_command>
f01139dc:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f01139df:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01139e5:	bb 31 3d 13 f0       	mov    $0xf0133d31,%ebx
f01139ea:	ba 0f 00 00 00       	mov    $0xf,%edx
f01139ef:	89 c7                	mov    %eax,%edi
f01139f1:	89 de                	mov    %ebx,%esi
f01139f3:	89 d1                	mov    %edx,%ecx
f01139f5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01139f7:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01139fd:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113a02:	b0 00                	mov    $0x0,%al
f0113a04:	89 d7                	mov    %edx,%edi
f0113a06:	f3 aa                	rep stos %al,%es:(%edi)
f0113a08:	83 ec 0c             	sub    $0xc,%esp
f0113a0b:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113a11:	50                   	push   %eax
f0113a12:	e8 04 e4 fe ff       	call   f0101e1b <execute_command>
f0113a17:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f0113a1a:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113a20:	bb 95 3d 13 f0       	mov    $0xf0133d95,%ebx
f0113a25:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113a2a:	89 c7                	mov    %eax,%edi
f0113a2c:	89 de                	mov    %ebx,%esi
f0113a2e:	89 d1                	mov    %edx,%ecx
f0113a30:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113a32:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0113a38:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113a3d:	b0 00                	mov    $0x0,%al
f0113a3f:	89 d7                	mov    %edx,%edi
f0113a41:	f3 aa                	rep stos %al,%es:(%edi)
f0113a43:	83 ec 0c             	sub    $0xc,%esp
f0113a46:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113a4c:	50                   	push   %eax
f0113a4d:	e8 c9 e3 fe ff       	call   f0101e1b <execute_command>
f0113a52:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f0113a55:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113a5b:	bb f9 3d 13 f0       	mov    $0xf0133df9,%ebx
f0113a60:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113a65:	89 c7                	mov    %eax,%edi
f0113a67:	89 de                	mov    %ebx,%esi
f0113a69:	89 d1                	mov    %edx,%ecx
f0113a6b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113a6d:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0113a73:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113a78:	b0 00                	mov    $0x0,%al
f0113a7a:	89 d7                	mov    %edx,%edi
f0113a7c:	f3 aa                	rep stos %al,%es:(%edi)
f0113a7e:	83 ec 0c             	sub    $0xc,%esp
f0113a81:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113a87:	50                   	push   %eax
f0113a88:	e8 8e e3 fe ff       	call   f0101e1b <execute_command>
f0113a8d:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0113a90:	83 ec 04             	sub    $0x4,%esp
f0113a93:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a99:	50                   	push   %eax
f0113a9a:	68 96 36 13 f0       	push   $0xf0133696
f0113a9f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113aa5:	50                   	push   %eax
f0113aa6:	e8 00 76 00 00       	call   f011b0ab <strcconcat>
f0113aab:	83 c4 10             	add    $0x10,%esp
f0113aae:	83 ec 0c             	sub    $0xc,%esp
f0113ab1:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113ab7:	50                   	push   %eax
f0113ab8:	e8 5e e3 fe ff       	call   f0101e1b <execute_command>
f0113abd:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0113ac0:	83 ec 04             	sub    $0x4,%esp
f0113ac3:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113ac9:	50                   	push   %eax
f0113aca:	68 a0 36 13 f0       	push   $0xf01336a0
f0113acf:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113ad5:	50                   	push   %eax
f0113ad6:	e8 d0 75 00 00       	call   f011b0ab <strcconcat>
f0113adb:	83 c4 10             	add    $0x10,%esp
f0113ade:	83 ec 0c             	sub    $0xc,%esp
f0113ae1:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113ae7:	50                   	push   %eax
f0113ae8:	e8 2e e3 fe ff       	call   f0101e1b <execute_command>
f0113aed:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f0113af0:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113af6:	bb 5d 3e 13 f0       	mov    $0xf0133e5d,%ebx
f0113afb:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b00:	89 c7                	mov    %eax,%edi
f0113b02:	89 de                	mov    %ebx,%esi
f0113b04:	89 d1                	mov    %edx,%ecx
f0113b06:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b08:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113b0e:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b13:	b0 00                	mov    $0x0,%al
f0113b15:	89 d7                	mov    %edx,%edi
f0113b17:	f3 aa                	rep stos %al,%es:(%edi)
f0113b19:	83 ec 0c             	sub    $0xc,%esp
f0113b1c:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113b22:	50                   	push   %eax
f0113b23:	e8 f3 e2 fe ff       	call   f0101e1b <execute_command>
f0113b28:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f0113b2b:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113b31:	bb c1 3e 13 f0       	mov    $0xf0133ec1,%ebx
f0113b36:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b3b:	89 c7                	mov    %eax,%edi
f0113b3d:	89 de                	mov    %ebx,%esi
f0113b3f:	89 d1                	mov    %edx,%ecx
f0113b41:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b43:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113b49:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b4e:	b0 00                	mov    $0x0,%al
f0113b50:	89 d7                	mov    %edx,%edi
f0113b52:	f3 aa                	rep stos %al,%es:(%edi)
f0113b54:	83 ec 0c             	sub    $0xc,%esp
f0113b57:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113b5d:	50                   	push   %eax
f0113b5e:	e8 b8 e2 fe ff       	call   f0101e1b <execute_command>
f0113b63:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f0113b66:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113b6c:	bb 25 3f 13 f0       	mov    $0xf0133f25,%ebx
f0113b71:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b76:	89 c7                	mov    %eax,%edi
f0113b78:	89 de                	mov    %ebx,%esi
f0113b7a:	89 d1                	mov    %edx,%ecx
f0113b7c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b7e:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113b84:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b89:	b0 00                	mov    $0x0,%al
f0113b8b:	89 d7                	mov    %edx,%edi
f0113b8d:	f3 aa                	rep stos %al,%es:(%edi)
f0113b8f:	83 ec 0c             	sub    $0xc,%esp
f0113b92:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113b98:	50                   	push   %eax
f0113b99:	e8 7d e2 fe ff       	call   f0101e1b <execute_command>
f0113b9e:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f0113ba1:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0113ba8:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f0113baf:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0113bb6:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f0113bbd:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0113bc4:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0113bcb:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f0113bd2:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f0113bd9:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f0113be0:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0113be7:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f0113bee:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0113bf5:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113bf8:	8a 00                	mov    (%eax),%al
f0113bfa:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113c00:	e8 a5 ac ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0113c05:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0113c08:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113c0b:	89 d0                	mov    %edx,%eax
f0113c0d:	01 c0                	add    %eax,%eax
f0113c0f:	01 d0                	add    %edx,%eax
f0113c11:	01 c0                	add    %eax,%eax
f0113c13:	50                   	push   %eax
f0113c14:	68 00 00 40 00       	push   $0x400000
f0113c19:	68 00 00 20 00       	push   $0x200000
f0113c1e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113c21:	e8 76 6f ff ff       	call   f010ab9c <copy_paste_chunk>
f0113c26:	83 c4 10             	add    $0x10,%esp
f0113c29:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113c2c:	e8 79 ac ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0113c31:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0113c34:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113c3b:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113c3f:	75 08                	jne    f0113c49 <test_copy_paste_chunk+0x929>
f0113c41:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113c44:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113c47:	74 2b                	je     f0113c74 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113c49:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113c4c:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113c4f:	83 ec 0c             	sub    $0xc,%esp
f0113c52:	50                   	push   %eax
f0113c53:	ff 75 80             	pushl  -0x80(%ebp)
f0113c56:	68 ac 36 13 f0       	push   $0xf01336ac
f0113c5b:	68 9e 03 00 00       	push   $0x39e
f0113c60:	68 72 2a 13 f0       	push   $0xf0132a72
f0113c65:	e8 ea d3 fe ff       	call   f0101054 <_warn>
f0113c6a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113c6d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113c74:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c78:	74 04                	je     f0113c7e <test_copy_paste_chunk+0x95e>
f0113c7a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113c7e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f0113c85:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0113c8c:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113c8f:	83 ec 08             	sub    $0x8,%esp
f0113c92:	6a 01                	push   $0x1
f0113c94:	6a 07                	push   $0x7
f0113c96:	6a 07                	push   $0x7
f0113c98:	6a 07                	push   $0x7
f0113c9a:	6a 07                	push   $0x7
f0113c9c:	6a 01                	push   $0x1
f0113c9e:	68 00 20 00 00       	push   $0x2000
f0113ca3:	68 00 00 40 00       	push   $0x400000
f0113ca8:	68 00 00 20 00       	push   $0x200000
f0113cad:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113cb0:	e8 bf 32 00 00       	call   f0116f74 <CCP>
f0113cb5:	83 c4 30             	add    $0x30,%esp
f0113cb8:	83 f8 01             	cmp    $0x1,%eax
f0113cbb:	74 2b                	je     f0113ce8 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f0113cbd:	83 ec 04             	sub    $0x4,%esp
f0113cc0:	68 00 37 13 f0       	push   $0xf0133700
f0113cc5:	68 a7 03 00 00       	push   $0x3a7
f0113cca:	68 72 2a 13 f0       	push   $0xf0132a72
f0113ccf:	e8 80 d3 fe ff       	call   f0101054 <_warn>
f0113cd4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113cd7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f0113cde:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113ce5:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113ce8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113cec:	74 04                	je     f0113cf2 <test_copy_paste_chunk+0x9d2>
f0113cee:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113cf2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113cf9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113cfc:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f0113cff:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113d02:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113d05:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113d08:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0113d0b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113d0e:	8a 00                	mov    (%eax),%al
f0113d10:	3c 61                	cmp    $0x61,%al
f0113d12:	75 69                	jne    f0113d7d <test_copy_paste_chunk+0xa5d>
f0113d14:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113d17:	8a 00                	mov    (%eax),%al
f0113d19:	3c 61                	cmp    $0x61,%al
f0113d1b:	75 60                	jne    f0113d7d <test_copy_paste_chunk+0xa5d>
f0113d1d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d20:	8a 00                	mov    (%eax),%al
f0113d22:	3c 79                	cmp    $0x79,%al
f0113d24:	75 57                	jne    f0113d7d <test_copy_paste_chunk+0xa5d>
f0113d26:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113d29:	8a 00                	mov    (%eax),%al
f0113d2b:	3c 62                	cmp    $0x62,%al
f0113d2d:	75 4e                	jne    f0113d7d <test_copy_paste_chunk+0xa5d>
f0113d2f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113d32:	8a 00                	mov    (%eax),%al
f0113d34:	3c 63                	cmp    $0x63,%al
f0113d36:	75 45                	jne    f0113d7d <test_copy_paste_chunk+0xa5d>
f0113d38:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113d3b:	8a 00                	mov    (%eax),%al
f0113d3d:	3c 7a                	cmp    $0x7a,%al
f0113d3f:	75 3c                	jne    f0113d7d <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f0113d41:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113d44:	8a 00                	mov    (%eax),%al
f0113d46:	3c 77                	cmp    $0x77,%al
f0113d48:	75 33                	jne    f0113d7d <test_copy_paste_chunk+0xa5d>
f0113d4a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113d4d:	8a 00                	mov    (%eax),%al
f0113d4f:	3c 64                	cmp    $0x64,%al
f0113d51:	75 2a                	jne    f0113d7d <test_copy_paste_chunk+0xa5d>
f0113d53:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113d56:	8a 00                	mov    (%eax),%al
f0113d58:	3c 65                	cmp    $0x65,%al
f0113d5a:	75 21                	jne    f0113d7d <test_copy_paste_chunk+0xa5d>
f0113d5c:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113d5f:	8a 00                	mov    (%eax),%al
f0113d61:	3c 65                	cmp    $0x65,%al
f0113d63:	75 18                	jne    f0113d7d <test_copy_paste_chunk+0xa5d>
f0113d65:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113d68:	8a 00                	mov    (%eax),%al
f0113d6a:	3c 66                	cmp    $0x66,%al
f0113d6c:	75 0f                	jne    f0113d7d <test_copy_paste_chunk+0xa5d>
f0113d6e:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113d71:	8a 10                	mov    (%eax),%dl
f0113d73:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113d79:	38 c2                	cmp    %al,%dl
f0113d7b:	74 21                	je     f0113d9e <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113d7d:	83 ec 04             	sub    $0x4,%esp
f0113d80:	68 00 36 13 f0       	push   $0xf0133600
f0113d85:	68 b5 03 00 00       	push   $0x3b5
f0113d8a:	68 72 2a 13 f0       	push   $0xf0132a72
f0113d8f:	e8 c0 d2 fe ff       	call   f0101054 <_warn>
f0113d94:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113d97:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113d9e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113da2:	74 04                	je     f0113da8 <test_copy_paste_chunk+0xa88>
f0113da4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113da8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f0113daf:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113db2:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113db5:	e8 f0 aa ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0113dba:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f0113dbd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113dc0:	89 c2                	mov    %eax,%edx
f0113dc2:	01 d2                	add    %edx,%edx
f0113dc4:	01 d0                	add    %edx,%eax
f0113dc6:	50                   	push   %eax
f0113dc7:	68 00 08 20 00       	push   $0x200800
f0113dcc:	68 00 08 40 00       	push   $0x400800
f0113dd1:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113dd4:	e8 c3 6d ff ff       	call   f010ab9c <copy_paste_chunk>
f0113dd9:	83 c4 10             	add    $0x10,%esp
f0113ddc:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113ddf:	e8 c6 aa ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0113de4:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113de7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113deb:	75 08                	jne    f0113df5 <test_copy_paste_chunk+0xad5>
f0113ded:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113df0:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113df3:	74 2b                	je     f0113e20 <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113df5:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113df8:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113dfb:	83 ec 0c             	sub    $0xc,%esp
f0113dfe:	50                   	push   %eax
f0113dff:	ff 75 80             	pushl  -0x80(%ebp)
f0113e02:	68 ac 36 13 f0       	push   $0xf01336ac
f0113e07:	68 c5 03 00 00       	push   $0x3c5
f0113e0c:	68 72 2a 13 f0       	push   $0xf0132a72
f0113e11:	e8 3e d2 fe ff       	call   f0101054 <_warn>
f0113e16:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113e19:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113e20:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113e24:	74 04                	je     f0113e2a <test_copy_paste_chunk+0xb0a>
f0113e26:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113e2a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113e31:	83 ec 08             	sub    $0x8,%esp
f0113e34:	6a 01                	push   $0x1
f0113e36:	6a 07                	push   $0x7
f0113e38:	6a 07                	push   $0x7
f0113e3a:	6a 07                	push   $0x7
f0113e3c:	6a 07                	push   $0x7
f0113e3e:	6a 01                	push   $0x1
f0113e40:	68 00 20 00 00       	push   $0x2000
f0113e45:	68 00 00 20 00       	push   $0x200000
f0113e4a:	68 00 00 40 00       	push   $0x400000
f0113e4f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113e52:	e8 1d 31 00 00       	call   f0116f74 <CCP>
f0113e57:	83 c4 30             	add    $0x30,%esp
f0113e5a:	83 f8 01             	cmp    $0x1,%eax
f0113e5d:	74 21                	je     f0113e80 <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113e5f:	83 ec 04             	sub    $0x4,%esp
f0113e62:	68 4c 37 13 f0       	push   $0xf013374c
f0113e67:	68 cd 03 00 00       	push   $0x3cd
f0113e6c:	68 72 2a 13 f0       	push   $0xf0132a72
f0113e71:	e8 de d1 fe ff       	call   f0101054 <_warn>
f0113e76:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e79:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113e80:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113e84:	74 04                	je     f0113e8a <test_copy_paste_chunk+0xb6a>
f0113e86:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113e8a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113e91:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e94:	8a 00                	mov    (%eax),%al
f0113e96:	3c 61                	cmp    $0x61,%al
f0113e98:	75 69                	jne    f0113f03 <test_copy_paste_chunk+0xbe3>
f0113e9a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e9d:	8a 00                	mov    (%eax),%al
f0113e9f:	3c 61                	cmp    $0x61,%al
f0113ea1:	75 60                	jne    f0113f03 <test_copy_paste_chunk+0xbe3>
f0113ea3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113ea6:	8a 00                	mov    (%eax),%al
f0113ea8:	3c 79                	cmp    $0x79,%al
f0113eaa:	75 57                	jne    f0113f03 <test_copy_paste_chunk+0xbe3>
f0113eac:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113eaf:	8a 00                	mov    (%eax),%al
f0113eb1:	3c 62                	cmp    $0x62,%al
f0113eb3:	75 4e                	jne    f0113f03 <test_copy_paste_chunk+0xbe3>
f0113eb5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113eb8:	8a 00                	mov    (%eax),%al
f0113eba:	3c 7a                	cmp    $0x7a,%al
f0113ebc:	75 45                	jne    f0113f03 <test_copy_paste_chunk+0xbe3>
f0113ebe:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113ec1:	8a 00                	mov    (%eax),%al
f0113ec3:	3c 7a                	cmp    $0x7a,%al
f0113ec5:	75 3c                	jne    f0113f03 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113ec7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113eca:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113ecc:	3c 64                	cmp    $0x64,%al
f0113ece:	75 33                	jne    f0113f03 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113ed0:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113ed3:	8a 00                	mov    (%eax),%al
f0113ed5:	3c 64                	cmp    $0x64,%al
f0113ed7:	75 2a                	jne    f0113f03 <test_copy_paste_chunk+0xbe3>
f0113ed9:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113edc:	8a 00                	mov    (%eax),%al
f0113ede:	3c 65                	cmp    $0x65,%al
f0113ee0:	75 21                	jne    f0113f03 <test_copy_paste_chunk+0xbe3>
f0113ee2:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113ee5:	8a 00                	mov    (%eax),%al
f0113ee7:	3c 78                	cmp    $0x78,%al
f0113ee9:	75 18                	jne    f0113f03 <test_copy_paste_chunk+0xbe3>
f0113eeb:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113eee:	8a 00                	mov    (%eax),%al
f0113ef0:	3c 66                	cmp    $0x66,%al
f0113ef2:	75 0f                	jne    f0113f03 <test_copy_paste_chunk+0xbe3>
f0113ef4:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113ef7:	8a 10                	mov    (%eax),%dl
f0113ef9:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113eff:	38 c2                	cmp    %al,%dl
f0113f01:	74 21                	je     f0113f24 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113f03:	83 ec 04             	sub    $0x4,%esp
f0113f06:	68 00 36 13 f0       	push   $0xf0133600
f0113f0b:	68 d6 03 00 00       	push   $0x3d6
f0113f10:	68 72 2a 13 f0       	push   $0xf0132a72
f0113f15:	e8 3a d1 fe ff       	call   f0101054 <_warn>
f0113f1a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113f1d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113f24:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113f28:	74 04                	je     f0113f2e <test_copy_paste_chunk+0xc0e>
f0113f2a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113f2e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0113f35:	83 ec 0c             	sub    $0xc,%esp
f0113f38:	68 97 37 13 f0       	push   $0xf0133797
f0113f3d:	e8 1a dc fe ff       	call   f0101b5c <cprintf>
f0113f42:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0113f45:	83 ec 0c             	sub    $0xc,%esp
f0113f48:	68 a8 37 13 f0       	push   $0xf01337a8
f0113f4d:	e8 0a dc fe ff       	call   f0101b5c <cprintf>
f0113f52:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0113f55:	83 ec 04             	sub    $0x4,%esp
f0113f58:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113f5e:	50                   	push   %eax
f0113f5f:	68 dc 37 13 f0       	push   $0xf01337dc
f0113f64:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113f6a:	50                   	push   %eax
f0113f6b:	e8 3b 71 00 00       	call   f011b0ab <strcconcat>
f0113f70:	83 c4 10             	add    $0x10,%esp
f0113f73:	83 ec 0c             	sub    $0xc,%esp
f0113f76:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113f7c:	50                   	push   %eax
f0113f7d:	e8 99 de fe ff       	call   f0101e1b <execute_command>
f0113f82:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0113f85:	83 ec 04             	sub    $0x4,%esp
f0113f88:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113f8e:	50                   	push   %eax
f0113f8f:	68 e6 37 13 f0       	push   $0xf01337e6
f0113f94:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113f9a:	50                   	push   %eax
f0113f9b:	e8 0b 71 00 00       	call   f011b0ab <strcconcat>
f0113fa0:	83 c4 10             	add    $0x10,%esp
f0113fa3:	83 ec 0c             	sub    $0xc,%esp
f0113fa6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113fac:	50                   	push   %eax
f0113fad:	e8 69 de fe ff       	call   f0101e1b <execute_command>
f0113fb2:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113fb5:	83 ec 04             	sub    $0x4,%esp
f0113fb8:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113fbe:	50                   	push   %eax
f0113fbf:	68 f0 37 13 f0       	push   $0xf01337f0
f0113fc4:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113fca:	50                   	push   %eax
f0113fcb:	e8 db 70 00 00       	call   f011b0ab <strcconcat>
f0113fd0:	83 c4 10             	add    $0x10,%esp
f0113fd3:	83 ec 0c             	sub    $0xc,%esp
f0113fd6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113fdc:	50                   	push   %eax
f0113fdd:	e8 39 de fe ff       	call   f0101e1b <execute_command>
f0113fe2:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113fe5:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113feb:	bb 89 3f 13 f0       	mov    $0xf0133f89,%ebx
f0113ff0:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113ff5:	89 c7                	mov    %eax,%edi
f0113ff7:	89 de                	mov    %ebx,%esi
f0113ff9:	89 d1                	mov    %edx,%ecx
f0113ffb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113ffd:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0114003:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114008:	b0 00                	mov    $0x0,%al
f011400a:	89 d7                	mov    %edx,%edi
f011400c:	f3 aa                	rep stos %al,%es:(%edi)
f011400e:	83 ec 0c             	sub    $0xc,%esp
f0114011:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0114017:	50                   	push   %eax
f0114018:	e8 fe dd fe ff       	call   f0101e1b <execute_command>
f011401d:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f0114020:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0114026:	bb ed 3f 13 f0       	mov    $0xf0133fed,%ebx
f011402b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114030:	89 c7                	mov    %eax,%edi
f0114032:	89 de                	mov    %ebx,%esi
f0114034:	89 d1                	mov    %edx,%ecx
f0114036:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114038:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f011403e:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114043:	b0 00                	mov    $0x0,%al
f0114045:	89 d7                	mov    %edx,%edi
f0114047:	f3 aa                	rep stos %al,%es:(%edi)
f0114049:	83 ec 0c             	sub    $0xc,%esp
f011404c:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0114052:	50                   	push   %eax
f0114053:	e8 c3 dd fe ff       	call   f0101e1b <execute_command>
f0114058:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f011405b:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0114061:	bb 51 40 13 f0       	mov    $0xf0134051,%ebx
f0114066:	ba 0f 00 00 00       	mov    $0xf,%edx
f011406b:	89 c7                	mov    %eax,%edi
f011406d:	89 de                	mov    %ebx,%esi
f011406f:	89 d1                	mov    %edx,%ecx
f0114071:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114073:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0114079:	b9 55 00 00 00       	mov    $0x55,%ecx
f011407e:	b0 00                	mov    $0x0,%al
f0114080:	89 d7                	mov    %edx,%edi
f0114082:	f3 aa                	rep stos %al,%es:(%edi)
f0114084:	83 ec 0c             	sub    $0xc,%esp
f0114087:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011408d:	50                   	push   %eax
f011408e:	e8 88 dd fe ff       	call   f0101e1b <execute_command>
f0114093:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114096:	e8 0f a8 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f011409b:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f011409e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01140a1:	89 d0                	mov    %edx,%eax
f01140a3:	01 c0                	add    %eax,%eax
f01140a5:	01 d0                	add    %edx,%eax
f01140a7:	c1 e0 02             	shl    $0x2,%eax
f01140aa:	50                   	push   %eax
f01140ab:	68 00 00 90 00       	push   $0x900000
f01140b0:	68 00 00 80 00       	push   $0x800000
f01140b5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01140b8:	e8 df 6a ff ff       	call   f010ab9c <copy_paste_chunk>
f01140bd:	83 c4 10             	add    $0x10,%esp
f01140c0:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01140c6:	e8 df a7 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f01140cb:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f01140ce:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f01140d5:	75 0b                	jne    f01140e2 <test_copy_paste_chunk+0xdc2>
f01140d7:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01140da:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01140dd:	83 f8 03             	cmp    $0x3,%eax
f01140e0:	74 2e                	je     f0114110 <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01140e2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01140e5:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01140e8:	83 ec 0c             	sub    $0xc,%esp
f01140eb:	50                   	push   %eax
f01140ec:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f01140f2:	68 ac 36 13 f0       	push   $0xf01336ac
f01140f7:	68 f4 03 00 00       	push   $0x3f4
f01140fc:	68 72 2a 13 f0       	push   $0xf0132a72
f0114101:	e8 4e cf fe ff       	call   f0101054 <_warn>
f0114106:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114109:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0114110:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114114:	74 04                	je     f011411a <test_copy_paste_chunk+0xdfa>
f0114116:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011411a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0114121:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0114128:	83 ec 08             	sub    $0x8,%esp
f011412b:	6a 01                	push   $0x1
f011412d:	6a 07                	push   $0x7
f011412f:	6a 07                	push   $0x7
f0114131:	6a 07                	push   $0x7
f0114133:	6a 07                	push   $0x7
f0114135:	6a 01                	push   $0x1
f0114137:	68 00 30 00 00       	push   $0x3000
f011413c:	68 00 00 90 00       	push   $0x900000
f0114141:	68 00 00 80 00       	push   $0x800000
f0114146:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114149:	e8 26 2e 00 00       	call   f0116f74 <CCP>
f011414e:	83 c4 30             	add    $0x30,%esp
f0114151:	83 f8 01             	cmp    $0x1,%eax
f0114154:	74 28                	je     f011417e <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0114156:	83 ec 04             	sub    $0x4,%esp
f0114159:	68 4c 37 13 f0       	push   $0xf013374c
f011415e:	68 fd 03 00 00       	push   $0x3fd
f0114163:	68 72 2a 13 f0       	push   $0xf0132a72
f0114168:	e8 e7 ce fe ff       	call   f0101054 <_warn>
f011416d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114170:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0114177:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f011417e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114182:	74 04                	je     f0114188 <test_copy_paste_chunk+0xe68>
f0114184:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114188:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f011418f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114193:	0f 84 9e 00 00 00    	je     f0114237 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0114199:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f01141a0:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f01141a7:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f01141ae:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f01141b5:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f01141bc:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f01141c3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01141c6:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f01141c9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01141cc:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f01141cf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01141d2:	8a 00                	mov    (%eax),%al
f01141d4:	3c 61                	cmp    $0x61,%al
f01141d6:	75 2d                	jne    f0114205 <test_copy_paste_chunk+0xee5>
f01141d8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01141db:	8a 00                	mov    (%eax),%al
f01141dd:	3c 61                	cmp    $0x61,%al
f01141df:	75 24                	jne    f0114205 <test_copy_paste_chunk+0xee5>
f01141e1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01141e4:	8a 00                	mov    (%eax),%al
f01141e6:	3c 79                	cmp    $0x79,%al
f01141e8:	75 1b                	jne    f0114205 <test_copy_paste_chunk+0xee5>
f01141ea:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01141ed:	8a 00                	mov    (%eax),%al
f01141ef:	3c 62                	cmp    $0x62,%al
f01141f1:	75 12                	jne    f0114205 <test_copy_paste_chunk+0xee5>
f01141f3:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01141f6:	8a 00                	mov    (%eax),%al
f01141f8:	3c 63                	cmp    $0x63,%al
f01141fa:	75 09                	jne    f0114205 <test_copy_paste_chunk+0xee5>
f01141fc:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01141ff:	8a 00                	mov    (%eax),%al
f0114201:	3c 7a                	cmp    $0x7a,%al
f0114203:	74 21                	je     f0114226 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0114205:	83 ec 04             	sub    $0x4,%esp
f0114208:	68 00 36 13 f0       	push   $0xf0133600
f011420d:	68 0f 04 00 00       	push   $0x40f
f0114212:	68 72 2a 13 f0       	push   $0xf0132a72
f0114217:	e8 38 ce fe ff       	call   f0101054 <_warn>
f011421c:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011421f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0114226:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011422a:	74 04                	je     f0114230 <test_copy_paste_chunk+0xf10>
f011422c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0114230:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114237:	e8 6e a6 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f011423c:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f011423f:	6a 00                	push   $0x0
f0114241:	6a 02                	push   $0x2
f0114243:	68 00 10 90 00       	push   $0x901000
f0114248:	ff 75 d4             	pushl  -0x2c(%ebp)
f011424b:	e8 b1 2b 00 00       	call   f0116e01 <SB>
f0114250:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0114253:	6a 00                	push   $0x0
f0114255:	6a 02                	push   $0x2
f0114257:	68 00 20 90 00       	push   $0x902000
f011425c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011425f:	e8 9d 2b 00 00       	call   f0116e01 <SB>
f0114264:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0114267:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011426a:	c1 e0 03             	shl    $0x3,%eax
f011426d:	50                   	push   %eax
f011426e:	68 00 f0 bf 00       	push   $0xbff000
f0114273:	68 00 10 90 00       	push   $0x901000
f0114278:	ff 75 d4             	pushl  -0x2c(%ebp)
f011427b:	e8 1c 69 ff ff       	call   f010ab9c <copy_paste_chunk>
f0114280:	83 c4 10             	add    $0x10,%esp
f0114283:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114289:	e8 1c a6 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f011428e:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0114291:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0114298:	75 0b                	jne    f01142a5 <test_copy_paste_chunk+0xf85>
f011429a:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011429d:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01142a0:	83 f8 03             	cmp    $0x3,%eax
f01142a3:	74 2e                	je     f01142d3 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01142a5:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01142a8:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01142ab:	83 ec 0c             	sub    $0xc,%esp
f01142ae:	50                   	push   %eax
f01142af:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f01142b5:	68 ac 36 13 f0       	push   $0xf01336ac
f01142ba:	68 1f 04 00 00       	push   $0x41f
f01142bf:	68 72 2a 13 f0       	push   $0xf0132a72
f01142c4:	e8 8b cd fe ff       	call   f0101054 <_warn>
f01142c9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01142cc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01142d3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01142d7:	74 04                	je     f01142dd <test_copy_paste_chunk+0xfbd>
f01142d9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01142dd:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f01142e4:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f01142eb:	83 ec 08             	sub    $0x8,%esp
f01142ee:	6a 01                	push   $0x1
f01142f0:	6a 07                	push   $0x7
f01142f2:	6a 03                	push   $0x3
f01142f4:	6a 07                	push   $0x7
f01142f6:	6a 03                	push   $0x3
f01142f8:	6a 01                	push   $0x1
f01142fa:	68 00 20 00 00       	push   $0x2000
f01142ff:	68 00 f0 bf 00       	push   $0xbff000
f0114304:	68 00 10 90 00       	push   $0x901000
f0114309:	ff 75 d4             	pushl  -0x2c(%ebp)
f011430c:	e8 63 2c 00 00       	call   f0116f74 <CCP>
f0114311:	83 c4 30             	add    $0x30,%esp
f0114314:	83 f8 01             	cmp    $0x1,%eax
f0114317:	74 28                	je     f0114341 <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0114319:	83 ec 04             	sub    $0x4,%esp
f011431c:	68 4c 37 13 f0       	push   $0xf013374c
f0114321:	68 28 04 00 00       	push   $0x428
f0114326:	68 72 2a 13 f0       	push   $0xf0132a72
f011432b:	e8 24 cd fe ff       	call   f0101054 <_warn>
f0114330:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114333:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f011433a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0114341:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114345:	74 04                	je     f011434b <test_copy_paste_chunk+0x102b>
f0114347:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011434b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0114352:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114356:	74 72                	je     f01143ca <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0114358:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f011435f:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0114366:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f011436d:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0114374:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114377:	8a 00                	mov    (%eax),%al
f0114379:	3c 62                	cmp    $0x62,%al
f011437b:	75 1b                	jne    f0114398 <test_copy_paste_chunk+0x1078>
f011437d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114380:	8a 00                	mov    (%eax),%al
f0114382:	3c 62                	cmp    $0x62,%al
f0114384:	75 12                	jne    f0114398 <test_copy_paste_chunk+0x1078>
f0114386:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114389:	8a 00                	mov    (%eax),%al
f011438b:	3c 7a                	cmp    $0x7a,%al
f011438d:	75 09                	jne    f0114398 <test_copy_paste_chunk+0x1078>
f011438f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0114392:	8a 00                	mov    (%eax),%al
f0114394:	3c 7a                	cmp    $0x7a,%al
f0114396:	74 21                	je     f01143b9 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0114398:	83 ec 04             	sub    $0x4,%esp
f011439b:	68 00 36 13 f0       	push   $0xf0133600
f01143a0:	68 34 04 00 00       	push   $0x434
f01143a5:	68 72 2a 13 f0       	push   $0xf0132a72
f01143aa:	e8 a5 cc fe ff       	call   f0101054 <_warn>
f01143af:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01143b2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01143b9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01143bd:	74 04                	je     f01143c3 <test_copy_paste_chunk+0x10a3>
f01143bf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01143c3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f01143ca:	83 ec 0c             	sub    $0xc,%esp
f01143cd:	68 fa 37 13 f0       	push   $0xf01337fa
f01143d2:	e8 85 d7 fe ff       	call   f0101b5c <cprintf>
f01143d7:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f01143da:	83 ec 08             	sub    $0x8,%esp
f01143dd:	ff 75 e4             	pushl  -0x1c(%ebp)
f01143e0:	68 0c 38 13 f0       	push   $0xf013380c
f01143e5:	e8 72 d7 fe ff       	call   f0101b5c <cprintf>
f01143ea:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01143ed:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01143f1:	75 10                	jne    f0114403 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f01143f3:	83 ec 0c             	sub    $0xc,%esp
f01143f6:	68 40 38 13 f0       	push   $0xf0133840
f01143fb:	e8 5c d7 fe ff       	call   f0101b5c <cprintf>
f0114400:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114403:	a1 40 64 85 f0       	mov    0xf0856440,%eax
f0114408:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011440b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011440e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114411:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114416:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114419:	5b                   	pop    %ebx
f011441a:	5e                   	pop    %esi
f011441b:	5f                   	pop    %edi
f011441c:	5d                   	pop    %ebp
f011441d:	c3                   	ret    

f011441e <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f011441e:	55                   	push   %ebp
f011441f:	89 e5                	mov    %esp,%ebp
f0114421:	57                   	push   %edi
f0114422:	56                   	push   %esi
f0114423:	53                   	push   %ebx
f0114424:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011442a:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0114430:	bb 0c 35 13 f0       	mov    $0xf013350c,%ebx
f0114435:	ba 0f 00 00 00       	mov    $0xf,%edx
f011443a:	89 c7                	mov    %eax,%edi
f011443c:	89 de                	mov    %ebx,%esi
f011443e:	89 d1                	mov    %edx,%ecx
f0114440:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114442:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0114448:	b9 23 00 00 00       	mov    $0x23,%ecx
f011444d:	b0 00                	mov    $0x0,%al
f011444f:	89 d7                	mov    %edx,%edi
f0114451:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114453:	6a 00                	push   $0x0
f0114455:	6a 0a                	push   $0xa
f0114457:	6a 14                	push   $0x14
f0114459:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f011445f:	50                   	push   %eax
f0114460:	e8 ff 69 ff ff       	call   f010ae64 <env_create>
f0114465:	83 c4 10             	add    $0x10,%esp
f0114468:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011446b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011446e:	8b 40 64             	mov    0x64(%eax),%eax
f0114471:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114474:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114477:	8b 40 68             	mov    0x68(%eax),%eax
f011447a:	89 45 80             	mov    %eax,-0x80(%ebp)
f011447d:	8b 45 80             	mov    -0x80(%ebp),%eax
f0114480:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114483:	83 ec 0c             	sub    $0xc,%esp
f0114486:	ff 75 cc             	pushl  -0x34(%ebp)
f0114489:	e8 b2 2a 00 00       	call   f0116f40 <ClearUserSpace>
f011448e:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114491:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114498:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f011449f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f01144a6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f01144aa:	83 ec 0c             	sub    $0xc,%esp
f01144ad:	68 b8 40 13 f0       	push   $0xf01340b8
f01144b2:	e8 a5 d6 fe ff       	call   f0101b5c <cprintf>
f01144b7:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f01144ba:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f01144c1:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f01144c8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01144cb:	8a 00                	mov    (%eax),%al
f01144cd:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f01144d3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01144d6:	8a 00                	mov    (%eax),%al
f01144d8:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f01144de:	e8 c7 a3 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f01144e3:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f01144e6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01144e9:	89 d0                	mov    %edx,%eax
f01144eb:	01 c0                	add    %eax,%eax
f01144ed:	01 d0                	add    %edx,%eax
f01144ef:	01 c0                	add    %eax,%eax
f01144f1:	83 ec 0c             	sub    $0xc,%esp
f01144f4:	6a 02                	push   $0x2
f01144f6:	50                   	push   %eax
f01144f7:	68 00 40 10 f0       	push   $0xf0104000
f01144fc:	68 00 00 10 f0       	push   $0xf0100000
f0114501:	ff 75 cc             	pushl  -0x34(%ebp)
f0114504:	e8 ad 66 ff ff       	call   f010abb6 <share_chunk>
f0114509:	83 c4 20             	add    $0x20,%esp
f011450c:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011450f:	e8 96 a3 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0114514:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114517:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f011451b:	75 08                	jne    f0114525 <test_share_chunk+0x107>
f011451d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114520:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114523:	74 28                	je     f011454d <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0114525:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114528:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011452b:	83 ec 0c             	sub    $0xc,%esp
f011452e:	50                   	push   %eax
f011452f:	ff 75 b0             	pushl  -0x50(%ebp)
f0114532:	68 e4 40 13 f0       	push   $0xf01340e4
f0114537:	68 70 04 00 00       	push   $0x470
f011453c:	68 72 2a 13 f0       	push   $0xf0132a72
f0114541:	e8 0e cb fe ff       	call   f0101054 <_warn>
f0114546:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114549:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011454d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114551:	74 04                	je     f0114557 <test_share_chunk+0x139>
f0114553:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114557:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f011455b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011455e:	c1 e0 03             	shl    $0x3,%eax
f0114561:	83 ec 08             	sub    $0x8,%esp
f0114564:	68 fd 00 00 00       	push   $0xfd
f0114569:	6a 07                	push   $0x7
f011456b:	6a 03                	push   $0x3
f011456d:	6a 07                	push   $0x7
f011456f:	6a 03                	push   $0x3
f0114571:	6a 01                	push   $0x1
f0114573:	50                   	push   %eax
f0114574:	68 00 40 10 f0       	push   $0xf0104000
f0114579:	68 00 00 10 f0       	push   $0xf0100000
f011457e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114581:	e8 ee 29 00 00       	call   f0116f74 <CCP>
f0114586:	83 c4 30             	add    $0x30,%esp
f0114589:	85 c0                	test   %eax,%eax
f011458b:	75 1e                	jne    f01145ab <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011458d:	83 ec 04             	sub    $0x4,%esp
f0114590:	68 40 41 13 f0       	push   $0xf0134140
f0114595:	68 78 04 00 00       	push   $0x478
f011459a:	68 72 2a 13 f0       	push   $0xf0132a72
f011459f:	e8 b0 ca fe ff       	call   f0101054 <_warn>
f01145a4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01145a7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01145ab:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145af:	74 04                	je     f01145b5 <test_share_chunk+0x197>
f01145b1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f01145b5:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01145b8:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f01145bb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01145be:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f01145c1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01145c4:	8a 00                	mov    (%eax),%al
f01145c6:	3c 41                	cmp    $0x41,%al
f01145c8:	75 09                	jne    f01145d3 <test_share_chunk+0x1b5>
f01145ca:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01145cd:	8a 00                	mov    (%eax),%al
f01145cf:	3c 42                	cmp    $0x42,%al
f01145d1:	74 1e                	je     f01145f1 <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01145d3:	83 ec 04             	sub    $0x4,%esp
f01145d6:	68 88 41 13 f0       	push   $0xf0134188
f01145db:	68 82 04 00 00       	push   $0x482
f01145e0:	68 72 2a 13 f0       	push   $0xf0132a72
f01145e5:	e8 6a ca fe ff       	call   f0101054 <_warn>
f01145ea:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01145ed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01145f1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145f5:	74 04                	je     f01145fb <test_share_chunk+0x1dd>
f01145f7:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01145fb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f01145ff:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0114605:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114608:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f011460a:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0114610:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114613:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0114615:	83 ec 0c             	sub    $0xc,%esp
f0114618:	68 bd 41 13 f0       	push   $0xf01341bd
f011461d:	e8 3a d5 fe ff       	call   f0101b5c <cprintf>
f0114622:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0114625:	83 ec 0c             	sub    $0xc,%esp
f0114628:	68 cc 41 13 f0       	push   $0xf01341cc
f011462d:	e8 2a d5 fe ff       	call   f0101b5c <cprintf>
f0114632:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114635:	e8 70 a2 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f011463a:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f011463d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114640:	c1 e0 05             	shl    $0x5,%eax
f0114643:	83 ec 0c             	sub    $0xc,%esp
f0114646:	68 02 0e 00 00       	push   $0xe02
f011464b:	50                   	push   %eax
f011464c:	68 00 00 00 40       	push   $0x40000000
f0114651:	68 00 00 00 f0       	push   $0xf0000000
f0114656:	ff 75 cc             	pushl  -0x34(%ebp)
f0114659:	e8 58 65 ff ff       	call   f010abb6 <share_chunk>
f011465e:	83 c4 20             	add    $0x20,%esp
f0114661:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114664:	e8 41 a2 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0114669:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f011466c:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0114670:	75 1f                	jne    f0114691 <test_share_chunk+0x273>
f0114672:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114675:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114678:	89 c1                	mov    %eax,%ecx
f011467a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011467d:	c1 e0 05             	shl    $0x5,%eax
f0114680:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114683:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011468a:	99                   	cltd   
f011468b:	f7 fb                	idiv   %ebx
f011468d:	39 c1                	cmp    %eax,%ecx
f011468f:	74 28                	je     f01146b9 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114691:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114694:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114697:	83 ec 0c             	sub    $0xc,%esp
f011469a:	50                   	push   %eax
f011469b:	ff 75 a8             	pushl  -0x58(%ebp)
f011469e:	68 08 42 13 f0       	push   $0xf0134208
f01146a3:	68 9a 04 00 00       	push   $0x49a
f01146a8:	68 72 2a 13 f0       	push   $0xf0132a72
f01146ad:	e8 a2 c9 fe ff       	call   f0101054 <_warn>
f01146b2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01146b5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01146b9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01146bd:	74 04                	je     f01146c3 <test_share_chunk+0x2a5>
f01146bf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01146c3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01146c7:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01146ce:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01146d1:	c1 e0 05             	shl    $0x5,%eax
f01146d4:	83 ec 08             	sub    $0x8,%esp
f01146d7:	6a 02                	push   $0x2
f01146d9:	6a 07                	push   $0x7
f01146db:	6a 03                	push   $0x3
f01146dd:	68 07 0e 00 00       	push   $0xe07
f01146e2:	68 03 0e 00 00       	push   $0xe03
f01146e7:	6a ff                	push   $0xffffffff
f01146e9:	50                   	push   %eax
f01146ea:	68 00 00 00 40       	push   $0x40000000
f01146ef:	68 00 00 00 f0       	push   $0xf0000000
f01146f4:	ff 75 cc             	pushl  -0x34(%ebp)
f01146f7:	e8 78 28 00 00       	call   f0116f74 <CCP>
f01146fc:	83 c4 30             	add    $0x30,%esp
f01146ff:	85 c0                	test   %eax,%eax
f0114701:	75 25                	jne    f0114728 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114703:	83 ec 04             	sub    $0x4,%esp
f0114706:	68 40 41 13 f0       	push   $0xf0134140
f011470b:	68 a3 04 00 00       	push   $0x4a3
f0114710:	68 72 2a 13 f0       	push   $0xf0132a72
f0114715:	e8 3a c9 fe ff       	call   f0101054 <_warn>
f011471a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011471d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114721:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114728:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011472b:	89 d0                	mov    %edx,%eax
f011472d:	01 c0                	add    %eax,%eax
f011472f:	01 d0                	add    %edx,%eax
f0114731:	c1 e0 02             	shl    $0x2,%eax
f0114734:	83 ec 08             	sub    $0x8,%esp
f0114737:	6a 02                	push   $0x2
f0114739:	6a 07                	push   $0x7
f011473b:	6a 03                	push   $0x3
f011473d:	68 07 0e 00 00       	push   $0xe07
f0114742:	68 03 0e 00 00       	push   $0xe03
f0114747:	6a 02                	push   $0x2
f0114749:	50                   	push   %eax
f011474a:	68 00 00 00 40       	push   $0x40000000
f011474f:	68 00 00 00 f0       	push   $0xf0000000
f0114754:	ff 75 cc             	pushl  -0x34(%ebp)
f0114757:	e8 18 28 00 00       	call   f0116f74 <CCP>
f011475c:	83 c4 30             	add    $0x30,%esp
f011475f:	85 c0                	test   %eax,%eax
f0114761:	75 1e                	jne    f0114781 <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114763:	83 ec 04             	sub    $0x4,%esp
f0114766:	68 40 41 13 f0       	push   $0xf0134140
f011476b:	68 aa 04 00 00       	push   $0x4aa
f0114770:	68 72 2a 13 f0       	push   $0xf0132a72
f0114775:	e8 da c8 fe ff       	call   f0101054 <_warn>
f011477a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011477d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114781:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114785:	74 04                	je     f011478b <test_share_chunk+0x36d>
f0114787:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011478b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f011478f:	b8 30 cd 87 f0       	mov    $0xf087cd30,%eax
f0114794:	05 00 00 00 10       	add    $0x10000000,%eax
f0114799:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f011479c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011479f:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f01147a4:	83 ec 08             	sub    $0x8,%esp
f01147a7:	6a 02                	push   $0x2
f01147a9:	6a 07                	push   $0x7
f01147ab:	6a 03                	push   $0x3
f01147ad:	68 07 0e 00 00       	push   $0xe07
f01147b2:	68 03 0e 00 00       	push   $0xe03
f01147b7:	6a 02                	push   $0x2
f01147b9:	50                   	push   %eax
f01147ba:	68 00 00 0a 40       	push   $0x400a0000
f01147bf:	68 00 00 0a f0       	push   $0xf00a0000
f01147c4:	ff 75 cc             	pushl  -0x34(%ebp)
f01147c7:	e8 a8 27 00 00       	call   f0116f74 <CCP>
f01147cc:	83 c4 30             	add    $0x30,%esp
f01147cf:	85 c0                	test   %eax,%eax
f01147d1:	75 1e                	jne    f01147f1 <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01147d3:	83 ec 04             	sub    $0x4,%esp
f01147d6:	68 40 41 13 f0       	push   $0xf0134140
f01147db:	68 b4 04 00 00       	push   $0x4b4
f01147e0:	68 72 2a 13 f0       	push   $0xf0132a72
f01147e5:	e8 6a c8 fe ff       	call   f0101054 <_warn>
f01147ea:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01147ed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01147f1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01147f5:	74 04                	je     f01147fb <test_share_chunk+0x3dd>
f01147f7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01147fb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01147ff:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114803:	0f 84 a4 00 00 00    	je     f01148ad <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0114809:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f0114810:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114813:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0114816:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f011481d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114820:	8a 00                	mov    (%eax),%al
f0114822:	3c 41                	cmp    $0x41,%al
f0114824:	75 09                	jne    f011482f <test_share_chunk+0x411>
f0114826:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114829:	8a 00                	mov    (%eax),%al
f011482b:	3c 41                	cmp    $0x41,%al
f011482d:	74 1e                	je     f011484d <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011482f:	83 ec 04             	sub    $0x4,%esp
f0114832:	68 88 41 13 f0       	push   $0xf0134188
f0114837:	68 c1 04 00 00       	push   $0x4c1
f011483c:	68 72 2a 13 f0       	push   $0xf0132a72
f0114841:	e8 0e c8 fe ff       	call   f0101054 <_warn>
f0114846:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114849:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011484d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114851:	74 04                	je     f0114857 <test_share_chunk+0x439>
f0114853:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114857:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f011485b:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0114862:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114865:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0114868:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f011486f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114872:	8a 00                	mov    (%eax),%al
f0114874:	3c 43                	cmp    $0x43,%al
f0114876:	75 09                	jne    f0114881 <test_share_chunk+0x463>
f0114878:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011487b:	8a 00                	mov    (%eax),%al
f011487d:	3c 43                	cmp    $0x43,%al
f011487f:	74 1e                	je     f011489f <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114881:	83 ec 04             	sub    $0x4,%esp
f0114884:	68 88 41 13 f0       	push   $0xf0134188
f0114889:	68 cc 04 00 00       	push   $0x4cc
f011488e:	68 72 2a 13 f0       	push   $0xf0132a72
f0114893:	e8 bc c7 fe ff       	call   f0101054 <_warn>
f0114898:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011489b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011489f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01148a3:	74 04                	je     f01148a9 <test_share_chunk+0x48b>
f01148a5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01148a9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01148ad:	83 ec 0c             	sub    $0xc,%esp
f01148b0:	68 97 37 13 f0       	push   $0xf0133797
f01148b5:	e8 a2 d2 fe ff       	call   f0101b5c <cprintf>
f01148ba:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f01148bd:	83 ec 0c             	sub    $0xc,%esp
f01148c0:	68 58 42 13 f0       	push   $0xf0134258
f01148c5:	e8 92 d2 fe ff       	call   f0101b5c <cprintf>
f01148ca:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01148cd:	e8 d8 9f ff ff       	call   f010e8aa <sys_calculate_free_frames>
f01148d2:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f01148d5:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01148d8:	89 d0                	mov    %edx,%eax
f01148da:	c1 e0 03             	shl    $0x3,%eax
f01148dd:	01 d0                	add    %edx,%eax
f01148df:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01148e6:	01 d0                	add    %edx,%eax
f01148e8:	c1 e0 03             	shl    $0x3,%eax
f01148eb:	83 ec 0c             	sub    $0xc,%esp
f01148ee:	6a 06                	push   $0x6
f01148f0:	50                   	push   %eax
f01148f1:	6a 00                	push   $0x0
f01148f3:	68 00 00 00 40       	push   $0x40000000
f01148f8:	ff 75 cc             	pushl  -0x34(%ebp)
f01148fb:	e8 b6 62 ff ff       	call   f010abb6 <share_chunk>
f0114900:	83 c4 20             	add    $0x20,%esp
f0114903:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114906:	e8 9f 9f ff ff       	call   f010e8aa <sys_calculate_free_frames>
f011490b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f011490e:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0114912:	75 0b                	jne    f011491f <test_share_chunk+0x501>
f0114914:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114917:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011491a:	83 f8 01             	cmp    $0x1,%eax
f011491d:	74 28                	je     f0114947 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011491f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114922:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114925:	83 ec 0c             	sub    $0xc,%esp
f0114928:	50                   	push   %eax
f0114929:	ff 75 a0             	pushl  -0x60(%ebp)
f011492c:	68 08 42 13 f0       	push   $0xf0134208
f0114931:	68 e2 04 00 00       	push   $0x4e2
f0114936:	68 72 2a 13 f0       	push   $0xf0132a72
f011493b:	e8 14 c7 fe ff       	call   f0101054 <_warn>
f0114940:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114943:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114947:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011494b:	74 04                	je     f0114951 <test_share_chunk+0x533>
f011494d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114951:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114955:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011495c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011495f:	05 00 80 02 00       	add    $0x28000,%eax
f0114964:	c1 e0 02             	shl    $0x2,%eax
f0114967:	83 ec 08             	sub    $0x8,%esp
f011496a:	6a 02                	push   $0x2
f011496c:	6a 07                	push   $0x7
f011496e:	6a 03                	push   $0x3
f0114970:	6a 07                	push   $0x7
f0114972:	6a 07                	push   $0x7
f0114974:	6a ff                	push   $0xffffffff
f0114976:	50                   	push   %eax
f0114977:	6a 00                	push   $0x0
f0114979:	68 00 00 00 40       	push   $0x40000000
f011497e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114981:	e8 ee 25 00 00       	call   f0116f74 <CCP>
f0114986:	83 c4 30             	add    $0x30,%esp
f0114989:	85 c0                	test   %eax,%eax
f011498b:	75 25                	jne    f01149b2 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011498d:	83 ec 04             	sub    $0x4,%esp
f0114990:	68 40 41 13 f0       	push   $0xf0134140
f0114995:	68 eb 04 00 00       	push   $0x4eb
f011499a:	68 72 2a 13 f0       	push   $0xf0132a72
f011499f:	e8 b0 c6 fe ff       	call   f0101054 <_warn>
f01149a4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01149a7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01149ab:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01149b2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01149b5:	89 d0                	mov    %edx,%eax
f01149b7:	01 c0                	add    %eax,%eax
f01149b9:	01 d0                	add    %edx,%eax
f01149bb:	c1 e0 02             	shl    $0x2,%eax
f01149be:	83 ec 08             	sub    $0x8,%esp
f01149c1:	6a 02                	push   $0x2
f01149c3:	6a 07                	push   $0x7
f01149c5:	6a 03                	push   $0x3
f01149c7:	6a 07                	push   $0x7
f01149c9:	6a 07                	push   $0x7
f01149cb:	6a 03                	push   $0x3
f01149cd:	50                   	push   %eax
f01149ce:	6a 00                	push   $0x0
f01149d0:	68 00 00 00 40       	push   $0x40000000
f01149d5:	ff 75 cc             	pushl  -0x34(%ebp)
f01149d8:	e8 97 25 00 00       	call   f0116f74 <CCP>
f01149dd:	83 c4 30             	add    $0x30,%esp
f01149e0:	85 c0                	test   %eax,%eax
f01149e2:	75 1e                	jne    f0114a02 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01149e4:	83 ec 04             	sub    $0x4,%esp
f01149e7:	68 40 41 13 f0       	push   $0xf0134140
f01149ec:	68 f2 04 00 00       	push   $0x4f2
f01149f1:	68 72 2a 13 f0       	push   $0xf0132a72
f01149f6:	e8 59 c6 fe ff       	call   f0101054 <_warn>
f01149fb:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01149fe:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114a02:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114a06:	74 04                	je     f0114a0c <test_share_chunk+0x5ee>
f0114a08:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114a0c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114a10:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114a13:	89 d0                	mov    %edx,%eax
f0114a15:	01 c0                	add    %eax,%eax
f0114a17:	01 d0                	add    %edx,%eax
f0114a19:	c1 e0 02             	shl    $0x2,%eax
f0114a1c:	f7 d8                	neg    %eax
f0114a1e:	05 00 00 0a 00       	add    $0xa0000,%eax
f0114a23:	83 ec 08             	sub    $0x8,%esp
f0114a26:	6a 02                	push   $0x2
f0114a28:	6a 07                	push   $0x7
f0114a2a:	6a 03                	push   $0x3
f0114a2c:	6a 07                	push   $0x7
f0114a2e:	6a 07                	push   $0x7
f0114a30:	6a 02                	push   $0x2
f0114a32:	50                   	push   %eax
f0114a33:	68 00 30 00 00       	push   $0x3000
f0114a38:	68 00 30 00 40       	push   $0x40003000
f0114a3d:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a40:	e8 2f 25 00 00       	call   f0116f74 <CCP>
f0114a45:	83 c4 30             	add    $0x30,%esp
f0114a48:	85 c0                	test   %eax,%eax
f0114a4a:	75 1e                	jne    f0114a6a <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114a4c:	83 ec 04             	sub    $0x4,%esp
f0114a4f:	68 40 41 13 f0       	push   $0xf0134140
f0114a54:	68 fa 04 00 00       	push   $0x4fa
f0114a59:	68 72 2a 13 f0       	push   $0xf0132a72
f0114a5e:	e8 f1 c5 fe ff       	call   f0101054 <_warn>
f0114a63:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114a66:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114a6a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114a6e:	74 04                	je     f0114a74 <test_share_chunk+0x656>
f0114a70:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114a74:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114a78:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114a7b:	c1 e0 02             	shl    $0x2,%eax
f0114a7e:	83 ec 08             	sub    $0x8,%esp
f0114a81:	6a 02                	push   $0x2
f0114a83:	6a 07                	push   $0x7
f0114a85:	6a 03                	push   $0x3
f0114a87:	6a 07                	push   $0x7
f0114a89:	6a 07                	push   $0x7
f0114a8b:	6a 03                	push   $0x3
f0114a8d:	50                   	push   %eax
f0114a8e:	68 00 00 0a 00       	push   $0xa0000
f0114a93:	68 00 00 0a 40       	push   $0x400a0000
f0114a98:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a9b:	e8 d4 24 00 00       	call   f0116f74 <CCP>
f0114aa0:	83 c4 30             	add    $0x30,%esp
f0114aa3:	85 c0                	test   %eax,%eax
f0114aa5:	75 1e                	jne    f0114ac5 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114aa7:	83 ec 04             	sub    $0x4,%esp
f0114aaa:	68 40 41 13 f0       	push   $0xf0134140
f0114aaf:	68 02 05 00 00       	push   $0x502
f0114ab4:	68 72 2a 13 f0       	push   $0xf0132a72
f0114ab9:	e8 96 c5 fe ff       	call   f0101054 <_warn>
f0114abe:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114ac1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114ac5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114ac9:	74 04                	je     f0114acf <test_share_chunk+0x6b1>
f0114acb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114acf:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114ad3:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114ad7:	0f 84 92 00 00 00    	je     f0114b6f <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f0114add:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f0114ae4:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f0114aeb:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f0114af2:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f0114af9:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114afc:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f0114aff:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0114b06:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114b0d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114b10:	8a 00                	mov    (%eax),%al
f0114b12:	3c 41                	cmp    $0x41,%al
f0114b14:	75 2d                	jne    f0114b43 <test_share_chunk+0x725>
f0114b16:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114b19:	8a 00                	mov    (%eax),%al
f0114b1b:	3c 41                	cmp    $0x41,%al
f0114b1d:	75 24                	jne    f0114b43 <test_share_chunk+0x725>
f0114b1f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114b22:	8a 00                	mov    (%eax),%al
f0114b24:	3c 41                	cmp    $0x41,%al
f0114b26:	75 1b                	jne    f0114b43 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0114b28:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114b2b:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114b2d:	3c 44                	cmp    $0x44,%al
f0114b2f:	75 12                	jne    f0114b43 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0114b31:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114b34:	8a 00                	mov    (%eax),%al
f0114b36:	3c 44                	cmp    $0x44,%al
f0114b38:	75 09                	jne    f0114b43 <test_share_chunk+0x725>
f0114b3a:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114b3d:	8a 00                	mov    (%eax),%al
f0114b3f:	3c 44                	cmp    $0x44,%al
f0114b41:	74 1e                	je     f0114b61 <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114b43:	83 ec 04             	sub    $0x4,%esp
f0114b46:	68 88 41 13 f0       	push   $0xf0134188
f0114b4b:	68 14 05 00 00       	push   $0x514
f0114b50:	68 72 2a 13 f0       	push   $0xf0132a72
f0114b55:	e8 fa c4 fe ff       	call   f0101054 <_warn>
f0114b5a:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114b5d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114b61:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114b65:	74 04                	je     f0114b6b <test_share_chunk+0x74d>
f0114b67:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114b6b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0114b6f:	83 ec 0c             	sub    $0xc,%esp
f0114b72:	68 fa 37 13 f0       	push   $0xf01337fa
f0114b77:	e8 e0 cf fe ff       	call   f0101b5c <cprintf>
f0114b7c:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0114b7f:	83 ec 0c             	sub    $0xc,%esp
f0114b82:	68 94 42 13 f0       	push   $0xf0134294
f0114b87:	e8 d0 cf fe ff       	call   f0101b5c <cprintf>
f0114b8c:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114b8f:	e8 16 9d ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0114b94:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0114b97:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114b9a:	89 d0                	mov    %edx,%eax
f0114b9c:	01 c0                	add    %eax,%eax
f0114b9e:	01 d0                	add    %edx,%eax
f0114ba0:	01 c0                	add    %eax,%eax
f0114ba2:	01 d0                	add    %edx,%eax
f0114ba4:	83 ec 0c             	sub    $0xc,%esp
f0114ba7:	6a 04                	push   $0x4
f0114ba9:	50                   	push   %eax
f0114baa:	68 00 fc 3f 00       	push   $0x3ffc00
f0114baf:	68 00 fc 09 00       	push   $0x9fc00
f0114bb4:	ff 75 cc             	pushl  -0x34(%ebp)
f0114bb7:	e8 fa 5f ff ff       	call   f010abb6 <share_chunk>
f0114bbc:	83 c4 20             	add    $0x20,%esp
f0114bbf:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114bc2:	e8 e3 9c ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0114bc7:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114bca:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f0114bce:	75 0b                	jne    f0114bdb <test_share_chunk+0x7bd>
f0114bd0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114bd3:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114bd6:	83 f8 01             	cmp    $0x1,%eax
f0114bd9:	74 28                	je     f0114c03 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114bdb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114bde:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114be1:	83 ec 0c             	sub    $0xc,%esp
f0114be4:	50                   	push   %eax
f0114be5:	ff 75 8c             	pushl  -0x74(%ebp)
f0114be8:	68 08 42 13 f0       	push   $0xf0134208
f0114bed:	68 2a 05 00 00       	push   $0x52a
f0114bf2:	68 72 2a 13 f0       	push   $0xf0132a72
f0114bf7:	e8 58 c4 fe ff       	call   f0101054 <_warn>
f0114bfc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114bff:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114c03:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114c07:	74 04                	je     f0114c0d <test_share_chunk+0x7ef>
f0114c09:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114c0d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114c11:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114c18:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114c1b:	89 d0                	mov    %edx,%eax
f0114c1d:	01 c0                	add    %eax,%eax
f0114c1f:	01 d0                	add    %edx,%eax
f0114c21:	c1 e0 02             	shl    $0x2,%eax
f0114c24:	83 ec 08             	sub    $0x8,%esp
f0114c27:	6a 02                	push   $0x2
f0114c29:	6a 07                	push   $0x7
f0114c2b:	6a 07                	push   $0x7
f0114c2d:	6a 07                	push   $0x7
f0114c2f:	6a 05                	push   $0x5
f0114c31:	6a ff                	push   $0xffffffff
f0114c33:	50                   	push   %eax
f0114c34:	68 00 f0 3f 00       	push   $0x3ff000
f0114c39:	68 00 f0 09 00       	push   $0x9f000
f0114c3e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114c41:	e8 2e 23 00 00       	call   f0116f74 <CCP>
f0114c46:	83 c4 30             	add    $0x30,%esp
f0114c49:	85 c0                	test   %eax,%eax
f0114c4b:	75 25                	jne    f0114c72 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114c4d:	83 ec 04             	sub    $0x4,%esp
f0114c50:	68 40 41 13 f0       	push   $0xf0134140
f0114c55:	68 33 05 00 00       	push   $0x533
f0114c5a:	68 72 2a 13 f0       	push   $0xf0132a72
f0114c5f:	e8 f0 c3 fe ff       	call   f0101054 <_warn>
f0114c64:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114c67:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114c6b:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f0114c72:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114c76:	74 04                	je     f0114c7c <test_share_chunk+0x85e>
f0114c78:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114c7c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114c80:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114c83:	c1 e0 02             	shl    $0x2,%eax
f0114c86:	83 ec 08             	sub    $0x8,%esp
f0114c89:	6a 02                	push   $0x2
f0114c8b:	6a 07                	push   $0x7
f0114c8d:	6a 07                	push   $0x7
f0114c8f:	6a 07                	push   $0x7
f0114c91:	6a 05                	push   $0x5
f0114c93:	6a 03                	push   $0x3
f0114c95:	50                   	push   %eax
f0114c96:	68 00 f0 3f 00       	push   $0x3ff000
f0114c9b:	68 00 f0 09 00       	push   $0x9f000
f0114ca0:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ca3:	e8 cc 22 00 00       	call   f0116f74 <CCP>
f0114ca8:	83 c4 30             	add    $0x30,%esp
f0114cab:	85 c0                	test   %eax,%eax
f0114cad:	75 1e                	jne    f0114ccd <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114caf:	83 ec 04             	sub    $0x4,%esp
f0114cb2:	68 40 41 13 f0       	push   $0xf0134140
f0114cb7:	68 3c 05 00 00       	push   $0x53c
f0114cbc:	68 72 2a 13 f0       	push   $0xf0132a72
f0114cc1:	e8 8e c3 fe ff       	call   f0101054 <_warn>
f0114cc6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114cc9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114ccd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114cd1:	74 04                	je     f0114cd7 <test_share_chunk+0x8b9>
f0114cd3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114cd7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114cdb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114cde:	c1 e0 03             	shl    $0x3,%eax
f0114ce1:	83 ec 08             	sub    $0x8,%esp
f0114ce4:	6a 02                	push   $0x2
f0114ce6:	6a 07                	push   $0x7
f0114ce8:	6a 07                	push   $0x7
f0114cea:	6a 07                	push   $0x7
f0114cec:	6a 05                	push   $0x5
f0114cee:	6a 04                	push   $0x4
f0114cf0:	50                   	push   %eax
f0114cf1:	68 00 00 40 00       	push   $0x400000
f0114cf6:	68 00 00 0a 00       	push   $0xa0000
f0114cfb:	ff 75 cc             	pushl  -0x34(%ebp)
f0114cfe:	e8 71 22 00 00       	call   f0116f74 <CCP>
f0114d03:	83 c4 30             	add    $0x30,%esp
f0114d06:	85 c0                	test   %eax,%eax
f0114d08:	75 1e                	jne    f0114d28 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114d0a:	83 ec 04             	sub    $0x4,%esp
f0114d0d:	68 40 41 13 f0       	push   $0xf0134140
f0114d12:	68 44 05 00 00       	push   $0x544
f0114d17:	68 72 2a 13 f0       	push   $0xf0132a72
f0114d1c:	e8 33 c3 fe ff       	call   f0101054 <_warn>
f0114d21:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114d24:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114d28:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114d2c:	74 04                	je     f0114d32 <test_share_chunk+0x914>
f0114d2e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114d32:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114d36:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0114d3a:	0f 84 b2 00 00 00    	je     f0114df2 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f0114d40:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f0114d47:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f0114d4e:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f0114d55:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f0114d5c:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f0114d63:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f0114d6a:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f0114d71:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114d78:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114d7b:	8a 00                	mov    (%eax),%al
f0114d7d:	3c 44                	cmp    $0x44,%al
f0114d7f:	75 45                	jne    f0114dc6 <test_share_chunk+0x9a8>
f0114d81:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114d84:	8a 00                	mov    (%eax),%al
f0114d86:	3c 44                	cmp    $0x44,%al
f0114d88:	75 3c                	jne    f0114dc6 <test_share_chunk+0x9a8>
f0114d8a:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114d8d:	8a 00                	mov    (%eax),%al
f0114d8f:	3c 44                	cmp    $0x44,%al
f0114d91:	75 33                	jne    f0114dc6 <test_share_chunk+0x9a8>
f0114d93:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114d96:	8a 00                	mov    (%eax),%al
f0114d98:	3c 44                	cmp    $0x44,%al
f0114d9a:	75 2a                	jne    f0114dc6 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114d9c:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114d9f:	8a 10                	mov    (%eax),%dl
f0114da1:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114da4:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114da6:	38 c2                	cmp    %al,%dl
f0114da8:	75 1c                	jne    f0114dc6 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114daa:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114dad:	8a 10                	mov    (%eax),%dl
f0114daf:	8b 45 88             	mov    -0x78(%ebp),%eax
f0114db2:	8a 00                	mov    (%eax),%al
f0114db4:	38 c2                	cmp    %al,%dl
f0114db6:	75 0e                	jne    f0114dc6 <test_share_chunk+0x9a8>
f0114db8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114dbb:	8a 10                	mov    (%eax),%dl
f0114dbd:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0114dc0:	8a 00                	mov    (%eax),%al
f0114dc2:	38 c2                	cmp    %al,%dl
f0114dc4:	74 1e                	je     f0114de4 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114dc6:	83 ec 04             	sub    $0x4,%esp
f0114dc9:	68 88 41 13 f0       	push   $0xf0134188
f0114dce:	68 59 05 00 00       	push   $0x559
f0114dd3:	68 72 2a 13 f0       	push   $0xf0132a72
f0114dd8:	e8 77 c2 fe ff       	call   f0101054 <_warn>
f0114ddd:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114de0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114de4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114de8:	74 04                	je     f0114dee <test_share_chunk+0x9d0>
f0114dea:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114dee:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114df2:	83 ec 0c             	sub    $0xc,%esp
f0114df5:	68 cc 42 13 f0       	push   $0xf01342cc
f0114dfa:	e8 5d cd fe ff       	call   f0101b5c <cprintf>
f0114dff:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0114e02:	83 ec 08             	sub    $0x8,%esp
f0114e05:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114e08:	68 dc 42 13 f0       	push   $0xf01342dc
f0114e0d:	e8 4a cd fe ff       	call   f0101b5c <cprintf>
f0114e12:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114e15:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114e19:	75 10                	jne    f0114e2b <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f0114e1b:	83 ec 0c             	sub    $0xc,%esp
f0114e1e:	68 0c 43 13 f0       	push   $0xf013430c
f0114e23:	e8 34 cd fe ff       	call   f0101b5c <cprintf>
f0114e28:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114e2b:	a1 40 64 85 f0       	mov    0xf0856440,%eax
f0114e30:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114e33:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114e36:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114e39:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114e3e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114e41:	5b                   	pop    %ebx
f0114e42:	5e                   	pop    %esi
f0114e43:	5f                   	pop    %edi
f0114e44:	5d                   	pop    %ebp
f0114e45:	c3                   	ret    

f0114e46 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f0114e46:	55                   	push   %ebp
f0114e47:	89 e5                	mov    %esp,%ebp
f0114e49:	57                   	push   %edi
f0114e4a:	56                   	push   %esi
f0114e4b:	53                   	push   %ebx
f0114e4c:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114e52:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114e58:	bb 0c 35 13 f0       	mov    $0xf013350c,%ebx
f0114e5d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114e62:	89 c7                	mov    %eax,%edi
f0114e64:	89 de                	mov    %ebx,%esi
f0114e66:	89 d1                	mov    %edx,%ecx
f0114e68:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114e6a:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0114e70:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114e75:	b0 00                	mov    $0x0,%al
f0114e77:	89 d7                	mov    %edx,%edi
f0114e79:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114e7b:	6a 00                	push   $0x0
f0114e7d:	6a 0a                	push   $0xa
f0114e7f:	6a 14                	push   $0x14
f0114e81:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114e87:	50                   	push   %eax
f0114e88:	e8 d7 5f ff ff       	call   f010ae64 <env_create>
f0114e8d:	83 c4 10             	add    $0x10,%esp
f0114e90:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114e93:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114e96:	8b 40 64             	mov    0x64(%eax),%eax
f0114e99:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114e9c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114e9f:	8b 40 68             	mov    0x68(%eax),%eax
f0114ea2:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114ea5:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114ea8:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114eab:	83 ec 0c             	sub    $0xc,%esp
f0114eae:	ff 75 cc             	pushl  -0x34(%ebp)
f0114eb1:	e8 8a 20 00 00       	call   f0116f40 <ClearUserSpace>
f0114eb6:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114eb9:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114ec0:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114ec7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f0114ece:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0114ed2:	83 ec 0c             	sub    $0xc,%esp
f0114ed5:	68 48 43 13 f0       	push   $0xf0134348
f0114eda:	e8 7d cc fe ff       	call   f0101b5c <cprintf>
f0114edf:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0114ee2:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114ee9:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f0114ef0:	eb 03                	jmp    f0114ef5 <test_allocate_chunk+0xaf>
f0114ef2:	ff 4d e4             	decl   -0x1c(%ebp)
f0114ef5:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114efc:	76 09                	jbe    f0114f07 <test_allocate_chunk+0xc1>
f0114efe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114f01:	8a 00                	mov    (%eax),%al
f0114f03:	84 c0                	test   %al,%al
f0114f05:	74 eb                	je     f0114ef2 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114f07:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114f0e:	75 06                	jne    f0114f16 <test_allocate_chunk+0xd0>
f0114f10:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114f13:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0114f16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114f19:	8a 00                	mov    (%eax),%al
f0114f1b:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f0114f21:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114f24:	8a 00                	mov    (%eax),%al
f0114f26:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f0114f2c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114f2f:	8a 00                	mov    (%eax),%al
f0114f31:	0f be c0             	movsbl %al,%eax
f0114f34:	83 ec 08             	sub    $0x8,%esp
f0114f37:	50                   	push   %eax
f0114f38:	68 72 43 13 f0       	push   $0xf0134372
f0114f3d:	e8 1a cc fe ff       	call   f0101b5c <cprintf>
f0114f42:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0114f45:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114f48:	8a 00                	mov    (%eax),%al
f0114f4a:	0f be c0             	movsbl %al,%eax
f0114f4d:	83 ec 08             	sub    $0x8,%esp
f0114f50:	50                   	push   %eax
f0114f51:	68 7e 43 13 f0       	push   $0xf013437e
f0114f56:	e8 01 cc fe ff       	call   f0101b5c <cprintf>
f0114f5b:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0114f5e:	83 ec 08             	sub    $0x8,%esp
f0114f61:	68 00 f0 bf ef       	push   $0xefbff000
f0114f66:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f69:	e8 b3 1f 00 00       	call   f0116f21 <GP>
f0114f6e:	83 c4 10             	add    $0x10,%esp
f0114f71:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114f74:	e8 31 99 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0114f79:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0114f7c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114f7f:	c1 e0 02             	shl    $0x2,%eax
f0114f82:	6a 02                	push   $0x2
f0114f84:	50                   	push   %eax
f0114f85:	68 00 f0 bf ef       	push   $0xefbff000
f0114f8a:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f8d:	e8 3e 5c ff ff       	call   f010abd0 <allocate_chunk>
f0114f92:	83 c4 10             	add    $0x10,%esp
f0114f95:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114f98:	e8 0d 99 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0114f9d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114fa0:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114fa4:	75 08                	jne    f0114fae <test_allocate_chunk+0x168>
f0114fa6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114fa9:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114fac:	74 2a                	je     f0114fd8 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114fae:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114fb1:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114fb4:	83 ec 08             	sub    $0x8,%esp
f0114fb7:	6a 00                	push   $0x0
f0114fb9:	50                   	push   %eax
f0114fba:	ff 75 b0             	pushl  -0x50(%ebp)
f0114fbd:	68 8c 43 13 f0       	push   $0xf013438c
f0114fc2:	68 99 05 00 00       	push   $0x599
f0114fc7:	68 72 2a 13 f0       	push   $0xf0132a72
f0114fcc:	e8 83 c0 fe ff       	call   f0101054 <_warn>
f0114fd1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114fd4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114fd8:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114fdc:	74 04                	je     f0114fe2 <test_allocate_chunk+0x19c>
f0114fde:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114fe2:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114fe6:	e8 bf 98 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0114feb:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f0114fee:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114ff1:	01 c0                	add    %eax,%eax
f0114ff3:	89 c1                	mov    %eax,%ecx
f0114ff5:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114ff8:	89 d0                	mov    %edx,%eax
f0114ffa:	c1 e0 02             	shl    $0x2,%eax
f0114ffd:	01 d0                	add    %edx,%eax
f0114fff:	f7 d8                	neg    %eax
f0115001:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0115006:	6a 02                	push   $0x2
f0115008:	51                   	push   %ecx
f0115009:	50                   	push   %eax
f011500a:	ff 75 cc             	pushl  -0x34(%ebp)
f011500d:	e8 be 5b ff ff       	call   f010abd0 <allocate_chunk>
f0115012:	83 c4 10             	add    $0x10,%esp
f0115015:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115018:	e8 8d 98 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f011501d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0115020:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0115024:	75 08                	jne    f011502e <test_allocate_chunk+0x1e8>
f0115026:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115029:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011502c:	74 2a                	je     f0115058 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011502e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115031:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115034:	83 ec 08             	sub    $0x8,%esp
f0115037:	6a 00                	push   $0x0
f0115039:	50                   	push   %eax
f011503a:	ff 75 b0             	pushl  -0x50(%ebp)
f011503d:	68 8c 43 13 f0       	push   $0xf013438c
f0115042:	68 a7 05 00 00       	push   $0x5a7
f0115047:	68 72 2a 13 f0       	push   $0xf0132a72
f011504c:	e8 03 c0 fe ff       	call   f0101054 <_warn>
f0115051:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115054:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0115058:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011505c:	74 04                	je     f0115062 <test_allocate_chunk+0x21c>
f011505e:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115062:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0115066:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115069:	c1 e0 02             	shl    $0x2,%eax
f011506c:	83 ec 08             	sub    $0x8,%esp
f011506f:	6a 03                	push   $0x3
f0115071:	6a 00                	push   $0x0
f0115073:	6a 00                	push   $0x0
f0115075:	68 ff 0f 00 00       	push   $0xfff
f011507a:	ff 75 b8             	pushl  -0x48(%ebp)
f011507d:	6a 01                	push   $0x1
f011507f:	50                   	push   %eax
f0115080:	68 00 f0 bf ef       	push   $0xefbff000
f0115085:	6a 00                	push   $0x0
f0115087:	ff 75 cc             	pushl  -0x34(%ebp)
f011508a:	e8 e5 1e 00 00       	call   f0116f74 <CCP>
f011508f:	83 c4 30             	add    $0x30,%esp
f0115092:	85 c0                	test   %eax,%eax
f0115094:	75 1e                	jne    f01150b4 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0115096:	83 ec 04             	sub    $0x4,%esp
f0115099:	68 f4 43 13 f0       	push   $0xf01343f4
f011509e:	68 af 05 00 00       	push   $0x5af
f01150a3:	68 72 2a 13 f0       	push   $0xf0132a72
f01150a8:	e8 a7 bf fe ff       	call   f0101054 <_warn>
f01150ad:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01150b0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01150b4:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01150b8:	74 04                	je     f01150be <test_allocate_chunk+0x278>
f01150ba:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01150be:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f01150c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01150c5:	8a 10                	mov    (%eax),%dl
f01150c7:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f01150cd:	38 c2                	cmp    %al,%dl
f01150cf:	75 0f                	jne    f01150e0 <test_allocate_chunk+0x29a>
f01150d1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01150d4:	8a 10                	mov    (%eax),%dl
f01150d6:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f01150dc:	38 c2                	cmp    %al,%dl
f01150de:	74 1e                	je     f01150fe <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01150e0:	83 ec 04             	sub    $0x4,%esp
f01150e3:	68 40 44 13 f0       	push   $0xf0134440
f01150e8:	68 b7 05 00 00       	push   $0x5b7
f01150ed:	68 72 2a 13 f0       	push   $0xf0132a72
f01150f2:	e8 5d bf fe ff       	call   f0101054 <_warn>
f01150f7:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01150fa:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01150fe:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115102:	74 04                	je     f0115108 <test_allocate_chunk+0x2c2>
f0115104:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115108:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011510c:	83 ec 0c             	sub    $0xc,%esp
f011510f:	68 bd 41 13 f0       	push   $0xf01341bd
f0115114:	e8 43 ca fe ff       	call   f0101b5c <cprintf>
f0115119:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f011511c:	83 ec 0c             	sub    $0xc,%esp
f011511f:	68 78 44 13 f0       	push   $0xf0134478
f0115124:	e8 33 ca fe ff       	call   f0101b5c <cprintf>
f0115129:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011512c:	e8 79 97 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0115131:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0115134:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115137:	c1 e0 05             	shl    $0x5,%eax
f011513a:	68 02 0e 00 00       	push   $0xe02
f011513f:	50                   	push   %eax
f0115140:	6a 00                	push   $0x0
f0115142:	ff 75 cc             	pushl  -0x34(%ebp)
f0115145:	e8 86 5a ff ff       	call   f010abd0 <allocate_chunk>
f011514a:	83 c4 10             	add    $0x10,%esp
f011514d:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115150:	e8 55 97 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0115155:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0115158:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f011515c:	75 36                	jne    f0115194 <test_allocate_chunk+0x34e>
f011515e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115161:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115164:	89 c1                	mov    %eax,%ecx
f0115166:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115169:	c1 e0 05             	shl    $0x5,%eax
f011516c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011516f:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115176:	99                   	cltd   
f0115177:	f7 fe                	idiv   %esi
f0115179:	89 c3                	mov    %eax,%ebx
f011517b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011517e:	c1 e0 05             	shl    $0x5,%eax
f0115181:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115184:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011518b:	99                   	cltd   
f011518c:	f7 fe                	idiv   %esi
f011518e:	01 d8                	add    %ebx,%eax
f0115190:	39 c1                	cmp    %eax,%ecx
f0115192:	74 54                	je     f01151e8 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0115194:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115197:	c1 e0 05             	shl    $0x5,%eax
f011519a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011519d:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01151a4:	99                   	cltd   
f01151a5:	f7 ff                	idiv   %edi
f01151a7:	89 c1                	mov    %eax,%ecx
f01151a9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01151ac:	c1 e0 05             	shl    $0x5,%eax
f01151af:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01151b2:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01151b9:	99                   	cltd   
f01151ba:	f7 fe                	idiv   %esi
f01151bc:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01151bf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01151c2:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01151c5:	83 ec 08             	sub    $0x8,%esp
f01151c8:	52                   	push   %edx
f01151c9:	50                   	push   %eax
f01151ca:	ff 75 a8             	pushl  -0x58(%ebp)
f01151cd:	68 b8 44 13 f0       	push   $0xf01344b8
f01151d2:	68 cc 05 00 00       	push   $0x5cc
f01151d7:	68 72 2a 13 f0       	push   $0xf0132a72
f01151dc:	e8 73 be fe ff       	call   f0101054 <_warn>
f01151e1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01151e4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01151e8:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01151ec:	74 04                	je     f01151f2 <test_allocate_chunk+0x3ac>
f01151ee:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01151f2:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01151f6:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01151fd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115200:	c1 e0 05             	shl    $0x5,%eax
f0115203:	83 ec 08             	sub    $0x8,%esp
f0115206:	6a 03                	push   $0x3
f0115208:	6a 00                	push   $0x0
f011520a:	6a 00                	push   $0x0
f011520c:	68 07 0e 00 00       	push   $0xe07
f0115211:	68 03 0e 00 00       	push   $0xe03
f0115216:	6a 01                	push   $0x1
f0115218:	50                   	push   %eax
f0115219:	6a 00                	push   $0x0
f011521b:	6a 00                	push   $0x0
f011521d:	ff 75 cc             	pushl  -0x34(%ebp)
f0115220:	e8 4f 1d 00 00       	call   f0116f74 <CCP>
f0115225:	83 c4 30             	add    $0x30,%esp
f0115228:	85 c0                	test   %eax,%eax
f011522a:	75 25                	jne    f0115251 <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011522c:	83 ec 04             	sub    $0x4,%esp
f011522f:	68 f4 43 13 f0       	push   $0xf01343f4
f0115234:	68 d5 05 00 00       	push   $0x5d5
f0115239:	68 72 2a 13 f0       	push   $0xf0132a72
f011523e:	e8 11 be fe ff       	call   f0101054 <_warn>
f0115243:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115246:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f011524a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0115251:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115255:	74 04                	je     f011525b <test_allocate_chunk+0x415>
f0115257:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f011525b:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f011525f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0115263:	74 5a                	je     f01152bf <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0115265:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115268:	01 c0                	add    %eax,%eax
f011526a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011526d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115270:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0115273:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115276:	01 c0                	add    %eax,%eax
f0115278:	89 45 bc             	mov    %eax,-0x44(%ebp)
f011527b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011527e:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0115281:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115284:	8a 00                	mov    (%eax),%al
f0115286:	3c 4b                	cmp    $0x4b,%al
f0115288:	75 09                	jne    f0115293 <test_allocate_chunk+0x44d>
f011528a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011528d:	8a 00                	mov    (%eax),%al
f011528f:	3c 4d                	cmp    $0x4d,%al
f0115291:	74 1e                	je     f01152b1 <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0115293:	83 ec 04             	sub    $0x4,%esp
f0115296:	68 40 44 13 f0       	push   $0xf0134440
f011529b:	68 e3 05 00 00       	push   $0x5e3
f01152a0:	68 72 2a 13 f0       	push   $0xf0132a72
f01152a5:	e8 aa bd fe ff       	call   f0101054 <_warn>
f01152aa:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01152ad:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f01152b1:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01152b5:	74 04                	je     f01152bb <test_allocate_chunk+0x475>
f01152b7:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f01152bb:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01152bf:	83 ec 0c             	sub    $0xc,%esp
f01152c2:	68 97 37 13 f0       	push   $0xf0133797
f01152c7:	e8 90 c8 fe ff       	call   f0101b5c <cprintf>
f01152cc:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f01152cf:	83 ec 0c             	sub    $0xc,%esp
f01152d2:	68 18 45 13 f0       	push   $0xf0134518
f01152d7:	e8 80 c8 fe ff       	call   f0101b5c <cprintf>
f01152dc:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01152df:	e8 c6 95 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f01152e4:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f01152e7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01152ea:	c1 e0 06             	shl    $0x6,%eax
f01152ed:	89 c2                	mov    %eax,%edx
f01152ef:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01152f2:	c1 e0 05             	shl    $0x5,%eax
f01152f5:	6a 00                	push   $0x0
f01152f7:	52                   	push   %edx
f01152f8:	50                   	push   %eax
f01152f9:	ff 75 cc             	pushl  -0x34(%ebp)
f01152fc:	e8 cf 58 ff ff       	call   f010abd0 <allocate_chunk>
f0115301:	83 c4 10             	add    $0x10,%esp
f0115304:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115307:	e8 9e 95 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f011530c:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f011530f:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0115313:	75 36                	jne    f011534b <test_allocate_chunk+0x505>
f0115315:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115318:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011531b:	89 c1                	mov    %eax,%ecx
f011531d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115320:	c1 e0 06             	shl    $0x6,%eax
f0115323:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115326:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f011532d:	99                   	cltd   
f011532e:	f7 ff                	idiv   %edi
f0115330:	89 c3                	mov    %eax,%ebx
f0115332:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115335:	c1 e0 06             	shl    $0x6,%eax
f0115338:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011533b:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115342:	99                   	cltd   
f0115343:	f7 fe                	idiv   %esi
f0115345:	01 d8                	add    %ebx,%eax
f0115347:	39 c1                	cmp    %eax,%ecx
f0115349:	74 54                	je     f011539f <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f011534b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011534e:	c1 e0 06             	shl    $0x6,%eax
f0115351:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115354:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011535b:	99                   	cltd   
f011535c:	f7 fb                	idiv   %ebx
f011535e:	89 c1                	mov    %eax,%ecx
f0115360:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115363:	c1 e0 06             	shl    $0x6,%eax
f0115366:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115369:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0115370:	99                   	cltd   
f0115371:	f7 ff                	idiv   %edi
f0115373:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0115376:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115379:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011537c:	83 ec 08             	sub    $0x8,%esp
f011537f:	52                   	push   %edx
f0115380:	50                   	push   %eax
f0115381:	ff 75 a4             	pushl  -0x5c(%ebp)
f0115384:	68 b8 44 13 f0       	push   $0xf01344b8
f0115389:	68 f9 05 00 00       	push   $0x5f9
f011538e:	68 72 2a 13 f0       	push   $0xf0132a72
f0115393:	e8 bc bc fe ff       	call   f0101054 <_warn>
f0115398:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011539b:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f011539f:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01153a3:	74 04                	je     f01153a9 <test_allocate_chunk+0x563>
f01153a5:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01153a9:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01153ad:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01153b4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01153b7:	c1 e0 06             	shl    $0x6,%eax
f01153ba:	89 c2                	mov    %eax,%edx
f01153bc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01153bf:	c1 e0 05             	shl    $0x5,%eax
f01153c2:	83 ec 08             	sub    $0x8,%esp
f01153c5:	6a 03                	push   $0x3
f01153c7:	6a 00                	push   $0x0
f01153c9:	6a 00                	push   $0x0
f01153cb:	68 07 0e 00 00       	push   $0xe07
f01153d0:	6a 01                	push   $0x1
f01153d2:	6a 01                	push   $0x1
f01153d4:	52                   	push   %edx
f01153d5:	50                   	push   %eax
f01153d6:	6a 00                	push   $0x0
f01153d8:	ff 75 cc             	pushl  -0x34(%ebp)
f01153db:	e8 94 1b 00 00       	call   f0116f74 <CCP>
f01153e0:	83 c4 30             	add    $0x30,%esp
f01153e3:	85 c0                	test   %eax,%eax
f01153e5:	75 25                	jne    f011540c <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01153e7:	83 ec 04             	sub    $0x4,%esp
f01153ea:	68 f4 43 13 f0       	push   $0xf01343f4
f01153ef:	68 02 06 00 00       	push   $0x602
f01153f4:	68 72 2a 13 f0       	push   $0xf0132a72
f01153f9:	e8 56 bc fe ff       	call   f0101054 <_warn>
f01153fe:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115401:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115405:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f011540c:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115410:	74 04                	je     f0115416 <test_allocate_chunk+0x5d0>
f0115412:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115416:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f011541a:	83 ec 0c             	sub    $0xc,%esp
f011541d:	68 fa 37 13 f0       	push   $0xf01337fa
f0115422:	e8 35 c7 fe ff       	call   f0101b5c <cprintf>
f0115427:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f011542a:	83 ec 0c             	sub    $0xc,%esp
f011542d:	68 58 45 13 f0       	push   $0xf0134558
f0115432:	e8 25 c7 fe ff       	call   f0101b5c <cprintf>
f0115437:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011543a:	e8 6b 94 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f011543f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0115442:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115445:	c1 e0 06             	shl    $0x6,%eax
f0115448:	68 06 0e 00 00       	push   $0xe06
f011544d:	50                   	push   %eax
f011544e:	68 00 00 00 80       	push   $0x80000000
f0115453:	ff 75 cc             	pushl  -0x34(%ebp)
f0115456:	e8 75 57 ff ff       	call   f010abd0 <allocate_chunk>
f011545b:	83 c4 10             	add    $0x10,%esp
f011545e:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115461:	e8 44 94 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0115466:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0115469:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f011546d:	75 36                	jne    f01154a5 <test_allocate_chunk+0x65f>
f011546f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115472:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115475:	89 c1                	mov    %eax,%ecx
f0115477:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011547a:	c1 e0 06             	shl    $0x6,%eax
f011547d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115480:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115487:	99                   	cltd   
f0115488:	f7 fb                	idiv   %ebx
f011548a:	89 c3                	mov    %eax,%ebx
f011548c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011548f:	c1 e0 06             	shl    $0x6,%eax
f0115492:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115495:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011549c:	99                   	cltd   
f011549d:	f7 fe                	idiv   %esi
f011549f:	01 d8                	add    %ebx,%eax
f01154a1:	39 c1                	cmp    %eax,%ecx
f01154a3:	74 54                	je     f01154f9 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f01154a5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01154a8:	c1 e0 06             	shl    $0x6,%eax
f01154ab:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01154ae:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01154b5:	99                   	cltd   
f01154b6:	f7 ff                	idiv   %edi
f01154b8:	89 c1                	mov    %eax,%ecx
f01154ba:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01154bd:	c1 e0 06             	shl    $0x6,%eax
f01154c0:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01154c3:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01154ca:	99                   	cltd   
f01154cb:	f7 fb                	idiv   %ebx
f01154cd:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01154d0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01154d3:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01154d6:	83 ec 08             	sub    $0x8,%esp
f01154d9:	52                   	push   %edx
f01154da:	50                   	push   %eax
f01154db:	ff 75 9c             	pushl  -0x64(%ebp)
f01154de:	68 b8 44 13 f0       	push   $0xf01344b8
f01154e3:	68 18 06 00 00       	push   $0x618
f01154e8:	68 72 2a 13 f0       	push   $0xf0132a72
f01154ed:	e8 62 bb fe ff       	call   f0101054 <_warn>
f01154f2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01154f5:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01154f9:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01154fd:	74 04                	je     f0115503 <test_allocate_chunk+0x6bd>
f01154ff:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0115503:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115507:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011550e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115511:	c1 e0 06             	shl    $0x6,%eax
f0115514:	83 ec 08             	sub    $0x8,%esp
f0115517:	6a 03                	push   $0x3
f0115519:	6a 00                	push   $0x0
f011551b:	6a 00                	push   $0x0
f011551d:	68 07 0e 00 00       	push   $0xe07
f0115522:	68 07 0e 00 00       	push   $0xe07
f0115527:	6a 01                	push   $0x1
f0115529:	50                   	push   %eax
f011552a:	68 00 00 00 80       	push   $0x80000000
f011552f:	6a 00                	push   $0x0
f0115531:	ff 75 cc             	pushl  -0x34(%ebp)
f0115534:	e8 3b 1a 00 00       	call   f0116f74 <CCP>
f0115539:	83 c4 30             	add    $0x30,%esp
f011553c:	85 c0                	test   %eax,%eax
f011553e:	75 25                	jne    f0115565 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0115540:	83 ec 04             	sub    $0x4,%esp
f0115543:	68 f4 43 13 f0       	push   $0xf01343f4
f0115548:	68 21 06 00 00       	push   $0x621
f011554d:	68 72 2a 13 f0       	push   $0xf0132a72
f0115552:	e8 fd ba fe ff       	call   f0101054 <_warn>
f0115557:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011555a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f011555e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0115565:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115569:	74 04                	je     f011556f <test_allocate_chunk+0x729>
f011556b:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f011556f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0115573:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0115577:	74 6f                	je     f01155e8 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0115579:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011557c:	01 c0                	add    %eax,%eax
f011557e:	05 00 00 00 80       	add    $0x80000000,%eax
f0115583:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0115586:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115589:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f011558c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011558f:	89 d0                	mov    %edx,%eax
f0115591:	c1 e0 02             	shl    $0x2,%eax
f0115594:	01 d0                	add    %edx,%eax
f0115596:	01 c0                	add    %eax,%eax
f0115598:	01 d0                	add    %edx,%eax
f011559a:	01 c0                	add    %eax,%eax
f011559c:	05 00 00 00 80       	add    $0x80000000,%eax
f01155a1:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01155a4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01155a7:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f01155aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01155ad:	8a 00                	mov    (%eax),%al
f01155af:	3c 4b                	cmp    $0x4b,%al
f01155b1:	75 09                	jne    f01155bc <test_allocate_chunk+0x776>
f01155b3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01155b6:	8a 00                	mov    (%eax),%al
f01155b8:	3c 4d                	cmp    $0x4d,%al
f01155ba:	74 1e                	je     f01155da <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01155bc:	83 ec 04             	sub    $0x4,%esp
f01155bf:	68 40 44 13 f0       	push   $0xf0134440
f01155c4:	68 2f 06 00 00       	push   $0x62f
f01155c9:	68 72 2a 13 f0       	push   $0xf0132a72
f01155ce:	e8 81 ba fe ff       	call   f0101054 <_warn>
f01155d3:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01155d6:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f01155da:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01155de:	74 04                	je     f01155e4 <test_allocate_chunk+0x79e>
f01155e0:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f01155e4:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f01155e8:	83 ec 0c             	sub    $0xc,%esp
f01155eb:	68 cc 42 13 f0       	push   $0xf01342cc
f01155f0:	e8 67 c5 fe ff       	call   f0101b5c <cprintf>
f01155f5:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f01155f8:	83 ec 0c             	sub    $0xc,%esp
f01155fb:	68 94 45 13 f0       	push   $0xf0134594
f0115600:	e8 57 c5 fe ff       	call   f0101b5c <cprintf>
f0115605:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115608:	e8 9d 92 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f011560d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0115610:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115613:	89 d0                	mov    %edx,%eax
f0115615:	01 c0                	add    %eax,%eax
f0115617:	01 d0                	add    %edx,%eax
f0115619:	01 c0                	add    %eax,%eax
f011561b:	01 d0                	add    %edx,%eax
f011561d:	68 04 0e 00 00       	push   $0xe04
f0115622:	50                   	push   %eax
f0115623:	68 00 fc 3f 40       	push   $0x403ffc00
f0115628:	ff 75 cc             	pushl  -0x34(%ebp)
f011562b:	e8 a0 55 ff ff       	call   f010abd0 <allocate_chunk>
f0115630:	83 c4 10             	add    $0x10,%esp
f0115633:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115636:	e8 6f 92 ff ff       	call   f010e8aa <sys_calculate_free_frames>
f011563b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f011563e:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0115642:	75 0b                	jne    f011564f <test_allocate_chunk+0x809>
f0115644:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115647:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011564a:	83 f8 05             	cmp    $0x5,%eax
f011564d:	74 2a                	je     f0115679 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f011564f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115652:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115655:	83 ec 08             	sub    $0x8,%esp
f0115658:	6a 05                	push   $0x5
f011565a:	50                   	push   %eax
f011565b:	ff 75 98             	pushl  -0x68(%ebp)
f011565e:	68 b8 44 13 f0       	push   $0xf01344b8
f0115663:	68 46 06 00 00       	push   $0x646
f0115668:	68 72 2a 13 f0       	push   $0xf0132a72
f011566d:	e8 e2 b9 fe ff       	call   f0101054 <_warn>
f0115672:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115675:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0115679:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011567d:	74 04                	je     f0115683 <test_allocate_chunk+0x83d>
f011567f:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115683:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115687:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011568e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115691:	89 d0                	mov    %edx,%eax
f0115693:	01 c0                	add    %eax,%eax
f0115695:	01 d0                	add    %edx,%eax
f0115697:	c1 e0 02             	shl    $0x2,%eax
f011569a:	83 ec 08             	sub    $0x8,%esp
f011569d:	6a 03                	push   $0x3
f011569f:	6a 00                	push   $0x0
f01156a1:	6a 00                	push   $0x0
f01156a3:	68 07 0e 00 00       	push   $0xe07
f01156a8:	68 05 0e 00 00       	push   $0xe05
f01156ad:	6a 01                	push   $0x1
f01156af:	50                   	push   %eax
f01156b0:	68 00 f0 3f 40       	push   $0x403ff000
f01156b5:	6a 00                	push   $0x0
f01156b7:	ff 75 cc             	pushl  -0x34(%ebp)
f01156ba:	e8 b5 18 00 00       	call   f0116f74 <CCP>
f01156bf:	83 c4 30             	add    $0x30,%esp
f01156c2:	85 c0                	test   %eax,%eax
f01156c4:	75 25                	jne    f01156eb <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01156c6:	83 ec 04             	sub    $0x4,%esp
f01156c9:	68 f4 43 13 f0       	push   $0xf01343f4
f01156ce:	68 4f 06 00 00       	push   $0x64f
f01156d3:	68 72 2a 13 f0       	push   $0xf0132a72
f01156d8:	e8 77 b9 fe ff       	call   f0101054 <_warn>
f01156dd:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01156e0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01156e4:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f01156eb:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01156ef:	74 04                	je     f01156f5 <test_allocate_chunk+0x8af>
f01156f1:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01156f5:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f01156f9:	83 ec 0c             	sub    $0xc,%esp
f01156fc:	68 cb 45 13 f0       	push   $0xf01345cb
f0115701:	e8 56 c4 fe ff       	call   f0101b5c <cprintf>
f0115706:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0115709:	83 ec 08             	sub    $0x8,%esp
f011570c:	ff 75 e0             	pushl  -0x20(%ebp)
f011570f:	68 dc 45 13 f0       	push   $0xf01345dc
f0115714:	e8 43 c4 fe ff       	call   f0101b5c <cprintf>
f0115719:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011571c:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0115720:	75 10                	jne    f0115732 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0115722:	83 ec 0c             	sub    $0xc,%esp
f0115725:	68 10 46 13 f0       	push   $0xf0134610
f011572a:	e8 2d c4 fe ff       	call   f0101b5c <cprintf>
f011572f:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115732:	a1 40 64 85 f0       	mov    0xf0856440,%eax
f0115737:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011573a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011573d:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115740:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115745:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115748:	5b                   	pop    %ebx
f0115749:	5e                   	pop    %esi
f011574a:	5f                   	pop    %edi
f011574b:	5d                   	pop    %ebp
f011574c:	c3                   	ret    

f011574d <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f011574d:	55                   	push   %ebp
f011574e:	89 e5                	mov    %esp,%ebp
f0115750:	57                   	push   %edi
f0115751:	56                   	push   %esi
f0115752:	53                   	push   %ebx
f0115753:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115759:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011575c:	bb 0c 35 13 f0       	mov    $0xf013350c,%ebx
f0115761:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115766:	89 c7                	mov    %eax,%edi
f0115768:	89 de                	mov    %ebx,%esi
f011576a:	89 d1                	mov    %edx,%ecx
f011576c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011576e:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115771:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115776:	b0 00                	mov    $0x0,%al
f0115778:	89 d7                	mov    %edx,%edi
f011577a:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011577c:	6a 00                	push   $0x0
f011577e:	6a 0a                	push   $0xa
f0115780:	6a 14                	push   $0x14
f0115782:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115785:	50                   	push   %eax
f0115786:	e8 d9 56 ff ff       	call   f010ae64 <env_create>
f011578b:	83 c4 10             	add    $0x10,%esp
f011578e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115791:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115794:	8b 40 64             	mov    0x64(%eax),%eax
f0115797:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011579a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011579d:	8b 40 68             	mov    0x68(%eax),%eax
f01157a0:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01157a3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01157a6:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01157a9:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f01157b0:	75 70 20 
f01157b3:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f01157ba:	00 00 00 
f01157bd:	8d 55 82             	lea    -0x7e(%ebp),%edx
f01157c0:	b9 03 00 00 00       	mov    $0x3,%ecx
f01157c5:	b8 00 00 00 00       	mov    $0x0,%eax
f01157ca:	89 d7                	mov    %edx,%edi
f01157cc:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01157ce:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01157d1:	8b 40 10             	mov    0x10(%eax),%eax
f01157d4:	83 ec 08             	sub    $0x8,%esp
f01157d7:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01157dd:	52                   	push   %edx
f01157de:	50                   	push   %eax
f01157df:	e8 ee 57 00 00       	call   f011afd2 <ltostr>
f01157e4:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01157e7:	83 ec 04             	sub    $0x4,%esp
f01157ea:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01157f0:	50                   	push   %eax
f01157f1:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01157f7:	50                   	push   %eax
f01157f8:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01157fe:	50                   	push   %eax
f01157ff:	e8 a7 58 00 00       	call   f011b0ab <strcconcat>
f0115804:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115807:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f011580e:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115815:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f011581c:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0115823:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0115827:	83 ec 0c             	sub    $0xc,%esp
f011582a:	ff 75 d8             	pushl  -0x28(%ebp)
f011582d:	e8 0e 17 00 00       	call   f0116f40 <ClearUserSpace>
f0115832:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115835:	83 ec 0c             	sub    $0xc,%esp
f0115838:	68 50 46 13 f0       	push   $0xf0134650
f011583d:	e8 1a c3 fe ff       	call   f0101b5c <cprintf>
f0115842:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115845:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115848:	c1 e0 03             	shl    $0x3,%eax
f011584b:	83 ec 04             	sub    $0x4,%esp
f011584e:	50                   	push   %eax
f011584f:	6a 00                	push   $0x0
f0115851:	ff 75 d8             	pushl  -0x28(%ebp)
f0115854:	e8 c5 53 ff ff       	call   f010ac1e <calculate_required_frames>
f0115859:	83 c4 10             	add    $0x10,%esp
f011585c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f011585f:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115863:	74 23                	je     f0115888 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115865:	83 ec 0c             	sub    $0xc,%esp
f0115868:	6a 03                	push   $0x3
f011586a:	ff 75 c8             	pushl  -0x38(%ebp)
f011586d:	68 84 46 13 f0       	push   $0xf0134684
f0115872:	68 88 06 00 00       	push   $0x688
f0115877:	68 72 2a 13 f0       	push   $0xf0132a72
f011587c:	e8 d3 b7 fe ff       	call   f0101054 <_warn>
f0115881:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115884:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115888:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011588c:	74 04                	je     f0115892 <test_calculate_required_frames+0x145>
f011588e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115892:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0115896:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115899:	c1 e0 02             	shl    $0x2,%eax
f011589c:	83 ec 04             	sub    $0x4,%esp
f011589f:	50                   	push   %eax
f01158a0:	6a 00                	push   $0x0
f01158a2:	ff 75 d8             	pushl  -0x28(%ebp)
f01158a5:	e8 74 53 ff ff       	call   f010ac1e <calculate_required_frames>
f01158aa:	83 c4 10             	add    $0x10,%esp
f01158ad:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f01158b0:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f01158b7:	74 26                	je     f01158df <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f01158b9:	83 ec 0c             	sub    $0xc,%esp
f01158bc:	68 01 04 00 00       	push   $0x401
f01158c1:	ff 75 c8             	pushl  -0x38(%ebp)
f01158c4:	68 84 46 13 f0       	push   $0xf0134684
f01158c9:	68 92 06 00 00       	push   $0x692
f01158ce:	68 72 2a 13 f0       	push   $0xf0132a72
f01158d3:	e8 7c b7 fe ff       	call   f0101054 <_warn>
f01158d8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01158db:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01158df:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01158e3:	74 04                	je     f01158e9 <test_calculate_required_frames+0x19c>
f01158e5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01158e9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01158ed:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01158f0:	c1 e0 0a             	shl    $0xa,%eax
f01158f3:	83 ec 04             	sub    $0x4,%esp
f01158f6:	50                   	push   %eax
f01158f7:	6a 00                	push   $0x0
f01158f9:	ff 75 d8             	pushl  -0x28(%ebp)
f01158fc:	e8 1d 53 ff ff       	call   f010ac1e <calculate_required_frames>
f0115901:	83 c4 10             	add    $0x10,%esp
f0115904:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0115907:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011590a:	c1 e0 0a             	shl    $0xa,%eax
f011590d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115910:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115917:	99                   	cltd   
f0115918:	f7 fb                	idiv   %ebx
f011591a:	89 c1                	mov    %eax,%ecx
f011591c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011591f:	c1 e0 0a             	shl    $0xa,%eax
f0115922:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115925:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011592c:	99                   	cltd   
f011592d:	f7 fe                	idiv   %esi
f011592f:	01 c8                	add    %ecx,%eax
f0115931:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115934:	74 4c                	je     f0115982 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0115936:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115939:	c1 e0 0a             	shl    $0xa,%eax
f011593c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011593f:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115946:	99                   	cltd   
f0115947:	f7 fb                	idiv   %ebx
f0115949:	89 c1                	mov    %eax,%ecx
f011594b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011594e:	c1 e0 0a             	shl    $0xa,%eax
f0115951:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115954:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011595b:	99                   	cltd   
f011595c:	f7 fe                	idiv   %esi
f011595e:	01 c8                	add    %ecx,%eax
f0115960:	83 ec 0c             	sub    $0xc,%esp
f0115963:	50                   	push   %eax
f0115964:	ff 75 c8             	pushl  -0x38(%ebp)
f0115967:	68 84 46 13 f0       	push   $0xf0134684
f011596c:	68 9c 06 00 00       	push   $0x69c
f0115971:	68 72 2a 13 f0       	push   $0xf0132a72
f0115976:	e8 d9 b6 fe ff       	call   f0101054 <_warn>
f011597b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011597e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115982:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115986:	74 04                	je     f011598c <test_calculate_required_frames+0x23f>
f0115988:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011598c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0115990:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115993:	89 d0                	mov    %edx,%eax
f0115995:	01 c0                	add    %eax,%eax
f0115997:	01 d0                	add    %edx,%eax
f0115999:	01 c0                	add    %eax,%eax
f011599b:	83 ec 04             	sub    $0x4,%esp
f011599e:	50                   	push   %eax
f011599f:	68 00 10 00 00       	push   $0x1000
f01159a4:	ff 75 d8             	pushl  -0x28(%ebp)
f01159a7:	e8 72 52 ff ff       	call   f010ac1e <calculate_required_frames>
f01159ac:	83 c4 10             	add    $0x10,%esp
f01159af:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01159b2:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01159b6:	74 23                	je     f01159db <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01159b8:	83 ec 0c             	sub    $0xc,%esp
f01159bb:	6a 03                	push   $0x3
f01159bd:	ff 75 c8             	pushl  -0x38(%ebp)
f01159c0:	68 84 46 13 f0       	push   $0xf0134684
f01159c5:	68 a8 06 00 00       	push   $0x6a8
f01159ca:	68 72 2a 13 f0       	push   $0xf0132a72
f01159cf:	e8 80 b6 fe ff       	call   f0101054 <_warn>
f01159d4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159d7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01159db:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159df:	74 04                	je     f01159e5 <test_calculate_required_frames+0x298>
f01159e1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01159e5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01159e9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01159ec:	89 c2                	mov    %eax,%edx
f01159ee:	01 d2                	add    %edx,%edx
f01159f0:	01 d0                	add    %edx,%eax
f01159f2:	83 ec 04             	sub    $0x4,%esp
f01159f5:	50                   	push   %eax
f01159f6:	68 00 18 00 00       	push   $0x1800
f01159fb:	ff 75 d8             	pushl  -0x28(%ebp)
f01159fe:	e8 1b 52 ff ff       	call   f010ac1e <calculate_required_frames>
f0115a03:	83 c4 10             	add    $0x10,%esp
f0115a06:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115a09:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115a0d:	74 23                	je     f0115a32 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115a0f:	83 ec 0c             	sub    $0xc,%esp
f0115a12:	6a 03                	push   $0x3
f0115a14:	ff 75 c8             	pushl  -0x38(%ebp)
f0115a17:	68 84 46 13 f0       	push   $0xf0134684
f0115a1c:	68 b2 06 00 00       	push   $0x6b2
f0115a21:	68 72 2a 13 f0       	push   $0xf0132a72
f0115a26:	e8 29 b6 fe ff       	call   f0101054 <_warn>
f0115a2b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a2e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115a32:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a36:	74 04                	je     f0115a3c <test_calculate_required_frames+0x2ef>
f0115a38:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115a3c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115a40:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115a43:	89 d0                	mov    %edx,%eax
f0115a45:	c1 e0 02             	shl    $0x2,%eax
f0115a48:	01 d0                	add    %edx,%eax
f0115a4a:	01 c0                	add    %eax,%eax
f0115a4c:	83 ec 04             	sub    $0x4,%esp
f0115a4f:	50                   	push   %eax
f0115a50:	68 00 00 40 00       	push   $0x400000
f0115a55:	ff 75 d8             	pushl  -0x28(%ebp)
f0115a58:	e8 c1 51 ff ff       	call   f010ac1e <calculate_required_frames>
f0115a5d:	83 c4 10             	add    $0x10,%esp
f0115a60:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f0115a63:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0115a6a:	74 26                	je     f0115a92 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115a6c:	83 ec 0c             	sub    $0xc,%esp
f0115a6f:	68 03 0a 00 00       	push   $0xa03
f0115a74:	ff 75 c8             	pushl  -0x38(%ebp)
f0115a77:	68 84 46 13 f0       	push   $0xf0134684
f0115a7c:	68 bc 06 00 00       	push   $0x6bc
f0115a81:	68 72 2a 13 f0       	push   $0xf0132a72
f0115a86:	e8 c9 b5 fe ff       	call   f0101054 <_warn>
f0115a8b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a8e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115a92:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a96:	74 04                	je     f0115a9c <test_calculate_required_frames+0x34f>
f0115a98:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115a9c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115aa0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115aa3:	01 c0                	add    %eax,%eax
f0115aa5:	83 ec 04             	sub    $0x4,%esp
f0115aa8:	50                   	push   %eax
f0115aa9:	68 00 00 70 00       	push   $0x700000
f0115aae:	ff 75 d8             	pushl  -0x28(%ebp)
f0115ab1:	e8 68 51 ff ff       	call   f010ac1e <calculate_required_frames>
f0115ab6:	83 c4 10             	add    $0x10,%esp
f0115ab9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0115abc:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0115ac3:	74 26                	je     f0115aeb <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0115ac5:	83 ec 0c             	sub    $0xc,%esp
f0115ac8:	68 02 02 00 00       	push   $0x202
f0115acd:	ff 75 c8             	pushl  -0x38(%ebp)
f0115ad0:	68 84 46 13 f0       	push   $0xf0134684
f0115ad5:	68 c8 06 00 00       	push   $0x6c8
f0115ada:	68 72 2a 13 f0       	push   $0xf0132a72
f0115adf:	e8 70 b5 fe ff       	call   f0101054 <_warn>
f0115ae4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ae7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115aeb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115aef:	74 04                	je     f0115af5 <test_calculate_required_frames+0x3a8>
f0115af1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115af5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115af9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115afc:	83 ec 04             	sub    $0x4,%esp
f0115aff:	50                   	push   %eax
f0115b00:	68 ff ff 3f 00       	push   $0x3fffff
f0115b05:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b08:	e8 11 51 ff ff       	call   f010ac1e <calculate_required_frames>
f0115b0d:	83 c4 10             	add    $0x10,%esp
f0115b10:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f0115b13:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0115b17:	74 23                	je     f0115b3c <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f0115b19:	83 ec 0c             	sub    $0xc,%esp
f0115b1c:	6a 04                	push   $0x4
f0115b1e:	ff 75 c8             	pushl  -0x38(%ebp)
f0115b21:	68 84 46 13 f0       	push   $0xf0134684
f0115b26:	68 d2 06 00 00       	push   $0x6d2
f0115b2b:	68 72 2a 13 f0       	push   $0xf0132a72
f0115b30:	e8 1f b5 fe ff       	call   f0101054 <_warn>
f0115b35:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b38:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115b3c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115b40:	74 04                	je     f0115b46 <test_calculate_required_frames+0x3f9>
f0115b42:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115b46:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115b4a:	83 ec 0c             	sub    $0xc,%esp
f0115b4d:	68 bd 41 13 f0       	push   $0xf01341bd
f0115b52:	e8 05 c0 fe ff       	call   f0101b5c <cprintf>
f0115b57:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0115b5a:	83 ec 0c             	sub    $0xc,%esp
f0115b5d:	68 dc 46 13 f0       	push   $0xf01346dc
f0115b62:	e8 f5 bf fe ff       	call   f0101b5c <cprintf>
f0115b67:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0115b6a:	83 ec 04             	sub    $0x4,%esp
f0115b6d:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0115b73:	50                   	push   %eax
f0115b74:	68 76 35 13 f0       	push   $0xf0133576
f0115b79:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115b7f:	50                   	push   %eax
f0115b80:	e8 26 55 00 00       	call   f011b0ab <strcconcat>
f0115b85:	83 c4 10             	add    $0x10,%esp
f0115b88:	83 ec 0c             	sub    $0xc,%esp
f0115b8b:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0115b91:	50                   	push   %eax
f0115b92:	e8 84 c2 fe ff       	call   f0101e1b <execute_command>
f0115b97:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115b9a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115b9d:	c1 e0 03             	shl    $0x3,%eax
f0115ba0:	83 ec 04             	sub    $0x4,%esp
f0115ba3:	50                   	push   %eax
f0115ba4:	6a 00                	push   $0x0
f0115ba6:	ff 75 d8             	pushl  -0x28(%ebp)
f0115ba9:	e8 70 50 ff ff       	call   f010ac1e <calculate_required_frames>
f0115bae:	83 c4 10             	add    $0x10,%esp
f0115bb1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115bb4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115bbb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115bbe:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115bc1:	74 24                	je     f0115be7 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115bc3:	83 ec 0c             	sub    $0xc,%esp
f0115bc6:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115bc9:	ff 75 c8             	pushl  -0x38(%ebp)
f0115bcc:	68 84 46 13 f0       	push   $0xf0134684
f0115bd1:	68 e6 06 00 00       	push   $0x6e6
f0115bd6:	68 72 2a 13 f0       	push   $0xf0132a72
f0115bdb:	e8 74 b4 fe ff       	call   f0101054 <_warn>
f0115be0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115be3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115be7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115beb:	74 04                	je     f0115bf1 <test_calculate_required_frames+0x4a4>
f0115bed:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115bf1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115bf5:	83 ec 04             	sub    $0x4,%esp
f0115bf8:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115bfe:	50                   	push   %eax
f0115bff:	68 83 35 13 f0       	push   $0xf0133583
f0115c04:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115c0a:	50                   	push   %eax
f0115c0b:	e8 9b 54 00 00       	call   f011b0ab <strcconcat>
f0115c10:	83 c4 10             	add    $0x10,%esp
f0115c13:	83 ec 0c             	sub    $0xc,%esp
f0115c16:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115c1c:	50                   	push   %eax
f0115c1d:	e8 f9 c1 fe ff       	call   f0101e1b <execute_command>
f0115c22:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115c25:	83 ec 04             	sub    $0x4,%esp
f0115c28:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115c2e:	50                   	push   %eax
f0115c2f:	68 10 47 13 f0       	push   $0xf0134710
f0115c34:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115c3a:	50                   	push   %eax
f0115c3b:	e8 6b 54 00 00       	call   f011b0ab <strcconcat>
f0115c40:	83 c4 10             	add    $0x10,%esp
f0115c43:	83 ec 0c             	sub    $0xc,%esp
f0115c46:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115c4c:	50                   	push   %eax
f0115c4d:	e8 c9 c1 fe ff       	call   f0101e1b <execute_command>
f0115c52:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f0115c55:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115c58:	c1 e0 03             	shl    $0x3,%eax
f0115c5b:	83 ec 04             	sub    $0x4,%esp
f0115c5e:	50                   	push   %eax
f0115c5f:	6a 00                	push   $0x0
f0115c61:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c64:	e8 b5 4f ff ff       	call   f010ac1e <calculate_required_frames>
f0115c69:	83 c4 10             	add    $0x10,%esp
f0115c6c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0115c6f:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f0115c76:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115c79:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115c7c:	74 24                	je     f0115ca2 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115c7e:	83 ec 0c             	sub    $0xc,%esp
f0115c81:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115c84:	ff 75 c8             	pushl  -0x38(%ebp)
f0115c87:	68 84 46 13 f0       	push   $0xf0134684
f0115c8c:	68 f4 06 00 00       	push   $0x6f4
f0115c91:	68 72 2a 13 f0       	push   $0xf0132a72
f0115c96:	e8 b9 b3 fe ff       	call   f0101054 <_warn>
f0115c9b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c9e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115ca2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115ca6:	74 04                	je     f0115cac <test_calculate_required_frames+0x55f>
f0115ca8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115cac:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115cb0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115cb3:	c1 e0 0a             	shl    $0xa,%eax
f0115cb6:	83 ec 04             	sub    $0x4,%esp
f0115cb9:	50                   	push   %eax
f0115cba:	6a 00                	push   $0x0
f0115cbc:	ff 75 d8             	pushl  -0x28(%ebp)
f0115cbf:	e8 5a 4f ff ff       	call   f010ac1e <calculate_required_frames>
f0115cc4:	83 c4 10             	add    $0x10,%esp
f0115cc7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0115cca:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115ccd:	c1 e0 0a             	shl    $0xa,%eax
f0115cd0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115cd3:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115cda:	99                   	cltd   
f0115cdb:	f7 fb                	idiv   %ebx
f0115cdd:	89 c1                	mov    %eax,%ecx
f0115cdf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115ce2:	c1 e0 0a             	shl    $0xa,%eax
f0115ce5:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115ce8:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115cef:	99                   	cltd   
f0115cf0:	f7 fe                	idiv   %esi
f0115cf2:	01 c8                	add    %ecx,%eax
f0115cf4:	83 e8 05             	sub    $0x5,%eax
f0115cf7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0115cfa:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115cfd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115d00:	74 24                	je     f0115d26 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115d02:	83 ec 0c             	sub    $0xc,%esp
f0115d05:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115d08:	ff 75 c8             	pushl  -0x38(%ebp)
f0115d0b:	68 84 46 13 f0       	push   $0xf0134684
f0115d10:	68 ff 06 00 00       	push   $0x6ff
f0115d15:	68 72 2a 13 f0       	push   $0xf0132a72
f0115d1a:	e8 35 b3 fe ff       	call   f0101054 <_warn>
f0115d1f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d22:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115d26:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d2a:	74 04                	je     f0115d30 <test_calculate_required_frames+0x5e3>
f0115d2c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115d30:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115d34:	83 ec 04             	sub    $0x4,%esp
f0115d37:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115d3d:	50                   	push   %eax
f0115d3e:	68 1c 47 13 f0       	push   $0xf013471c
f0115d43:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115d49:	50                   	push   %eax
f0115d4a:	e8 5c 53 00 00       	call   f011b0ab <strcconcat>
f0115d4f:	83 c4 10             	add    $0x10,%esp
f0115d52:	83 ec 0c             	sub    $0xc,%esp
f0115d55:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115d5b:	50                   	push   %eax
f0115d5c:	e8 ba c0 fe ff       	call   f0101e1b <execute_command>
f0115d61:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0115d64:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115d67:	89 c2                	mov    %eax,%edx
f0115d69:	01 d2                	add    %edx,%edx
f0115d6b:	01 d0                	add    %edx,%eax
f0115d6d:	83 ec 04             	sub    $0x4,%esp
f0115d70:	50                   	push   %eax
f0115d71:	68 00 18 00 00       	push   $0x1800
f0115d76:	ff 75 d8             	pushl  -0x28(%ebp)
f0115d79:	e8 a0 4e ff ff       	call   f010ac1e <calculate_required_frames>
f0115d7e:	83 c4 10             	add    $0x10,%esp
f0115d81:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115d84:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115d8b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115d8e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115d91:	74 24                	je     f0115db7 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115d93:	83 ec 0c             	sub    $0xc,%esp
f0115d96:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115d99:	ff 75 c8             	pushl  -0x38(%ebp)
f0115d9c:	68 84 46 13 f0       	push   $0xf0134684
f0115da1:	68 0e 07 00 00       	push   $0x70e
f0115da6:	68 72 2a 13 f0       	push   $0xf0132a72
f0115dab:	e8 a4 b2 fe ff       	call   f0101054 <_warn>
f0115db0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115db3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115db7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115dbb:	74 04                	je     f0115dc1 <test_calculate_required_frames+0x674>
f0115dbd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115dc1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115dc5:	83 ec 04             	sub    $0x4,%esp
f0115dc8:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115dce:	50                   	push   %eax
f0115dcf:	68 dc 37 13 f0       	push   $0xf01337dc
f0115dd4:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115dda:	50                   	push   %eax
f0115ddb:	e8 cb 52 00 00       	call   f011b0ab <strcconcat>
f0115de0:	83 c4 10             	add    $0x10,%esp
f0115de3:	83 ec 0c             	sub    $0xc,%esp
f0115de6:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115dec:	50                   	push   %eax
f0115ded:	e8 29 c0 fe ff       	call   f0101e1b <execute_command>
f0115df2:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115df5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115df8:	89 d0                	mov    %edx,%eax
f0115dfa:	c1 e0 02             	shl    $0x2,%eax
f0115dfd:	01 d0                	add    %edx,%eax
f0115dff:	01 c0                	add    %eax,%eax
f0115e01:	83 ec 04             	sub    $0x4,%esp
f0115e04:	50                   	push   %eax
f0115e05:	68 00 00 40 00       	push   $0x400000
f0115e0a:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e0d:	e8 0c 4e ff ff       	call   f010ac1e <calculate_required_frames>
f0115e12:	83 c4 10             	add    $0x10,%esp
f0115e15:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0115e18:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f0115e1f:	74 26                	je     f0115e47 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115e21:	83 ec 0c             	sub    $0xc,%esp
f0115e24:	68 03 0a 00 00       	push   $0xa03
f0115e29:	ff 75 c8             	pushl  -0x38(%ebp)
f0115e2c:	68 84 46 13 f0       	push   $0xf0134684
f0115e31:	68 1a 07 00 00       	push   $0x71a
f0115e36:	68 72 2a 13 f0       	push   $0xf0132a72
f0115e3b:	e8 14 b2 fe ff       	call   f0101054 <_warn>
f0115e40:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e43:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115e47:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e4b:	74 04                	je     f0115e51 <test_calculate_required_frames+0x704>
f0115e4d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115e51:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0115e55:	83 ec 04             	sub    $0x4,%esp
f0115e58:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115e5e:	50                   	push   %eax
f0115e5f:	68 e6 37 13 f0       	push   $0xf01337e6
f0115e64:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115e6a:	50                   	push   %eax
f0115e6b:	e8 3b 52 00 00       	call   f011b0ab <strcconcat>
f0115e70:	83 c4 10             	add    $0x10,%esp
f0115e73:	83 ec 0c             	sub    $0xc,%esp
f0115e76:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115e7c:	50                   	push   %eax
f0115e7d:	e8 99 bf fe ff       	call   f0101e1b <execute_command>
f0115e82:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0115e85:	83 ec 04             	sub    $0x4,%esp
f0115e88:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115e8e:	50                   	push   %eax
f0115e8f:	68 24 47 13 f0       	push   $0xf0134724
f0115e94:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115e9a:	50                   	push   %eax
f0115e9b:	e8 0b 52 00 00       	call   f011b0ab <strcconcat>
f0115ea0:	83 c4 10             	add    $0x10,%esp
f0115ea3:	83 ec 0c             	sub    $0xc,%esp
f0115ea6:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115eac:	50                   	push   %eax
f0115ead:	e8 69 bf fe ff       	call   f0101e1b <execute_command>
f0115eb2:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115eb5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115eb8:	01 c0                	add    %eax,%eax
f0115eba:	83 ec 04             	sub    $0x4,%esp
f0115ebd:	50                   	push   %eax
f0115ebe:	68 00 00 70 00       	push   $0x700000
f0115ec3:	ff 75 d8             	pushl  -0x28(%ebp)
f0115ec6:	e8 53 4d ff ff       	call   f010ac1e <calculate_required_frames>
f0115ecb:	83 c4 10             	add    $0x10,%esp
f0115ece:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f0115ed1:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0115ed8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115edb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115ede:	74 24                	je     f0115f04 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115ee0:	83 ec 0c             	sub    $0xc,%esp
f0115ee3:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115ee6:	ff 75 c8             	pushl  -0x38(%ebp)
f0115ee9:	68 84 46 13 f0       	push   $0xf0134684
f0115eee:	68 2a 07 00 00       	push   $0x72a
f0115ef3:	68 72 2a 13 f0       	push   $0xf0132a72
f0115ef8:	e8 57 b1 fe ff       	call   f0101054 <_warn>
f0115efd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f00:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115f04:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f08:	74 04                	je     f0115f0e <test_calculate_required_frames+0x7c1>
f0115f0a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115f0e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115f12:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115f15:	83 ec 04             	sub    $0x4,%esp
f0115f18:	50                   	push   %eax
f0115f19:	68 ff ff 3f 00       	push   $0x3fffff
f0115f1e:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f21:	e8 f8 4c ff ff       	call   f010ac1e <calculate_required_frames>
f0115f26:	83 c4 10             	add    $0x10,%esp
f0115f29:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f0115f2c:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0115f33:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115f36:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115f39:	74 24                	je     f0115f5f <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115f3b:	83 ec 0c             	sub    $0xc,%esp
f0115f3e:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115f41:	ff 75 c8             	pushl  -0x38(%ebp)
f0115f44:	68 84 46 13 f0       	push   $0xf0134684
f0115f49:	68 35 07 00 00       	push   $0x735
f0115f4e:	68 72 2a 13 f0       	push   $0xf0132a72
f0115f53:	e8 fc b0 fe ff       	call   f0101054 <_warn>
f0115f58:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f5b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115f5f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f63:	74 04                	je     f0115f69 <test_calculate_required_frames+0x81c>
f0115f65:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115f69:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0115f6d:	83 ec 0c             	sub    $0xc,%esp
f0115f70:	68 97 37 13 f0       	push   $0xf0133797
f0115f75:	e8 e2 bb fe ff       	call   f0101b5c <cprintf>
f0115f7a:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0115f7d:	83 ec 08             	sub    $0x8,%esp
f0115f80:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115f83:	68 30 47 13 f0       	push   $0xf0134730
f0115f88:	e8 cf bb fe ff       	call   f0101b5c <cprintf>
f0115f8d:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115f90:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115f94:	75 10                	jne    f0115fa6 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0115f96:	83 ec 0c             	sub    $0xc,%esp
f0115f99:	68 70 47 13 f0       	push   $0xf0134770
f0115f9e:	e8 b9 bb fe ff       	call   f0101b5c <cprintf>
f0115fa3:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115fa6:	a1 40 64 85 f0       	mov    0xf0856440,%eax
f0115fab:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0115fae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115fb1:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115fb4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115fb9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115fbc:	5b                   	pop    %ebx
f0115fbd:	5e                   	pop    %esi
f0115fbe:	5f                   	pop    %edi
f0115fbf:	5d                   	pop    %ebp
f0115fc0:	c3                   	ret    

f0115fc1 <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0115fc1:	55                   	push   %ebp
f0115fc2:	89 e5                	mov    %esp,%ebp
f0115fc4:	57                   	push   %edi
f0115fc5:	56                   	push   %esi
f0115fc6:	53                   	push   %ebx
f0115fc7:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115fcd:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115fd0:	bb 0c 35 13 f0       	mov    $0xf013350c,%ebx
f0115fd5:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115fda:	89 c7                	mov    %eax,%edi
f0115fdc:	89 de                	mov    %ebx,%esi
f0115fde:	89 d1                	mov    %edx,%ecx
f0115fe0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115fe2:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115fe5:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115fea:	b0 00                	mov    $0x0,%al
f0115fec:	89 d7                	mov    %edx,%edi
f0115fee:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115ff0:	6a 00                	push   $0x0
f0115ff2:	6a 0a                	push   $0xa
f0115ff4:	6a 14                	push   $0x14
f0115ff6:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115ff9:	50                   	push   %eax
f0115ffa:	e8 65 4e ff ff       	call   f010ae64 <env_create>
f0115fff:	83 c4 10             	add    $0x10,%esp
f0116002:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0116005:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116008:	8b 40 64             	mov    0x64(%eax),%eax
f011600b:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011600e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116011:	8b 40 68             	mov    0x68(%eax),%eax
f0116014:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0116017:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011601a:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011601d:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0116024:	75 70 20 
f0116027:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f011602e:	00 00 00 
f0116031:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0116034:	b9 03 00 00 00       	mov    $0x3,%ecx
f0116039:	b8 00 00 00 00       	mov    $0x0,%eax
f011603e:	89 d7                	mov    %edx,%edi
f0116040:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0116042:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116045:	8b 40 10             	mov    0x10(%eax),%eax
f0116048:	83 ec 08             	sub    $0x8,%esp
f011604b:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0116051:	52                   	push   %edx
f0116052:	50                   	push   %eax
f0116053:	e8 7a 4f 00 00       	call   f011afd2 <ltostr>
f0116058:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f011605b:	83 ec 04             	sub    $0x4,%esp
f011605e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116064:	50                   	push   %eax
f0116065:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f011606b:	50                   	push   %eax
f011606c:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0116072:	50                   	push   %eax
f0116073:	e8 33 50 00 00       	call   f011b0ab <strcconcat>
f0116078:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f011607b:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0116082:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0116089:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0116090:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0116094:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011609b:	00 00 00 
	uint32 num_tables = 0;
f011609e:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01160a5:	00 00 00 
	ClearUserSpace(proc_directory);
f01160a8:	83 ec 0c             	sub    $0xc,%esp
f01160ab:	ff 75 d8             	pushl  -0x28(%ebp)
f01160ae:	e8 8d 0e 00 00       	call   f0116f40 <ClearUserSpace>
f01160b3:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f01160b6:	83 ec 0c             	sub    $0xc,%esp
f01160b9:	68 50 46 13 f0       	push   $0xf0134650
f01160be:	e8 99 ba fe ff       	call   f0101b5c <cprintf>
f01160c3:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f01160c6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01160c9:	c1 e0 03             	shl    $0x3,%eax
f01160cc:	89 c2                	mov    %eax,%edx
f01160ce:	83 ec 0c             	sub    $0xc,%esp
f01160d1:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01160d7:	50                   	push   %eax
f01160d8:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01160de:	50                   	push   %eax
f01160df:	52                   	push   %edx
f01160e0:	6a 00                	push   $0x0
f01160e2:	ff 75 d8             	pushl  -0x28(%ebp)
f01160e5:	e8 1a 4b ff ff       	call   f010ac04 <calculate_allocated_space>
f01160ea:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01160ed:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01160f3:	85 c0                	test   %eax,%eax
f01160f5:	74 27                	je     f011611e <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01160f7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01160fd:	83 ec 0c             	sub    $0xc,%esp
f0116100:	6a 00                	push   $0x0
f0116102:	50                   	push   %eax
f0116103:	68 bc 47 13 f0       	push   $0xf01347bc
f0116108:	68 6a 07 00 00       	push   $0x76a
f011610d:	68 72 2a 13 f0       	push   $0xf0132a72
f0116112:	e8 3d af fe ff       	call   f0101054 <_warn>
f0116117:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011611a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011611e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116124:	85 c0                	test   %eax,%eax
f0116126:	74 27                	je     f011614f <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116128:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011612e:	83 ec 0c             	sub    $0xc,%esp
f0116131:	6a 00                	push   $0x0
f0116133:	50                   	push   %eax
f0116134:	68 1c 48 13 f0       	push   $0xf013481c
f0116139:	68 6f 07 00 00       	push   $0x76f
f011613e:	68 72 2a 13 f0       	push   $0xf0132a72
f0116143:	e8 0c af fe ff       	call   f0101054 <_warn>
f0116148:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011614b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011614f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116153:	74 04                	je     f0116159 <test_calculate_allocated_space+0x198>
f0116155:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116159:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f011615d:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116164:	00 00 00 
		num_pages = 0;
f0116167:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011616e:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0116171:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116174:	c1 e0 02             	shl    $0x2,%eax
f0116177:	89 c2                	mov    %eax,%edx
f0116179:	83 ec 0c             	sub    $0xc,%esp
f011617c:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116182:	50                   	push   %eax
f0116183:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116189:	50                   	push   %eax
f011618a:	52                   	push   %edx
f011618b:	6a 00                	push   $0x0
f011618d:	ff 75 d8             	pushl  -0x28(%ebp)
f0116190:	e8 6f 4a ff ff       	call   f010ac04 <calculate_allocated_space>
f0116195:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116198:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011619e:	85 c0                	test   %eax,%eax
f01161a0:	74 27                	je     f01161c9 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01161a2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01161a8:	83 ec 0c             	sub    $0xc,%esp
f01161ab:	6a 00                	push   $0x0
f01161ad:	50                   	push   %eax
f01161ae:	68 bc 47 13 f0       	push   $0xf01347bc
f01161b3:	68 7b 07 00 00       	push   $0x77b
f01161b8:	68 72 2a 13 f0       	push   $0xf0132a72
f01161bd:	e8 92 ae fe ff       	call   f0101054 <_warn>
f01161c2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01161c5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01161c9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01161cf:	85 c0                	test   %eax,%eax
f01161d1:	74 27                	je     f01161fa <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01161d3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01161d9:	83 ec 0c             	sub    $0xc,%esp
f01161dc:	6a 00                	push   $0x0
f01161de:	50                   	push   %eax
f01161df:	68 1c 48 13 f0       	push   $0xf013481c
f01161e4:	68 80 07 00 00       	push   $0x780
f01161e9:	68 72 2a 13 f0       	push   $0xf0132a72
f01161ee:	e8 61 ae fe ff       	call   f0101054 <_warn>
f01161f3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01161f6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01161fa:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01161fe:	74 04                	je     f0116204 <test_calculate_allocated_space+0x243>
f0116200:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116204:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0116208:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011620f:	00 00 00 
		num_pages = 0;
f0116212:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116219:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f011621c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011621f:	c1 e0 0a             	shl    $0xa,%eax
f0116222:	89 c2                	mov    %eax,%edx
f0116224:	83 ec 0c             	sub    $0xc,%esp
f0116227:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011622d:	50                   	push   %eax
f011622e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116234:	50                   	push   %eax
f0116235:	52                   	push   %edx
f0116236:	6a 00                	push   $0x0
f0116238:	ff 75 d8             	pushl  -0x28(%ebp)
f011623b:	e8 c4 49 ff ff       	call   f010ac04 <calculate_allocated_space>
f0116240:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116243:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116249:	85 c0                	test   %eax,%eax
f011624b:	74 27                	je     f0116274 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011624d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116253:	83 ec 0c             	sub    $0xc,%esp
f0116256:	6a 00                	push   $0x0
f0116258:	50                   	push   %eax
f0116259:	68 bc 47 13 f0       	push   $0xf01347bc
f011625e:	68 8c 07 00 00       	push   $0x78c
f0116263:	68 72 2a 13 f0       	push   $0xf0132a72
f0116268:	e8 e7 ad fe ff       	call   f0101054 <_warn>
f011626d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116270:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116274:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011627a:	85 c0                	test   %eax,%eax
f011627c:	74 27                	je     f01162a5 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011627e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116284:	83 ec 0c             	sub    $0xc,%esp
f0116287:	6a 00                	push   $0x0
f0116289:	50                   	push   %eax
f011628a:	68 1c 48 13 f0       	push   $0xf013481c
f011628f:	68 91 07 00 00       	push   $0x791
f0116294:	68 72 2a 13 f0       	push   $0xf0132a72
f0116299:	e8 b6 ad fe ff       	call   f0101054 <_warn>
f011629e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01162a1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01162a5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01162a9:	74 04                	je     f01162af <test_calculate_allocated_space+0x2ee>
f01162ab:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01162af:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f01162b3:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01162ba:	00 00 00 
		num_pages = 0;
f01162bd:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01162c4:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f01162c7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01162ca:	89 d0                	mov    %edx,%eax
f01162cc:	01 c0                	add    %eax,%eax
f01162ce:	01 d0                	add    %edx,%eax
f01162d0:	01 c0                	add    %eax,%eax
f01162d2:	05 00 10 00 00       	add    $0x1000,%eax
f01162d7:	89 c2                	mov    %eax,%edx
f01162d9:	83 ec 0c             	sub    $0xc,%esp
f01162dc:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01162e2:	50                   	push   %eax
f01162e3:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01162e9:	50                   	push   %eax
f01162ea:	52                   	push   %edx
f01162eb:	68 00 10 00 00       	push   $0x1000
f01162f0:	ff 75 d8             	pushl  -0x28(%ebp)
f01162f3:	e8 0c 49 ff ff       	call   f010ac04 <calculate_allocated_space>
f01162f8:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01162fb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116301:	85 c0                	test   %eax,%eax
f0116303:	74 27                	je     f011632c <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116305:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011630b:	83 ec 0c             	sub    $0xc,%esp
f011630e:	6a 00                	push   $0x0
f0116310:	50                   	push   %eax
f0116311:	68 bc 47 13 f0       	push   $0xf01347bc
f0116316:	68 9e 07 00 00       	push   $0x79e
f011631b:	68 72 2a 13 f0       	push   $0xf0132a72
f0116320:	e8 2f ad fe ff       	call   f0101054 <_warn>
f0116325:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116328:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011632c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116332:	85 c0                	test   %eax,%eax
f0116334:	74 27                	je     f011635d <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116336:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011633c:	83 ec 0c             	sub    $0xc,%esp
f011633f:	6a 00                	push   $0x0
f0116341:	50                   	push   %eax
f0116342:	68 1c 48 13 f0       	push   $0xf013481c
f0116347:	68 a3 07 00 00       	push   $0x7a3
f011634c:	68 72 2a 13 f0       	push   $0xf0132a72
f0116351:	e8 fe ac fe ff       	call   f0101054 <_warn>
f0116356:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116359:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011635d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116361:	74 04                	je     f0116367 <test_calculate_allocated_space+0x3a6>
f0116363:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116367:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f011636b:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116372:	00 00 00 
		num_pages = 0;
f0116375:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011637c:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f011637f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116382:	89 c2                	mov    %eax,%edx
f0116384:	01 d2                	add    %edx,%edx
f0116386:	01 d0                	add    %edx,%eax
f0116388:	05 00 18 00 00       	add    $0x1800,%eax
f011638d:	89 c2                	mov    %eax,%edx
f011638f:	83 ec 0c             	sub    $0xc,%esp
f0116392:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116398:	50                   	push   %eax
f0116399:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011639f:	50                   	push   %eax
f01163a0:	52                   	push   %edx
f01163a1:	68 00 18 00 00       	push   $0x1800
f01163a6:	ff 75 d8             	pushl  -0x28(%ebp)
f01163a9:	e8 56 48 ff ff       	call   f010ac04 <calculate_allocated_space>
f01163ae:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01163b1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01163b7:	85 c0                	test   %eax,%eax
f01163b9:	74 27                	je     f01163e2 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01163bb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01163c1:	83 ec 0c             	sub    $0xc,%esp
f01163c4:	6a 00                	push   $0x0
f01163c6:	50                   	push   %eax
f01163c7:	68 bc 47 13 f0       	push   $0xf01347bc
f01163cc:	68 af 07 00 00       	push   $0x7af
f01163d1:	68 72 2a 13 f0       	push   $0xf0132a72
f01163d6:	e8 79 ac fe ff       	call   f0101054 <_warn>
f01163db:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01163de:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01163e2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01163e8:	85 c0                	test   %eax,%eax
f01163ea:	74 27                	je     f0116413 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01163ec:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01163f2:	83 ec 0c             	sub    $0xc,%esp
f01163f5:	6a 00                	push   $0x0
f01163f7:	50                   	push   %eax
f01163f8:	68 1c 48 13 f0       	push   $0xf013481c
f01163fd:	68 b4 07 00 00       	push   $0x7b4
f0116402:	68 72 2a 13 f0       	push   $0xf0132a72
f0116407:	e8 48 ac fe ff       	call   f0101054 <_warn>
f011640c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011640f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116413:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116417:	74 04                	je     f011641d <test_calculate_allocated_space+0x45c>
f0116419:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011641d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0116421:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116428:	00 00 00 
		num_pages = 0;
f011642b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116432:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0116435:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116438:	89 d0                	mov    %edx,%eax
f011643a:	c1 e0 02             	shl    $0x2,%eax
f011643d:	01 d0                	add    %edx,%eax
f011643f:	01 c0                	add    %eax,%eax
f0116441:	05 00 00 40 00       	add    $0x400000,%eax
f0116446:	89 c2                	mov    %eax,%edx
f0116448:	83 ec 0c             	sub    $0xc,%esp
f011644b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116451:	50                   	push   %eax
f0116452:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116458:	50                   	push   %eax
f0116459:	52                   	push   %edx
f011645a:	68 00 00 40 00       	push   $0x400000
f011645f:	ff 75 d8             	pushl  -0x28(%ebp)
f0116462:	e8 9d 47 ff ff       	call   f010ac04 <calculate_allocated_space>
f0116467:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011646a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116470:	85 c0                	test   %eax,%eax
f0116472:	74 27                	je     f011649b <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116474:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011647a:	83 ec 0c             	sub    $0xc,%esp
f011647d:	6a 00                	push   $0x0
f011647f:	50                   	push   %eax
f0116480:	68 bc 47 13 f0       	push   $0xf01347bc
f0116485:	68 c0 07 00 00       	push   $0x7c0
f011648a:	68 72 2a 13 f0       	push   $0xf0132a72
f011648f:	e8 c0 ab fe ff       	call   f0101054 <_warn>
f0116494:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116497:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011649b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01164a1:	85 c0                	test   %eax,%eax
f01164a3:	74 27                	je     f01164cc <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01164a5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01164ab:	83 ec 0c             	sub    $0xc,%esp
f01164ae:	6a 00                	push   $0x0
f01164b0:	50                   	push   %eax
f01164b1:	68 1c 48 13 f0       	push   $0xf013481c
f01164b6:	68 c5 07 00 00       	push   $0x7c5
f01164bb:	68 72 2a 13 f0       	push   $0xf0132a72
f01164c0:	e8 8f ab fe ff       	call   f0101054 <_warn>
f01164c5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01164c8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01164cc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01164d0:	74 04                	je     f01164d6 <test_calculate_allocated_space+0x515>
f01164d2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01164d6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f01164da:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01164e1:	00 00 00 
		num_pages = 0;
f01164e4:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01164eb:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f01164ee:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01164f1:	05 00 00 38 00       	add    $0x380000,%eax
f01164f6:	01 c0                	add    %eax,%eax
f01164f8:	89 c2                	mov    %eax,%edx
f01164fa:	83 ec 0c             	sub    $0xc,%esp
f01164fd:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116503:	50                   	push   %eax
f0116504:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011650a:	50                   	push   %eax
f011650b:	52                   	push   %edx
f011650c:	68 00 00 70 00       	push   $0x700000
f0116511:	ff 75 d8             	pushl  -0x28(%ebp)
f0116514:	e8 eb 46 ff ff       	call   f010ac04 <calculate_allocated_space>
f0116519:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011651c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116522:	85 c0                	test   %eax,%eax
f0116524:	74 27                	je     f011654d <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116526:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011652c:	83 ec 0c             	sub    $0xc,%esp
f011652f:	6a 00                	push   $0x0
f0116531:	50                   	push   %eax
f0116532:	68 bc 47 13 f0       	push   $0xf01347bc
f0116537:	68 d2 07 00 00       	push   $0x7d2
f011653c:	68 72 2a 13 f0       	push   $0xf0132a72
f0116541:	e8 0e ab fe ff       	call   f0101054 <_warn>
f0116546:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116549:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011654d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116553:	85 c0                	test   %eax,%eax
f0116555:	74 27                	je     f011657e <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116557:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011655d:	83 ec 0c             	sub    $0xc,%esp
f0116560:	6a 00                	push   $0x0
f0116562:	50                   	push   %eax
f0116563:	68 1c 48 13 f0       	push   $0xf013481c
f0116568:	68 d7 07 00 00       	push   $0x7d7
f011656d:	68 72 2a 13 f0       	push   $0xf0132a72
f0116572:	e8 dd aa fe ff       	call   f0101054 <_warn>
f0116577:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011657a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011657e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116582:	74 04                	je     f0116588 <test_calculate_allocated_space+0x5c7>
f0116584:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116588:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f011658c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116593:	00 00 00 
		num_pages = 0;
f0116596:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011659d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f01165a0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01165a3:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f01165a8:	89 c2                	mov    %eax,%edx
f01165aa:	83 ec 0c             	sub    $0xc,%esp
f01165ad:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01165b3:	50                   	push   %eax
f01165b4:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01165ba:	50                   	push   %eax
f01165bb:	52                   	push   %edx
f01165bc:	68 ff ff 3f 00       	push   $0x3fffff
f01165c1:	ff 75 d8             	pushl  -0x28(%ebp)
f01165c4:	e8 3b 46 ff ff       	call   f010ac04 <calculate_allocated_space>
f01165c9:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01165cc:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01165d2:	85 c0                	test   %eax,%eax
f01165d4:	74 27                	je     f01165fd <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01165d6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01165dc:	83 ec 0c             	sub    $0xc,%esp
f01165df:	6a 00                	push   $0x0
f01165e1:	50                   	push   %eax
f01165e2:	68 bc 47 13 f0       	push   $0xf01347bc
f01165e7:	68 e3 07 00 00       	push   $0x7e3
f01165ec:	68 72 2a 13 f0       	push   $0xf0132a72
f01165f1:	e8 5e aa fe ff       	call   f0101054 <_warn>
f01165f6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01165f9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01165fd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116603:	85 c0                	test   %eax,%eax
f0116605:	74 27                	je     f011662e <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116607:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011660d:	83 ec 0c             	sub    $0xc,%esp
f0116610:	6a 00                	push   $0x0
f0116612:	50                   	push   %eax
f0116613:	68 1c 48 13 f0       	push   $0xf013481c
f0116618:	68 e8 07 00 00       	push   $0x7e8
f011661d:	68 72 2a 13 f0       	push   $0xf0132a72
f0116622:	e8 2d aa fe ff       	call   f0101054 <_warn>
f0116627:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011662a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011662e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116632:	74 04                	je     f0116638 <test_calculate_allocated_space+0x677>
f0116634:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116638:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011663c:	83 ec 0c             	sub    $0xc,%esp
f011663f:	68 bd 41 13 f0       	push   $0xf01341bd
f0116644:	e8 13 b5 fe ff       	call   f0101b5c <cprintf>
f0116649:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f011664c:	83 ec 0c             	sub    $0xc,%esp
f011664f:	68 dc 46 13 f0       	push   $0xf01346dc
f0116654:	e8 03 b5 fe ff       	call   f0101b5c <cprintf>
f0116659:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f011665c:	83 ec 04             	sub    $0x4,%esp
f011665f:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0116665:	50                   	push   %eax
f0116666:	68 76 35 13 f0       	push   $0xf0133576
f011666b:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116671:	50                   	push   %eax
f0116672:	e8 34 4a 00 00       	call   f011b0ab <strcconcat>
f0116677:	83 c4 10             	add    $0x10,%esp
f011667a:	83 ec 0c             	sub    $0xc,%esp
f011667d:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0116683:	50                   	push   %eax
f0116684:	e8 92 b7 fe ff       	call   f0101e1b <execute_command>
f0116689:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f011668c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116693:	00 00 00 
		num_pages = 0;
f0116696:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011669d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f01166a0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01166a3:	c1 e0 03             	shl    $0x3,%eax
f01166a6:	89 c2                	mov    %eax,%edx
f01166a8:	83 ec 0c             	sub    $0xc,%esp
f01166ab:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01166b1:	50                   	push   %eax
f01166b2:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01166b8:	50                   	push   %eax
f01166b9:	52                   	push   %edx
f01166ba:	6a 00                	push   $0x0
f01166bc:	ff 75 d8             	pushl  -0x28(%ebp)
f01166bf:	e8 40 45 ff ff       	call   f010ac04 <calculate_allocated_space>
f01166c4:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f01166c7:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f01166ce:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01166d5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166db:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01166de:	74 28                	je     f0116708 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01166e0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166e6:	83 ec 0c             	sub    $0xc,%esp
f01166e9:	ff 75 c8             	pushl  -0x38(%ebp)
f01166ec:	50                   	push   %eax
f01166ed:	68 bc 47 13 f0       	push   $0xf01347bc
f01166f2:	68 ff 07 00 00       	push   $0x7ff
f01166f7:	68 72 2a 13 f0       	push   $0xf0132a72
f01166fc:	e8 53 a9 fe ff       	call   f0101054 <_warn>
f0116701:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116704:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116708:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011670e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116711:	74 28                	je     f011673b <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116713:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116719:	83 ec 0c             	sub    $0xc,%esp
f011671c:	ff 75 c4             	pushl  -0x3c(%ebp)
f011671f:	50                   	push   %eax
f0116720:	68 1c 48 13 f0       	push   $0xf013481c
f0116725:	68 04 08 00 00       	push   $0x804
f011672a:	68 72 2a 13 f0       	push   $0xf0132a72
f011672f:	e8 20 a9 fe ff       	call   f0101054 <_warn>
f0116734:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116737:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011673b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011673f:	74 04                	je     f0116745 <test_calculate_allocated_space+0x784>
f0116741:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116745:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0116749:	83 ec 04             	sub    $0x4,%esp
f011674c:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116752:	50                   	push   %eax
f0116753:	68 83 35 13 f0       	push   $0xf0133583
f0116758:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011675e:	50                   	push   %eax
f011675f:	e8 47 49 00 00       	call   f011b0ab <strcconcat>
f0116764:	83 c4 10             	add    $0x10,%esp
f0116767:	83 ec 0c             	sub    $0xc,%esp
f011676a:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116770:	50                   	push   %eax
f0116771:	e8 a5 b6 fe ff       	call   f0101e1b <execute_command>
f0116776:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0116779:	83 ec 04             	sub    $0x4,%esp
f011677c:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116782:	50                   	push   %eax
f0116783:	68 10 47 13 f0       	push   $0xf0134710
f0116788:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011678e:	50                   	push   %eax
f011678f:	e8 17 49 00 00       	call   f011b0ab <strcconcat>
f0116794:	83 c4 10             	add    $0x10,%esp
f0116797:	83 ec 0c             	sub    $0xc,%esp
f011679a:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01167a0:	50                   	push   %eax
f01167a1:	e8 75 b6 fe ff       	call   f0101e1b <execute_command>
f01167a6:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f01167a9:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01167b0:	00 00 00 
		num_pages = 0;
f01167b3:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01167ba:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f01167bd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01167c0:	c1 e0 03             	shl    $0x3,%eax
f01167c3:	89 c2                	mov    %eax,%edx
f01167c5:	83 ec 0c             	sub    $0xc,%esp
f01167c8:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01167ce:	50                   	push   %eax
f01167cf:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01167d5:	50                   	push   %eax
f01167d6:	52                   	push   %edx
f01167d7:	6a 00                	push   $0x0
f01167d9:	ff 75 d8             	pushl  -0x28(%ebp)
f01167dc:	e8 23 44 ff ff       	call   f010ac04 <calculate_allocated_space>
f01167e1:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f01167e4:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f01167eb:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01167f2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167f8:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01167fb:	74 28                	je     f0116825 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01167fd:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116803:	83 ec 0c             	sub    $0xc,%esp
f0116806:	ff 75 c8             	pushl  -0x38(%ebp)
f0116809:	50                   	push   %eax
f011680a:	68 bc 47 13 f0       	push   $0xf01347bc
f011680f:	68 15 08 00 00       	push   $0x815
f0116814:	68 72 2a 13 f0       	push   $0xf0132a72
f0116819:	e8 36 a8 fe ff       	call   f0101054 <_warn>
f011681e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116821:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116825:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011682b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011682e:	74 28                	je     f0116858 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116830:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116836:	83 ec 0c             	sub    $0xc,%esp
f0116839:	ff 75 c4             	pushl  -0x3c(%ebp)
f011683c:	50                   	push   %eax
f011683d:	68 1c 48 13 f0       	push   $0xf013481c
f0116842:	68 1a 08 00 00       	push   $0x81a
f0116847:	68 72 2a 13 f0       	push   $0xf0132a72
f011684c:	e8 03 a8 fe ff       	call   f0101054 <_warn>
f0116851:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116854:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116858:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011685c:	74 04                	je     f0116862 <test_calculate_allocated_space+0x8a1>
f011685e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116862:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0116866:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011686d:	00 00 00 
		num_pages = 0;
f0116870:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116877:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f011687a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011687d:	c1 e0 0a             	shl    $0xa,%eax
f0116880:	89 c2                	mov    %eax,%edx
f0116882:	83 ec 0c             	sub    $0xc,%esp
f0116885:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011688b:	50                   	push   %eax
f011688c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116892:	50                   	push   %eax
f0116893:	52                   	push   %edx
f0116894:	6a 00                	push   $0x0
f0116896:	ff 75 d8             	pushl  -0x28(%ebp)
f0116899:	e8 66 43 ff ff       	call   f010ac04 <calculate_allocated_space>
f011689e:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f01168a1:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f01168a8:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01168af:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01168b5:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01168b8:	74 28                	je     f01168e2 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01168ba:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01168c0:	83 ec 0c             	sub    $0xc,%esp
f01168c3:	ff 75 c8             	pushl  -0x38(%ebp)
f01168c6:	50                   	push   %eax
f01168c7:	68 bc 47 13 f0       	push   $0xf01347bc
f01168cc:	68 28 08 00 00       	push   $0x828
f01168d1:	68 72 2a 13 f0       	push   $0xf0132a72
f01168d6:	e8 79 a7 fe ff       	call   f0101054 <_warn>
f01168db:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01168de:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01168e2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01168e8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01168eb:	74 28                	je     f0116915 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01168ed:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01168f3:	83 ec 0c             	sub    $0xc,%esp
f01168f6:	ff 75 c4             	pushl  -0x3c(%ebp)
f01168f9:	50                   	push   %eax
f01168fa:	68 1c 48 13 f0       	push   $0xf013481c
f01168ff:	68 2d 08 00 00       	push   $0x82d
f0116904:	68 72 2a 13 f0       	push   $0xf0132a72
f0116909:	e8 46 a7 fe ff       	call   f0101054 <_warn>
f011690e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116911:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116915:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116919:	74 04                	je     f011691f <test_calculate_allocated_space+0x95e>
f011691b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011691f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0116923:	83 ec 04             	sub    $0x4,%esp
f0116926:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011692c:	50                   	push   %eax
f011692d:	68 1c 47 13 f0       	push   $0xf013471c
f0116932:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116938:	50                   	push   %eax
f0116939:	e8 6d 47 00 00       	call   f011b0ab <strcconcat>
f011693e:	83 c4 10             	add    $0x10,%esp
f0116941:	83 ec 0c             	sub    $0xc,%esp
f0116944:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011694a:	50                   	push   %eax
f011694b:	e8 cb b4 fe ff       	call   f0101e1b <execute_command>
f0116950:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0116953:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011695a:	00 00 00 
		num_pages = 0;
f011695d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116964:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0116967:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011696a:	89 c2                	mov    %eax,%edx
f011696c:	01 d2                	add    %edx,%edx
f011696e:	01 d0                	add    %edx,%eax
f0116970:	05 00 18 00 00       	add    $0x1800,%eax
f0116975:	89 c2                	mov    %eax,%edx
f0116977:	83 ec 0c             	sub    $0xc,%esp
f011697a:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116980:	50                   	push   %eax
f0116981:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116987:	50                   	push   %eax
f0116988:	52                   	push   %edx
f0116989:	68 00 18 00 00       	push   $0x1800
f011698e:	ff 75 d8             	pushl  -0x28(%ebp)
f0116991:	e8 6e 42 ff ff       	call   f010ac04 <calculate_allocated_space>
f0116996:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116999:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f01169a0:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01169a7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01169ad:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01169b0:	74 28                	je     f01169da <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01169b2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01169b8:	83 ec 0c             	sub    $0xc,%esp
f01169bb:	ff 75 c8             	pushl  -0x38(%ebp)
f01169be:	50                   	push   %eax
f01169bf:	68 bc 47 13 f0       	push   $0xf01347bc
f01169c4:	68 3e 08 00 00       	push   $0x83e
f01169c9:	68 72 2a 13 f0       	push   $0xf0132a72
f01169ce:	e8 81 a6 fe ff       	call   f0101054 <_warn>
f01169d3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01169d6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01169da:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01169e0:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01169e3:	74 28                	je     f0116a0d <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01169e5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01169eb:	83 ec 0c             	sub    $0xc,%esp
f01169ee:	ff 75 c4             	pushl  -0x3c(%ebp)
f01169f1:	50                   	push   %eax
f01169f2:	68 1c 48 13 f0       	push   $0xf013481c
f01169f7:	68 43 08 00 00       	push   $0x843
f01169fc:	68 72 2a 13 f0       	push   $0xf0132a72
f0116a01:	e8 4e a6 fe ff       	call   f0101054 <_warn>
f0116a06:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116a09:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116a0d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116a11:	74 04                	je     f0116a17 <test_calculate_allocated_space+0xa56>
f0116a13:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116a17:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0116a1b:	83 ec 04             	sub    $0x4,%esp
f0116a1e:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116a24:	50                   	push   %eax
f0116a25:	68 dc 37 13 f0       	push   $0xf01337dc
f0116a2a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116a30:	50                   	push   %eax
f0116a31:	e8 75 46 00 00       	call   f011b0ab <strcconcat>
f0116a36:	83 c4 10             	add    $0x10,%esp
f0116a39:	83 ec 0c             	sub    $0xc,%esp
f0116a3c:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116a42:	50                   	push   %eax
f0116a43:	e8 d3 b3 fe ff       	call   f0101e1b <execute_command>
f0116a48:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0116a4b:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116a52:	00 00 00 
		num_pages = 0;
f0116a55:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116a5c:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0116a5f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116a62:	89 d0                	mov    %edx,%eax
f0116a64:	c1 e0 02             	shl    $0x2,%eax
f0116a67:	01 d0                	add    %edx,%eax
f0116a69:	01 c0                	add    %eax,%eax
f0116a6b:	05 00 00 40 00       	add    $0x400000,%eax
f0116a70:	89 c2                	mov    %eax,%edx
f0116a72:	83 ec 0c             	sub    $0xc,%esp
f0116a75:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116a7b:	50                   	push   %eax
f0116a7c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116a82:	50                   	push   %eax
f0116a83:	52                   	push   %edx
f0116a84:	68 00 00 40 00       	push   $0x400000
f0116a89:	ff 75 d8             	pushl  -0x28(%ebp)
f0116a8c:	e8 73 41 ff ff       	call   f010ac04 <calculate_allocated_space>
f0116a91:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116a94:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116a9b:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116aa2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116aa8:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116aab:	74 28                	je     f0116ad5 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116aad:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116ab3:	83 ec 0c             	sub    $0xc,%esp
f0116ab6:	ff 75 c8             	pushl  -0x38(%ebp)
f0116ab9:	50                   	push   %eax
f0116aba:	68 bc 47 13 f0       	push   $0xf01347bc
f0116abf:	68 53 08 00 00       	push   $0x853
f0116ac4:	68 72 2a 13 f0       	push   $0xf0132a72
f0116ac9:	e8 86 a5 fe ff       	call   f0101054 <_warn>
f0116ace:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116ad1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116ad5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116adb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116ade:	74 28                	je     f0116b08 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116ae0:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116ae6:	83 ec 0c             	sub    $0xc,%esp
f0116ae9:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116aec:	50                   	push   %eax
f0116aed:	68 1c 48 13 f0       	push   $0xf013481c
f0116af2:	68 58 08 00 00       	push   $0x858
f0116af7:	68 72 2a 13 f0       	push   $0xf0132a72
f0116afc:	e8 53 a5 fe ff       	call   f0101054 <_warn>
f0116b01:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116b04:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116b08:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116b0c:	74 04                	je     f0116b12 <test_calculate_allocated_space+0xb51>
f0116b0e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116b12:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0116b16:	83 ec 04             	sub    $0x4,%esp
f0116b19:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116b1f:	50                   	push   %eax
f0116b20:	68 e6 37 13 f0       	push   $0xf01337e6
f0116b25:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116b2b:	50                   	push   %eax
f0116b2c:	e8 7a 45 00 00       	call   f011b0ab <strcconcat>
f0116b31:	83 c4 10             	add    $0x10,%esp
f0116b34:	83 ec 0c             	sub    $0xc,%esp
f0116b37:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116b3d:	50                   	push   %eax
f0116b3e:	e8 d8 b2 fe ff       	call   f0101e1b <execute_command>
f0116b43:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0116b46:	83 ec 04             	sub    $0x4,%esp
f0116b49:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116b4f:	50                   	push   %eax
f0116b50:	68 24 47 13 f0       	push   $0xf0134724
f0116b55:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116b5b:	50                   	push   %eax
f0116b5c:	e8 4a 45 00 00       	call   f011b0ab <strcconcat>
f0116b61:	83 c4 10             	add    $0x10,%esp
f0116b64:	83 ec 0c             	sub    $0xc,%esp
f0116b67:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116b6d:	50                   	push   %eax
f0116b6e:	e8 a8 b2 fe ff       	call   f0101e1b <execute_command>
f0116b73:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0116b76:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116b7d:	00 00 00 
		num_pages = 0;
f0116b80:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116b87:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0116b8a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116b8d:	05 00 00 38 00       	add    $0x380000,%eax
f0116b92:	01 c0                	add    %eax,%eax
f0116b94:	89 c2                	mov    %eax,%edx
f0116b96:	83 ec 0c             	sub    $0xc,%esp
f0116b99:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116b9f:	50                   	push   %eax
f0116ba0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116ba6:	50                   	push   %eax
f0116ba7:	52                   	push   %edx
f0116ba8:	68 00 00 70 00       	push   $0x700000
f0116bad:	ff 75 d8             	pushl  -0x28(%ebp)
f0116bb0:	e8 4f 40 ff ff       	call   f010ac04 <calculate_allocated_space>
f0116bb5:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116bb8:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f0116bbf:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116bc6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116bcc:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116bcf:	74 28                	je     f0116bf9 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116bd1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116bd7:	83 ec 0c             	sub    $0xc,%esp
f0116bda:	ff 75 c8             	pushl  -0x38(%ebp)
f0116bdd:	50                   	push   %eax
f0116bde:	68 bc 47 13 f0       	push   $0xf01347bc
f0116be3:	68 6a 08 00 00       	push   $0x86a
f0116be8:	68 72 2a 13 f0       	push   $0xf0132a72
f0116bed:	e8 62 a4 fe ff       	call   f0101054 <_warn>
f0116bf2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116bf5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116bf9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116bff:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116c02:	74 28                	je     f0116c2c <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116c04:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116c0a:	83 ec 0c             	sub    $0xc,%esp
f0116c0d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116c10:	50                   	push   %eax
f0116c11:	68 1c 48 13 f0       	push   $0xf013481c
f0116c16:	68 6f 08 00 00       	push   $0x86f
f0116c1b:	68 72 2a 13 f0       	push   $0xf0132a72
f0116c20:	e8 2f a4 fe ff       	call   f0101054 <_warn>
f0116c25:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116c28:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116c2c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116c30:	74 04                	je     f0116c36 <test_calculate_allocated_space+0xc75>
f0116c32:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116c36:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f0116c3a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116c41:	00 00 00 
		num_pages = 0;
f0116c44:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116c4b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0116c4e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116c51:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0116c56:	89 c2                	mov    %eax,%edx
f0116c58:	83 ec 0c             	sub    $0xc,%esp
f0116c5b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116c61:	50                   	push   %eax
f0116c62:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116c68:	50                   	push   %eax
f0116c69:	52                   	push   %edx
f0116c6a:	68 ff ff 3f 00       	push   $0x3fffff
f0116c6f:	ff 75 d8             	pushl  -0x28(%ebp)
f0116c72:	e8 8d 3f ff ff       	call   f010ac04 <calculate_allocated_space>
f0116c77:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116c7a:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f0116c81:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116c88:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116c8e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116c91:	74 28                	je     f0116cbb <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116c93:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116c99:	83 ec 0c             	sub    $0xc,%esp
f0116c9c:	ff 75 c8             	pushl  -0x38(%ebp)
f0116c9f:	50                   	push   %eax
f0116ca0:	68 bc 47 13 f0       	push   $0xf01347bc
f0116ca5:	68 7d 08 00 00       	push   $0x87d
f0116caa:	68 72 2a 13 f0       	push   $0xf0132a72
f0116caf:	e8 a0 a3 fe ff       	call   f0101054 <_warn>
f0116cb4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116cb7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116cbb:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116cc1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116cc4:	74 28                	je     f0116cee <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116cc6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116ccc:	83 ec 0c             	sub    $0xc,%esp
f0116ccf:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116cd2:	50                   	push   %eax
f0116cd3:	68 1c 48 13 f0       	push   $0xf013481c
f0116cd8:	68 82 08 00 00       	push   $0x882
f0116cdd:	68 72 2a 13 f0       	push   $0xf0132a72
f0116ce2:	e8 6d a3 fe ff       	call   f0101054 <_warn>
f0116ce7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116cea:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116cee:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116cf2:	74 04                	je     f0116cf8 <test_calculate_allocated_space+0xd37>
f0116cf4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116cf8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0116cfc:	83 ec 0c             	sub    $0xc,%esp
f0116cff:	68 97 37 13 f0       	push   $0xf0133797
f0116d04:	e8 53 ae fe ff       	call   f0101b5c <cprintf>
f0116d09:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f0116d0c:	83 ec 08             	sub    $0x8,%esp
f0116d0f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116d12:	68 78 48 13 f0       	push   $0xf0134878
f0116d17:	e8 40 ae fe ff       	call   f0101b5c <cprintf>
f0116d1c:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0116d1f:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116d23:	75 10                	jne    f0116d35 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0116d25:	83 ec 0c             	sub    $0xc,%esp
f0116d28:	68 b8 48 13 f0       	push   $0xf01348b8
f0116d2d:	e8 2a ae fe ff       	call   f0101b5c <cprintf>
f0116d32:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116d35:	a1 40 64 85 f0       	mov    0xf0856440,%eax
f0116d3a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0116d3d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116d40:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0116d43:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116d48:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116d4b:	5b                   	pop    %ebx
f0116d4c:	5e                   	pop    %esi
f0116d4d:	5f                   	pop    %edi
f0116d4e:	5d                   	pop    %ebp
f0116d4f:	c3                   	ret    

f0116d50 <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f0116d50:	55                   	push   %ebp
f0116d51:	89 e5                	mov    %esp,%ebp
f0116d53:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0116d56:	8b 45 10             	mov    0x10(%ebp),%eax
f0116d59:	ba 01 00 00 00       	mov    $0x1,%edx
f0116d5e:	88 c1                	mov    %al,%cl
f0116d60:	d3 e2                	shl    %cl,%edx
f0116d62:	89 d0                	mov    %edx,%eax
f0116d64:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116d67:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116d6a:	c1 e8 16             	shr    $0x16,%eax
f0116d6d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116d74:	8b 45 08             	mov    0x8(%ebp),%eax
f0116d77:	01 d0                	add    %edx,%eax
f0116d79:	8b 00                	mov    (%eax),%eax
f0116d7b:	83 e0 01             	and    $0x1,%eax
f0116d7e:	85 c0                	test   %eax,%eax
f0116d80:	75 07                	jne    f0116d89 <CB+0x39>
f0116d82:	b8 00 00 00 00       	mov    $0x0,%eax
f0116d87:	eb 76                	jmp    f0116dff <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116d89:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116d8c:	c1 e8 16             	shr    $0x16,%eax
f0116d8f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116d96:	8b 45 08             	mov    0x8(%ebp),%eax
f0116d99:	01 d0                	add    %edx,%eax
f0116d9b:	8b 00                	mov    (%eax),%eax
f0116d9d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116da2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116da5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116da8:	c1 e8 0c             	shr    $0xc,%eax
f0116dab:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0116dae:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f0116db3:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116db6:	72 17                	jb     f0116dcf <CB+0x7f>
f0116db8:	ff 75 f0             	pushl  -0x10(%ebp)
f0116dbb:	68 04 49 13 f0       	push   $0xf0134904
f0116dc0:	68 9d 08 00 00       	push   $0x89d
f0116dc5:	68 72 2a 13 f0       	push   $0xf0132a72
f0116dca:	e8 e0 a0 fe ff       	call   f0100eaf <_panic>
f0116dcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116dd2:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116dd7:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0116dda:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116ddd:	c1 e8 0c             	shr    $0xc,%eax
f0116de0:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116de5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116dec:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116def:	01 d0                	add    %edx,%eax
f0116df1:	8b 00                	mov    (%eax),%eax
f0116df3:	23 45 f4             	and    -0xc(%ebp),%eax
f0116df6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116df9:	0f 94 c0             	sete   %al
f0116dfc:	0f b6 c0             	movzbl %al,%eax
}
f0116dff:	c9                   	leave  
f0116e00:	c3                   	ret    

f0116e01 <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f0116e01:	55                   	push   %ebp
f0116e02:	89 e5                	mov    %esp,%ebp
f0116e04:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116e07:	68 33 49 13 f0       	push   $0xf0134933
f0116e0c:	68 42 49 13 f0       	push   $0xf0134942
f0116e11:	68 a2 08 00 00       	push   $0x8a2
f0116e16:	68 72 2a 13 f0       	push   $0xf0132a72
f0116e1b:	e8 8f a0 fe ff       	call   f0100eaf <_panic>

f0116e20 <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f0116e20:	55                   	push   %ebp
f0116e21:	89 e5                	mov    %esp,%ebp
f0116e23:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116e26:	68 33 49 13 f0       	push   $0xf0134933
f0116e2b:	68 42 49 13 f0       	push   $0xf0134942
f0116e30:	68 ac 08 00 00       	push   $0x8ac
f0116e35:	68 72 2a 13 f0       	push   $0xf0132a72
f0116e3a:	e8 70 a0 fe ff       	call   f0100eaf <_panic>

f0116e3f <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f0116e3f:	55                   	push   %ebp
f0116e40:	89 e5                	mov    %esp,%ebp
f0116e42:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116e45:	68 33 49 13 f0       	push   $0xf0134933
f0116e4a:	68 42 49 13 f0       	push   $0xf0134942
f0116e4f:	68 bb 08 00 00       	push   $0x8bb
f0116e54:	68 72 2a 13 f0       	push   $0xf0132a72
f0116e59:	e8 51 a0 fe ff       	call   f0100eaf <_panic>

f0116e5e <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return (table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF) + (va & 0xFFF);
}

int CE(uint32 *_d, uint32 va)
{
f0116e5e:	55                   	push   %ebp
f0116e5f:	89 e5                	mov    %esp,%ebp
f0116e61:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116e64:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116e67:	c1 e8 16             	shr    $0x16,%eax
f0116e6a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116e71:	8b 45 08             	mov    0x8(%ebp),%eax
f0116e74:	01 d0                	add    %edx,%eax
f0116e76:	8b 00                	mov    (%eax),%eax
f0116e78:	83 e0 01             	and    $0x1,%eax
f0116e7b:	85 c0                	test   %eax,%eax
f0116e7d:	75 07                	jne    f0116e86 <CE+0x28>
f0116e7f:	b8 00 00 00 00       	mov    $0x0,%eax
f0116e84:	eb 7a                	jmp    f0116f00 <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116e86:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116e89:	c1 e8 16             	shr    $0x16,%eax
f0116e8c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116e93:	8b 45 08             	mov    0x8(%ebp),%eax
f0116e96:	01 d0                	add    %edx,%eax
f0116e98:	8b 00                	mov    (%eax),%eax
f0116e9a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116e9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116ea2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116ea5:	c1 e8 0c             	shr    $0xc,%eax
f0116ea8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116eab:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f0116eb0:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116eb3:	72 17                	jb     f0116ecc <CE+0x6e>
f0116eb5:	ff 75 f4             	pushl  -0xc(%ebp)
f0116eb8:	68 04 49 13 f0       	push   $0xf0134904
f0116ebd:	68 c4 08 00 00       	push   $0x8c4
f0116ec2:	68 72 2a 13 f0       	push   $0xf0132a72
f0116ec7:	e8 e3 9f fe ff       	call   f0100eaf <_panic>
f0116ecc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116ecf:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116ed4:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0116ed7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116eda:	c1 e8 0c             	shr    $0xc,%eax
f0116edd:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116ee2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116ee9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116eec:	01 d0                	add    %edx,%eax
f0116eee:	8b 00                	mov    (%eax),%eax
f0116ef0:	85 c0                	test   %eax,%eax
f0116ef2:	74 07                	je     f0116efb <CE+0x9d>
f0116ef4:	b8 00 00 00 00       	mov    $0x0,%eax
f0116ef9:	eb 05                	jmp    f0116f00 <CE+0xa2>
	return 1;
f0116efb:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116f00:	c9                   	leave  
f0116f01:	c3                   	ret    

f0116f02 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0116f02:	55                   	push   %ebp
f0116f03:	89 e5                	mov    %esp,%ebp
f0116f05:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116f08:	68 33 49 13 f0       	push   $0xf0134933
f0116f0d:	68 42 49 13 f0       	push   $0xf0134942
f0116f12:	68 cb 08 00 00       	push   $0x8cb
f0116f17:	68 72 2a 13 f0       	push   $0xf0132a72
f0116f1c:	e8 8e 9f fe ff       	call   f0100eaf <_panic>

f0116f21 <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f0116f21:	55                   	push   %ebp
f0116f22:	89 e5                	mov    %esp,%ebp
f0116f24:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116f27:	68 33 49 13 f0       	push   $0xf0134933
f0116f2c:	68 42 49 13 f0       	push   $0xf0134942
f0116f31:	68 db 08 00 00       	push   $0x8db
f0116f36:	68 72 2a 13 f0       	push   $0xf0132a72
f0116f3b:	e8 6f 9f fe ff       	call   f0100eaf <_panic>

f0116f40 <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f0116f40:	55                   	push   %ebp
f0116f41:	89 e5                	mov    %esp,%ebp
f0116f43:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116f46:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0116f4d:	eb 18                	jmp    f0116f67 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0116f4f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116f52:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116f59:	8b 45 08             	mov    0x8(%ebp),%eax
f0116f5c:	01 d0                	add    %edx,%eax
f0116f5e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116f64:	ff 45 fc             	incl   -0x4(%ebp)
f0116f67:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116f6a:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0116f6f:	76 de                	jbe    f0116f4f <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0116f71:	90                   	nop
f0116f72:	c9                   	leave  
f0116f73:	c3                   	ret    

f0116f74 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0116f74:	55                   	push   %ebp
f0116f75:	89 e5                	mov    %esp,%ebp
f0116f77:	83 ec 38             	sub    $0x38,%esp
f0116f7a:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0116f7d:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0116f80:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116f83:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116f88:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0116f8b:	8b 45 10             	mov    0x10(%ebp),%eax
f0116f8e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116f93:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116f96:	e9 ea 01 00 00       	jmp    f0117185 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0116f9b:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116f9f:	74 44                	je     f0116fe5 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0116fa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116fa4:	83 ec 04             	sub    $0x4,%esp
f0116fa7:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116faa:	52                   	push   %edx
f0116fab:	50                   	push   %eax
f0116fac:	ff 75 08             	pushl  0x8(%ebp)
f0116faf:	e8 1c 26 ff ff       	call   f01095d0 <get_frame_info>
f0116fb4:	83 c4 10             	add    $0x10,%esp
f0116fb7:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116fba:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116fbd:	85 c0                	test   %eax,%eax
f0116fbf:	75 24                	jne    f0116fe5 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0116fc1:	83 ec 04             	sub    $0x4,%esp
f0116fc4:	68 58 49 13 f0       	push   $0xf0134958
f0116fc9:	68 f8 08 00 00       	push   $0x8f8
f0116fce:	68 72 2a 13 f0       	push   $0xf0132a72
f0116fd3:	e8 7c a0 fe ff       	call   f0101054 <_warn>
f0116fd8:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116fdb:	b8 00 00 00 00       	mov    $0x0,%eax
f0116fe0:	e9 b6 01 00 00       	jmp    f011719b <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116fe5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116fe8:	83 ec 04             	sub    $0x4,%esp
f0116feb:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0116fee:	52                   	push   %edx
f0116fef:	50                   	push   %eax
f0116ff0:	ff 75 08             	pushl  0x8(%ebp)
f0116ff3:	e8 d8 25 ff ff       	call   f01095d0 <get_frame_info>
f0116ff8:	83 c4 10             	add    $0x10,%esp
f0116ffb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0116ffe:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0117001:	85 c0                	test   %eax,%eax
f0117003:	75 24                	jne    f0117029 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0117005:	83 ec 04             	sub    $0x4,%esp
f0117008:	68 84 49 13 f0       	push   $0xf0134984
f011700d:	68 ff 08 00 00       	push   $0x8ff
f0117012:	68 72 2a 13 f0       	push   $0xf0132a72
f0117017:	e8 38 a0 fe ff       	call   f0101054 <_warn>
f011701c:	83 c4 10             	add    $0x10,%esp
			return 0;
f011701f:	b8 00 00 00 00       	mov    $0x0,%eax
f0117024:	e9 72 01 00 00       	jmp    f011719b <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0117029:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f011702d:	75 70                	jne    f011709f <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f011702f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117032:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0117035:	c1 ea 0c             	shr    $0xc,%edx
f0117038:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011703e:	c1 e2 02             	shl    $0x2,%edx
f0117041:	01 d0                	add    %edx,%eax
f0117043:	8b 00                	mov    (%eax),%eax
f0117045:	c1 e8 0c             	shr    $0xc,%eax
f0117048:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f011704b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011704e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0117051:	c1 ea 0c             	shr    $0xc,%edx
f0117054:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011705a:	c1 e2 02             	shl    $0x2,%edx
f011705d:	01 d0                	add    %edx,%eax
f011705f:	8b 00                	mov    (%eax),%eax
f0117061:	c1 e8 0c             	shr    $0xc,%eax
f0117064:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0117067:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011706a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011706d:	74 30                	je     f011709f <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f011706f:	83 ec 04             	sub    $0x4,%esp
f0117072:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117075:	ff 75 e8             	pushl  -0x18(%ebp)
f0117078:	ff 75 f0             	pushl  -0x10(%ebp)
f011707b:	ff 75 f4             	pushl  -0xc(%ebp)
f011707e:	68 b0 49 13 f0       	push   $0xf01349b0
f0117083:	68 09 09 00 00       	push   $0x909
f0117088:	68 72 2a 13 f0       	push   $0xf0132a72
f011708d:	e8 c2 9f fe ff       	call   f0101054 <_warn>
f0117092:	83 c4 20             	add    $0x20,%esp
				return 0;
f0117095:	b8 00 00 00 00       	mov    $0x0,%eax
f011709a:	e9 fc 00 00 00       	jmp    f011719b <CCP+0x227>
			}
		}
		if (ref != -1)
f011709f:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f01170a3:	74 52                	je     f01170f7 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f01170a5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01170a9:	74 0e                	je     f01170b9 <CCP+0x145>
f01170ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01170ae:	8b 40 08             	mov    0x8(%eax),%eax
f01170b1:	0f b7 c0             	movzwl %ax,%eax
f01170b4:	3b 45 18             	cmp    0x18(%ebp),%eax
f01170b7:	74 3e                	je     f01170f7 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f01170b9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01170bd:	74 0b                	je     f01170ca <CCP+0x156>
f01170bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01170c2:	8b 40 08             	mov    0x8(%eax),%eax
f01170c5:	0f b7 c0             	movzwl %ax,%eax
f01170c8:	eb 05                	jmp    f01170cf <CCP+0x15b>
f01170ca:	b8 00 00 00 00       	mov    $0x0,%eax
f01170cf:	83 ec 0c             	sub    $0xc,%esp
f01170d2:	50                   	push   %eax
f01170d3:	ff 75 f0             	pushl  -0x10(%ebp)
f01170d6:	68 0c 4a 13 f0       	push   $0xf0134a0c
f01170db:	68 11 09 00 00       	push   $0x911
f01170e0:	68 72 2a 13 f0       	push   $0xf0132a72
f01170e5:	e8 6a 9f fe ff       	call   f0101054 <_warn>
f01170ea:	83 c4 20             	add    $0x20,%esp
				return 0;
f01170ed:	b8 00 00 00 00       	mov    $0x0,%eax
f01170f2:	e9 a4 00 00 00       	jmp    f011719b <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f01170f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01170fa:	ff 75 20             	pushl  0x20(%ebp)
f01170fd:	ff 75 1c             	pushl  0x1c(%ebp)
f0117100:	50                   	push   %eax
f0117101:	ff 75 08             	pushl  0x8(%ebp)
f0117104:	e8 17 fd ff ff       	call   f0116e20 <CPs>
f0117109:	83 c4 10             	add    $0x10,%esp
f011710c:	85 c0                	test   %eax,%eax
f011710e:	7f 21                	jg     f0117131 <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0117110:	83 ec 04             	sub    $0x4,%esp
f0117113:	68 7c 4a 13 f0       	push   $0xf0134a7c
f0117118:	68 17 09 00 00       	push   $0x917
f011711d:	68 72 2a 13 f0       	push   $0xf0132a72
f0117122:	e8 2d 9f fe ff       	call   f0101054 <_warn>
f0117127:	83 c4 10             	add    $0x10,%esp
			return 0;
f011712a:	b8 00 00 00 00       	mov    $0x0,%eax
f011712f:	eb 6a                	jmp    f011719b <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0117131:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0117135:	74 3a                	je     f0117171 <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0117137:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011713a:	ff 75 28             	pushl  0x28(%ebp)
f011713d:	ff 75 24             	pushl  0x24(%ebp)
f0117140:	50                   	push   %eax
f0117141:	ff 75 08             	pushl  0x8(%ebp)
f0117144:	e8 d7 fc ff ff       	call   f0116e20 <CPs>
f0117149:	83 c4 10             	add    $0x10,%esp
f011714c:	85 c0                	test   %eax,%eax
f011714e:	7f 21                	jg     f0117171 <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0117150:	83 ec 04             	sub    $0x4,%esp
f0117153:	68 c4 4a 13 f0       	push   $0xf0134ac4
f0117158:	68 1e 09 00 00       	push   $0x91e
f011715d:	68 72 2a 13 f0       	push   $0xf0132a72
f0117162:	e8 ed 9e fe ff       	call   f0101054 <_warn>
f0117167:	83 c4 10             	add    $0x10,%esp
				return 0;
f011716a:	b8 00 00 00 00       	mov    $0x0,%eax
f011716f:	eb 2a                	jmp    f011719b <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0117171:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0117175:	74 07                	je     f011717e <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0117177:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f011717e:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0117185:	8b 55 10             	mov    0x10(%ebp),%edx
f0117188:	8b 45 14             	mov    0x14(%ebp),%eax
f011718b:	01 d0                	add    %edx,%eax
f011718d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0117190:	0f 87 05 fe ff ff    	ja     f0116f9b <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0117196:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011719b:	c9                   	leave  
f011719c:	c3                   	ret    

f011719d <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f011719d:	55                   	push   %ebp
f011719e:	89 e5                	mov    %esp,%ebp
f01171a0:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f01171a3:	83 ec 04             	sub    $0x4,%esp
f01171a6:	68 04 4b 13 f0       	push   $0xf0134b04
f01171ab:	6a 0e                	push   $0xe
f01171ad:	68 14 4b 13 f0       	push   $0xf0134b14
f01171b2:	e8 f8 9c fe ff       	call   f0100eaf <_panic>

f01171b7 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f01171b7:	55                   	push   %ebp
f01171b8:	89 e5                	mov    %esp,%ebp
f01171ba:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f01171bd:	83 ec 04             	sub    $0x4,%esp
f01171c0:	68 04 4b 13 f0       	push   $0xf0134b04
f01171c5:	68 d7 00 00 00       	push   $0xd7
f01171ca:	68 14 4b 13 f0       	push   $0xf0134b14
f01171cf:	e8 db 9c fe ff       	call   f0100eaf <_panic>

f01171d4 <get_kheap_strategy>:
static inline uint32 get_kheap_strategy(){return kheapPlacementStrategy ;}
f01171d4:	55                   	push   %ebp
f01171d5:	89 e5                	mov    %esp,%ebp
f01171d7:	a1 24 60 85 f0       	mov    0xf0856024,%eax
f01171dc:	5d                   	pop    %ebp
f01171dd:	c3                   	ret    

f01171de <test_kmalloc>:


uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;

int test_kmalloc(uint32 ALLOC_TYPE)
{
f01171de:	55                   	push   %ebp
f01171df:	89 e5                	mov    %esp,%ebp
f01171e1:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f01171e4:	e8 eb ff ff ff       	call   f01171d4 <get_kheap_strategy>
f01171e9:	83 f8 01             	cmp    $0x1,%eax
f01171ec:	75 34                	jne    f0117222 <test_kmalloc+0x44>
	{
		//Test FIRST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01171ee:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01171f2:	75 0a                	jne    f01171fe <test_kmalloc+0x20>
			test_kmalloc_FF_page();
f01171f4:	e8 d3 03 00 00       	call   f01175cc <test_kmalloc_FF_page>
f01171f9:	e9 f3 00 00 00       	jmp    f01172f1 <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01171fe:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117202:	75 0a                	jne    f011720e <test_kmalloc+0x30>
			test_kmalloc_FF_block();
f0117204:	e8 54 04 00 00       	call   f011765d <test_kmalloc_FF_block>
f0117209:	e9 e3 00 00 00       	jmp    f01172f1 <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011720e:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117212:	0f 85 d9 00 00 00    	jne    f01172f1 <test_kmalloc+0x113>
			test_kmalloc_FF_both();
f0117218:	e8 d1 04 00 00       	call   f01176ee <test_kmalloc_FF_both>
f011721d:	e9 cf 00 00 00       	jmp    f01172f1 <test_kmalloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f0117222:	e8 ad ff ff ff       	call   f01171d4 <get_kheap_strategy>
f0117227:	83 f8 02             	cmp    $0x2,%eax
f011722a:	75 34                	jne    f0117260 <test_kmalloc+0x82>
	{
		//Test BEST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011722c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117230:	75 0a                	jne    f011723c <test_kmalloc+0x5e>
			test_kmalloc_BF_page();
f0117232:	e8 cf 03 00 00       	call   f0117606 <test_kmalloc_BF_page>
f0117237:	e9 b5 00 00 00       	jmp    f01172f1 <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011723c:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117240:	75 0a                	jne    f011724c <test_kmalloc+0x6e>
			test_kmalloc_BF_block();
f0117242:	e8 50 04 00 00       	call   f0117697 <test_kmalloc_BF_block>
f0117247:	e9 a5 00 00 00       	jmp    f01172f1 <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011724c:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117250:	0f 85 9b 00 00 00    	jne    f01172f1 <test_kmalloc+0x113>
			test_kmalloc_BF_both();
f0117256:	e8 cd 04 00 00       	call   f0117728 <test_kmalloc_BF_both>
f011725b:	e9 91 00 00 00       	jmp    f01172f1 <test_kmalloc+0x113>
	}
	else if(get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f0117260:	e8 6f ff ff ff       	call   f01171d4 <get_kheap_strategy>
f0117265:	83 f8 03             	cmp    $0x3,%eax
f0117268:	75 27                	jne    f0117291 <test_kmalloc+0xb3>
	{
		//Test NEXT FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011726a:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011726e:	75 07                	jne    f0117277 <test_kmalloc+0x99>
			test_kmalloc_NF_page();
f0117270:	e8 74 03 00 00       	call   f01175e9 <test_kmalloc_NF_page>
f0117275:	eb 7a                	jmp    f01172f1 <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117277:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011727b:	75 07                	jne    f0117284 <test_kmalloc+0xa6>
			test_kmalloc_NF_block();
f011727d:	e8 f8 03 00 00       	call   f011767a <test_kmalloc_NF_block>
f0117282:	eb 6d                	jmp    f01172f1 <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117284:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117288:	75 67                	jne    f01172f1 <test_kmalloc+0x113>
			test_kmalloc_NF_both();
f011728a:	e8 7c 04 00 00       	call   f011770b <test_kmalloc_NF_both>
f011728f:	eb 60                	jmp    f01172f1 <test_kmalloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f0117291:	e8 3e ff ff ff       	call   f01171d4 <get_kheap_strategy>
f0117296:	83 f8 04             	cmp    $0x4,%eax
f0117299:	75 27                	jne    f01172c2 <test_kmalloc+0xe4>
	{
		//Test WORST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011729b:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011729f:	75 07                	jne    f01172a8 <test_kmalloc+0xca>
			test_kmalloc_WF_page();
f01172a1:	e8 7d 03 00 00       	call   f0117623 <test_kmalloc_WF_page>
f01172a6:	eb 49                	jmp    f01172f1 <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01172a8:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01172ac:	75 07                	jne    f01172b5 <test_kmalloc+0xd7>
			test_kmalloc_WF_block();
f01172ae:	e8 01 04 00 00       	call   f01176b4 <test_kmalloc_WF_block>
f01172b3:	eb 3c                	jmp    f01172f1 <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01172b5:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01172b9:	75 36                	jne    f01172f1 <test_kmalloc+0x113>
			test_kmalloc_WF_both();
f01172bb:	e8 85 04 00 00       	call   f0117745 <test_kmalloc_WF_both>
f01172c0:	eb 2f                	jmp    f01172f1 <test_kmalloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f01172c2:	e8 0d ff ff ff       	call   f01171d4 <get_kheap_strategy>
f01172c7:	83 f8 05             	cmp    $0x5,%eax
f01172ca:	75 25                	jne    f01172f1 <test_kmalloc+0x113>
	{
		//Test CUSTOM FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01172cc:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01172d0:	75 07                	jne    f01172d9 <test_kmalloc+0xfb>
			test_kmalloc_CF_page();
f01172d2:	e8 69 03 00 00       	call   f0117640 <test_kmalloc_CF_page>
f01172d7:	eb 18                	jmp    f01172f1 <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01172d9:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01172dd:	75 07                	jne    f01172e6 <test_kmalloc+0x108>
			test_kmalloc_CF_block();
f01172df:	e8 ed 03 00 00       	call   f01176d1 <test_kmalloc_CF_block>
f01172e4:	eb 0b                	jmp    f01172f1 <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01172e6:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01172ea:	75 05                	jne    f01172f1 <test_kmalloc+0x113>
			test_kmalloc_CF_both();
f01172ec:	e8 71 04 00 00       	call   f0117762 <test_kmalloc_CF_both>
	}
	return 0;
f01172f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01172f6:	c9                   	leave  
f01172f7:	c3                   	ret    

f01172f8 <test_kfree>:

int test_kfree(uint32 ALLOC_TYPE)
{
f01172f8:	55                   	push   %ebp
f01172f9:	89 e5                	mov    %esp,%ebp
f01172fb:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f01172fe:	e8 d1 fe ff ff       	call   f01171d4 <get_kheap_strategy>
f0117303:	83 f8 01             	cmp    $0x1,%eax
f0117306:	75 34                	jne    f011733c <test_kfree+0x44>
	{
		//Test FIRST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117308:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011730c:	75 0a                	jne    f0117318 <test_kfree+0x20>
			test_kfree_FF_page();
f011730e:	e8 6c 04 00 00       	call   f011777f <test_kfree_FF_page>
f0117313:	e9 f3 00 00 00       	jmp    f011740b <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117318:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011731c:	75 0a                	jne    f0117328 <test_kfree+0x30>
			test_kfree_FF_block();
f011731e:	e8 ed 04 00 00       	call   f0117810 <test_kfree_FF_block>
f0117323:	e9 e3 00 00 00       	jmp    f011740b <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117328:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011732c:	0f 85 d9 00 00 00    	jne    f011740b <test_kfree+0x113>
			test_kfree_FF_both();
f0117332:	e8 6a 05 00 00       	call   f01178a1 <test_kfree_FF_both>
f0117337:	e9 cf 00 00 00       	jmp    f011740b <test_kfree+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f011733c:	e8 93 fe ff ff       	call   f01171d4 <get_kheap_strategy>
f0117341:	83 f8 02             	cmp    $0x2,%eax
f0117344:	75 34                	jne    f011737a <test_kfree+0x82>
	{
		//Test BEST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117346:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011734a:	75 0a                	jne    f0117356 <test_kfree+0x5e>
			test_kfree_BF_page();
f011734c:	e8 68 04 00 00       	call   f01177b9 <test_kfree_BF_page>
f0117351:	e9 b5 00 00 00       	jmp    f011740b <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117356:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011735a:	75 0a                	jne    f0117366 <test_kfree+0x6e>
			test_kfree_BF_block();
f011735c:	e8 e9 04 00 00       	call   f011784a <test_kfree_BF_block>
f0117361:	e9 a5 00 00 00       	jmp    f011740b <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117366:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011736a:	0f 85 9b 00 00 00    	jne    f011740b <test_kfree+0x113>
			test_kfree_BF_both();
f0117370:	e8 66 05 00 00       	call   f01178db <test_kfree_BF_both>
f0117375:	e9 91 00 00 00       	jmp    f011740b <test_kfree+0x113>
	}
	else if(get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f011737a:	e8 55 fe ff ff       	call   f01171d4 <get_kheap_strategy>
f011737f:	83 f8 03             	cmp    $0x3,%eax
f0117382:	75 27                	jne    f01173ab <test_kfree+0xb3>
	{
		//Test NEXT FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117384:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117388:	75 07                	jne    f0117391 <test_kfree+0x99>
			test_kfree_NF_page();
f011738a:	e8 0d 04 00 00       	call   f011779c <test_kfree_NF_page>
f011738f:	eb 7a                	jmp    f011740b <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117391:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117395:	75 07                	jne    f011739e <test_kfree+0xa6>
			test_kfree_NF_block();
f0117397:	e8 91 04 00 00       	call   f011782d <test_kfree_NF_block>
f011739c:	eb 6d                	jmp    f011740b <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011739e:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01173a2:	75 67                	jne    f011740b <test_kfree+0x113>
			test_kfree_NF_both();
f01173a4:	e8 15 05 00 00       	call   f01178be <test_kfree_NF_both>
f01173a9:	eb 60                	jmp    f011740b <test_kfree+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f01173ab:	e8 24 fe ff ff       	call   f01171d4 <get_kheap_strategy>
f01173b0:	83 f8 04             	cmp    $0x4,%eax
f01173b3:	75 27                	jne    f01173dc <test_kfree+0xe4>
	{
		//Test WORST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01173b5:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01173b9:	75 07                	jne    f01173c2 <test_kfree+0xca>
			test_kfree_WF_page();
f01173bb:	e8 16 04 00 00       	call   f01177d6 <test_kfree_WF_page>
f01173c0:	eb 49                	jmp    f011740b <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01173c2:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01173c6:	75 07                	jne    f01173cf <test_kfree+0xd7>
			test_kfree_WF_block();
f01173c8:	e8 9a 04 00 00       	call   f0117867 <test_kfree_WF_block>
f01173cd:	eb 3c                	jmp    f011740b <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01173cf:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01173d3:	75 36                	jne    f011740b <test_kfree+0x113>
			test_kfree_WF_both();
f01173d5:	e8 1e 05 00 00       	call   f01178f8 <test_kfree_WF_both>
f01173da:	eb 2f                	jmp    f011740b <test_kfree+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f01173dc:	e8 f3 fd ff ff       	call   f01171d4 <get_kheap_strategy>
f01173e1:	83 f8 05             	cmp    $0x5,%eax
f01173e4:	75 25                	jne    f011740b <test_kfree+0x113>
	{
		//Test CUSTOM FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01173e6:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01173ea:	75 07                	jne    f01173f3 <test_kfree+0xfb>
			test_kfree_CF_page();
f01173ec:	e8 02 04 00 00       	call   f01177f3 <test_kfree_CF_page>
f01173f1:	eb 18                	jmp    f011740b <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01173f3:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01173f7:	75 07                	jne    f0117400 <test_kfree+0x108>
			test_kfree_CF_block();
f01173f9:	e8 86 04 00 00       	call   f0117884 <test_kfree_CF_block>
f01173fe:	eb 0b                	jmp    f011740b <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117400:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117404:	75 05                	jne    f011740b <test_kfree+0x113>
			test_kfree_CF_both();
f0117406:	e8 0a 05 00 00       	call   f0117915 <test_kfree_CF_both>
	}
	return 0;
f011740b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0117410:	c9                   	leave  
f0117411:	c3                   	ret    

f0117412 <test_krealloc>:
int test_krealloc(uint32 ALLOC_TYPE)
{
f0117412:	55                   	push   %ebp
f0117413:	89 e5                	mov    %esp,%ebp
f0117415:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f0117418:	e8 b7 fd ff ff       	call   f01171d4 <get_kheap_strategy>
f011741d:	83 f8 01             	cmp    $0x1,%eax
f0117420:	75 34                	jne    f0117456 <test_krealloc+0x44>
	{
		//Test FIRST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117422:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117426:	75 0a                	jne    f0117432 <test_krealloc+0x20>
			test_krealloc_FF_page();
f0117428:	e8 05 05 00 00       	call   f0117932 <test_krealloc_FF_page>
f011742d:	e9 f3 00 00 00       	jmp    f0117525 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117432:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117436:	75 0a                	jne    f0117442 <test_krealloc+0x30>
			test_krealloc_FF_block();
f0117438:	e8 86 05 00 00       	call   f01179c3 <test_krealloc_FF_block>
f011743d:	e9 e3 00 00 00       	jmp    f0117525 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117442:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117446:	0f 85 d9 00 00 00    	jne    f0117525 <test_krealloc+0x113>
			test_krealloc_FF_both();
f011744c:	e8 03 06 00 00       	call   f0117a54 <test_krealloc_FF_both>
f0117451:	e9 cf 00 00 00       	jmp    f0117525 <test_krealloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f0117456:	e8 79 fd ff ff       	call   f01171d4 <get_kheap_strategy>
f011745b:	83 f8 02             	cmp    $0x2,%eax
f011745e:	75 34                	jne    f0117494 <test_krealloc+0x82>
	{
		//Test BEST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117460:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117464:	75 0a                	jne    f0117470 <test_krealloc+0x5e>
			test_krealloc_BF_page();
f0117466:	e8 01 05 00 00       	call   f011796c <test_krealloc_BF_page>
f011746b:	e9 b5 00 00 00       	jmp    f0117525 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117470:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117474:	75 0a                	jne    f0117480 <test_krealloc+0x6e>
			test_krealloc_BF_block();
f0117476:	e8 82 05 00 00       	call   f01179fd <test_krealloc_BF_block>
f011747b:	e9 a5 00 00 00       	jmp    f0117525 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117480:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117484:	0f 85 9b 00 00 00    	jne    f0117525 <test_krealloc+0x113>
			test_krealloc_BF_both();
f011748a:	e8 ff 05 00 00       	call   f0117a8e <test_krealloc_BF_both>
f011748f:	e9 91 00 00 00       	jmp    f0117525 <test_krealloc+0x113>
	}
	else if(get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f0117494:	e8 3b fd ff ff       	call   f01171d4 <get_kheap_strategy>
f0117499:	83 f8 03             	cmp    $0x3,%eax
f011749c:	75 27                	jne    f01174c5 <test_krealloc+0xb3>
	{
		//Test NEXT FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011749e:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01174a2:	75 07                	jne    f01174ab <test_krealloc+0x99>
			test_krealloc_NF_page();
f01174a4:	e8 a6 04 00 00       	call   f011794f <test_krealloc_NF_page>
f01174a9:	eb 7a                	jmp    f0117525 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01174ab:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01174af:	75 07                	jne    f01174b8 <test_krealloc+0xa6>
			test_krealloc_NF_block();
f01174b1:	e8 2a 05 00 00       	call   f01179e0 <test_krealloc_NF_block>
f01174b6:	eb 6d                	jmp    f0117525 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01174b8:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01174bc:	75 67                	jne    f0117525 <test_krealloc+0x113>
			test_krealloc_NF_both();
f01174be:	e8 ae 05 00 00       	call   f0117a71 <test_krealloc_NF_both>
f01174c3:	eb 60                	jmp    f0117525 <test_krealloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f01174c5:	e8 0a fd ff ff       	call   f01171d4 <get_kheap_strategy>
f01174ca:	83 f8 04             	cmp    $0x4,%eax
f01174cd:	75 27                	jne    f01174f6 <test_krealloc+0xe4>
	{
		//Test WORST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01174cf:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01174d3:	75 07                	jne    f01174dc <test_krealloc+0xca>
			test_krealloc_WF_page();
f01174d5:	e8 af 04 00 00       	call   f0117989 <test_krealloc_WF_page>
f01174da:	eb 49                	jmp    f0117525 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01174dc:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01174e0:	75 07                	jne    f01174e9 <test_krealloc+0xd7>
			test_krealloc_WF_block();
f01174e2:	e8 33 05 00 00       	call   f0117a1a <test_krealloc_WF_block>
f01174e7:	eb 3c                	jmp    f0117525 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01174e9:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01174ed:	75 36                	jne    f0117525 <test_krealloc+0x113>
			test_krealloc_WF_both();
f01174ef:	e8 b7 05 00 00       	call   f0117aab <test_krealloc_WF_both>
f01174f4:	eb 2f                	jmp    f0117525 <test_krealloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f01174f6:	e8 d9 fc ff ff       	call   f01171d4 <get_kheap_strategy>
f01174fb:	83 f8 05             	cmp    $0x5,%eax
f01174fe:	75 25                	jne    f0117525 <test_krealloc+0x113>
	{
		//Test CUSTOM FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117500:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117504:	75 07                	jne    f011750d <test_krealloc+0xfb>
			test_krealloc_CF_page();
f0117506:	e8 9b 04 00 00       	call   f01179a6 <test_krealloc_CF_page>
f011750b:	eb 18                	jmp    f0117525 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011750d:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117511:	75 07                	jne    f011751a <test_krealloc+0x108>
			test_krealloc_CF_block();
f0117513:	e8 1f 05 00 00       	call   f0117a37 <test_krealloc_CF_block>
f0117518:	eb 0b                	jmp    f0117525 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011751a:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011751e:	75 05                	jne    f0117525 <test_krealloc+0x113>
			test_krealloc_CF_both();
f0117520:	e8 a3 05 00 00       	call   f0117ac8 <test_krealloc_CF_both>
	}
	return 0;
f0117525:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011752a:	c9                   	leave  
f011752b:	c3                   	ret    

f011752c <test_fast_page_alloc>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fast_page_alloc()
{
f011752c:	55                   	push   %ebp
f011752d:	89 e5                	mov    %esp,%ebp
f011752f:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f0117532:	e8 9d fc ff ff       	call   f01171d4 <get_kheap_strategy>
f0117537:	83 f8 01             	cmp    $0x1,%eax
f011753a:	75 07                	jne    f0117543 <test_fast_page_alloc+0x17>
	{
		test_fast_FF();
f011753c:	e8 a4 05 00 00       	call   f0117ae5 <test_fast_FF>
f0117541:	eb 42                	jmp    f0117585 <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f0117543:	e8 8c fc ff ff       	call   f01171d4 <get_kheap_strategy>
f0117548:	83 f8 03             	cmp    $0x3,%eax
f011754b:	75 07                	jne    f0117554 <test_fast_page_alloc+0x28>
	{
		test_fast_NF();
f011754d:	e8 b0 05 00 00       	call   f0117b02 <test_fast_NF>
f0117552:	eb 31                	jmp    f0117585 <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f0117554:	e8 7b fc ff ff       	call   f01171d4 <get_kheap_strategy>
f0117559:	83 f8 02             	cmp    $0x2,%eax
f011755c:	75 07                	jne    f0117565 <test_fast_page_alloc+0x39>
	{
		test_fast_BF();
f011755e:	e8 bc 05 00 00       	call   f0117b1f <test_fast_BF>
f0117563:	eb 20                	jmp    f0117585 <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f0117565:	e8 6a fc ff ff       	call   f01171d4 <get_kheap_strategy>
f011756a:	83 f8 04             	cmp    $0x4,%eax
f011756d:	75 07                	jne    f0117576 <test_fast_page_alloc+0x4a>
	{
		test_fast_WF();
f011756f:	e8 c8 05 00 00       	call   f0117b3c <test_fast_WF>
f0117574:	eb 0f                	jmp    f0117585 <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f0117576:	e8 59 fc ff ff       	call   f01171d4 <get_kheap_strategy>
f011757b:	83 f8 05             	cmp    $0x5,%eax
f011757e:	75 05                	jne    f0117585 <test_fast_page_alloc+0x59>
	{
		test_fast_CF();
f0117580:	e8 d4 05 00 00       	call   f0117b59 <test_fast_CF>
	}
	return 0;
f0117585:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011758a:	c9                   	leave  
f011758b:	c3                   	ret    

f011758c <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011758c:	55                   	push   %ebp
f011758d:	89 e5                	mov    %esp,%ebp
f011758f:	81 ec 28 35 00 00    	sub    $0x3528,%esp
	panic("update is required!!");
f0117595:	83 ec 04             	sub    $0x4,%esp
f0117598:	68 30 4b 13 f0       	push   $0xf0134b30
f011759d:	68 28 01 00 00       	push   $0x128
f01175a2:	68 45 4b 13 f0       	push   $0xf0134b45
f01175a7:	e8 03 99 fe ff       	call   f0100eaf <_panic>

f01175ac <test_kheap_virt_addr>:
	return 1;

}

int test_kheap_virt_addr()
{
f01175ac:	55                   	push   %ebp
f01175ad:	89 e5                	mov    %esp,%ebp
f01175af:	81 ec 08 01 00 00    	sub    $0x108,%esp
	panic("update is required!!");
f01175b5:	83 ec 04             	sub    $0x4,%esp
f01175b8:	68 30 4b 13 f0       	push   $0xf0134b30
f01175bd:	68 6d 02 00 00       	push   $0x26d
f01175c2:	68 45 4b 13 f0       	push   $0xf0134b45
f01175c7:	e8 e3 98 fe ff       	call   f0100eaf <_panic>

f01175cc <test_kmalloc_FF_page>:

/**********************************************************************************************/
/********************************** KMALLOC TESTING AREA **************************************/
/**********************************************************************************************/
int test_kmalloc_FF_page()
{
f01175cc:	55                   	push   %ebp
f01175cd:	89 e5                	mov    %esp,%ebp
f01175cf:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01175d2:	83 ec 04             	sub    $0x4,%esp
f01175d5:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01175da:	68 93 03 00 00       	push   $0x393
f01175df:	68 45 4b 13 f0       	push   $0xf0134b45
f01175e4:	e8 c6 98 fe ff       	call   f0100eaf <_panic>

f01175e9 <test_kmalloc_NF_page>:
}
int test_kmalloc_NF_page()
{
f01175e9:	55                   	push   %ebp
f01175ea:	89 e5                	mov    %esp,%ebp
f01175ec:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01175ef:	83 ec 04             	sub    $0x4,%esp
f01175f2:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01175f7:	68 97 03 00 00       	push   $0x397
f01175fc:	68 45 4b 13 f0       	push   $0xf0134b45
f0117601:	e8 a9 98 fe ff       	call   f0100eaf <_panic>

f0117606 <test_kmalloc_BF_page>:
}
int test_kmalloc_BF_page()
{
f0117606:	55                   	push   %ebp
f0117607:	89 e5                	mov    %esp,%ebp
f0117609:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011760c:	83 ec 04             	sub    $0x4,%esp
f011760f:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117614:	68 9b 03 00 00       	push   $0x39b
f0117619:	68 45 4b 13 f0       	push   $0xf0134b45
f011761e:	e8 8c 98 fe ff       	call   f0100eaf <_panic>

f0117623 <test_kmalloc_WF_page>:
}
int test_kmalloc_WF_page()
{
f0117623:	55                   	push   %ebp
f0117624:	89 e5                	mov    %esp,%ebp
f0117626:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117629:	83 ec 04             	sub    $0x4,%esp
f011762c:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117631:	68 9f 03 00 00       	push   $0x39f
f0117636:	68 45 4b 13 f0       	push   $0xf0134b45
f011763b:	e8 6f 98 fe ff       	call   f0100eaf <_panic>

f0117640 <test_kmalloc_CF_page>:
}
int test_kmalloc_CF_page()
{
f0117640:	55                   	push   %ebp
f0117641:	89 e5                	mov    %esp,%ebp
f0117643:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117646:	83 ec 04             	sub    $0x4,%esp
f0117649:	68 5d 4b 13 f0       	push   $0xf0134b5d
f011764e:	68 a3 03 00 00       	push   $0x3a3
f0117653:	68 45 4b 13 f0       	push   $0xf0134b45
f0117658:	e8 52 98 fe ff       	call   f0100eaf <_panic>

f011765d <test_kmalloc_FF_block>:
}

int test_kmalloc_FF_block()
{
f011765d:	55                   	push   %ebp
f011765e:	89 e5                	mov    %esp,%ebp
f0117660:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117663:	83 ec 04             	sub    $0x4,%esp
f0117666:	68 5d 4b 13 f0       	push   $0xf0134b5d
f011766b:	68 a8 03 00 00       	push   $0x3a8
f0117670:	68 45 4b 13 f0       	push   $0xf0134b45
f0117675:	e8 35 98 fe ff       	call   f0100eaf <_panic>

f011767a <test_kmalloc_NF_block>:
}
int test_kmalloc_NF_block()
{
f011767a:	55                   	push   %ebp
f011767b:	89 e5                	mov    %esp,%ebp
f011767d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117680:	83 ec 04             	sub    $0x4,%esp
f0117683:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117688:	68 ac 03 00 00       	push   $0x3ac
f011768d:	68 45 4b 13 f0       	push   $0xf0134b45
f0117692:	e8 18 98 fe ff       	call   f0100eaf <_panic>

f0117697 <test_kmalloc_BF_block>:
}
int test_kmalloc_BF_block()
{
f0117697:	55                   	push   %ebp
f0117698:	89 e5                	mov    %esp,%ebp
f011769a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011769d:	83 ec 04             	sub    $0x4,%esp
f01176a0:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01176a5:	68 b0 03 00 00       	push   $0x3b0
f01176aa:	68 45 4b 13 f0       	push   $0xf0134b45
f01176af:	e8 fb 97 fe ff       	call   f0100eaf <_panic>

f01176b4 <test_kmalloc_WF_block>:
}
int test_kmalloc_WF_block()
{
f01176b4:	55                   	push   %ebp
f01176b5:	89 e5                	mov    %esp,%ebp
f01176b7:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01176ba:	83 ec 04             	sub    $0x4,%esp
f01176bd:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01176c2:	68 b4 03 00 00       	push   $0x3b4
f01176c7:	68 45 4b 13 f0       	push   $0xf0134b45
f01176cc:	e8 de 97 fe ff       	call   f0100eaf <_panic>

f01176d1 <test_kmalloc_CF_block>:
}
int test_kmalloc_CF_block()
{
f01176d1:	55                   	push   %ebp
f01176d2:	89 e5                	mov    %esp,%ebp
f01176d4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01176d7:	83 ec 04             	sub    $0x4,%esp
f01176da:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01176df:	68 b8 03 00 00       	push   $0x3b8
f01176e4:	68 45 4b 13 f0       	push   $0xf0134b45
f01176e9:	e8 c1 97 fe ff       	call   f0100eaf <_panic>

f01176ee <test_kmalloc_FF_both>:
}

int test_kmalloc_FF_both()
{
f01176ee:	55                   	push   %ebp
f01176ef:	89 e5                	mov    %esp,%ebp
f01176f1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01176f4:	83 ec 04             	sub    $0x4,%esp
f01176f7:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01176fc:	68 bd 03 00 00       	push   $0x3bd
f0117701:	68 45 4b 13 f0       	push   $0xf0134b45
f0117706:	e8 a4 97 fe ff       	call   f0100eaf <_panic>

f011770b <test_kmalloc_NF_both>:
}
int test_kmalloc_NF_both()
{
f011770b:	55                   	push   %ebp
f011770c:	89 e5                	mov    %esp,%ebp
f011770e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117711:	83 ec 04             	sub    $0x4,%esp
f0117714:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117719:	68 c1 03 00 00       	push   $0x3c1
f011771e:	68 45 4b 13 f0       	push   $0xf0134b45
f0117723:	e8 87 97 fe ff       	call   f0100eaf <_panic>

f0117728 <test_kmalloc_BF_both>:
}
int test_kmalloc_BF_both()
{
f0117728:	55                   	push   %ebp
f0117729:	89 e5                	mov    %esp,%ebp
f011772b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011772e:	83 ec 04             	sub    $0x4,%esp
f0117731:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117736:	68 c5 03 00 00       	push   $0x3c5
f011773b:	68 45 4b 13 f0       	push   $0xf0134b45
f0117740:	e8 6a 97 fe ff       	call   f0100eaf <_panic>

f0117745 <test_kmalloc_WF_both>:
}
int test_kmalloc_WF_both()
{
f0117745:	55                   	push   %ebp
f0117746:	89 e5                	mov    %esp,%ebp
f0117748:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011774b:	83 ec 04             	sub    $0x4,%esp
f011774e:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117753:	68 c9 03 00 00       	push   $0x3c9
f0117758:	68 45 4b 13 f0       	push   $0xf0134b45
f011775d:	e8 4d 97 fe ff       	call   f0100eaf <_panic>

f0117762 <test_kmalloc_CF_both>:
}
int test_kmalloc_CF_both()
{
f0117762:	55                   	push   %ebp
f0117763:	89 e5                	mov    %esp,%ebp
f0117765:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117768:	83 ec 04             	sub    $0x4,%esp
f011776b:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117770:	68 cd 03 00 00       	push   $0x3cd
f0117775:	68 45 4b 13 f0       	push   $0xf0134b45
f011777a:	e8 30 97 fe ff       	call   f0100eaf <_panic>

f011777f <test_kfree_FF_page>:

/**********************************************************************************************/
/*********************************** KFREE TESTING AREA ***************************************/
/**********************************************************************************************/
int test_kfree_FF_page()
{
f011777f:	55                   	push   %ebp
f0117780:	89 e5                	mov    %esp,%ebp
f0117782:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117785:	83 ec 04             	sub    $0x4,%esp
f0117788:	68 5d 4b 13 f0       	push   $0xf0134b5d
f011778d:	68 d5 03 00 00       	push   $0x3d5
f0117792:	68 45 4b 13 f0       	push   $0xf0134b45
f0117797:	e8 13 97 fe ff       	call   f0100eaf <_panic>

f011779c <test_kfree_NF_page>:
}
int test_kfree_NF_page()
{
f011779c:	55                   	push   %ebp
f011779d:	89 e5                	mov    %esp,%ebp
f011779f:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01177a2:	83 ec 04             	sub    $0x4,%esp
f01177a5:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01177aa:	68 d9 03 00 00       	push   $0x3d9
f01177af:	68 45 4b 13 f0       	push   $0xf0134b45
f01177b4:	e8 f6 96 fe ff       	call   f0100eaf <_panic>

f01177b9 <test_kfree_BF_page>:
}
int test_kfree_BF_page()
{
f01177b9:	55                   	push   %ebp
f01177ba:	89 e5                	mov    %esp,%ebp
f01177bc:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01177bf:	83 ec 04             	sub    $0x4,%esp
f01177c2:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01177c7:	68 dd 03 00 00       	push   $0x3dd
f01177cc:	68 45 4b 13 f0       	push   $0xf0134b45
f01177d1:	e8 d9 96 fe ff       	call   f0100eaf <_panic>

f01177d6 <test_kfree_WF_page>:
}
int test_kfree_WF_page()
{
f01177d6:	55                   	push   %ebp
f01177d7:	89 e5                	mov    %esp,%ebp
f01177d9:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01177dc:	83 ec 04             	sub    $0x4,%esp
f01177df:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01177e4:	68 e1 03 00 00       	push   $0x3e1
f01177e9:	68 45 4b 13 f0       	push   $0xf0134b45
f01177ee:	e8 bc 96 fe ff       	call   f0100eaf <_panic>

f01177f3 <test_kfree_CF_page>:
}
int test_kfree_CF_page()
{
f01177f3:	55                   	push   %ebp
f01177f4:	89 e5                	mov    %esp,%ebp
f01177f6:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01177f9:	83 ec 04             	sub    $0x4,%esp
f01177fc:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117801:	68 e5 03 00 00       	push   $0x3e5
f0117806:	68 45 4b 13 f0       	push   $0xf0134b45
f011780b:	e8 9f 96 fe ff       	call   f0100eaf <_panic>

f0117810 <test_kfree_FF_block>:
}

int test_kfree_FF_block()
{
f0117810:	55                   	push   %ebp
f0117811:	89 e5                	mov    %esp,%ebp
f0117813:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117816:	83 ec 04             	sub    $0x4,%esp
f0117819:	68 5d 4b 13 f0       	push   $0xf0134b5d
f011781e:	68 ea 03 00 00       	push   $0x3ea
f0117823:	68 45 4b 13 f0       	push   $0xf0134b45
f0117828:	e8 82 96 fe ff       	call   f0100eaf <_panic>

f011782d <test_kfree_NF_block>:
}
int test_kfree_NF_block()
{
f011782d:	55                   	push   %ebp
f011782e:	89 e5                	mov    %esp,%ebp
f0117830:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117833:	83 ec 04             	sub    $0x4,%esp
f0117836:	68 5d 4b 13 f0       	push   $0xf0134b5d
f011783b:	68 ee 03 00 00       	push   $0x3ee
f0117840:	68 45 4b 13 f0       	push   $0xf0134b45
f0117845:	e8 65 96 fe ff       	call   f0100eaf <_panic>

f011784a <test_kfree_BF_block>:
}
int test_kfree_BF_block()
{
f011784a:	55                   	push   %ebp
f011784b:	89 e5                	mov    %esp,%ebp
f011784d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117850:	83 ec 04             	sub    $0x4,%esp
f0117853:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117858:	68 f2 03 00 00       	push   $0x3f2
f011785d:	68 45 4b 13 f0       	push   $0xf0134b45
f0117862:	e8 48 96 fe ff       	call   f0100eaf <_panic>

f0117867 <test_kfree_WF_block>:
}
int test_kfree_WF_block()
{
f0117867:	55                   	push   %ebp
f0117868:	89 e5                	mov    %esp,%ebp
f011786a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011786d:	83 ec 04             	sub    $0x4,%esp
f0117870:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117875:	68 f6 03 00 00       	push   $0x3f6
f011787a:	68 45 4b 13 f0       	push   $0xf0134b45
f011787f:	e8 2b 96 fe ff       	call   f0100eaf <_panic>

f0117884 <test_kfree_CF_block>:
}
int test_kfree_CF_block()
{
f0117884:	55                   	push   %ebp
f0117885:	89 e5                	mov    %esp,%ebp
f0117887:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011788a:	83 ec 04             	sub    $0x4,%esp
f011788d:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117892:	68 fa 03 00 00       	push   $0x3fa
f0117897:	68 45 4b 13 f0       	push   $0xf0134b45
f011789c:	e8 0e 96 fe ff       	call   f0100eaf <_panic>

f01178a1 <test_kfree_FF_both>:
}

int test_kfree_FF_both()
{
f01178a1:	55                   	push   %ebp
f01178a2:	89 e5                	mov    %esp,%ebp
f01178a4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01178a7:	83 ec 04             	sub    $0x4,%esp
f01178aa:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01178af:	68 ff 03 00 00       	push   $0x3ff
f01178b4:	68 45 4b 13 f0       	push   $0xf0134b45
f01178b9:	e8 f1 95 fe ff       	call   f0100eaf <_panic>

f01178be <test_kfree_NF_both>:
}
int test_kfree_NF_both()
{
f01178be:	55                   	push   %ebp
f01178bf:	89 e5                	mov    %esp,%ebp
f01178c1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01178c4:	83 ec 04             	sub    $0x4,%esp
f01178c7:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01178cc:	68 03 04 00 00       	push   $0x403
f01178d1:	68 45 4b 13 f0       	push   $0xf0134b45
f01178d6:	e8 d4 95 fe ff       	call   f0100eaf <_panic>

f01178db <test_kfree_BF_both>:
}
int test_kfree_BF_both()
{
f01178db:	55                   	push   %ebp
f01178dc:	89 e5                	mov    %esp,%ebp
f01178de:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01178e1:	83 ec 04             	sub    $0x4,%esp
f01178e4:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01178e9:	68 07 04 00 00       	push   $0x407
f01178ee:	68 45 4b 13 f0       	push   $0xf0134b45
f01178f3:	e8 b7 95 fe ff       	call   f0100eaf <_panic>

f01178f8 <test_kfree_WF_both>:
}
int test_kfree_WF_both()
{
f01178f8:	55                   	push   %ebp
f01178f9:	89 e5                	mov    %esp,%ebp
f01178fb:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01178fe:	83 ec 04             	sub    $0x4,%esp
f0117901:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117906:	68 0b 04 00 00       	push   $0x40b
f011790b:	68 45 4b 13 f0       	push   $0xf0134b45
f0117910:	e8 9a 95 fe ff       	call   f0100eaf <_panic>

f0117915 <test_kfree_CF_both>:
}
int test_kfree_CF_both()
{
f0117915:	55                   	push   %ebp
f0117916:	89 e5                	mov    %esp,%ebp
f0117918:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011791b:	83 ec 04             	sub    $0x4,%esp
f011791e:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117923:	68 0f 04 00 00       	push   $0x40f
f0117928:	68 45 4b 13 f0       	push   $0xf0134b45
f011792d:	e8 7d 95 fe ff       	call   f0100eaf <_panic>

f0117932 <test_krealloc_FF_page>:

/**********************************************************************************************/
/********************************** KREALLOC TESTING AREA *************************************/
/**********************************************************************************************/
int test_krealloc_FF_page()
{
f0117932:	55                   	push   %ebp
f0117933:	89 e5                	mov    %esp,%ebp
f0117935:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117938:	83 ec 04             	sub    $0x4,%esp
f011793b:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117940:	68 17 04 00 00       	push   $0x417
f0117945:	68 45 4b 13 f0       	push   $0xf0134b45
f011794a:	e8 60 95 fe ff       	call   f0100eaf <_panic>

f011794f <test_krealloc_NF_page>:
}
int test_krealloc_NF_page()
{
f011794f:	55                   	push   %ebp
f0117950:	89 e5                	mov    %esp,%ebp
f0117952:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117955:	83 ec 04             	sub    $0x4,%esp
f0117958:	68 5d 4b 13 f0       	push   $0xf0134b5d
f011795d:	68 1b 04 00 00       	push   $0x41b
f0117962:	68 45 4b 13 f0       	push   $0xf0134b45
f0117967:	e8 43 95 fe ff       	call   f0100eaf <_panic>

f011796c <test_krealloc_BF_page>:
}
int test_krealloc_BF_page()
{
f011796c:	55                   	push   %ebp
f011796d:	89 e5                	mov    %esp,%ebp
f011796f:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117972:	83 ec 04             	sub    $0x4,%esp
f0117975:	68 5d 4b 13 f0       	push   $0xf0134b5d
f011797a:	68 1f 04 00 00       	push   $0x41f
f011797f:	68 45 4b 13 f0       	push   $0xf0134b45
f0117984:	e8 26 95 fe ff       	call   f0100eaf <_panic>

f0117989 <test_krealloc_WF_page>:
}
int test_krealloc_WF_page()
{
f0117989:	55                   	push   %ebp
f011798a:	89 e5                	mov    %esp,%ebp
f011798c:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011798f:	83 ec 04             	sub    $0x4,%esp
f0117992:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117997:	68 23 04 00 00       	push   $0x423
f011799c:	68 45 4b 13 f0       	push   $0xf0134b45
f01179a1:	e8 09 95 fe ff       	call   f0100eaf <_panic>

f01179a6 <test_krealloc_CF_page>:
}
int test_krealloc_CF_page()
{
f01179a6:	55                   	push   %ebp
f01179a7:	89 e5                	mov    %esp,%ebp
f01179a9:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01179ac:	83 ec 04             	sub    $0x4,%esp
f01179af:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01179b4:	68 27 04 00 00       	push   $0x427
f01179b9:	68 45 4b 13 f0       	push   $0xf0134b45
f01179be:	e8 ec 94 fe ff       	call   f0100eaf <_panic>

f01179c3 <test_krealloc_FF_block>:
}

int test_krealloc_FF_block()
{
f01179c3:	55                   	push   %ebp
f01179c4:	89 e5                	mov    %esp,%ebp
f01179c6:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01179c9:	83 ec 04             	sub    $0x4,%esp
f01179cc:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01179d1:	68 2c 04 00 00       	push   $0x42c
f01179d6:	68 45 4b 13 f0       	push   $0xf0134b45
f01179db:	e8 cf 94 fe ff       	call   f0100eaf <_panic>

f01179e0 <test_krealloc_NF_block>:
}
int test_krealloc_NF_block()
{
f01179e0:	55                   	push   %ebp
f01179e1:	89 e5                	mov    %esp,%ebp
f01179e3:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01179e6:	83 ec 04             	sub    $0x4,%esp
f01179e9:	68 5d 4b 13 f0       	push   $0xf0134b5d
f01179ee:	68 30 04 00 00       	push   $0x430
f01179f3:	68 45 4b 13 f0       	push   $0xf0134b45
f01179f8:	e8 b2 94 fe ff       	call   f0100eaf <_panic>

f01179fd <test_krealloc_BF_block>:
}
int test_krealloc_BF_block()
{
f01179fd:	55                   	push   %ebp
f01179fe:	89 e5                	mov    %esp,%ebp
f0117a00:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a03:	83 ec 04             	sub    $0x4,%esp
f0117a06:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117a0b:	68 34 04 00 00       	push   $0x434
f0117a10:	68 45 4b 13 f0       	push   $0xf0134b45
f0117a15:	e8 95 94 fe ff       	call   f0100eaf <_panic>

f0117a1a <test_krealloc_WF_block>:
}
int test_krealloc_WF_block()
{
f0117a1a:	55                   	push   %ebp
f0117a1b:	89 e5                	mov    %esp,%ebp
f0117a1d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a20:	83 ec 04             	sub    $0x4,%esp
f0117a23:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117a28:	68 38 04 00 00       	push   $0x438
f0117a2d:	68 45 4b 13 f0       	push   $0xf0134b45
f0117a32:	e8 78 94 fe ff       	call   f0100eaf <_panic>

f0117a37 <test_krealloc_CF_block>:
}
int test_krealloc_CF_block()
{
f0117a37:	55                   	push   %ebp
f0117a38:	89 e5                	mov    %esp,%ebp
f0117a3a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a3d:	83 ec 04             	sub    $0x4,%esp
f0117a40:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117a45:	68 3c 04 00 00       	push   $0x43c
f0117a4a:	68 45 4b 13 f0       	push   $0xf0134b45
f0117a4f:	e8 5b 94 fe ff       	call   f0100eaf <_panic>

f0117a54 <test_krealloc_FF_both>:
}

int test_krealloc_FF_both()
{
f0117a54:	55                   	push   %ebp
f0117a55:	89 e5                	mov    %esp,%ebp
f0117a57:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a5a:	83 ec 04             	sub    $0x4,%esp
f0117a5d:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117a62:	68 41 04 00 00       	push   $0x441
f0117a67:	68 45 4b 13 f0       	push   $0xf0134b45
f0117a6c:	e8 3e 94 fe ff       	call   f0100eaf <_panic>

f0117a71 <test_krealloc_NF_both>:
}
int test_krealloc_NF_both()
{
f0117a71:	55                   	push   %ebp
f0117a72:	89 e5                	mov    %esp,%ebp
f0117a74:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a77:	83 ec 04             	sub    $0x4,%esp
f0117a7a:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117a7f:	68 45 04 00 00       	push   $0x445
f0117a84:	68 45 4b 13 f0       	push   $0xf0134b45
f0117a89:	e8 21 94 fe ff       	call   f0100eaf <_panic>

f0117a8e <test_krealloc_BF_both>:
}
int test_krealloc_BF_both()
{
f0117a8e:	55                   	push   %ebp
f0117a8f:	89 e5                	mov    %esp,%ebp
f0117a91:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a94:	83 ec 04             	sub    $0x4,%esp
f0117a97:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117a9c:	68 49 04 00 00       	push   $0x449
f0117aa1:	68 45 4b 13 f0       	push   $0xf0134b45
f0117aa6:	e8 04 94 fe ff       	call   f0100eaf <_panic>

f0117aab <test_krealloc_WF_both>:
}
int test_krealloc_WF_both()
{
f0117aab:	55                   	push   %ebp
f0117aac:	89 e5                	mov    %esp,%ebp
f0117aae:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117ab1:	83 ec 04             	sub    $0x4,%esp
f0117ab4:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117ab9:	68 4d 04 00 00       	push   $0x44d
f0117abe:	68 45 4b 13 f0       	push   $0xf0134b45
f0117ac3:	e8 e7 93 fe ff       	call   f0100eaf <_panic>

f0117ac8 <test_krealloc_CF_both>:
}
int test_krealloc_CF_both()
{
f0117ac8:	55                   	push   %ebp
f0117ac9:	89 e5                	mov    %esp,%ebp
f0117acb:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117ace:	83 ec 04             	sub    $0x4,%esp
f0117ad1:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117ad6:	68 51 04 00 00       	push   $0x451
f0117adb:	68 45 4b 13 f0       	push   $0xf0134b45
f0117ae0:	e8 ca 93 fe ff       	call   f0100eaf <_panic>

f0117ae5 <test_fast_FF>:

/**********************************************************************************************/
/*************************** FAST PAGE ALLOCATOR TESTING AREA *********************************/
/**********************************************************************************************/
int test_fast_FF()
{
f0117ae5:	55                   	push   %ebp
f0117ae6:	89 e5                	mov    %esp,%ebp
f0117ae8:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117aeb:	83 ec 04             	sub    $0x4,%esp
f0117aee:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117af3:	68 59 04 00 00       	push   $0x459
f0117af8:	68 45 4b 13 f0       	push   $0xf0134b45
f0117afd:	e8 ad 93 fe ff       	call   f0100eaf <_panic>

f0117b02 <test_fast_NF>:
}
int test_fast_NF()
{
f0117b02:	55                   	push   %ebp
f0117b03:	89 e5                	mov    %esp,%ebp
f0117b05:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b08:	83 ec 04             	sub    $0x4,%esp
f0117b0b:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117b10:	68 5d 04 00 00       	push   $0x45d
f0117b15:	68 45 4b 13 f0       	push   $0xf0134b45
f0117b1a:	e8 90 93 fe ff       	call   f0100eaf <_panic>

f0117b1f <test_fast_BF>:
}
int test_fast_BF()
{
f0117b1f:	55                   	push   %ebp
f0117b20:	89 e5                	mov    %esp,%ebp
f0117b22:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b25:	83 ec 04             	sub    $0x4,%esp
f0117b28:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117b2d:	68 61 04 00 00       	push   $0x461
f0117b32:	68 45 4b 13 f0       	push   $0xf0134b45
f0117b37:	e8 73 93 fe ff       	call   f0100eaf <_panic>

f0117b3c <test_fast_WF>:
}
int test_fast_WF()
{
f0117b3c:	55                   	push   %ebp
f0117b3d:	89 e5                	mov    %esp,%ebp
f0117b3f:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b42:	83 ec 04             	sub    $0x4,%esp
f0117b45:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117b4a:	68 65 04 00 00       	push   $0x465
f0117b4f:	68 45 4b 13 f0       	push   $0xf0134b45
f0117b54:	e8 56 93 fe ff       	call   f0100eaf <_panic>

f0117b59 <test_fast_CF>:
}
int test_fast_CF()
{
f0117b59:	55                   	push   %ebp
f0117b5a:	89 e5                	mov    %esp,%ebp
f0117b5c:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b5f:	83 ec 04             	sub    $0x4,%esp
f0117b62:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117b67:	68 69 04 00 00       	push   $0x469
f0117b6c:	68 45 4b 13 f0       	push   $0xf0134b45
f0117b71:	e8 39 93 fe ff       	call   f0100eaf <_panic>

f0117b76 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f0117b76:	55                   	push   %ebp
f0117b77:	89 e5                	mov    %esp,%ebp
f0117b79:	57                   	push   %edi
f0117b7a:	56                   	push   %esi
f0117b7b:	53                   	push   %ebx
f0117b7c:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f0117b82:	a0 a8 01 18 f0       	mov    0xf01801a8,%al
f0117b87:	84 c0                	test   %al,%al
f0117b89:	74 56                	je     f0117be1 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f0117b8b:	c6 05 a8 01 18 f0 00 	movb   $0x0,0xf01801a8
		initFreeFrames = sys_calculate_free_frames() ;
f0117b92:	e8 13 6d ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0117b97:	a3 28 cb 87 f0       	mov    %eax,0xf087cb28
		initFreeDiskFrames = pf_calculate_free_frames() ;
f0117b9c:	e8 88 dc fe ff       	call   f0105829 <pf_calculate_free_frames>
f0117ba1:	a3 24 cb 87 f0       	mov    %eax,0xf087cb24
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f0117ba6:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0117bac:	bb 35 4d 13 f0       	mov    $0xf0134d35,%ebx
f0117bb1:	ba 11 00 00 00       	mov    $0x11,%edx
f0117bb6:	89 c7                	mov    %eax,%edi
f0117bb8:	89 de                	mov    %ebx,%esi
f0117bba:	89 d1                	mov    %edx,%ecx
f0117bbc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117bbe:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f0117bc4:	b9 53 00 00 00       	mov    $0x53,%ecx
f0117bc9:	b0 00                	mov    $0x0,%al
f0117bcb:	89 d7                	mov    %edx,%edi
f0117bcd:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f0117bcf:	83 ec 0c             	sub    $0xc,%esp
f0117bd2:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0117bd8:	50                   	push   %eax
f0117bd9:	e8 3d a2 fe ff       	call   f0101e1b <execute_command>
f0117bde:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f0117be1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f0117be8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0117bef:	a1 00 de 83 f0       	mov    0xf083de00,%eax
f0117bf4:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0117bf7:	eb 2b                	jmp    f0117c24 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f0117bf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117bfc:	83 c0 20             	add    $0x20,%eax
f0117bff:	83 ec 08             	sub    $0x8,%esp
f0117c02:	68 76 4b 13 f0       	push   $0xf0134b76
f0117c07:	50                   	push   %eax
f0117c08:	e8 7c 2f 00 00       	call   f011ab89 <strcmp>
f0117c0d:	83 c4 10             	add    $0x10,%esp
f0117c10:	85 c0                	test   %eax,%eax
f0117c12:	75 08                	jne    f0117c1c <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f0117c14:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117c17:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f0117c1a:	eb 2f                	jmp    f0117c4b <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0117c1c:	a1 08 de 83 f0       	mov    0xf083de08,%eax
f0117c21:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0117c24:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117c28:	74 08                	je     f0117c32 <test_three_creation_functions+0xbc>
f0117c2a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117c2d:	8b 40 08             	mov    0x8(%eax),%eax
f0117c30:	eb 05                	jmp    f0117c37 <test_three_creation_functions+0xc1>
f0117c32:	b8 00 00 00 00       	mov    $0x0,%eax
f0117c37:	a3 08 de 83 f0       	mov    %eax,0xf083de08
f0117c3c:	a1 08 de 83 f0       	mov    0xf083de08,%eax
f0117c41:	85 c0                	test   %eax,%eax
f0117c43:	75 b4                	jne    f0117bf9 <test_three_creation_functions+0x83>
f0117c45:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117c49:	75 ae                	jne    f0117bf9 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f0117c4b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117c4e:	8b 80 98 05 00 00    	mov    0x598(%eax),%eax
f0117c54:	85 c0                	test   %eax,%eax
f0117c56:	74 17                	je     f0117c6f <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f0117c58:	83 ec 04             	sub    $0x4,%esp
f0117c5b:	68 80 4b 13 f0       	push   $0xf0134b80
f0117c60:	68 90 04 00 00       	push   $0x490
f0117c65:	68 45 4b 13 f0       	push   $0xf0134b45
f0117c6a:	e8 40 92 fe ff       	call   f0100eaf <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f0117c6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117c72:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0117c78:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f0117c7b:	e8 2a 6c ff ff       	call   f010e8aa <sys_calculate_free_frames>
f0117c80:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f0117c83:	e8 a1 db fe ff       	call   f0105829 <pf_calculate_free_frames>
f0117c88:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117c8b:	a1 24 cb 87 f0       	mov    0xf087cb24,%eax
f0117c90:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f0117c93:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0117c96:	74 17                	je     f0117caf <test_three_creation_functions+0x139>
f0117c98:	83 ec 04             	sub    $0x4,%esp
f0117c9b:	68 d0 4b 13 f0       	push   $0xf0134bd0
f0117ca0:	68 9a 04 00 00       	push   $0x49a
f0117ca5:	68 45 4b 13 f0       	push   $0xf0134b45
f0117caa:	e8 00 92 fe ff       	call   f0100eaf <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f0117caf:	a1 28 cb 87 f0       	mov    0xf087cb28,%eax
f0117cb4:	2b 45 d8             	sub    -0x28(%ebp),%eax
f0117cb7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0117cba:	83 c2 15             	add    $0x15,%edx
f0117cbd:	39 d0                	cmp    %edx,%eax
f0117cbf:	74 17                	je     f0117cd8 <test_three_creation_functions+0x162>
f0117cc1:	83 ec 04             	sub    $0x4,%esp
f0117cc4:	68 38 4c 13 f0       	push   $0xf0134c38
f0117cc9:	68 9c 04 00 00       	push   $0x49c
f0117cce:	68 45 4b 13 f0       	push   $0xf0134b45
f0117cd3:	e8 d7 91 fe ff       	call   f0100eaf <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f0117cd8:	83 ec 0c             	sub    $0xc,%esp
f0117cdb:	68 00 10 00 00       	push   $0x1000
f0117ce0:	e8 54 1e ff ff       	call   f0109b39 <kmalloc>
f0117ce5:	83 c4 10             	add    $0x10,%esp
f0117ce8:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f0117ceb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117cee:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f0117cf3:	74 17                	je     f0117d0c <test_three_creation_functions+0x196>
f0117cf5:	83 ec 04             	sub    $0x4,%esp
f0117cf8:	68 78 4c 13 f0       	push   $0xf0134c78
f0117cfd:	68 a0 04 00 00       	push   $0x4a0
f0117d02:	68 45 4b 13 f0       	push   $0xf0134b45
f0117d07:	e8 a3 91 fe ff       	call   f0100eaf <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f0117d0c:	83 ec 0c             	sub    $0xc,%esp
f0117d0f:	68 e8 4c 13 f0       	push   $0xf0134ce8
f0117d14:	e8 43 9e fe ff       	call   f0101b5c <cprintf>
f0117d19:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117d1c:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117d21:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0117d24:	5b                   	pop    %ebx
f0117d25:	5e                   	pop    %esi
f0117d26:	5f                   	pop    %edi
f0117d27:	5d                   	pop    %ebp
f0117d28:	c3                   	ret    

f0117d29 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f0117d29:	55                   	push   %ebp
f0117d2a:	89 e5                	mov    %esp,%ebp
f0117d2c:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117d2f:	83 ec 04             	sub    $0x4,%esp
f0117d32:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117d37:	68 ae 04 00 00       	push   $0x4ae
f0117d3c:	68 45 4b 13 f0       	push   $0xf0134b45
f0117d41:	e8 69 91 fe ff       	call   f0100eaf <_panic>

f0117d46 <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f0117d46:	55                   	push   %ebp
f0117d47:	89 e5                	mov    %esp,%ebp
f0117d49:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117d4c:	83 ec 04             	sub    $0x4,%esp
f0117d4f:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117d54:	68 b6 04 00 00       	push   $0x4b6
f0117d59:	68 45 4b 13 f0       	push   $0xf0134b45
f0117d5e:	e8 4c 91 fe ff       	call   f0100eaf <_panic>

f0117d63 <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f0117d63:	55                   	push   %ebp
f0117d64:	89 e5                	mov    %esp,%ebp
f0117d66:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117d69:	83 ec 04             	sub    $0x4,%esp
f0117d6c:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117d71:	68 bd 04 00 00       	push   $0x4bd
f0117d76:	68 45 4b 13 f0       	push   $0xf0134b45
f0117d7b:	e8 2f 91 fe ff       	call   f0100eaf <_panic>

f0117d80 <test_kfreelast>:
}


int test_kfreelast()
{
f0117d80:	55                   	push   %ebp
f0117d81:	89 e5                	mov    %esp,%ebp
f0117d83:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117d86:	83 ec 04             	sub    $0x4,%esp
f0117d89:	68 5d 4b 13 f0       	push   $0xf0134b5d
f0117d8e:	68 c3 04 00 00       	push   $0x4c3
f0117d93:	68 45 4b 13 f0       	push   $0xf0134b45
f0117d98:	e8 12 91 fe ff       	call   f0100eaf <_panic>

f0117d9d <print_order>:
uint8 firstTimeTest = 1;
int prog_orders[TOTAL_TEST_VALUES+1][INSTANCES_NUMBER] = {0};
int env_count[TOTAL_TEST_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f0117d9d:	55                   	push   %ebp
f0117d9e:	89 e5                	mov    %esp,%ebp
f0117da0:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f0117da3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0117daa:	e9 84 00 00 00       	jmp    f0117e33 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f0117daf:	83 ec 08             	sub    $0x8,%esp
f0117db2:	ff 75 f4             	pushl  -0xc(%ebp)
f0117db5:	68 a0 4d 13 f0       	push   $0xf0134da0
f0117dba:	e8 9d 9d fe ff       	call   f0101b5c <cprintf>
f0117dbf:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f0117dc2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dc9:	eb 4c                	jmp    f0117e17 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f0117dcb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0117dce:	89 d0                	mov    %edx,%eax
f0117dd0:	c1 e0 02             	shl    $0x2,%eax
f0117dd3:	01 d0                	add    %edx,%eax
f0117dd5:	c1 e0 03             	shl    $0x3,%eax
f0117dd8:	89 c2                	mov    %eax,%edx
f0117dda:	8b 45 08             	mov    0x8(%ebp),%eax
f0117ddd:	01 c2                	add    %eax,%edx
f0117ddf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117de2:	8b 04 82             	mov    (%edx,%eax,4),%eax
f0117de5:	85 c0                	test   %eax,%eax
f0117de7:	74 36                	je     f0117e1f <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f0117de9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0117dec:	89 d0                	mov    %edx,%eax
f0117dee:	c1 e0 02             	shl    $0x2,%eax
f0117df1:	01 d0                	add    %edx,%eax
f0117df3:	c1 e0 03             	shl    $0x3,%eax
f0117df6:	89 c2                	mov    %eax,%edx
f0117df8:	8b 45 08             	mov    0x8(%ebp),%eax
f0117dfb:	01 c2                	add    %eax,%edx
f0117dfd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117e00:	8b 04 82             	mov    (%edx,%eax,4),%eax
f0117e03:	83 ec 08             	sub    $0x8,%esp
f0117e06:	50                   	push   %eax
f0117e07:	68 a8 4d 13 f0       	push   $0xf0134da8
f0117e0c:	e8 4b 9d fe ff       	call   f0101b5c <cprintf>
f0117e11:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_TEST_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f0117e14:	ff 45 f0             	incl   -0x10(%ebp)
f0117e17:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f0117e1b:	7e ae                	jle    f0117dcb <print_order+0x2e>
f0117e1d:	eb 01                	jmp    f0117e20 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f0117e1f:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f0117e20:	83 ec 0c             	sub    $0xc,%esp
f0117e23:	68 ad 4d 13 f0       	push   $0xf0134dad
f0117e28:	e8 2f 9d fe ff       	call   f0101b5c <cprintf>
f0117e2d:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_TEST_VALUES+1][INSTANCES_NUMBER] = {0};
int env_count[TOTAL_TEST_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f0117e30:	ff 45 f4             	incl   -0xc(%ebp)
f0117e33:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f0117e37:	0f 8e 72 ff ff ff    	jle    f0117daf <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f0117e3d:	90                   	nop
f0117e3e:	c9                   	leave  
f0117e3f:	c3                   	ret    

f0117e40 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f0117e40:	55                   	push   %ebp
f0117e41:	89 e5                	mov    %esp,%ebp
f0117e43:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f0117e46:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_kspinlock(&ProcessQueues.qlock);
f0117e4d:	83 ec 0c             	sub    $0xc,%esp
f0117e50:	68 80 dd 83 f0       	push   $0xf083dd80
f0117e55:	e8 23 7f ff ff       	call   f010fd7d <acquire_kspinlock>
f0117e5a:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f0117e5d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f0117e64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0117e6b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0117e6e:	8b 45 10             	mov    0x10(%ebp),%eax
f0117e71:	01 d0                	add    %edx,%eax
f0117e73:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0117e76:	a1 0c de 83 f0       	mov    0xf083de0c,%eax
f0117e7b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f0117e7e:	a1 04 de 83 f0       	mov    0xf083de04,%eax
f0117e83:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f0117e86:	ff 75 e8             	pushl  -0x18(%ebp)
f0117e89:	ff 75 0c             	pushl  0xc(%ebp)
f0117e8c:	ff 75 08             	pushl  0x8(%ebp)
f0117e8f:	68 b0 4d 13 f0       	push   $0xf0134db0
f0117e94:	e8 c3 9c fe ff       	call   f0101b5c <cprintf>
f0117e99:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f0117e9c:	eb 34                	jmp    f0117ed2 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f0117e9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ea1:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0117ea4:	7d 05                	jge    f0117eab <find_in_range+0x6b>
			{
				i++;
f0117ea6:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f0117ea9:	eb 1e                	jmp    f0117ec9 <find_in_range+0x89>
			}
			if (i >= end)
f0117eab:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117eae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117eb1:	7d 29                	jge    f0117edc <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f0117eb3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117eb6:	8b 40 10             	mov    0x10(%eax),%eax
f0117eb9:	3b 45 08             	cmp    0x8(%ebp),%eax
f0117ebc:	75 08                	jne    f0117ec6 <find_in_range+0x86>
			{
				ret = i;
f0117ebe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f0117ec4:	eb 17                	jmp    f0117edd <find_in_range+0x9d>
			}
			i++;
f0117ec6:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f0117ec9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117ecc:	8b 40 0c             	mov    0xc(%eax),%eax
f0117ecf:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0117ed2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ed5:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0117ed8:	7c c4                	jl     f0117e9e <find_in_range+0x5e>
f0117eda:	eb 01                	jmp    f0117edd <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f0117edc:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_kspinlock(&ProcessQueues.qlock);
f0117edd:	83 ec 0c             	sub    $0xc,%esp
f0117ee0:	68 80 dd 83 f0       	push   $0xf083dd80
f0117ee5:	e8 38 7f ff ff       	call   f010fe22 <release_kspinlock>
f0117eea:	83 c4 10             	add    $0x10,%esp
	return ret;
f0117eed:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0117ef0:	c9                   	leave  
f0117ef1:	c3                   	ret    

f0117ef2 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f0117ef2:	55                   	push   %ebp
f0117ef3:	89 e5                	mov    %esp,%ebp
f0117ef5:	83 ec 08             	sub    $0x8,%esp
	panic("Not Implemented");
f0117ef8:	83 ec 04             	sub    $0x4,%esp
f0117efb:	68 e1 4d 13 f0       	push   $0xf0134de1
f0117f00:	6a 49                	push   $0x49
f0117f02:	68 f1 4d 13 f0       	push   $0xf0134df1
f0117f07:	e8 a3 8f fe ff       	call   f0100eaf <_panic>

f0117f0c <test_bsd_nice_1>:
}


void test_bsd_nice_1()
{
f0117f0c:	55                   	push   %ebp
f0117f0d:	89 e5                	mov    %esp,%ebp
f0117f0f:	83 ec 08             	sub    $0x8,%esp
	panic("Not Implemented");
f0117f12:	83 ec 04             	sub    $0x4,%esp
f0117f15:	68 e1 4d 13 f0       	push   $0xf0134de1
f0117f1a:	6a 4f                	push   $0x4f
f0117f1c:	68 f1 4d 13 f0       	push   $0xf0134df1
f0117f21:	e8 89 8f fe ff       	call   f0100eaf <_panic>

f0117f26 <test_bsd_nice_2>:
}

void test_bsd_nice_2()
{
f0117f26:	55                   	push   %ebp
f0117f27:	89 e5                	mov    %esp,%ebp
f0117f29:	83 ec 08             	sub    $0x8,%esp
	panic("Not Implemented");
f0117f2c:	83 ec 04             	sub    $0x4,%esp
f0117f2f:	68 e1 4d 13 f0       	push   $0xf0134de1
f0117f34:	6a 54                	push   $0x54
f0117f36:	68 f1 4d 13 f0       	push   $0xf0134df1
f0117f3b:	e8 6f 8f fe ff       	call   f0100eaf <_panic>

f0117f40 <test_priorityRR_0>:
}


void test_priorityRR_0()
{
f0117f40:	55                   	push   %ebp
f0117f41:	89 e5                	mov    %esp,%ebp
f0117f43:	57                   	push   %edi
f0117f44:	56                   	push   %esi
f0117f45:	53                   	push   %ebx
f0117f46:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTest)
f0117f49:	a0 a9 01 18 f0       	mov    0xf01801a9,%al
f0117f4e:	84 c0                	test   %al,%al
f0117f50:	0f 84 bd 01 00 00    	je     f0118113 <test_priorityRR_0+0x1d3>
	{
		firstTimeTest = 0;
f0117f56:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
		int priority_values[] = {0, 2, 4, 6, 8};
f0117f5d:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0117f60:	bb 4c 4f 13 f0       	mov    $0xf0134f4c,%ebx
f0117f65:	ba 05 00 00 00       	mov    $0x5,%edx
f0117f6a:	89 c7                	mov    %eax,%edi
f0117f6c:	89 de                	mov    %ebx,%esi
f0117f6e:	89 d1                	mov    %edx,%ecx
f0117f70:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f0117f72:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0117f79:	e9 66 01 00 00       	jmp    f01180e4 <test_priorityRR_0+0x1a4>
		{
			struct Env *env ;
			if (i == 4)
f0117f7e:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f0117f82:	75 1b                	jne    f0117f9f <test_priorityRR_0+0x5f>
			{
				env = env_create("priRR_fib_small", 500, 0, 0);
f0117f84:	6a 00                	push   $0x0
f0117f86:	6a 00                	push   $0x0
f0117f88:	68 f4 01 00 00       	push   $0x1f4
f0117f8d:	68 0d 4e 13 f0       	push   $0xf0134e0d
f0117f92:	e8 cd 2e ff ff       	call   f010ae64 <env_create>
f0117f97:	83 c4 10             	add    $0x10,%esp
f0117f9a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0117f9d:	eb 19                	jmp    f0117fb8 <test_priorityRR_0+0x78>
			}
			else
			{
				env = env_create("priRR_fib", 500, 0, 0);
f0117f9f:	6a 00                	push   $0x0
f0117fa1:	6a 00                	push   $0x0
f0117fa3:	68 f4 01 00 00       	push   $0x1f4
f0117fa8:	68 1d 4e 13 f0       	push   $0xf0134e1d
f0117fad:	e8 b2 2e ff ff       	call   f010ae64 <env_create>
f0117fb2:	83 c4 10             	add    $0x10,%esp
f0117fb5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			}
			int priority_index = i % TOTAL_TEST_VALUES;
f0117fb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117fbb:	b9 05 00 00 00       	mov    $0x5,%ecx
f0117fc0:	99                   	cltd   
f0117fc1:	f7 f9                	idiv   %ecx
f0117fc3:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_priority(env->env_id, priority_values[priority_index]);
f0117fc6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117fc9:	8b 54 85 b8          	mov    -0x48(%ebp,%eax,4),%edx
f0117fcd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117fd0:	8b 40 10             	mov    0x10(%eax),%eax
f0117fd3:	83 ec 08             	sub    $0x8,%esp
f0117fd6:	52                   	push   %edx
f0117fd7:	50                   	push   %eax
f0117fd8:	e8 81 f6 fe ff       	call   f010765e <env_set_priority>
f0117fdd:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f0117fe0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117fe4:	75 14                	jne    f0117ffa <test_priorityRR_0+0xba>
				panic("Loading programs failed\n");
f0117fe6:	83 ec 04             	sub    $0x4,%esp
f0117fe9:	68 27 4e 13 f0       	push   $0xf0134e27
f0117fee:	6a 6c                	push   $0x6c
f0117ff0:	68 f1 4d 13 f0       	push   $0xf0134df1
f0117ff5:	e8 b5 8e fe ff       	call   f0100eaf <_panic>
			if (env->page_WS_max_size != 500)
f0117ffa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117ffd:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118003:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f0118008:	74 14                	je     f011801e <test_priorityRR_0+0xde>
				panic("The program working set size is not correct\n");
f011800a:	83 ec 04             	sub    $0x4,%esp
f011800d:	68 40 4e 13 f0       	push   $0xf0134e40
f0118012:	6a 6e                	push   $0x6e
f0118014:	68 f1 4d 13 f0       	push   $0xf0134df1
f0118019:	e8 91 8e fe ff       	call   f0100eaf <_panic>

			switch (priority_values[priority_index])
f011801e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0118021:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f0118025:	83 f8 08             	cmp    $0x8,%eax
f0118028:	0f 87 a5 00 00 00    	ja     f01180d3 <test_priorityRR_0+0x193>
f011802e:	8b 04 85 60 4f 13 f0 	mov    -0xfecb0a0(,%eax,4),%eax
f0118035:	ff e0                	jmp    *%eax
			{
			case 0:
				prog_orders[0][env_count[0]++] = env->env_id;
f0118037:	a1 70 db 83 f0       	mov    0xf083db70,%eax
f011803c:	8d 50 01             	lea    0x1(%eax),%edx
f011803f:	89 15 70 db 83 f0    	mov    %edx,0xf083db70
f0118045:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118048:	8b 52 10             	mov    0x10(%edx),%edx
f011804b:	89 14 85 80 da 83 f0 	mov    %edx,-0xf7c2580(,%eax,4)
				break;
f0118052:	eb 7f                	jmp    f01180d3 <test_priorityRR_0+0x193>
			case 2:
				prog_orders[1][env_count[1]++] = env->env_id;
f0118054:	a1 74 db 83 f0       	mov    0xf083db74,%eax
f0118059:	8d 50 01             	lea    0x1(%eax),%edx
f011805c:	89 15 74 db 83 f0    	mov    %edx,0xf083db74
f0118062:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118065:	8b 52 10             	mov    0x10(%edx),%edx
f0118068:	83 c0 0a             	add    $0xa,%eax
f011806b:	89 14 85 80 da 83 f0 	mov    %edx,-0xf7c2580(,%eax,4)
				break;
f0118072:	eb 5f                	jmp    f01180d3 <test_priorityRR_0+0x193>
			case 4:
				prog_orders[2][env_count[2]++] = env->env_id;
f0118074:	a1 78 db 83 f0       	mov    0xf083db78,%eax
f0118079:	8d 50 01             	lea    0x1(%eax),%edx
f011807c:	89 15 78 db 83 f0    	mov    %edx,0xf083db78
f0118082:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118085:	8b 52 10             	mov    0x10(%edx),%edx
f0118088:	83 c0 14             	add    $0x14,%eax
f011808b:	89 14 85 80 da 83 f0 	mov    %edx,-0xf7c2580(,%eax,4)
				break;
f0118092:	eb 3f                	jmp    f01180d3 <test_priorityRR_0+0x193>
			case 6:
				prog_orders[3][env_count[3]++] = env->env_id;
f0118094:	a1 7c db 83 f0       	mov    0xf083db7c,%eax
f0118099:	8d 50 01             	lea    0x1(%eax),%edx
f011809c:	89 15 7c db 83 f0    	mov    %edx,0xf083db7c
f01180a2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01180a5:	8b 52 10             	mov    0x10(%edx),%edx
f01180a8:	83 c0 1e             	add    $0x1e,%eax
f01180ab:	89 14 85 80 da 83 f0 	mov    %edx,-0xf7c2580(,%eax,4)
				break;
f01180b2:	eb 1f                	jmp    f01180d3 <test_priorityRR_0+0x193>
			case 8:
				prog_orders[4][env_count[4]++] = env->env_id;
f01180b4:	a1 80 db 83 f0       	mov    0xf083db80,%eax
f01180b9:	8d 50 01             	lea    0x1(%eax),%edx
f01180bc:	89 15 80 db 83 f0    	mov    %edx,0xf083db80
f01180c2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01180c5:	8b 52 10             	mov    0x10(%edx),%edx
f01180c8:	83 c0 28             	add    $0x28,%eax
f01180cb:	89 14 85 80 da 83 f0 	mov    %edx,-0xf7c2580(,%eax,4)
				break;
f01180d2:	90                   	nop
			}
			sched_new_env(env);
f01180d3:	83 ec 0c             	sub    $0xc,%esp
f01180d6:	ff 75 e0             	pushl  -0x20(%ebp)
f01180d9:	e8 ab e5 fe ff       	call   f0106689 <sched_new_env>
f01180de:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTest)
	{
		firstTimeTest = 0;
		int priority_values[] = {0, 2, 4, 6, 8};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f01180e1:	ff 45 e4             	incl   -0x1c(%ebp)
f01180e4:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f01180e8:	0f 8e 90 fe ff ff    	jle    f0117f7e <test_priorityRR_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f01180ee:	83 ec 0c             	sub    $0xc,%esp
f01180f1:	68 70 4e 13 f0       	push   $0xf0134e70
f01180f6:	e8 61 9a fe ff       	call   f0101b5c <cprintf>
f01180fb:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f01180fe:	83 ec 0c             	sub    $0xc,%esp
f0118101:	68 bf 4e 13 f0       	push   $0xf0134ebf
f0118106:	e8 10 9d fe ff       	call   f0101e1b <execute_command>
f011810b:	83 c4 10             	add    $0x10,%esp
f011810e:	e9 c3 00 00 00       	jmp    f01181d6 <test_priorityRR_0+0x296>
	}
	else
	{
		cprintf("> Checking...\n");
f0118113:	83 ec 0c             	sub    $0xc,%esp
f0118116:	68 c6 4e 13 f0       	push   $0xf0134ec6
f011811b:	e8 3c 9a fe ff       	call   f0101b5c <cprintf>
f0118120:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f0118123:	e8 ad ec fe ff       	call   f0106dd5 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f0118128:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f011812f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0118136:	e9 8a 00 00 00       	jmp    f01181c5 <test_priorityRR_0+0x285>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011813b:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0118142:	eb 55                	jmp    f0118199 <test_priorityRR_0+0x259>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
f0118144:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0118147:	8b 14 85 70 db 83 f0 	mov    -0xf7c2490(,%eax,4),%edx
f011814e:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0118151:	89 c8                	mov    %ecx,%eax
f0118153:	c1 e0 02             	shl    $0x2,%eax
f0118156:	01 c8                	add    %ecx,%eax
f0118158:	01 c0                	add    %eax,%eax
f011815a:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011815d:	01 c8                	add    %ecx,%eax
f011815f:	8b 04 85 80 da 83 f0 	mov    -0xf7c2580(,%eax,4),%eax
f0118166:	83 ec 04             	sub    $0x4,%esp
f0118169:	52                   	push   %edx
f011816a:	ff 75 dc             	pushl  -0x24(%ebp)
f011816d:	50                   	push   %eax
f011816e:	e8 cd fc ff ff       	call   f0117e40 <find_in_range>
f0118173:	83 c4 10             	add    $0x10,%esp
f0118176:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f0118179:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011817d:	75 17                	jne    f0118196 <test_priorityRR_0+0x256>
					panic("The programs' order of finishing is not correct\n");
f011817f:	83 ec 04             	sub    $0x4,%esp
f0118182:	68 d8 4e 13 f0       	push   $0xf0134ed8
f0118187:	68 94 00 00 00       	push   $0x94
f011818c:	68 f1 4d 13 f0       	push   $0xf0134df1
f0118191:	e8 19 8d fe ff       	call   f0100eaf <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f0118196:	ff 45 d4             	incl   -0x2c(%ebp)
f0118199:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011819c:	89 d0                	mov    %edx,%eax
f011819e:	c1 e0 02             	shl    $0x2,%eax
f01181a1:	01 d0                	add    %edx,%eax
f01181a3:	01 c0                	add    %eax,%eax
f01181a5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01181a8:	01 d0                	add    %edx,%eax
f01181aa:	8b 04 85 80 da 83 f0 	mov    -0xf7c2580(,%eax,4),%eax
f01181b1:	85 c0                	test   %eax,%eax
f01181b3:	75 8f                	jne    f0118144 <test_priorityRR_0+0x204>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += env_count[i];
f01181b5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01181b8:	8b 04 85 70 db 83 f0 	mov    -0xf7c2490(,%eax,4),%eax
f01181bf:	01 45 dc             	add    %eax,-0x24(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f01181c2:	ff 45 d8             	incl   -0x28(%ebp)
f01181c5:	83 7d d8 04          	cmpl   $0x4,-0x28(%ebp)
f01181c9:	0f 8e 6c ff ff ff    	jle    f011813b <test_priorityRR_0+0x1fb>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += env_count[i];
		}
		firstTimeTest = 0;
f01181cf:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
	}
	cprintf("\nCongratulations!! test_priorityRR_0 completed successfully.\n");
f01181d6:	83 ec 0c             	sub    $0xc,%esp
f01181d9:	68 0c 4f 13 f0       	push   $0xf0134f0c
f01181de:	e8 79 99 fe ff       	call   f0101b5c <cprintf>
f01181e3:	83 c4 10             	add    $0x10,%esp
}
f01181e6:	90                   	nop
f01181e7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01181ea:	5b                   	pop    %ebx
f01181eb:	5e                   	pop    %esi
f01181ec:	5f                   	pop    %edi
f01181ed:	5d                   	pop    %ebp
f01181ee:	c3                   	ret    

f01181ef <test_priorityRR_1>:

void test_priorityRR_1()
{
f01181ef:	55                   	push   %ebp
f01181f0:	89 e5                	mov    %esp,%ebp
f01181f2:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTest)
f01181f5:	a0 a9 01 18 f0       	mov    0xf01801a9,%al
f01181fa:	84 c0                	test   %al,%al
f01181fc:	0f 84 ad 01 00 00    	je     f01183af <test_priorityRR_1+0x1c0>
	{
		rsttst();
f0118202:	e8 2e 07 00 00       	call   f0118935 <rsttst>
		firstTimeTest = 0;
f0118207:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
		struct Env *fibPri0Env = env_create("priRR_fib", 500, 0, 0);
f011820e:	6a 00                	push   $0x0
f0118210:	6a 00                	push   $0x0
f0118212:	68 f4 01 00 00       	push   $0x1f4
f0118217:	68 1d 4e 13 f0       	push   $0xf0134e1d
f011821c:	e8 43 2c ff ff       	call   f010ae64 <env_create>
f0118221:	83 c4 10             	add    $0x10,%esp
f0118224:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibPri4Env = env_create("priRR_fib_pri4", 500, 0, 0);
f0118227:	6a 00                	push   $0x0
f0118229:	6a 00                	push   $0x0
f011822b:	68 f4 01 00 00       	push   $0x1f4
f0118230:	68 84 4f 13 f0       	push   $0xf0134f84
f0118235:	e8 2a 2c ff ff       	call   f010ae64 <env_create>
f011823a:	83 c4 10             	add    $0x10,%esp
f011823d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibPri8Env = env_create("priRR_fib_pri8", 500, 0, 0);
f0118240:	6a 00                	push   $0x0
f0118242:	6a 00                	push   $0x0
f0118244:	68 f4 01 00 00       	push   $0x1f4
f0118249:	68 93 4f 13 f0       	push   $0xf0134f93
f011824e:	e8 11 2c ff ff       	call   f010ae64 <env_create>
f0118253:	83 c4 10             	add    $0x10,%esp
f0118256:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		struct Env *fibPri2ParentEnv = env_create("priRR_fib_create", 500, 0, 0);
f0118259:	6a 00                	push   $0x0
f011825b:	6a 00                	push   $0x0
f011825d:	68 f4 01 00 00       	push   $0x1f4
f0118262:	68 a2 4f 13 f0       	push   $0xf0134fa2
f0118267:	e8 f8 2b ff ff       	call   f010ae64 <env_create>
f011826c:	83 c4 10             	add    $0x10,%esp
f011826f:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (fibPri0Env == NULL || fibPri4Env == NULL || fibPri8Env == NULL || fibPri2ParentEnv == NULL)
f0118272:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0118276:	74 12                	je     f011828a <test_priorityRR_1+0x9b>
f0118278:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011827c:	74 0c                	je     f011828a <test_priorityRR_1+0x9b>
f011827e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0118282:	74 06                	je     f011828a <test_priorityRR_1+0x9b>
f0118284:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0118288:	75 17                	jne    f01182a1 <test_priorityRR_1+0xb2>
			panic("Loading programs failed\n");
f011828a:	83 ec 04             	sub    $0x4,%esp
f011828d:	68 27 4e 13 f0       	push   $0xf0134e27
f0118292:	68 a8 00 00 00       	push   $0xa8
f0118297:	68 f1 4d 13 f0       	push   $0xf0134df1
f011829c:	e8 0e 8c fe ff       	call   f0100eaf <_panic>
		if (fibPri0Env->page_WS_max_size != 500 || fibPri4Env->page_WS_max_size != 500 || fibPri8Env->page_WS_max_size != 500 || fibPri2ParentEnv->page_WS_max_size != 500)
f01182a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01182a4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01182aa:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01182af:	75 30                	jne    f01182e1 <test_priorityRR_1+0xf2>
f01182b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01182b4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01182ba:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01182bf:	75 20                	jne    f01182e1 <test_priorityRR_1+0xf2>
f01182c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01182c4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01182ca:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01182cf:	75 10                	jne    f01182e1 <test_priorityRR_1+0xf2>
f01182d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01182d4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01182da:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01182df:	74 17                	je     f01182f8 <test_priorityRR_1+0x109>
			panic("The programs should be initially loaded with the given working set size.\n");
f01182e1:	83 ec 04             	sub    $0x4,%esp
f01182e4:	68 b4 4f 13 f0       	push   $0xf0134fb4
f01182e9:	68 aa 00 00 00       	push   $0xaa
f01182ee:	68 f1 4d 13 f0       	push   $0xf0134df1
f01182f3:	e8 b7 8b fe ff       	call   f0100eaf <_panic>
		sched_new_env(fibPri8Env);
f01182f8:	83 ec 0c             	sub    $0xc,%esp
f01182fb:	ff 75 e4             	pushl  -0x1c(%ebp)
f01182fe:	e8 86 e3 fe ff       	call   f0106689 <sched_new_env>
f0118303:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibPri0Env);
f0118306:	83 ec 0c             	sub    $0xc,%esp
f0118309:	ff 75 ec             	pushl  -0x14(%ebp)
f011830c:	e8 78 e3 fe ff       	call   f0106689 <sched_new_env>
f0118311:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibPri4Env);
f0118314:	83 ec 0c             	sub    $0xc,%esp
f0118317:	ff 75 e8             	pushl  -0x18(%ebp)
f011831a:	e8 6a e3 fe ff       	call   f0106689 <sched_new_env>
f011831f:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibPri2ParentEnv);
f0118322:	83 ec 0c             	sub    $0xc,%esp
f0118325:	ff 75 e0             	pushl  -0x20(%ebp)
f0118328:	e8 5c e3 fe ff       	call   f0106689 <sched_new_env>
f011832d:	83 c4 10             	add    $0x10,%esp
		env_set_priority(fibPri2ParentEnv->env_id, 6);
f0118330:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118333:	8b 40 10             	mov    0x10(%eax),%eax
f0118336:	83 ec 08             	sub    $0x8,%esp
f0118339:	6a 06                	push   $0x6
f011833b:	50                   	push   %eax
f011833c:	e8 1d f3 fe ff       	call   f010765e <env_set_priority>
f0118341:	83 c4 10             	add    $0x10,%esp

		prog_orders[0][0] = fibPri0Env->env_id;
f0118344:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118347:	8b 40 10             	mov    0x10(%eax),%eax
f011834a:	a3 80 da 83 f0       	mov    %eax,0xf083da80
		prog_orders[1][0] = fibPri4Env->env_id;
f011834f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118352:	8b 40 10             	mov    0x10(%eax),%eax
f0118355:	a3 a8 da 83 f0       	mov    %eax,0xf083daa8
		prog_orders[2][0] = fibPri2ParentEnv->env_id ; //id of the parent
f011835a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011835d:	8b 40 10             	mov    0x10(%eax),%eax
f0118360:	a3 d0 da 83 f0       	mov    %eax,0xf083dad0
		prog_orders[3][0] = fibPri2ParentEnv->env_id + 1; //id of the 1st created child fib
f0118365:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118368:	8b 40 10             	mov    0x10(%eax),%eax
f011836b:	40                   	inc    %eax
f011836c:	a3 f8 da 83 f0       	mov    %eax,0xf083daf8
		prog_orders[4][0] = fibPri8Env->env_id;
f0118371:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118374:	8b 40 10             	mov    0x10(%eax),%eax
f0118377:	a3 20 db 83 f0       	mov    %eax,0xf083db20
		prog_orders[5][0] = fibPri2ParentEnv->env_id + 2; //id of the 2nd created child fib
f011837c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011837f:	8b 40 10             	mov    0x10(%eax),%eax
f0118382:	83 c0 02             	add    $0x2,%eax
f0118385:	a3 48 db 83 f0       	mov    %eax,0xf083db48

		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011838a:	83 ec 0c             	sub    $0xc,%esp
f011838d:	68 70 4e 13 f0       	push   $0xf0134e70
f0118392:	e8 c5 97 fe ff       	call   f0101b5c <cprintf>
f0118397:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011839a:	83 ec 0c             	sub    $0xc,%esp
f011839d:	68 bf 4e 13 f0       	push   $0xf0134ebf
f01183a2:	e8 74 9a fe ff       	call   f0101e1b <execute_command>
f01183a7:	83 c4 10             	add    $0x10,%esp
f01183aa:	e9 c0 00 00 00       	jmp    f011846f <test_priorityRR_1+0x280>
	}
	else
	{
		cprintf("> Checking...\n");
f01183af:	83 ec 0c             	sub    $0xc,%esp
f01183b2:	68 c6 4e 13 f0       	push   $0xf0134ec6
f01183b7:	e8 a0 97 fe ff       	call   f0101b5c <cprintf>
f01183bc:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f01183bf:	e8 11 ea fe ff       	call   f0106dd5 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f01183c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f01183cb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_kspinlock(&ProcessQueues.qlock);
f01183d2:	83 ec 0c             	sub    $0xc,%esp
f01183d5:	68 80 dd 83 f0       	push   $0xf083dd80
f01183da:	e8 9e 79 ff ff       	call   f010fd7d <acquire_kspinlock>
f01183df:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f01183e2:	a1 0c de 83 f0       	mov    0xf083de0c,%eax
f01183e7:	89 45 dc             	mov    %eax,-0x24(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f01183ea:	a1 04 de 83 f0       	mov    0xf083de04,%eax
f01183ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f01183f2:	eb 63                	jmp    f0118457 <test_priorityRR_1+0x268>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				cprintf("%s - id=%d, priority=%d\n", env->prog_name, env->env_id, env->priority);
f01183f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01183f7:	8b 50 1c             	mov    0x1c(%eax),%edx
f01183fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01183fd:	8b 40 10             	mov    0x10(%eax),%eax
f0118400:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0118403:	83 c1 20             	add    $0x20,%ecx
f0118406:	52                   	push   %edx
f0118407:	50                   	push   %eax
f0118408:	51                   	push   %ecx
f0118409:	68 fe 4f 13 f0       	push   $0xf0134ffe
f011840e:	e8 49 97 fe ff       	call   f0101b5c <cprintf>
f0118413:	83 c4 10             	add    $0x10,%esp
				if (prog_orders[i][0] != env->env_id)
f0118416:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118419:	89 d0                	mov    %edx,%eax
f011841b:	c1 e0 02             	shl    $0x2,%eax
f011841e:	01 d0                	add    %edx,%eax
f0118420:	c1 e0 03             	shl    $0x3,%eax
f0118423:	05 80 da 83 f0       	add    $0xf083da80,%eax
f0118428:	8b 10                	mov    (%eax),%edx
f011842a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011842d:	8b 40 10             	mov    0x10(%eax),%eax
f0118430:	39 c2                	cmp    %eax,%edx
f0118432:	74 17                	je     f011844b <test_priorityRR_1+0x25c>
					panic("The programs' order of finishing is not correct\n");
f0118434:	83 ec 04             	sub    $0x4,%esp
f0118437:	68 d8 4e 13 f0       	push   $0xf0134ed8
f011843c:	68 cc 00 00 00       	push   $0xcc
f0118441:	68 f1 4d 13 f0       	push   $0xf0134df1
f0118446:	e8 64 8a fe ff       	call   f0100eaf <_panic>
				i++;
f011844b:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011844e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118451:	8b 40 0c             	mov    0xc(%eax),%eax
f0118454:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118457:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011845a:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011845d:	7c 95                	jl     f01183f4 <test_priorityRR_1+0x205>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);
f011845f:	83 ec 0c             	sub    $0xc,%esp
f0118462:	68 80 dd 83 f0       	push   $0xf083dd80
f0118467:	e8 b6 79 ff ff       	call   f010fe22 <release_kspinlock>
f011846c:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_priorityRR_1 completed successfully.\n");
f011846f:	83 ec 0c             	sub    $0xc,%esp
f0118472:	68 18 50 13 f0       	push   $0xf0135018
f0118477:	e8 e0 96 fe ff       	call   f0101b5c <cprintf>
f011847c:	83 c4 10             	add    $0x10,%esp
}
f011847f:	90                   	nop
f0118480:	c9                   	leave  
f0118481:	c3                   	ret    

f0118482 <test_priorityRR_2>:

void test_priorityRR_2()
{
f0118482:	55                   	push   %ebp
f0118483:	89 e5                	mov    %esp,%ebp
f0118485:	57                   	push   %edi
f0118486:	56                   	push   %esi
f0118487:	53                   	push   %ebx
f0118488:	83 ec 6c             	sub    $0x6c,%esp
	if (firstTimeTest)
f011848b:	a0 a9 01 18 f0       	mov    0xf01801a9,%al
f0118490:	84 c0                	test   %al,%al
f0118492:	0f 84 6c 02 00 00    	je     f0118704 <test_priorityRR_2+0x282>
	{
		firstTimeTest = 0;
f0118498:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
		int priority_values[] = {0, 2, 4, 6};
f011849f:	8d 45 a8             	lea    -0x58(%ebp),%eax
f01184a2:	bb 98 50 13 f0       	mov    $0xf0135098,%ebx
f01184a7:	ba 04 00 00 00       	mov    $0x4,%edx
f01184ac:	89 c7                	mov    %eax,%edi
f01184ae:	89 de                	mov    %ebx,%esi
f01184b0:	89 d1                	mov    %edx,%ecx
f01184b2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f01184b4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01184bb:	e9 41 01 00 00       	jmp    f0118601 <test_priorityRR_2+0x17f>
		{
			struct Env *env = env_create("priRR_fib", 500, 0, 0);
f01184c0:	6a 00                	push   $0x0
f01184c2:	6a 00                	push   $0x0
f01184c4:	68 f4 01 00 00       	push   $0x1f4
f01184c9:	68 1d 4e 13 f0       	push   $0xf0134e1d
f01184ce:	e8 91 29 ff ff       	call   f010ae64 <env_create>
f01184d3:	83 c4 10             	add    $0x10,%esp
f01184d6:	89 45 cc             	mov    %eax,-0x34(%ebp)
			int priority_index = i % (TOTAL_TEST_VALUES-1);
f01184d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01184dc:	25 03 00 00 80       	and    $0x80000003,%eax
f01184e1:	85 c0                	test   %eax,%eax
f01184e3:	79 05                	jns    f01184ea <test_priorityRR_2+0x68>
f01184e5:	48                   	dec    %eax
f01184e6:	83 c8 fc             	or     $0xfffffffc,%eax
f01184e9:	40                   	inc    %eax
f01184ea:	89 45 c8             	mov    %eax,-0x38(%ebp)
			env_set_priority(env->env_id, priority_values[priority_index]);
f01184ed:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01184f0:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
f01184f4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01184f7:	8b 40 10             	mov    0x10(%eax),%eax
f01184fa:	83 ec 08             	sub    $0x8,%esp
f01184fd:	52                   	push   %edx
f01184fe:	50                   	push   %eax
f01184ff:	e8 5a f1 fe ff       	call   f010765e <env_set_priority>
f0118504:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f0118507:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f011850b:	75 17                	jne    f0118524 <test_priorityRR_2+0xa2>
				panic("Loading programs failed\n");
f011850d:	83 ec 04             	sub    $0x4,%esp
f0118510:	68 27 4e 13 f0       	push   $0xf0134e27
f0118515:	68 e1 00 00 00       	push   $0xe1
f011851a:	68 f1 4d 13 f0       	push   $0xf0134df1
f011851f:	e8 8b 89 fe ff       	call   f0100eaf <_panic>
			if (env->page_WS_max_size != 500)
f0118524:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118527:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011852d:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f0118532:	74 17                	je     f011854b <test_priorityRR_2+0xc9>
				panic("The program working set size is not correct\n");
f0118534:	83 ec 04             	sub    $0x4,%esp
f0118537:	68 40 4e 13 f0       	push   $0xf0134e40
f011853c:	68 e3 00 00 00       	push   $0xe3
f0118541:	68 f1 4d 13 f0       	push   $0xf0134df1
f0118546:	e8 64 89 fe ff       	call   f0100eaf <_panic>

			switch (priority_values[priority_index])
f011854b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011854e:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
f0118552:	83 f8 02             	cmp    $0x2,%eax
f0118555:	74 3a                	je     f0118591 <test_priorityRR_2+0x10f>
f0118557:	83 f8 02             	cmp    $0x2,%eax
f011855a:	7f 09                	jg     f0118565 <test_priorityRR_2+0xe3>
f011855c:	85 c0                	test   %eax,%eax
f011855e:	74 11                	je     f0118571 <test_priorityRR_2+0xef>
f0118560:	e9 8b 00 00 00       	jmp    f01185f0 <test_priorityRR_2+0x16e>
f0118565:	83 f8 04             	cmp    $0x4,%eax
f0118568:	74 47                	je     f01185b1 <test_priorityRR_2+0x12f>
f011856a:	83 f8 06             	cmp    $0x6,%eax
f011856d:	74 62                	je     f01185d1 <test_priorityRR_2+0x14f>
f011856f:	eb 7f                	jmp    f01185f0 <test_priorityRR_2+0x16e>
			{
			case 0:
				prog_orders[1][env_count[1]++] = env->env_id;
f0118571:	a1 74 db 83 f0       	mov    0xf083db74,%eax
f0118576:	8d 50 01             	lea    0x1(%eax),%edx
f0118579:	89 15 74 db 83 f0    	mov    %edx,0xf083db74
f011857f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0118582:	8b 52 10             	mov    0x10(%edx),%edx
f0118585:	83 c0 0a             	add    $0xa,%eax
f0118588:	89 14 85 80 da 83 f0 	mov    %edx,-0xf7c2580(,%eax,4)
				break;
f011858f:	eb 5f                	jmp    f01185f0 <test_priorityRR_2+0x16e>
			case 2:
				prog_orders[2][env_count[2]++] = env->env_id;
f0118591:	a1 78 db 83 f0       	mov    0xf083db78,%eax
f0118596:	8d 50 01             	lea    0x1(%eax),%edx
f0118599:	89 15 78 db 83 f0    	mov    %edx,0xf083db78
f011859f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01185a2:	8b 52 10             	mov    0x10(%edx),%edx
f01185a5:	83 c0 14             	add    $0x14,%eax
f01185a8:	89 14 85 80 da 83 f0 	mov    %edx,-0xf7c2580(,%eax,4)
				break;
f01185af:	eb 3f                	jmp    f01185f0 <test_priorityRR_2+0x16e>
			case 4:
				prog_orders[3][env_count[3]++] = env->env_id;
f01185b1:	a1 7c db 83 f0       	mov    0xf083db7c,%eax
f01185b6:	8d 50 01             	lea    0x1(%eax),%edx
f01185b9:	89 15 7c db 83 f0    	mov    %edx,0xf083db7c
f01185bf:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01185c2:	8b 52 10             	mov    0x10(%edx),%edx
f01185c5:	83 c0 1e             	add    $0x1e,%eax
f01185c8:	89 14 85 80 da 83 f0 	mov    %edx,-0xf7c2580(,%eax,4)
				break;
f01185cf:	eb 1f                	jmp    f01185f0 <test_priorityRR_2+0x16e>
			case 6:
				prog_orders[4][env_count[4]++] = env->env_id;
f01185d1:	a1 80 db 83 f0       	mov    0xf083db80,%eax
f01185d6:	8d 50 01             	lea    0x1(%eax),%edx
f01185d9:	89 15 80 db 83 f0    	mov    %edx,0xf083db80
f01185df:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01185e2:	8b 52 10             	mov    0x10(%edx),%edx
f01185e5:	83 c0 28             	add    $0x28,%eax
f01185e8:	89 14 85 80 da 83 f0 	mov    %edx,-0xf7c2580(,%eax,4)
				break;
f01185ef:	90                   	nop
			}
			sched_new_env(env);
f01185f0:	83 ec 0c             	sub    $0xc,%esp
f01185f3:	ff 75 cc             	pushl  -0x34(%ebp)
f01185f6:	e8 8e e0 fe ff       	call   f0106689 <sched_new_env>
f01185fb:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTest)
	{
		firstTimeTest = 0;
		int priority_values[] = {0, 2, 4, 6};
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f01185fe:	ff 45 e4             	incl   -0x1c(%ebp)
f0118601:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
f0118605:	0f 8e b5 fe ff ff    	jle    f01184c0 <test_priorityRR_2+0x3e>
				break;
			}
			sched_new_env(env);
		}

		int priority_values2[] = {0, 1, 2, 3, 4, 5, 6, 7 };
f011860b:	8d 45 88             	lea    -0x78(%ebp),%eax
f011860e:	bb c0 50 13 f0       	mov    $0xf01350c0,%ebx
f0118613:	ba 08 00 00 00       	mov    $0x8,%edx
f0118618:	89 c7                	mov    %eax,%edi
f011861a:	89 de                	mov    %ebx,%esi
f011861c:	89 d1                	mov    %edx,%ecx
f011861e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f0118620:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0118627:	e9 a9 00 00 00       	jmp    f01186d5 <test_priorityRR_2+0x253>
		{
			struct Env *env = env_create("priRR_fib_small", 500, 0, 0);
f011862c:	6a 00                	push   $0x0
f011862e:	6a 00                	push   $0x0
f0118630:	68 f4 01 00 00       	push   $0x1f4
f0118635:	68 0d 4e 13 f0       	push   $0xf0134e0d
f011863a:	e8 25 28 ff ff       	call   f010ae64 <env_create>
f011863f:	83 c4 10             	add    $0x10,%esp
f0118642:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			int priority_index = i ;
f0118645:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118648:	89 45 c0             	mov    %eax,-0x40(%ebp)
			env_set_priority(env->env_id, priority_values2[priority_index]);
f011864b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011864e:	8b 54 85 88          	mov    -0x78(%ebp,%eax,4),%edx
f0118652:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118655:	8b 40 10             	mov    0x10(%eax),%eax
f0118658:	83 ec 08             	sub    $0x8,%esp
f011865b:	52                   	push   %edx
f011865c:	50                   	push   %eax
f011865d:	e8 fc ef fe ff       	call   f010765e <env_set_priority>
f0118662:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f0118665:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f0118669:	75 17                	jne    f0118682 <test_priorityRR_2+0x200>
				panic("Loading programs failed\n");
f011866b:	83 ec 04             	sub    $0x4,%esp
f011866e:	68 27 4e 13 f0       	push   $0xf0134e27
f0118673:	68 fe 00 00 00       	push   $0xfe
f0118678:	68 f1 4d 13 f0       	push   $0xf0134df1
f011867d:	e8 2d 88 fe ff       	call   f0100eaf <_panic>
			if (env->page_WS_max_size != 500)
f0118682:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118685:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011868b:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f0118690:	74 17                	je     f01186a9 <test_priorityRR_2+0x227>
				panic("The program working set size is not correct\n");
f0118692:	83 ec 04             	sub    $0x4,%esp
f0118695:	68 40 4e 13 f0       	push   $0xf0134e40
f011869a:	68 00 01 00 00       	push   $0x100
f011869f:	68 f1 4d 13 f0       	push   $0xf0134df1
f01186a4:	e8 06 88 fe ff       	call   f0100eaf <_panic>

			prog_orders[0][env_count[0]++] = env->env_id;
f01186a9:	a1 70 db 83 f0       	mov    0xf083db70,%eax
f01186ae:	8d 50 01             	lea    0x1(%eax),%edx
f01186b1:	89 15 70 db 83 f0    	mov    %edx,0xf083db70
f01186b7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01186ba:	8b 52 10             	mov    0x10(%edx),%edx
f01186bd:	89 14 85 80 da 83 f0 	mov    %edx,-0xf7c2580(,%eax,4)

			sched_new_env(env);
f01186c4:	83 ec 0c             	sub    $0xc,%esp
f01186c7:	ff 75 c4             	pushl  -0x3c(%ebp)
f01186ca:	e8 ba df fe ff       	call   f0106689 <sched_new_env>
f01186cf:	83 c4 10             	add    $0x10,%esp
			}
			sched_new_env(env);
		}

		int priority_values2[] = {0, 1, 2, 3, 4, 5, 6, 7 };
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f01186d2:	ff 45 e0             	incl   -0x20(%ebp)
f01186d5:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
f01186d9:	0f 8e 4d ff ff ff    	jle    f011862c <test_priorityRR_2+0x1aa>
			prog_orders[0][env_count[0]++] = env->env_id;

			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f01186df:	83 ec 0c             	sub    $0xc,%esp
f01186e2:	68 70 4e 13 f0       	push   $0xf0134e70
f01186e7:	e8 70 94 fe ff       	call   f0101b5c <cprintf>
f01186ec:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f01186ef:	83 ec 0c             	sub    $0xc,%esp
f01186f2:	68 bf 4e 13 f0       	push   $0xf0134ebf
f01186f7:	e8 1f 97 fe ff       	call   f0101e1b <execute_command>
f01186fc:	83 c4 10             	add    $0x10,%esp
f01186ff:	e9 36 01 00 00       	jmp    f011883a <test_priorityRR_2+0x3b8>
	}
	else
	{
		cprintf("> Checking...\n");
f0118704:	83 ec 0c             	sub    $0xc,%esp
f0118707:	68 c6 4e 13 f0       	push   $0xf0134ec6
f011870c:	e8 4b 94 fe ff       	call   f0101b5c <cprintf>
f0118711:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f0118714:	e8 bc e6 fe ff       	call   f0106dd5 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f0118719:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f0118720:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0118727:	e9 fd 00 00 00       	jmp    f0118829 <test_priorityRR_2+0x3a7>
		{
			if (i == 0) //small programs should finish in their strict order
f011872c:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0118730:	75 6d                	jne    f011879f <test_priorityRR_2+0x31d>
			{
				for (int j = 0; j < INSTANCES_NUMBER - 2; j++)
f0118732:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0118739:	eb 4c                	jmp    f0118787 <test_priorityRR_2+0x305>
				{
					int exist = find_in_range(prog_orders[i][j], j, 1);
f011873b:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011873e:	89 d0                	mov    %edx,%eax
f0118740:	c1 e0 02             	shl    $0x2,%eax
f0118743:	01 d0                	add    %edx,%eax
f0118745:	01 c0                	add    %eax,%eax
f0118747:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011874a:	01 d0                	add    %edx,%eax
f011874c:	8b 04 85 80 da 83 f0 	mov    -0xf7c2580(,%eax,4),%eax
f0118753:	83 ec 04             	sub    $0x4,%esp
f0118756:	6a 01                	push   $0x1
f0118758:	ff 75 d4             	pushl  -0x2c(%ebp)
f011875b:	50                   	push   %eax
f011875c:	e8 df f6 ff ff       	call   f0117e40 <find_in_range>
f0118761:	83 c4 10             	add    $0x10,%esp
f0118764:	89 45 bc             	mov    %eax,-0x44(%ebp)
					if (exist == -1)
f0118767:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f011876b:	75 17                	jne    f0118784 <test_priorityRR_2+0x302>
						panic("The programs' order of finishing is not correct\n");
f011876d:	83 ec 04             	sub    $0x4,%esp
f0118770:	68 d8 4e 13 f0       	push   $0xf0134ed8
f0118775:	68 18 01 00 00       	push   $0x118
f011877a:	68 f1 4d 13 f0       	push   $0xf0134df1
f011877f:	e8 2b 87 fe ff       	call   f0100eaf <_panic>
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
		{
			if (i == 0) //small programs should finish in their strict order
			{
				for (int j = 0; j < INSTANCES_NUMBER - 2; j++)
f0118784:	ff 45 d4             	incl   -0x2c(%ebp)
f0118787:	83 7d d4 07          	cmpl   $0x7,-0x2c(%ebp)
f011878b:	7e ae                	jle    f011873b <test_priorityRR_2+0x2b9>
				{
					int exist = find_in_range(prog_orders[i][j], j, 1);
					if (exist == -1)
						panic("The programs' order of finishing is not correct\n");
				}
				start_idx += env_count[i];
f011878d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0118790:	8b 04 85 70 db 83 f0 	mov    -0xf7c2490(,%eax,4),%eax
f0118797:	01 45 dc             	add    %eax,-0x24(%ebp)
f011879a:	e9 87 00 00 00       	jmp    f0118826 <test_priorityRR_2+0x3a4>
			}
			else
			{
				for (int j = 0; prog_orders[i][j] != 0; j++)
f011879f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01187a6:	eb 55                	jmp    f01187fd <test_priorityRR_2+0x37b>
				{
					int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
f01187a8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01187ab:	8b 14 85 70 db 83 f0 	mov    -0xf7c2490(,%eax,4),%edx
f01187b2:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f01187b5:	89 c8                	mov    %ecx,%eax
f01187b7:	c1 e0 02             	shl    $0x2,%eax
f01187ba:	01 c8                	add    %ecx,%eax
f01187bc:	01 c0                	add    %eax,%eax
f01187be:	8b 4d d0             	mov    -0x30(%ebp),%ecx
f01187c1:	01 c8                	add    %ecx,%eax
f01187c3:	8b 04 85 80 da 83 f0 	mov    -0xf7c2580(,%eax,4),%eax
f01187ca:	83 ec 04             	sub    $0x4,%esp
f01187cd:	52                   	push   %edx
f01187ce:	ff 75 dc             	pushl  -0x24(%ebp)
f01187d1:	50                   	push   %eax
f01187d2:	e8 69 f6 ff ff       	call   f0117e40 <find_in_range>
f01187d7:	83 c4 10             	add    $0x10,%esp
f01187da:	89 45 b8             	mov    %eax,-0x48(%ebp)
					if (exist == -1)
f01187dd:	83 7d b8 ff          	cmpl   $0xffffffff,-0x48(%ebp)
f01187e1:	75 17                	jne    f01187fa <test_priorityRR_2+0x378>
						panic("The programs' order of finishing is not correct\n");
f01187e3:	83 ec 04             	sub    $0x4,%esp
f01187e6:	68 d8 4e 13 f0       	push   $0xf0134ed8
f01187eb:	68 22 01 00 00       	push   $0x122
f01187f0:	68 f1 4d 13 f0       	push   $0xf0134df1
f01187f5:	e8 b5 86 fe ff       	call   f0100eaf <_panic>
				}
				start_idx += env_count[i];
			}
			else
			{
				for (int j = 0; prog_orders[i][j] != 0; j++)
f01187fa:	ff 45 d0             	incl   -0x30(%ebp)
f01187fd:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0118800:	89 d0                	mov    %edx,%eax
f0118802:	c1 e0 02             	shl    $0x2,%eax
f0118805:	01 d0                	add    %edx,%eax
f0118807:	01 c0                	add    %eax,%eax
f0118809:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011880c:	01 d0                	add    %edx,%eax
f011880e:	8b 04 85 80 da 83 f0 	mov    -0xf7c2580(,%eax,4),%eax
f0118815:	85 c0                	test   %eax,%eax
f0118817:	75 8f                	jne    f01187a8 <test_priorityRR_2+0x326>
				{
					int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
					if (exist == -1)
						panic("The programs' order of finishing is not correct\n");
				}
				start_idx += env_count[i];
f0118819:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011881c:	8b 04 85 70 db 83 f0 	mov    -0xf7c2490(,%eax,4),%eax
f0118823:	01 45 dc             	add    %eax,-0x24(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f0118826:	ff 45 d8             	incl   -0x28(%ebp)
f0118829:	83 7d d8 04          	cmpl   $0x4,-0x28(%ebp)
f011882d:	0f 8e f9 fe ff ff    	jle    f011872c <test_priorityRR_2+0x2aa>
						panic("The programs' order of finishing is not correct\n");
				}
				start_idx += env_count[i];
			}
		}
		firstTimeTest = 0;
f0118833:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
	}
	cprintf("\nCongratulations!! test_priorityRR_2 completed successfully.\n");
f011883a:	83 ec 0c             	sub    $0xc,%esp
f011883d:	68 58 50 13 f0       	push   $0xf0135058
f0118842:	e8 15 93 fe ff       	call   f0101b5c <cprintf>
f0118847:	83 c4 10             	add    $0x10,%esp
}
f011884a:	90                   	nop
f011884b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011884e:	5b                   	pop    %ebx
f011884f:	5e                   	pop    %esi
f0118850:	5f                   	pop    %edi
f0118851:	5d                   	pop    %ebp
f0118852:	c3                   	ret    

f0118853 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f0118853:	55                   	push   %ebp
f0118854:	89 e5                	mov    %esp,%ebp
f0118856:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f0118859:	8b 45 0c             	mov    0xc(%ebp),%eax
f011885c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011885f:	8b 45 08             	mov    0x8(%ebp),%eax
f0118862:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0118865:	89 10                	mov    %edx,(%eax)
}
f0118867:	8b 45 08             	mov    0x8(%ebp),%eax
f011886a:	c9                   	leave  
f011886b:	c2 04 00             	ret    $0x4

f011886e <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011886e:	55                   	push   %ebp
f011886f:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f0118871:	8b 45 08             	mov    0x8(%ebp),%eax
f0118874:	85 c0                	test   %eax,%eax
f0118876:	78 16                	js     f011888e <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f0118878:	8b 45 08             	mov    0x8(%ebp),%eax
f011887b:	05 00 20 00 00       	add    $0x2000,%eax
f0118880:	85 c0                	test   %eax,%eax
f0118882:	79 05                	jns    f0118889 <fix_round+0x1b>
f0118884:	05 ff 3f 00 00       	add    $0x3fff,%eax
f0118889:	c1 f8 0e             	sar    $0xe,%eax
f011888c:	eb 14                	jmp    f01188a2 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011888e:	8b 45 08             	mov    0x8(%ebp),%eax
f0118891:	2d 00 20 00 00       	sub    $0x2000,%eax
f0118896:	85 c0                	test   %eax,%eax
f0118898:	79 05                	jns    f011889f <fix_round+0x31>
f011889a:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011889f:	c1 f8 0e             	sar    $0xe,%eax
}
f01188a2:	5d                   	pop    %ebp
f01188a3:	c3                   	ret    

f01188a4 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f01188a4:	55                   	push   %ebp
f01188a5:	89 e5                	mov    %esp,%ebp
f01188a7:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f01188aa:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01188ae:	79 16                	jns    f01188c6 <fix_scale+0x22>
f01188b0:	68 e0 50 13 f0       	push   $0xf01350e0
f01188b5:	68 e7 50 13 f0       	push   $0xf01350e7
f01188ba:	6a 5a                	push   $0x5a
f01188bc:	68 fc 50 13 f0       	push   $0xf01350fc
f01188c1:	e8 e9 85 fe ff       	call   f0100eaf <_panic>
  return __mk_fix (x.f * n);
f01188c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01188c9:	0f af 45 10          	imul   0x10(%ebp),%eax
f01188cd:	89 c2                	mov    %eax,%edx
f01188cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01188d2:	83 ec 08             	sub    $0x8,%esp
f01188d5:	52                   	push   %edx
f01188d6:	50                   	push   %eax
f01188d7:	e8 77 ff ff ff       	call   f0118853 <__mk_fix>
f01188dc:	83 c4 0c             	add    $0xc,%esp
}
f01188df:	8b 45 08             	mov    0x8(%ebp),%eax
f01188e2:	c9                   	leave  
f01188e3:	c2 04 00             	ret    $0x4

f01188e6 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f01188e6:	55                   	push   %ebp
f01188e7:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f01188e9:	8b 45 08             	mov    0x8(%ebp),%eax
f01188ec:	8b 15 68 61 85 f0    	mov    0xf0856168,%edx
f01188f2:	29 d0                	sub    %edx,%eax
f01188f4:	c1 f8 02             	sar    $0x2,%eax
f01188f7:	89 c2                	mov    %eax,%edx
f01188f9:	89 d0                	mov    %edx,%eax
f01188fb:	c1 e0 02             	shl    $0x2,%eax
f01188fe:	01 d0                	add    %edx,%eax
f0118900:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0118907:	01 c8                	add    %ecx,%eax
f0118909:	01 c0                	add    %eax,%eax
f011890b:	01 d0                	add    %edx,%eax
f011890d:	89 c1                	mov    %eax,%ecx
f011890f:	c1 e1 08             	shl    $0x8,%ecx
f0118912:	01 c8                	add    %ecx,%eax
f0118914:	89 c1                	mov    %eax,%ecx
f0118916:	c1 e1 10             	shl    $0x10,%ecx
f0118919:	01 c8                	add    %ecx,%eax
f011891b:	c1 e0 02             	shl    $0x2,%eax
f011891e:	01 d0                	add    %edx,%eax
}
f0118920:	5d                   	pop    %ebp
f0118921:	c3                   	ret    

f0118922 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0118922:	55                   	push   %ebp
f0118923:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0118925:	ff 75 08             	pushl  0x8(%ebp)
f0118928:	e8 b9 ff ff ff       	call   f01188e6 <to_frame_number>
f011892d:	83 c4 04             	add    $0x4,%esp
f0118930:	c1 e0 0c             	shl    $0xc,%eax
}
f0118933:	c9                   	leave  
f0118934:	c3                   	ret    

f0118935 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f0118935:	55                   	push   %ebp
f0118936:	89 e5                	mov    %esp,%ebp
f0118938:	83 ec 08             	sub    $0x8,%esp
	init_kspinlock(&tstcntlock, "tstcnt lock");
f011893b:	83 ec 08             	sub    $0x8,%esp
f011893e:	68 10 51 13 f0       	push   $0xf0135110
f0118943:	68 60 64 85 f0       	push   $0xf0856460
f0118948:	e8 ff 73 ff ff       	call   f010fd4c <init_kspinlock>
f011894d:	83 c4 10             	add    $0x10,%esp
	acquire_kspinlock(&tstcntlock);
f0118950:	83 ec 0c             	sub    $0xc,%esp
f0118953:	68 60 64 85 f0       	push   $0xf0856460
f0118958:	e8 20 74 ff ff       	call   f010fd7d <acquire_kspinlock>
f011895d:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f0118960:	c7 05 c8 dc 83 f0 00 	movl   $0x0,0xf083dcc8
f0118967:	00 00 00 
	}
	release_kspinlock(&tstcntlock);
f011896a:	83 ec 0c             	sub    $0xc,%esp
f011896d:	68 60 64 85 f0       	push   $0xf0856460
f0118972:	e8 ab 74 ff ff       	call   f010fe22 <release_kspinlock>
f0118977:	83 c4 10             	add    $0x10,%esp
}
f011897a:	90                   	nop
f011897b:	c9                   	leave  
f011897c:	c3                   	ret    

f011897d <inctst>:
void inctst()
{
f011897d:	55                   	push   %ebp
f011897e:	89 e5                	mov    %esp,%ebp
f0118980:	83 ec 08             	sub    $0x8,%esp
	acquire_kspinlock(&tstcntlock);
f0118983:	83 ec 0c             	sub    $0xc,%esp
f0118986:	68 60 64 85 f0       	push   $0xf0856460
f011898b:	e8 ed 73 ff ff       	call   f010fd7d <acquire_kspinlock>
f0118990:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f0118993:	a1 c8 dc 83 f0       	mov    0xf083dcc8,%eax
f0118998:	40                   	inc    %eax
f0118999:	a3 c8 dc 83 f0       	mov    %eax,0xf083dcc8
	}
	release_kspinlock(&tstcntlock);
f011899e:	83 ec 0c             	sub    $0xc,%esp
f01189a1:	68 60 64 85 f0       	push   $0xf0856460
f01189a6:	e8 77 74 ff ff       	call   f010fe22 <release_kspinlock>
f01189ab:	83 c4 10             	add    $0x10,%esp
}
f01189ae:	90                   	nop
f01189af:	c9                   	leave  
f01189b0:	c3                   	ret    

f01189b1 <gettst>:
uint32 gettst()
{
f01189b1:	55                   	push   %ebp
f01189b2:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f01189b4:	a1 c8 dc 83 f0       	mov    0xf083dcc8,%eax
}
f01189b9:	5d                   	pop    %ebp
f01189ba:	c3                   	ret    

f01189bb <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f01189bb:	55                   	push   %ebp
f01189bc:	89 e5                	mov    %esp,%ebp
f01189be:	83 ec 28             	sub    $0x28,%esp
f01189c1:	8b 45 14             	mov    0x14(%ebp),%eax
f01189c4:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f01189c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f01189ce:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f01189d2:	83 f8 65             	cmp    $0x65,%eax
f01189d5:	74 5d                	je     f0118a34 <tst+0x79>
f01189d7:	83 f8 65             	cmp    $0x65,%eax
f01189da:	7f 0a                	jg     f01189e6 <tst+0x2b>
f01189dc:	83 f8 62             	cmp    $0x62,%eax
f01189df:	74 73                	je     f0118a54 <tst+0x99>
f01189e1:	e9 91 00 00 00       	jmp    f0118a77 <tst+0xbc>
f01189e6:	83 f8 67             	cmp    $0x67,%eax
f01189e9:	74 29                	je     f0118a14 <tst+0x59>
f01189eb:	83 f8 6c             	cmp    $0x6c,%eax
f01189ee:	0f 85 83 00 00 00    	jne    f0118a77 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f01189f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01189f7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01189fa:	73 09                	jae    f0118a05 <tst+0x4a>
			chk = 1;
f01189fc:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0118a03:	eb 68                	jmp    f0118a6d <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f0118a05:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0118a09:	74 62                	je     f0118a6d <tst+0xb2>
			chk = 1;
f0118a0b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0118a12:	eb 59                	jmp    f0118a6d <tst+0xb2>
	case 'g':
		if (n > v1)
f0118a14:	8b 45 08             	mov    0x8(%ebp),%eax
f0118a17:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118a1a:	76 09                	jbe    f0118a25 <tst+0x6a>
			chk = 1;
f0118a1c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0118a23:	eb 4b                	jmp    f0118a70 <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f0118a25:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0118a29:	74 45                	je     f0118a70 <tst+0xb5>
			chk = 1;
f0118a2b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0118a32:	eb 3c                	jmp    f0118a70 <tst+0xb5>
	case 'e':
		if (n == v1)
f0118a34:	8b 45 08             	mov    0x8(%ebp),%eax
f0118a37:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118a3a:	75 09                	jne    f0118a45 <tst+0x8a>
			chk = 1;
f0118a3c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0118a43:	eb 2e                	jmp    f0118a73 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f0118a45:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0118a49:	74 28                	je     f0118a73 <tst+0xb8>
			chk = 1;
f0118a4b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0118a52:	eb 1f                	jmp    f0118a73 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f0118a54:	8b 45 08             	mov    0x8(%ebp),%eax
f0118a57:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118a5a:	72 1a                	jb     f0118a76 <tst+0xbb>
f0118a5c:	8b 45 08             	mov    0x8(%ebp),%eax
f0118a5f:	3b 45 10             	cmp    0x10(%ebp),%eax
f0118a62:	77 12                	ja     f0118a76 <tst+0xbb>
			chk = 1;
f0118a64:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0118a6b:	eb 09                	jmp    f0118a76 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0118a6d:	90                   	nop
f0118a6e:	eb 07                	jmp    f0118a77 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0118a70:	90                   	nop
f0118a71:	eb 04                	jmp    f0118a77 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0118a73:	90                   	nop
f0118a74:	eb 01                	jmp    f0118a77 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f0118a76:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f0118a77:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0118a7b:	75 14                	jne    f0118a91 <tst+0xd6>
f0118a7d:	83 ec 04             	sub    $0x4,%esp
f0118a80:	68 1c 51 13 f0       	push   $0xf013511c
f0118a85:	6a 49                	push   $0x49
f0118a87:	68 2f 51 13 f0       	push   $0xf013512f
f0118a8c:	e8 1e 84 fe ff       	call   f0100eaf <_panic>

	acquire_kspinlock(&tstcntlock);
f0118a91:	83 ec 0c             	sub    $0xc,%esp
f0118a94:	68 60 64 85 f0       	push   $0xf0856460
f0118a99:	e8 df 72 ff ff       	call   f010fd7d <acquire_kspinlock>
f0118a9e:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f0118aa1:	a1 c8 dc 83 f0       	mov    0xf083dcc8,%eax
f0118aa6:	40                   	inc    %eax
f0118aa7:	a3 c8 dc 83 f0       	mov    %eax,0xf083dcc8
	}
	release_kspinlock(&tstcntlock);
f0118aac:	83 ec 0c             	sub    $0xc,%esp
f0118aaf:	68 60 64 85 f0       	push   $0xf0856460
f0118ab4:	e8 69 73 ff ff       	call   f010fe22 <release_kspinlock>
f0118ab9:	83 c4 10             	add    $0x10,%esp

	return;
f0118abc:	90                   	nop
}
f0118abd:	c9                   	leave  
f0118abe:	c3                   	ret    

f0118abf <chktst>:

void chktst(uint32 n)
{
f0118abf:	55                   	push   %ebp
f0118ac0:	89 e5                	mov    %esp,%ebp
f0118ac2:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_kspinlock(&tstcntlock);
f0118ac5:	83 ec 0c             	sub    $0xc,%esp
f0118ac8:	68 60 64 85 f0       	push   $0xf0856460
f0118acd:	e8 ab 72 ff ff       	call   f010fd7d <acquire_kspinlock>
f0118ad2:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f0118ad5:	a1 c8 dc 83 f0       	mov    0xf083dcc8,%eax
f0118ada:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_kspinlock(&tstcntlock);
f0118add:	83 ec 0c             	sub    $0xc,%esp
f0118ae0:	68 60 64 85 f0       	push   $0xf0856460
f0118ae5:	e8 38 73 ff ff       	call   f010fe22 <release_kspinlock>
f0118aea:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f0118aed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118af0:	3b 45 08             	cmp    0x8(%ebp),%eax
f0118af3:	75 12                	jne    f0118b07 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f0118af5:	83 ec 0c             	sub    $0xc,%esp
f0118af8:	68 48 51 13 f0       	push   $0xf0135148
f0118afd:	e8 5a 90 fe ff       	call   f0101b5c <cprintf>
f0118b02:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f0118b05:	eb 14                	jmp    f0118b1b <chktst+0x5c>
	}
	release_kspinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f0118b07:	83 ec 04             	sub    $0x4,%esp
f0118b0a:	68 74 51 13 f0       	push   $0xf0135174
f0118b0f:	6a 5f                	push   $0x5f
f0118b11:	68 2f 51 13 f0       	push   $0xf013512f
f0118b16:	e8 94 83 fe ff       	call   f0100eaf <_panic>
}
f0118b1b:	c9                   	leave  
f0118b1c:	c3                   	ret    

f0118b1d <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f0118b1d:	55                   	push   %ebp
f0118b1e:	89 e5                	mov    %esp,%ebp
f0118b20:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f0118b23:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0118b27:	77 07                	ja     f0118b30 <nearest_pow2_ceil+0x13>
f0118b29:	b8 01 00 00 00       	mov    $0x1,%eax
f0118b2e:	eb 20                	jmp    f0118b50 <nearest_pow2_ceil+0x33>
	int power = 2;
f0118b30:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f0118b37:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f0118b3a:	eb 08                	jmp    f0118b44 <nearest_pow2_ceil+0x27>
		power <<= 1;
f0118b3c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0118b3f:	01 c0                	add    %eax,%eax
f0118b41:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f0118b44:	d1 6d 08             	shrl   0x8(%ebp)
f0118b47:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0118b4b:	75 ef                	jne    f0118b3c <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f0118b4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0118b50:	c9                   	leave  
f0118b51:	c3                   	ret    

f0118b52 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f0118b52:	55                   	push   %ebp
f0118b53:	89 e5                	mov    %esp,%ebp
f0118b55:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f0118b58:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0118b5c:	77 07                	ja     f0118b65 <log2_ceil+0x13>
f0118b5e:	b8 01 00 00 00       	mov    $0x1,%eax
f0118b63:	eb 1b                	jmp    f0118b80 <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f0118b65:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f0118b6c:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f0118b6f:	eb 03                	jmp    f0118b74 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f0118b71:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f0118b74:	d1 6d 08             	shrl   0x8(%ebp)
f0118b77:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0118b7b:	75 f4                	jne    f0118b71 <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f0118b7d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0118b80:	c9                   	leave  
f0118b81:	c3                   	ret    

f0118b82 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f0118b82:	55                   	push   %ebp
f0118b83:	89 e5                	mov    %esp,%ebp
f0118b85:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f0118b88:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f0118b8f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b96:	eb 12                	jmp    f0118baa <fixedPt2Str+0x28>
		mulFactor *= 10;
f0118b98:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118b9b:	89 d0                	mov    %edx,%eax
f0118b9d:	c1 e0 02             	shl    $0x2,%eax
f0118ba0:	01 d0                	add    %edx,%eax
f0118ba2:	01 c0                	add    %eax,%eax
f0118ba4:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f0118ba7:	ff 45 f0             	incl   -0x10(%ebp)
f0118baa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118bad:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118bb0:	7c e6                	jl     f0118b98 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f0118bb2:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0118bb5:	83 ec 04             	sub    $0x4,%esp
f0118bb8:	ff 75 f4             	pushl  -0xc(%ebp)
f0118bbb:	ff 75 08             	pushl  0x8(%ebp)
f0118bbe:	50                   	push   %eax
f0118bbf:	e8 e0 fc ff ff       	call   f01188a4 <fix_scale>
f0118bc4:	83 c4 0c             	add    $0xc,%esp
f0118bc7:	83 ec 0c             	sub    $0xc,%esp
f0118bca:	ff 75 dc             	pushl  -0x24(%ebp)
f0118bcd:	e8 9c fc ff ff       	call   f011886e <fix_round>
f0118bd2:	83 c4 10             	add    $0x10,%esp
f0118bd5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f0118bd8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118bdb:	99                   	cltd   
f0118bdc:	f7 7d f4             	idivl  -0xc(%ebp)
f0118bdf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f0118be2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118be5:	99                   	cltd   
f0118be6:	f7 7d f4             	idivl  -0xc(%ebp)
f0118be9:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f0118bec:	83 ec 08             	sub    $0x8,%esp
f0118bef:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0118bf2:	50                   	push   %eax
f0118bf3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118bf6:	e8 d7 23 00 00       	call   f011afd2 <ltostr>
f0118bfb:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f0118bfe:	83 ec 08             	sub    $0x8,%esp
f0118c01:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0118c04:	50                   	push   %eax
f0118c05:	ff 75 e0             	pushl  -0x20(%ebp)
f0118c08:	e8 c5 23 00 00       	call   f011afd2 <ltostr>
f0118c0d:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f0118c10:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118c13:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0118c18:	f7 e9                	imul   %ecx
f0118c1a:	c1 fa 02             	sar    $0x2,%edx
f0118c1d:	89 c8                	mov    %ecx,%eax
f0118c1f:	c1 f8 1f             	sar    $0x1f,%eax
f0118c22:	29 c2                	sub    %eax,%edx
f0118c24:	89 d0                	mov    %edx,%eax
f0118c26:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f0118c29:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f0118c30:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f0118c37:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f0118c3d:	eb 31                	jmp    f0118c70 <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f0118c3f:	83 ec 04             	sub    $0x4,%esp
f0118c42:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0118c45:	50                   	push   %eax
f0118c46:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0118c49:	50                   	push   %eax
f0118c4a:	68 90 51 13 f0       	push   $0xf0135190
f0118c4f:	e8 57 24 00 00       	call   f011b0ab <strcconcat>
f0118c54:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f0118c57:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0118c5a:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0118c5f:	f7 e9                	imul   %ecx
f0118c61:	c1 fa 02             	sar    $0x2,%edx
f0118c64:	89 c8                	mov    %ecx,%eax
f0118c66:	c1 f8 1f             	sar    $0x1f,%eax
f0118c69:	29 c2                	sub    %eax,%edx
f0118c6b:	89 d0                	mov    %edx,%eax
f0118c6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f0118c70:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118c73:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118c76:	7c c7                	jl     f0118c3f <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f0118c78:	83 ec 04             	sub    $0x4,%esp
f0118c7b:	8d 45 96             	lea    -0x6a(%ebp),%eax
f0118c7e:	50                   	push   %eax
f0118c7f:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0118c82:	50                   	push   %eax
f0118c83:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0118c86:	50                   	push   %eax
f0118c87:	e8 1f 24 00 00       	call   f011b0ab <strcconcat>
f0118c8c:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f0118c8f:	83 ec 04             	sub    $0x4,%esp
f0118c92:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0118c95:	50                   	push   %eax
f0118c96:	68 92 51 13 f0       	push   $0xf0135192
f0118c9b:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0118c9e:	50                   	push   %eax
f0118c9f:	e8 07 24 00 00       	call   f011b0ab <strcconcat>
f0118ca4:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f0118ca7:	83 ec 04             	sub    $0x4,%esp
f0118caa:	ff 75 10             	pushl  0x10(%ebp)
f0118cad:	8d 45 96             	lea    -0x6a(%ebp),%eax
f0118cb0:	50                   	push   %eax
f0118cb1:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0118cb4:	50                   	push   %eax
f0118cb5:	e8 f1 23 00 00       	call   f011b0ab <strcconcat>
f0118cba:	83 c4 10             	add    $0x10,%esp

}
f0118cbd:	90                   	nop
f0118cbe:	c9                   	leave  
f0118cbf:	c3                   	ret    

f0118cc0 <sys_utilities>:
struct kspinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f0118cc0:	55                   	push   %ebp
f0118cc1:	89 e5                	mov    %esp,%ebp
f0118cc3:	81 ec c8 00 00 00    	sub    $0xc8,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f0118cc9:	83 ec 0c             	sub    $0xc,%esp
f0118ccc:	68 94 51 13 f0       	push   $0xf0135194
f0118cd1:	e8 a7 1d 00 00       	call   f011aa7d <strlen>
f0118cd6:	83 c4 10             	add    $0x10,%esp
f0118cd9:	83 ec 04             	sub    $0x4,%esp
f0118cdc:	50                   	push   %eax
f0118cdd:	68 94 51 13 f0       	push   $0xf0135194
f0118ce2:	ff 75 08             	pushl  0x8(%ebp)
f0118ce5:	e8 d7 1e 00 00       	call   f011abc1 <strncmp>
f0118cea:	83 c4 10             	add    $0x10,%esp
f0118ced:	85 c0                	test   %eax,%eax
f0118cef:	0f 85 8a 00 00 00    	jne    f0118d7f <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0118cf5:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0118cf8:	50                   	push   %eax
f0118cf9:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0118cff:	50                   	push   %eax
f0118d00:	68 a2 51 13 f0       	push   $0xf01351a2
f0118d05:	ff 75 08             	pushl  0x8(%ebp)
f0118d08:	e8 34 24 00 00       	call   f011b141 <strsplit>
f0118d0d:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0118d10:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0118d16:	83 ec 04             	sub    $0x4,%esp
f0118d19:	6a 0a                	push   $0xa
f0118d1b:	6a 00                	push   $0x0
f0118d1d:	50                   	push   %eax
f0118d1e:	e8 69 21 00 00       	call   f011ae8c <strtol>
f0118d23:	83 c4 10             	add    $0x10,%esp
f0118d26:	89 45 98             	mov    %eax,-0x68(%ebp)
		struct Env* env = NULL ;
f0118d29:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
		envid2env(envID, &env, 0);
f0118d30:	83 ec 04             	sub    $0x4,%esp
f0118d33:	6a 00                	push   $0x0
f0118d35:	8d 45 90             	lea    -0x70(%ebp),%eax
f0118d38:	50                   	push   %eax
f0118d39:	ff 75 98             	pushl  -0x68(%ebp)
f0118d3c:	e8 2a 2d ff ff       	call   f010ba6b <envid2env>
f0118d41:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f0118d44:	8b 45 90             	mov    -0x70(%ebp),%eax
f0118d47:	8b 40 10             	mov    0x10(%eax),%eax
f0118d4a:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0118d4d:	74 19                	je     f0118d68 <sys_utilities+0xa8>
f0118d4f:	68 a4 51 13 f0       	push   $0xf01351a4
f0118d54:	68 e7 50 13 f0       	push   $0xf01350e7
f0118d59:	68 a5 00 00 00       	push   $0xa5
f0118d5e:	68 2f 51 13 f0       	push   $0xf013512f
f0118d63:	e8 47 81 fe ff       	call   f0100eaf <_panic>
		env_set_nice(env, value);
f0118d68:	8b 45 90             	mov    -0x70(%ebp),%eax
f0118d6b:	83 ec 08             	sub    $0x8,%esp
f0118d6e:	ff 75 0c             	pushl  0xc(%ebp)
f0118d71:	50                   	push   %eax
f0118d72:	e8 90 e8 fe ff       	call   f0107607 <env_set_nice>
f0118d77:	83 c4 10             	add    $0x10,%esp
f0118d7a:	e9 8d 07 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strncmp(utilityName, "__PRIRRSetPriority@", strlen("__PRIRRSetPriority@")) == 0)
f0118d7f:	83 ec 0c             	sub    $0xc,%esp
f0118d82:	68 b9 51 13 f0       	push   $0xf01351b9
f0118d87:	e8 f1 1c 00 00       	call   f011aa7d <strlen>
f0118d8c:	83 c4 10             	add    $0x10,%esp
f0118d8f:	83 ec 04             	sub    $0x4,%esp
f0118d92:	50                   	push   %eax
f0118d93:	68 b9 51 13 f0       	push   $0xf01351b9
f0118d98:	ff 75 08             	pushl  0x8(%ebp)
f0118d9b:	e8 21 1e 00 00       	call   f011abc1 <strncmp>
f0118da0:	83 c4 10             	add    $0x10,%esp
f0118da3:	85 c0                	test   %eax,%eax
f0118da5:	0f 85 89 00 00 00    	jne    f0118e34 <sys_utilities+0x174>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0118dab:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0118dae:	50                   	push   %eax
f0118daf:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0118db5:	50                   	push   %eax
f0118db6:	68 a2 51 13 f0       	push   $0xf01351a2
f0118dbb:	ff 75 08             	pushl  0x8(%ebp)
f0118dbe:	e8 7e 23 00 00       	call   f011b141 <strsplit>
f0118dc3:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0118dc6:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0118dcc:	83 ec 04             	sub    $0x4,%esp
f0118dcf:	6a 0a                	push   $0xa
f0118dd1:	6a 00                	push   $0x0
f0118dd3:	50                   	push   %eax
f0118dd4:	e8 b3 20 00 00       	call   f011ae8c <strtol>
f0118dd9:	83 c4 10             	add    $0x10,%esp
f0118ddc:	89 45 9c             	mov    %eax,-0x64(%ebp)
		struct Env* env = NULL ;
f0118ddf:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)
		envid2env(envID, &env, 0);
f0118de6:	83 ec 04             	sub    $0x4,%esp
f0118de9:	6a 00                	push   $0x0
f0118deb:	8d 45 88             	lea    -0x78(%ebp),%eax
f0118dee:	50                   	push   %eax
f0118def:	ff 75 9c             	pushl  -0x64(%ebp)
f0118df2:	e8 74 2c ff ff       	call   f010ba6b <envid2env>
f0118df7:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f0118dfa:	8b 45 88             	mov    -0x78(%ebp),%eax
f0118dfd:	8b 40 10             	mov    0x10(%eax),%eax
f0118e00:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f0118e03:	74 19                	je     f0118e1e <sys_utilities+0x15e>
f0118e05:	68 a4 51 13 f0       	push   $0xf01351a4
f0118e0a:	68 e7 50 13 f0       	push   $0xf01350e7
f0118e0f:	68 b1 00 00 00       	push   $0xb1
f0118e14:	68 2f 51 13 f0       	push   $0xf013512f
f0118e19:	e8 91 80 fe ff       	call   f0100eaf <_panic>
		env_set_priority(envID, value);
f0118e1e:	83 ec 08             	sub    $0x8,%esp
f0118e21:	ff 75 0c             	pushl  0xc(%ebp)
f0118e24:	ff 75 9c             	pushl  -0x64(%ebp)
f0118e27:	e8 32 e8 fe ff       	call   f010765e <env_set_priority>
f0118e2c:	83 c4 10             	add    $0x10,%esp
f0118e2f:	e9 d8 06 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f0118e34:	83 ec 0c             	sub    $0xc,%esp
f0118e37:	68 cd 51 13 f0       	push   $0xf01351cd
f0118e3c:	e8 3c 1c 00 00       	call   f011aa7d <strlen>
f0118e41:	83 c4 10             	add    $0x10,%esp
f0118e44:	83 ec 04             	sub    $0x4,%esp
f0118e47:	50                   	push   %eax
f0118e48:	68 cd 51 13 f0       	push   $0xf01351cd
f0118e4d:	ff 75 08             	pushl  0x8(%ebp)
f0118e50:	e8 6c 1d 00 00       	call   f011abc1 <strncmp>
f0118e55:	83 c4 10             	add    $0x10,%esp
f0118e58:	85 c0                	test   %eax,%eax
f0118e5a:	0f 85 ba 01 00 00    	jne    f011901a <sys_utilities+0x35a>
	{
		int* numOfInstances = (int*) value ;
f0118e60:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118e63:	89 45 a8             	mov    %eax,-0x58(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0118e66:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0118e69:	50                   	push   %eax
f0118e6a:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0118e70:	50                   	push   %eax
f0118e71:	68 a2 51 13 f0       	push   $0xf01351a2
f0118e76:	ff 75 08             	pushl  0x8(%ebp)
f0118e79:	e8 c3 22 00 00       	call   f011b141 <strsplit>
f0118e7e:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f0118e81:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0118e87:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		struct Env* env = NULL ;
f0118e8a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f0118e91:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f0118e98:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f0118e9f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118ea2:	8b 00                	mov    (%eax),%eax
f0118ea4:	85 c0                	test   %eax,%eax
f0118ea6:	79 1c                	jns    f0118ec4 <sys_utilities+0x204>
		{
			chkAscending = 0;
f0118ea8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f0118eaf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118eb2:	8b 00                	mov    (%eax),%eax
f0118eb4:	f7 d8                	neg    %eax
f0118eb6:	89 c2                	mov    %eax,%edx
f0118eb8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118ebb:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f0118ebd:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f0118ec4:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_kspinlock(&ProcessQueues.qlock);
f0118ecb:	83 ec 0c             	sub    $0xc,%esp
f0118ece:	68 80 dd 83 f0       	push   $0xf083dd80
f0118ed3:	e8 a5 6e ff ff       	call   f010fd7d <acquire_kspinlock>
f0118ed8:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0118edb:	a1 0c de 83 f0       	mov    0xf083de0c,%eax
f0118ee0:	89 45 a0             	mov    %eax,-0x60(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f0118ee3:	a1 04 de 83 f0       	mov    0xf083de04,%eax
f0118ee8:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f0118eeb:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118eee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0118ef1:	eb 6c                	jmp    f0118f5f <sys_utilities+0x29f>
			{
				if (strcmp(env->prog_name, progName) != 0)
f0118ef3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118ef6:	83 c0 20             	add    $0x20,%eax
f0118ef9:	83 ec 08             	sub    $0x8,%esp
f0118efc:	ff 75 a4             	pushl  -0x5c(%ebp)
f0118eff:	50                   	push   %eax
f0118f00:	e8 84 1c 00 00       	call   f011ab89 <strcmp>
f0118f05:	83 c4 10             	add    $0x10,%esp
f0118f08:	85 c0                	test   %eax,%eax
f0118f0a:	75 46                	jne    f0118f52 <sys_utilities+0x292>
					continue;
				(*numOfInstances)-- ;
f0118f0c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118f0f:	8b 00                	mov    (%eax),%eax
f0118f11:	8d 50 ff             	lea    -0x1(%eax),%edx
f0118f14:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118f17:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f0118f19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118f1d:	74 14                	je     f0118f33 <sys_utilities+0x273>
				{
					if (prevEnvID > env->env_id)
f0118f1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f22:	8b 40 10             	mov    0x10(%eax),%eax
f0118f25:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118f28:	7d 1d                	jge    f0118f47 <sys_utilities+0x287>
					{
						success = 0;
f0118f2a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f0118f31:	eb 32                	jmp    f0118f65 <sys_utilities+0x2a5>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f0118f33:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f36:	8b 40 10             	mov    0x10(%eax),%eax
f0118f39:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118f3c:	7e 09                	jle    f0118f47 <sys_utilities+0x287>
					{
						success = 0;
f0118f3e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f0118f45:	eb 1e                	jmp    f0118f65 <sys_utilities+0x2a5>
					}
				}
				prevEnvID = env->env_id;
f0118f47:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f4a:	8b 40 10             	mov    0x10(%eax),%eax
f0118f4d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0118f50:	eb 01                	jmp    f0118f53 <sys_utilities+0x293>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f0118f52:	90                   	nop
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f0118f53:	ff 4d e4             	decl   -0x1c(%ebp)
f0118f56:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f59:	8b 40 0c             	mov    0xc(%eax),%eax
f0118f5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0118f5f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0118f63:	7f 8e                	jg     f0118ef3 <sys_utilities+0x233>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);
f0118f65:	83 ec 0c             	sub    $0xc,%esp
f0118f68:	68 80 dd 83 f0       	push   $0xf083dd80
f0118f6d:	e8 b0 6e ff ff       	call   f010fe22 <release_kspinlock>
f0118f72:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f0118f75:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118f78:	8b 00                	mov    (%eax),%eax
f0118f7a:	85 c0                	test   %eax,%eax
f0118f7c:	75 06                	jne    f0118f84 <sys_utilities+0x2c4>
f0118f7e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0118f82:	75 4b                	jne    f0118fcf <sys_utilities+0x30f>
		{
			cons_lock();
f0118f84:	e8 f8 8a fe ff       	call   f0101a81 <cons_lock>
			{
				cprintf("###########################################\n");
f0118f89:	83 ec 0c             	sub    $0xc,%esp
f0118f8c:	68 e0 51 13 f0       	push   $0xf01351e0
f0118f91:	e8 c6 8b fe ff       	call   f0101b5c <cprintf>
f0118f96:	83 c4 10             	add    $0x10,%esp
				cprintf("%s: check exit order is FAILED\n", progName);
f0118f99:	83 ec 08             	sub    $0x8,%esp
f0118f9c:	ff 75 a4             	pushl  -0x5c(%ebp)
f0118f9f:	68 10 52 13 f0       	push   $0xf0135210
f0118fa4:	e8 b3 8b fe ff       	call   f0101b5c <cprintf>
f0118fa9:	83 c4 10             	add    $0x10,%esp
				cprintf("###########################################\n");
f0118fac:	83 ec 0c             	sub    $0xc,%esp
f0118faf:	68 e0 51 13 f0       	push   $0xf01351e0
f0118fb4:	e8 a3 8b fe ff       	call   f0101b5c <cprintf>
f0118fb9:	83 c4 10             	add    $0x10,%esp
			}
			cons_unlock();
f0118fbc:	e8 07 8b fe ff       	call   f0101ac8 <cons_unlock>
			*numOfInstances = 0; //to indicate the failure of test
f0118fc1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118fc4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0118fca:	e9 3d 05 00 00       	jmp    f011950c <sys_utilities+0x84c>
		}
		else
		{
			cons_lock();
f0118fcf:	e8 ad 8a fe ff       	call   f0101a81 <cons_lock>
			{
				cprintf("####################################################\n");
f0118fd4:	83 ec 0c             	sub    $0xc,%esp
f0118fd7:	68 30 52 13 f0       	push   $0xf0135230
f0118fdc:	e8 7b 8b fe ff       	call   f0101b5c <cprintf>
f0118fe1:	83 c4 10             	add    $0x10,%esp
				cprintf("%s: check exit order is SUCCEEDED\n", progName);
f0118fe4:	83 ec 08             	sub    $0x8,%esp
f0118fe7:	ff 75 a4             	pushl  -0x5c(%ebp)
f0118fea:	68 68 52 13 f0       	push   $0xf0135268
f0118fef:	e8 68 8b fe ff       	call   f0101b5c <cprintf>
f0118ff4:	83 c4 10             	add    $0x10,%esp
				cprintf("####################################################\n");
f0118ff7:	83 ec 0c             	sub    $0xc,%esp
f0118ffa:	68 30 52 13 f0       	push   $0xf0135230
f0118fff:	e8 58 8b fe ff       	call   f0101b5c <cprintf>
f0119004:	83 c4 10             	add    $0x10,%esp
			}
			cons_unlock();
f0119007:	e8 bc 8a fe ff       	call   f0101ac8 <cons_unlock>
			*numOfInstances = 1; //to indicate the success of test
f011900c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011900f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f0119015:	e9 f2 04 00 00       	jmp    f011950c <sys_utilities+0x84c>
		}
	}
	else if (strncmp(utilityName, "__NthClkRepl@", strlen("__NthClkRepl@")) == 0)
f011901a:	83 ec 0c             	sub    $0xc,%esp
f011901d:	68 8b 52 13 f0       	push   $0xf013528b
f0119022:	e8 56 1a 00 00       	call   f011aa7d <strlen>
f0119027:	83 c4 10             	add    $0x10,%esp
f011902a:	83 ec 04             	sub    $0x4,%esp
f011902d:	50                   	push   %eax
f011902e:	68 8b 52 13 f0       	push   $0xf013528b
f0119033:	ff 75 08             	pushl  0x8(%ebp)
f0119036:	e8 86 1b 00 00       	call   f011abc1 <strncmp>
f011903b:	83 c4 10             	add    $0x10,%esp
f011903e:	85 c0                	test   %eax,%eax
f0119040:	75 76                	jne    f01190b8 <sys_utilities+0x3f8>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0119042:	8d 45 80             	lea    -0x80(%ebp),%eax
f0119045:	50                   	push   %eax
f0119046:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f011904c:	50                   	push   %eax
f011904d:	68 a2 51 13 f0       	push   $0xf01351a2
f0119052:	ff 75 08             	pushl  0x8(%ebp)
f0119055:	e8 e7 20 00 00       	call   f011b141 <strsplit>
f011905a:	83 c4 10             	add    $0x10,%esp
		int type = strtol(tokens[1], NULL, 10);
f011905d:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0119063:	83 ec 04             	sub    $0x4,%esp
f0119066:	6a 0a                	push   $0xa
f0119068:	6a 00                	push   $0x0
f011906a:	50                   	push   %eax
f011906b:	e8 1c 1e 00 00       	call   f011ae8c <strtol>
f0119070:	83 c4 10             	add    $0x10,%esp
f0119073:	89 45 ac             	mov    %eax,-0x54(%ebp)
		int N = value;
f0119076:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119079:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (type == 2)
f011907c:	83 7d ac 02          	cmpl   $0x2,-0x54(%ebp)
f0119080:	75 03                	jne    f0119085 <sys_utilities+0x3c5>
			N *= -1;
f0119082:	f7 5d e0             	negl   -0x20(%ebp)
		setPageReplacmentAlgorithmNchanceCLOCK(N);
f0119085:	83 ec 0c             	sub    $0xc,%esp
f0119088:	ff 75 e0             	pushl  -0x20(%ebp)
f011908b:	e8 5f 67 ff ff       	call   f010f7ef <setPageReplacmentAlgorithmNchanceCLOCK>
f0119090:	83 c4 10             	add    $0x10,%esp
		cons_lock();
f0119093:	e8 e9 89 fe ff       	call   f0101a81 <cons_lock>
		{
			cprintf("\n*********************************************************"
f0119098:	83 ec 04             	sub    $0x4,%esp
f011909b:	ff 75 e0             	pushl  -0x20(%ebp)
f011909e:	ff 75 ac             	pushl  -0x54(%ebp)
f01190a1:	68 9c 52 13 f0       	push   $0xf013529c
f01190a6:	e8 b1 8a fe ff       	call   f0101b5c <cprintf>
f01190ab:	83 c4 10             	add    $0x10,%esp
					"\nPAGE REPLACEMENT IS SET TO Nth Clock type = %d (N = %d)."
					"\n*********************************************************\n", type, N);
		}
		cons_unlock();
f01190ae:	e8 15 8a fe ff       	call   f0101ac8 <cons_unlock>
f01190b3:	e9 54 04 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f01190b8:	83 ec 08             	sub    $0x8,%esp
f01190bb:	68 4b 53 13 f0       	push   $0xf013534b
f01190c0:	ff 75 08             	pushl  0x8(%ebp)
f01190c3:	e8 c1 1a 00 00       	call   f011ab89 <strcmp>
f01190c8:	83 c4 10             	add    $0x10,%esp
f01190cb:	85 c0                	test   %eax,%eax
f01190cd:	75 77                	jne    f0119146 <sys_utilities+0x486>
	{
		if (__firstTimeSleep)
f01190cf:	a1 ac 01 18 f0       	mov    0xf01801ac,%eax
f01190d4:	85 c0                	test   %eax,%eax
f01190d6:	74 34                	je     f011910c <sys_utilities+0x44c>
		{
			__firstTimeSleep = 0;
f01190d8:	c7 05 ac 01 18 f0 00 	movl   $0x0,0xf01801ac
f01190df:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f01190e2:	83 ec 08             	sub    $0x8,%esp
f01190e5:	68 55 53 13 f0       	push   $0xf0135355
f01190ea:	68 40 cb 87 f0       	push   $0xf087cb40
f01190ef:	e8 61 70 ff ff       	call   f0110155 <init_channel>
f01190f4:	83 c4 10             	add    $0x10,%esp
			init_kspinlock(&__tstchan_lk__, "Test Channel Lock");
f01190f7:	83 ec 08             	sub    $0x8,%esp
f01190fa:	68 62 53 13 f0       	push   $0xf0135362
f01190ff:	68 c0 cc 87 f0       	push   $0xf087ccc0
f0119104:	e8 43 6c ff ff       	call   f010fd4c <init_kspinlock>
f0119109:	83 c4 10             	add    $0x10,%esp
		}
		acquire_kspinlock(&__tstchan_lk__);
f011910c:	83 ec 0c             	sub    $0xc,%esp
f011910f:	68 c0 cc 87 f0       	push   $0xf087ccc0
f0119114:	e8 64 6c ff ff       	call   f010fd7d <acquire_kspinlock>
f0119119:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011911c:	83 ec 08             	sub    $0x8,%esp
f011911f:	68 c0 cc 87 f0       	push   $0xf087ccc0
f0119124:	68 40 cb 87 f0       	push   $0xf087cb40
f0119129:	e8 54 70 ff ff       	call   f0110182 <sleep>
f011912e:	83 c4 10             	add    $0x10,%esp
		release_kspinlock(&__tstchan_lk__);
f0119131:	83 ec 0c             	sub    $0xc,%esp
f0119134:	68 c0 cc 87 f0       	push   $0xf087ccc0
f0119139:	e8 e4 6c ff ff       	call   f010fe22 <release_kspinlock>
f011913e:	83 c4 10             	add    $0x10,%esp
f0119141:	e9 c6 03 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f0119146:	83 ec 08             	sub    $0x8,%esp
f0119149:	68 74 53 13 f0       	push   $0xf0135374
f011914e:	ff 75 08             	pushl  0x8(%ebp)
f0119151:	e8 33 1a 00 00       	call   f011ab89 <strcmp>
f0119156:	83 c4 10             	add    $0x10,%esp
f0119159:	85 c0                	test   %eax,%eax
f011915b:	75 15                	jne    f0119172 <sys_utilities+0x4b2>
	{
		wakeup_one(&__tstchan__);
f011915d:	83 ec 0c             	sub    $0xc,%esp
f0119160:	68 40 cb 87 f0       	push   $0xf087cb40
f0119165:	e8 32 70 ff ff       	call   f011019c <wakeup_one>
f011916a:	83 c4 10             	add    $0x10,%esp
f011916d:	e9 9a 03 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f0119172:	83 ec 08             	sub    $0x8,%esp
f0119175:	68 82 53 13 f0       	push   $0xf0135382
f011917a:	ff 75 08             	pushl  0x8(%ebp)
f011917d:	e8 07 1a 00 00       	call   f011ab89 <strcmp>
f0119182:	83 c4 10             	add    $0x10,%esp
f0119185:	85 c0                	test   %eax,%eax
f0119187:	75 15                	jne    f011919e <sys_utilities+0x4de>
	{
		wakeup_all(&__tstchan__);
f0119189:	83 ec 0c             	sub    $0xc,%esp
f011918c:	68 40 cb 87 f0       	push   $0xf087cb40
f0119191:	e8 20 70 ff ff       	call   f01101b6 <wakeup_all>
f0119196:	83 c4 10             	add    $0x10,%esp
f0119199:	e9 6e 03 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011919e:	83 ec 08             	sub    $0x8,%esp
f01191a1:	68 90 53 13 f0       	push   $0xf0135390
f01191a6:	ff 75 08             	pushl  0x8(%ebp)
f01191a9:	e8 db 19 00 00       	call   f011ab89 <strcmp>
f01191ae:	83 c4 10             	add    $0x10,%esp
f01191b1:	85 c0                	test   %eax,%eax
f01191b3:	75 17                	jne    f01191cc <sys_utilities+0x50c>
	{
		int* numOfProcesses = (int*) value ;
f01191b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01191b8:	89 45 b0             	mov    %eax,-0x50(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f01191bb:	a1 4c cb 87 f0       	mov    0xf087cb4c,%eax
f01191c0:	89 c2                	mov    %eax,%edx
f01191c2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01191c5:	89 10                	mov    %edx,(%eax)
f01191c7:	e9 40 03 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f01191cc:	83 ec 08             	sub    $0x8,%esp
f01191cf:	68 a5 53 13 f0       	push   $0xf01353a5
f01191d4:	ff 75 08             	pushl  0x8(%ebp)
f01191d7:	e8 ad 19 00 00       	call   f011ab89 <strcmp>
f01191dc:	83 c4 10             	add    $0x10,%esp
f01191df:	85 c0                	test   %eax,%eax
f01191e1:	75 1a                	jne    f01191fd <sys_utilities+0x53d>
	{
		int* numOfProcesses = (int*) value ;
f01191e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01191e6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f01191e9:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f01191ee:	8b 40 0c             	mov    0xc(%eax),%eax
f01191f1:	89 c2                	mov    %eax,%edx
f01191f3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01191f6:	89 10                	mov    %edx,(%eax)
f01191f8:	e9 0f 03 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f01191fd:	83 ec 08             	sub    $0x8,%esp
f0119200:	68 bb 53 13 f0       	push   $0xf01353bb
f0119205:	ff 75 08             	pushl  0x8(%ebp)
f0119208:	e8 7c 19 00 00       	call   f011ab89 <strcmp>
f011920d:	83 c4 10             	add    $0x10,%esp
f0119210:	85 c0                	test   %eax,%eax
f0119212:	75 3d                	jne    f0119251 <sys_utilities+0x591>
	{
		if (__firstTimeSleepLock)
f0119214:	a1 b0 01 18 f0       	mov    0xf01801b0,%eax
f0119219:	85 c0                	test   %eax,%eax
f011921b:	74 1f                	je     f011923c <sys_utilities+0x57c>
		{
			__firstTimeSleepLock = 0;
f011921d:	c7 05 b0 01 18 f0 00 	movl   $0x0,0xf01801b0
f0119224:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f0119227:	83 ec 08             	sub    $0x8,%esp
f011922a:	68 d0 53 13 f0       	push   $0xf01353d0
f011922f:	68 a0 cb 87 f0       	push   $0xf087cba0
f0119234:	e8 da 6d ff ff       	call   f0110013 <init_sleeplock>
f0119239:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011923c:	83 ec 0c             	sub    $0xc,%esp
f011923f:	68 a0 cb 87 f0       	push   $0xf087cba0
f0119244:	e8 78 6e ff ff       	call   f01100c1 <acquire_sleeplock>
f0119249:	83 c4 10             	add    $0x10,%esp
f011924c:	e9 bb 02 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f0119251:	83 ec 08             	sub    $0x8,%esp
f0119254:	68 e0 53 13 f0       	push   $0xf01353e0
f0119259:	ff 75 08             	pushl  0x8(%ebp)
f011925c:	e8 28 19 00 00       	call   f011ab89 <strcmp>
f0119261:	83 c4 10             	add    $0x10,%esp
f0119264:	85 c0                	test   %eax,%eax
f0119266:	75 15                	jne    f011927d <sys_utilities+0x5bd>
	{
		release_sleeplock(&__tstslplk__);
f0119268:	83 ec 0c             	sub    $0xc,%esp
f011926b:	68 a0 cb 87 f0       	push   $0xf087cba0
f0119270:	e8 66 6e ff ff       	call   f01100db <release_sleeplock>
f0119275:	83 c4 10             	add    $0x10,%esp
f0119278:	e9 8f 02 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011927d:	83 ec 08             	sub    $0x8,%esp
f0119280:	68 f5 53 13 f0       	push   $0xf01353f5
f0119285:	ff 75 08             	pushl  0x8(%ebp)
f0119288:	e8 fc 18 00 00       	call   f011ab89 <strcmp>
f011928d:	83 c4 10             	add    $0x10,%esp
f0119290:	85 c0                	test   %eax,%eax
f0119292:	75 17                	jne    f01192ab <sys_utilities+0x5eb>
	{
		int* numOfProcesses = (int*) value ;
f0119294:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119297:	89 45 b8             	mov    %eax,-0x48(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011929a:	a1 20 cc 87 f0       	mov    0xf087cc20,%eax
f011929f:	89 c2                	mov    %eax,%edx
f01192a1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01192a4:	89 10                	mov    %edx,(%eax)
f01192a6:	e9 61 02 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f01192ab:	83 ec 08             	sub    $0x8,%esp
f01192ae:	68 0a 54 13 f0       	push   $0xf013540a
f01192b3:	ff 75 08             	pushl  0x8(%ebp)
f01192b6:	e8 ce 18 00 00       	call   f011ab89 <strcmp>
f01192bb:	83 c4 10             	add    $0x10,%esp
f01192be:	85 c0                	test   %eax,%eax
f01192c0:	75 16                	jne    f01192d8 <sys_utilities+0x618>
	{
		int* lockVal = (int*) value ;
f01192c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01192c5:	89 45 bc             	mov    %eax,-0x44(%ebp)
		*lockVal =__tstslplk__.locked;
f01192c8:	8b 15 a0 cb 87 f0    	mov    0xf087cba0,%edx
f01192ce:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01192d1:	89 10                	mov    %edx,(%eax)
f01192d3:	e9 34 02 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f01192d8:	83 ec 08             	sub    $0x8,%esp
f01192db:	68 1b 54 13 f0       	push   $0xf013541b
f01192e0:	ff 75 08             	pushl  0x8(%ebp)
f01192e3:	e8 a1 18 00 00       	call   f011ab89 <strcmp>
f01192e8:	83 c4 10             	add    $0x10,%esp
f01192eb:	85 c0                	test   %eax,%eax
f01192ed:	75 17                	jne    f0119306 <sys_utilities+0x646>
	{
		uint32* lockOwnerID = (uint32*) value ;
f01192ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f01192f2:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f01192f5:	a1 a4 cc 87 f0       	mov    0xf087cca4,%eax
f01192fa:	89 c2                	mov    %eax,%edx
f01192fc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01192ff:	89 10                	mov    %edx,(%eax)
f0119301:	e9 06 02 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetConsLockedCnt__") == 0)
f0119306:	83 ec 08             	sub    $0x8,%esp
f0119309:	68 2c 54 13 f0       	push   $0xf013542c
f011930e:	ff 75 08             	pushl  0x8(%ebp)
f0119311:	e8 73 18 00 00       	call   f011ab89 <strcmp>
f0119316:	83 c4 10             	add    $0x10,%esp
f0119319:	85 c0                	test   %eax,%eax
f011931b:	75 22                	jne    f011933f <sys_utilities+0x67f>
	{
		uint32* consLockCnt = (uint32*) value ;
f011931d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119320:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*consLockCnt = queue_size(&(conslock.chan.queue));
f0119323:	83 ec 0c             	sub    $0xc,%esp
f0119326:	68 34 dc 83 f0       	push   $0xf083dc34
f011932b:	e8 c3 cb fe ff       	call   f0105ef3 <queue_size>
f0119330:	83 c4 10             	add    $0x10,%esp
f0119333:	89 c2                	mov    %eax,%edx
f0119335:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119338:	89 10                	mov    %edx,(%eax)
f011933a:	e9 cd 01 00 00       	jmp    f011950c <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__tmpReleaseConsLock__") == 0)
f011933f:	83 ec 08             	sub    $0x8,%esp
f0119342:	68 41 54 13 f0       	push   $0xf0135441
f0119347:	ff 75 08             	pushl  0x8(%ebp)
f011934a:	e8 3a 18 00 00       	call   f011ab89 <strcmp>
f011934f:	83 c4 10             	add    $0x10,%esp
f0119352:	85 c0                	test   %eax,%eax
f0119354:	0f 84 b2 01 00 00    	je     f011950c <sys_utilities+0x84c>
	/*else if (strcmp(utilityName, "__getKernelSBreak__") == 0)
	{
		uint32* ksbrk = (uint32*) value ;
		*ksbrk = (uint32)sbrk(0);
	}*/
	else if (strcmp(utilityName, "__changeInterruptStatus__") == 0)
f011935a:	83 ec 08             	sub    $0x8,%esp
f011935d:	68 58 54 13 f0       	push   $0xf0135458
f0119362:	ff 75 08             	pushl  0x8(%ebp)
f0119365:	e8 1f 18 00 00       	call   f011ab89 <strcmp>
f011936a:	83 c4 10             	add    $0x10,%esp
f011936d:	85 c0                	test   %eax,%eax
f011936f:	0f 85 96 00 00 00    	jne    f011940b <sys_utilities+0x74b>
	{
		if (value == 0)
f0119375:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0119379:	75 43                	jne    f01193be <sys_utilities+0x6fe>
		{
			kclock_stop();
f011937b:	e8 9b c8 fe ff       	call   f0105c1b <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0119380:	fa                   	cli    
			cli();
			struct Env * p = get_cpu_proc();
f0119381:	e8 95 26 ff ff       	call   f010ba1b <get_cpu_proc>
f0119386:	89 45 cc             	mov    %eax,-0x34(%ebp)
			if (p == NULL)
f0119389:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f011938d:	75 17                	jne    f01193a6 <sys_utilities+0x6e6>
			{
				panic("cons_lock: no running process to block");
f011938f:	83 ec 04             	sub    $0x4,%esp
f0119392:	68 74 54 13 f0       	push   $0xf0135474
f0119397:	68 67 01 00 00       	push   $0x167
f011939c:	68 2f 51 13 f0       	push   $0xf013512f
f01193a1:	e8 09 7b fe ff       	call   f0100eaf <_panic>
			}
			p->env_tf->tf_eflags &= ~FL_IF ;
f01193a6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01193a9:	8b 00                	mov    (%eax),%eax
f01193ab:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01193ae:	8b 12                	mov    (%edx),%edx
f01193b0:	8b 52 38             	mov    0x38(%edx),%edx
f01193b3:	80 e6 fd             	and    $0xfd,%dh
f01193b6:	89 50 38             	mov    %edx,0x38(%eax)
f01193b9:	e9 4e 01 00 00       	jmp    f011950c <sys_utilities+0x84c>
			//cprintf("\nINTERRUPT WILL BE DISABLED\n");
		}
		else if (value == 1)
f01193be:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f01193c2:	0f 85 44 01 00 00    	jne    f011950c <sys_utilities+0x84c>
		{
			kclock_stop();
f01193c8:	e8 4e c8 fe ff       	call   f0105c1b <kclock_stop>
f01193cd:	fa                   	cli    
			cli();
			struct Env * p = get_cpu_proc();
f01193ce:	e8 48 26 ff ff       	call   f010ba1b <get_cpu_proc>
f01193d3:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if (p == NULL)
f01193d6:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01193da:	75 17                	jne    f01193f3 <sys_utilities+0x733>
			{
				panic("cons_unlock: no running process to block");
f01193dc:	83 ec 04             	sub    $0x4,%esp
f01193df:	68 9c 54 13 f0       	push   $0xf013549c
f01193e4:	68 73 01 00 00       	push   $0x173
f01193e9:	68 2f 51 13 f0       	push   $0xf013512f
f01193ee:	e8 bc 7a fe ff       	call   f0100eaf <_panic>
			}
			p->env_tf->tf_eflags |= FL_IF ;
f01193f3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01193f6:	8b 00                	mov    (%eax),%eax
f01193f8:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01193fb:	8b 12                	mov    (%edx),%edx
f01193fd:	8b 52 38             	mov    0x38(%edx),%edx
f0119400:	80 ce 02             	or     $0x2,%dh
f0119403:	89 50 38             	mov    %edx,0x38(%eax)
f0119406:	e9 01 01 00 00       	jmp    f011950c <sys_utilities+0x84c>
			//cprintf("\nINTERRUPT WILL BE ENABLED\n");
		}
	}
	else if (strncmp(utilityName, "__getProcState@", strlen("__getProcState@")) == 0)
f011940b:	83 ec 0c             	sub    $0xc,%esp
f011940e:	68 c5 54 13 f0       	push   $0xf01354c5
f0119413:	e8 65 16 00 00       	call   f011aa7d <strlen>
f0119418:	83 c4 10             	add    $0x10,%esp
f011941b:	83 ec 04             	sub    $0x4,%esp
f011941e:	50                   	push   %eax
f011941f:	68 c5 54 13 f0       	push   $0xf01354c5
f0119424:	ff 75 08             	pushl  0x8(%ebp)
f0119427:	e8 95 17 00 00       	call   f011abc1 <strncmp>
f011942c:	83 c4 10             	add    $0x10,%esp
f011942f:	85 c0                	test   %eax,%eax
f0119431:	0f 85 ac 00 00 00    	jne    f01194e3 <sys_utilities+0x823>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0119437:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f011943d:	50                   	push   %eax
f011943e:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0119444:	50                   	push   %eax
f0119445:	68 a2 51 13 f0       	push   $0xf01351a2
f011944a:	ff 75 08             	pushl  0x8(%ebp)
f011944d:	e8 ef 1c 00 00       	call   f011b141 <strsplit>
f0119452:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0119455:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011945b:	83 ec 04             	sub    $0x4,%esp
f011945e:	6a 0a                	push   $0xa
f0119460:	6a 00                	push   $0x0
f0119462:	50                   	push   %eax
f0119463:	e8 24 1a 00 00       	call   f011ae8c <strtol>
f0119468:	83 c4 10             	add    $0x10,%esp
f011946b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		struct Env* env = NULL ;
f011946e:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f0119475:	00 00 00 
		int ret = envid2env(envID, &env, 0);
f0119478:	83 ec 04             	sub    $0x4,%esp
f011947b:	6a 00                	push   $0x0
f011947d:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0119483:	50                   	push   %eax
f0119484:	ff 75 dc             	pushl  -0x24(%ebp)
f0119487:	e8 df 25 ff ff       	call   f010ba6b <envid2env>
f011948c:	83 c4 10             	add    $0x10,%esp
f011948f:	89 45 d8             	mov    %eax,-0x28(%ebp)
		uint32* procState = (uint32*) value ;
f0119492:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119495:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if (ret == E_BAD_ENV)
f0119498:	83 7d d8 fe          	cmpl   $0xfffffffe,-0x28(%ebp)
f011949c:	75 0e                	jne    f01194ac <sys_utilities+0x7ec>
		{
			//cprintf("\n\n<<<<<<<<<<< BAD ENV >>>>>>>>>>>\n\n");
			*procState = E_BAD_ENV;
f011949e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01194a1:	c7 00 fe ff ff ff    	movl   $0xfffffffe,(%eax)
f01194a7:	e9 5d 01 00 00       	jmp    f0119609 <sys_utilities+0x949>
			return;
		}
		else
		{
			assert(env->env_id == envID) ;
f01194ac:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01194b2:	8b 40 10             	mov    0x10(%eax),%eax
f01194b5:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01194b8:	74 19                	je     f01194d3 <sys_utilities+0x813>
f01194ba:	68 a4 51 13 f0       	push   $0xf01351a4
f01194bf:	68 e7 50 13 f0       	push   $0xf01350e7
f01194c4:	68 8b 01 00 00       	push   $0x18b
f01194c9:	68 2f 51 13 f0       	push   $0xf013512f
f01194ce:	e8 dc 79 fe ff       	call   f0100eaf <_panic>
			*procState = env->env_status;
f01194d3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01194d9:	8b 50 18             	mov    0x18(%eax),%edx
f01194dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01194df:	89 10                	mov    %edx,(%eax)
f01194e1:	eb 29                	jmp    f011950c <sys_utilities+0x84c>
		}
	}
	else if (strcmp(utilityName, "__IsOPTRepl__") == 0)
f01194e3:	83 ec 08             	sub    $0x8,%esp
f01194e6:	68 d5 54 13 f0       	push   $0xf01354d5
f01194eb:	ff 75 08             	pushl  0x8(%ebp)
f01194ee:	e8 96 16 00 00       	call   f011ab89 <strcmp>
f01194f3:	83 c4 10             	add    $0x10,%esp
f01194f6:	85 c0                	test   %eax,%eax
f01194f8:	75 12                	jne    f011950c <sys_utilities+0x84c>
	{
		uint32* isOPTRepl = (uint32*) value ;
f01194fa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01194fd:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*isOPTRepl = isPageReplacmentAlgorithmOPTIMAL();
f0119500:	e8 bd 63 ff ff       	call   f010f8c2 <isPageReplacmentAlgorithmOPTIMAL>
f0119505:	89 c2                	mov    %eax,%edx
f0119507:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011950a:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011950c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0119510:	0f 89 f3 00 00 00    	jns    f0119609 <sys_utilities+0x949>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f0119516:	83 ec 08             	sub    $0x8,%esp
f0119519:	68 e3 54 13 f0       	push   $0xf01354e3
f011951e:	ff 75 08             	pushl  0x8(%ebp)
f0119521:	e8 63 16 00 00       	call   f011ab89 <strcmp>
f0119526:	83 c4 10             	add    $0x10,%esp
f0119529:	85 c0                	test   %eax,%eax
f011952b:	0f 85 d8 00 00 00    	jne    f0119609 <sys_utilities+0x949>
		{
			switch (value)
f0119531:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119534:	83 c0 08             	add    $0x8,%eax
f0119537:	83 f8 07             	cmp    $0x7,%eax
f011953a:	0f 87 c8 00 00 00    	ja     f0119608 <sys_utilities+0x948>
f0119540:	8b 04 85 30 58 13 f0 	mov    -0xfeca7d0(,%eax,4),%eax
f0119547:	ff e0                	jmp    *%eax
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f0119549:	83 ec 0c             	sub    $0xc,%esp
f011954c:	68 f4 54 13 f0       	push   $0xf01354f4
f0119551:	e8 06 86 fe ff       	call   f0101b5c <cprintf>
f0119556:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f0119559:	e8 61 62 ff ff       	call   f010f7bf <setPageReplacmentAlgorithmFIFO>
				break;
f011955e:	e9 a6 00 00 00       	jmp    f0119609 <sys_utilities+0x949>
			case -PG_REP_CLOCK:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO CLOCK.\n*************************************\n");
f0119563:	83 ec 0c             	sub    $0xc,%esp
f0119566:	68 64 55 13 f0       	push   $0xf0135564
f011956b:	e8 ec 85 fe ff       	call   f0101b5c <cprintf>
f0119570:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmCLOCK();
f0119573:	e8 37 62 ff ff       	call   f010f7af <setPageReplacmentAlgorithmCLOCK>
				break;
f0119578:	e9 8c 00 00 00       	jmp    f0119609 <sys_utilities+0x949>
			case -PG_REP_MODIFIEDCLOCK:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO MODIFIED CLOCK.\n*************************************\n");
f011957d:	83 ec 0c             	sub    $0xc,%esp
f0119580:	68 d4 55 13 f0       	push   $0xf01355d4
f0119585:	e8 d2 85 fe ff       	call   f0101b5c <cprintf>
f011958a:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmModifiedCLOCK();
f011958d:	e8 3d 62 ff ff       	call   f010f7cf <setPageReplacmentAlgorithmModifiedCLOCK>
				break;
f0119592:	eb 75                	jmp    f0119609 <sys_utilities+0x949>
			case -PG_REP_OPTIMAL:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO OPTIMAL.\n*************************************\n");
f0119594:	83 ec 0c             	sub    $0xc,%esp
f0119597:	68 50 56 13 f0       	push   $0xf0135650
f011959c:	e8 bb 85 fe ff       	call   f0101b5c <cprintf>
f01195a1:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmOPTIMAL();
f01195a4:	e8 6c 62 ff ff       	call   f010f815 <setPageReplacmentAlgorithmOPTIMAL>
				break;
f01195a9:	eb 5e                	jmp    f0119609 <sys_utilities+0x949>
			case -PG_REP_LRU_TIME_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU AGING.\n*************************************\n");
f01195ab:	83 ec 0c             	sub    $0xc,%esp
f01195ae:	68 c4 56 13 f0       	push   $0xf01356c4
f01195b3:	e8 a4 85 fe ff       	call   f0101b5c <cprintf>
f01195b8:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
f01195bb:	83 ec 0c             	sub    $0xc,%esp
f01195be:	6a 01                	push   $0x1
f01195c0:	e8 b7 61 ff ff       	call   f010f77c <setPageReplacmentAlgorithmLRU>
f01195c5:	83 c4 10             	add    $0x10,%esp
				break;
f01195c8:	eb 3f                	jmp    f0119609 <sys_utilities+0x949>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f01195ca:	83 ec 0c             	sub    $0xc,%esp
f01195cd:	68 38 57 13 f0       	push   $0xf0135738
f01195d2:	e8 85 85 fe ff       	call   f0101b5c <cprintf>
f01195d7:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f01195da:	83 ec 0c             	sub    $0xc,%esp
f01195dd:	6a 02                	push   $0x2
f01195df:	e8 98 61 ff ff       	call   f010f77c <setPageReplacmentAlgorithmLRU>
f01195e4:	83 c4 10             	add    $0x10,%esp
				break;
f01195e7:	eb 20                	jmp    f0119609 <sys_utilities+0x949>
			case -PG_REP_NchanceCLOCK:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO Nth Clock Normal (N=1).\n*************************************\n");
f01195e9:	83 ec 0c             	sub    $0xc,%esp
f01195ec:	68 ac 57 13 f0       	push   $0xf01357ac
f01195f1:	e8 66 85 fe ff       	call   f0101b5c <cprintf>
f01195f6:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmNchanceCLOCK(1);
f01195f9:	83 ec 0c             	sub    $0xc,%esp
f01195fc:	6a 01                	push   $0x1
f01195fe:	e8 ec 61 ff ff       	call   f010f7ef <setPageReplacmentAlgorithmNchanceCLOCK>
f0119603:	83 c4 10             	add    $0x10,%esp
				break;
f0119606:	eb 01                	jmp    f0119609 <sys_utilities+0x949>
			default:
				break;
f0119608:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f0119609:	c9                   	leave  
f011960a:	c3                   	ret    

f011960b <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011960b:	55                   	push   %ebp
f011960c:	89 e5                	mov    %esp,%ebp
f011960e:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f0119611:	8b 45 08             	mov    0x8(%ebp),%eax
f0119614:	8b 00                	mov    (%eax),%eax
f0119616:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f0119619:	8b 45 08             	mov    0x8(%ebp),%eax
f011961c:	8b 00                	mov    (%eax),%eax
f011961e:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f0119621:	eb 52                	jmp    f0119675 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f0119623:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119626:	8b 00                	mov    (%eax),%eax
f0119628:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011962b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011962e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119631:	75 12                	jne    f0119645 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f0119633:	83 ec 0c             	sub    $0xc,%esp
f0119636:	68 50 58 13 f0       	push   $0xf0135850
f011963b:	e8 1c 85 fe ff       	call   f0101b5c <cprintf>
f0119640:	83 c4 10             	add    $0x10,%esp
			break;
f0119643:	eb 3f                	jmp    f0119684 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f0119645:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119649:	74 38                	je     f0119683 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011964b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011964e:	8b 00                	mov    (%eax),%eax
f0119650:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f0119653:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119656:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119659:	75 12                	jne    f011966d <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011965b:	83 ec 0c             	sub    $0xc,%esp
f011965e:	68 6c 58 13 f0       	push   $0xf013586c
f0119663:	e8 f4 84 fe ff       	call   f0101b5c <cprintf>
f0119668:	83 c4 10             	add    $0x10,%esp
			break;
f011966b:	eb 17                	jmp    f0119684 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011966d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119670:	8b 00                	mov    (%eax),%eax
f0119672:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f0119675:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0119679:	74 09                	je     f0119684 <detect_loop_in_FrameInfo_list+0x79>
f011967b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011967f:	75 a2                	jne    f0119623 <detect_loop_in_FrameInfo_list+0x18>
f0119681:	eb 01                	jmp    f0119684 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f0119683:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f0119684:	83 ec 0c             	sub    $0xc,%esp
f0119687:	68 83 58 13 f0       	push   $0xf0135883
f011968c:	e8 cb 84 fe ff       	call   f0101b5c <cprintf>
f0119691:	83 c4 10             	add    $0x10,%esp
}
f0119694:	90                   	nop
f0119695:	c9                   	leave  
f0119696:	c3                   	ret    

f0119697 <scarce_memory>:

void scarce_memory()
{
f0119697:	55                   	push   %ebp
f0119698:	89 e5                	mov    %esp,%ebp
f011969a:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011969d:	a1 50 df 83 f0       	mov    0xf083df50,%eax
f01196a2:	ba 64 00 00 00       	mov    $0x64,%edx
f01196a7:	29 c2                	sub    %eax,%edx
f01196a9:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f01196ae:	0f af c2             	imul   %edx,%eax
f01196b1:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f01196b6:	f7 e2                	mul    %edx
f01196b8:	89 d0                	mov    %edx,%eax
f01196ba:	c1 e8 05             	shr    $0x5,%eax
f01196bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f01196c0:	a1 50 df 83 f0       	mov    0xf083df50,%eax
f01196c5:	ba 64 00 00 00       	mov    $0x64,%edx
f01196ca:	29 c2                	sub    %eax,%edx
f01196cc:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f01196d1:	89 d1                	mov    %edx,%ecx
f01196d3:	0f af c8             	imul   %eax,%ecx
f01196d6:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01196db:	f7 e1                	mul    %ecx
f01196dd:	c1 ea 05             	shr    $0x5,%edx
f01196e0:	89 d0                	mov    %edx,%eax
f01196e2:	c1 e0 02             	shl    $0x2,%eax
f01196e5:	01 d0                	add    %edx,%eax
f01196e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01196ee:	01 d0                	add    %edx,%eax
f01196f0:	c1 e0 02             	shl    $0x2,%eax
f01196f3:	29 c1                	sub    %eax,%ecx
f01196f5:	89 ca                	mov    %ecx,%edx
f01196f7:	85 d2                	test   %edx,%edx
f01196f9:	74 03                	je     f01196fe <scarce_memory+0x67>
		total_size_tobe_allocated++;
f01196fb:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f01196fe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_kspinlock(&MemFrameLists.mfllock);
f0119705:	83 ec 0c             	sub    $0xc,%esp
f0119708:	68 40 de 83 f0       	push   $0xf083de40
f011970d:	e8 6b 66 ff ff       	call   f010fd7d <acquire_kspinlock>
f0119712:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f0119715:	a1 2c de 83 f0       	mov    0xf083de2c,%eax
f011971a:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011971d:	8b 15 18 e0 83 f0    	mov    0xf083e018,%edx
f0119723:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0119726:	29 c2                	sub    %eax,%edx
f0119728:	89 d0                	mov    %edx,%eax
f011972a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011972d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119730:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0119733:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f0119736:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011973d:	eb 12                	jmp    f0119751 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011973f:	83 ec 0c             	sub    $0xc,%esp
f0119742:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0119745:	50                   	push   %eax
f0119746:	e8 fa f8 fe ff       	call   f0109045 <allocate_frame>
f011974b:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011974e:	ff 45 f0             	incl   -0x10(%ebp)
f0119751:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119754:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0119757:	76 e6                	jbe    f011973f <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_kspinlock(&MemFrameLists.mfllock);
f0119759:	83 ec 0c             	sub    $0xc,%esp
f011975c:	68 40 de 83 f0       	push   $0xf083de40
f0119761:	e8 bc 66 ff ff       	call   f010fe22 <release_kspinlock>
f0119766:	83 c4 10             	add    $0x10,%esp

}
f0119769:	90                   	nop
f011976a:	c9                   	leave  
f011976b:	c3                   	ret    

f011976c <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011976c:	55                   	push   %ebp
f011976d:	89 e5                	mov    %esp,%ebp
f011976f:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f0119772:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f0119779:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f0119780:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f0119787:	e8 8f 22 ff ff       	call   f010ba1b <get_cpu_proc>
f011978c:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011978f:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0119793:	75 19                	jne    f01197ae <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f0119795:	68 9d 58 13 f0       	push   $0xf013589d
f011979a:	68 e7 50 13 f0       	push   $0xf01350e7
f011979f:	68 fd 01 00 00       	push   $0x1fd
f01197a4:	68 2f 51 13 f0       	push   $0xf013512f
f01197a9:	e8 01 77 fe ff       	call   f0100eaf <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f01197ae:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01197b2:	0f 85 d6 01 00 00    	jne    f011998e <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_kspinlock(&ProcessQueues.qlock);
f01197b8:	83 ec 0c             	sub    $0xc,%esp
f01197bb:	68 80 dd 83 f0       	push   $0xf083dd80
f01197c0:	e8 b8 65 ff ff       	call   f010fd7d <acquire_kspinlock>
f01197c5:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f01197c8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01197cf:	e9 d2 00 00 00       	jmp    f01198a6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f01197d4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f01197db:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f01197e0:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01197e3:	c1 e2 04             	shl    $0x4,%edx
f01197e6:	01 d0                	add    %edx,%eax
f01197e8:	8b 00                	mov    (%eax),%eax
f01197ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01197ed:	eb 7c                	jmp    f011986b <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f01197ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01197f2:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01197f8:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f01197fb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01197fe:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119804:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119807:	0f af c2             	imul   %edx,%eax
f011980a:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011980f:	f7 e2                	mul    %edx
f0119811:	89 d0                	mov    %edx,%eax
f0119813:	c1 e8 05             	shr    $0x5,%eax
f0119816:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0119819:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011981c:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119822:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119825:	89 d1                	mov    %edx,%ecx
f0119827:	0f af c8             	imul   %eax,%ecx
f011982a:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011982f:	f7 e1                	mul    %ecx
f0119831:	c1 ea 05             	shr    $0x5,%edx
f0119834:	89 d0                	mov    %edx,%eax
f0119836:	c1 e0 02             	shl    $0x2,%eax
f0119839:	01 d0                	add    %edx,%eax
f011983b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119842:	01 d0                	add    %edx,%eax
f0119844:	c1 e0 02             	shl    $0x2,%eax
f0119847:	29 c1                	sub    %eax,%ecx
f0119849:	89 ca                	mov    %ecx,%edx
f011984b:	85 d2                	test   %edx,%edx
f011984d:	74 03                	je     f0119852 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011984f:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f0119852:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119855:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f0119858:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f011985d:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0119860:	c1 e2 04             	shl    $0x4,%edx
f0119863:	01 d0                	add    %edx,%eax
f0119865:	8b 40 08             	mov    0x8(%eax),%eax
f0119868:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011986b:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0119870:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0119873:	c1 e2 04             	shl    $0x4,%edx
f0119876:	01 d0                	add    %edx,%eax
f0119878:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011987c:	74 08                	je     f0119886 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011987e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119881:	8b 52 08             	mov    0x8(%edx),%edx
f0119884:	eb 05                	jmp    f011988b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f0119886:	ba 00 00 00 00       	mov    $0x0,%edx
f011988b:	89 50 08             	mov    %edx,0x8(%eax)
f011988e:	8b 40 08             	mov    0x8(%eax),%eax
f0119891:	85 c0                	test   %eax,%eax
f0119893:	0f 85 56 ff ff ff    	jne    f01197ef <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f0119899:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011989d:	0f 85 4c ff ff ff    	jne    f01197ef <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f01198a3:	ff 45 e8             	incl   -0x18(%ebp)
f01198a6:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f01198ab:	0f b6 c0             	movzbl %al,%eax
f01198ae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01198b1:	0f 8f 1d ff ff ff    	jg     f01197d4 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f01198b7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f01198be:	a1 00 de 83 f0       	mov    0xf083de00,%eax
f01198c3:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01198c6:	eb 1a                	jmp    f01198e2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f01198c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01198cb:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01198d1:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f01198d4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01198d7:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f01198da:	a1 08 de 83 f0       	mov    0xf083de08,%eax
f01198df:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01198e2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01198e6:	74 08                	je     f01198f0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f01198e8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01198eb:	8b 40 08             	mov    0x8(%eax),%eax
f01198ee:	eb 05                	jmp    f01198f5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f01198f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01198f5:	a3 08 de 83 f0       	mov    %eax,0xf083de08
f01198fa:	a1 08 de 83 f0       	mov    0xf083de08,%eax
f01198ff:	85 c0                	test   %eax,%eax
f0119901:	75 c5                	jne    f01198c8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f0119903:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0119907:	75 bf                	jne    f01198c8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);
f0119909:	83 ec 0c             	sub    $0xc,%esp
f011990c:	68 80 dd 83 f0       	push   $0xf083dd80
f0119911:	e8 0c 65 ff ff       	call   f010fe22 <release_kspinlock>
f0119916:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f0119919:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011991d:	0f 84 d4 00 00 00    	je     f01199f7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f0119923:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119926:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011992c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011992f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119932:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119938:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011993b:	0f af c2             	imul   %edx,%eax
f011993e:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0119943:	f7 e2                	mul    %edx
f0119945:	89 d0                	mov    %edx,%eax
f0119947:	c1 e8 05             	shr    $0x5,%eax
f011994a:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011994d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119950:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119956:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119959:	89 d1                	mov    %edx,%ecx
f011995b:	0f af c8             	imul   %eax,%ecx
f011995e:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119963:	f7 e1                	mul    %ecx
f0119965:	c1 ea 05             	shr    $0x5,%edx
f0119968:	89 d0                	mov    %edx,%eax
f011996a:	c1 e0 02             	shl    $0x2,%eax
f011996d:	01 d0                	add    %edx,%eax
f011996f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119976:	01 d0                	add    %edx,%eax
f0119978:	c1 e0 02             	shl    $0x2,%eax
f011997b:	29 c1                	sub    %eax,%ecx
f011997d:	89 ca                	mov    %ecx,%edx
f011997f:	85 d2                	test   %edx,%edx
f0119981:	74 03                	je     f0119986 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f0119983:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f0119986:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0119989:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011998c:	eb 69                	jmp    f01199f7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011998e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119991:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0119997:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011999a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011999d:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f01199a3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01199a6:	0f af c2             	imul   %edx,%eax
f01199a9:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f01199ae:	f7 e2                	mul    %edx
f01199b0:	89 d0                	mov    %edx,%eax
f01199b2:	c1 e8 05             	shr    $0x5,%eax
f01199b5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f01199b8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01199bb:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f01199c1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01199c4:	89 d1                	mov    %edx,%ecx
f01199c6:	0f af c8             	imul   %eax,%ecx
f01199c9:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01199ce:	f7 e1                	mul    %ecx
f01199d0:	c1 ea 05             	shr    $0x5,%edx
f01199d3:	89 d0                	mov    %edx,%eax
f01199d5:	c1 e0 02             	shl    $0x2,%eax
f01199d8:	01 d0                	add    %edx,%eax
f01199da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01199e1:	01 d0                	add    %edx,%eax
f01199e3:	c1 e0 02             	shl    $0x2,%eax
f01199e6:	29 c1                	sub    %eax,%ecx
f01199e8:	89 ca                	mov    %ecx,%edx
f01199ea:	85 d2                	test   %edx,%edx
f01199ec:	74 03                	je     f01199f1 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f01199ee:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f01199f1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01199f4:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f01199f7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01199fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01199fd:	01 c2                	add    %eax,%edx
f01199ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119a02:	01 d0                	add    %edx,%eax
}
f0119a04:	c9                   	leave  
f0119a05:	c3                   	ret    

f0119a06 <schenv>:


void schenv()
{
f0119a06:	55                   	push   %ebp
f0119a07:	89 e5                	mov    %esp,%ebp
f0119a09:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f0119a0c:	c6 05 3c 64 85 f0 00 	movb   $0x0,0xf085643c
	__ne = NULL;
f0119a13:	c7 05 54 61 85 f0 00 	movl   $0x0,0xf0856154
f0119a1a:	00 00 00 
	acquire_kspinlock(&ProcessQueues.qlock);
f0119a1d:	83 ec 0c             	sub    $0xc,%esp
f0119a20:	68 80 dd 83 f0       	push   $0xf083dd80
f0119a25:	e8 53 63 ff ff       	call   f010fd7d <acquire_kspinlock>
f0119a2a:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f0119a2d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a34:	eb 3f                	jmp    f0119a75 <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f0119a36:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0119a3b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119a3e:	c1 e2 04             	shl    $0x4,%edx
f0119a41:	01 d0                	add    %edx,%eax
f0119a43:	83 ec 0c             	sub    $0xc,%esp
f0119a46:	50                   	push   %eax
f0119a47:	e8 a7 c4 fe ff       	call   f0105ef3 <queue_size>
f0119a4c:	83 c4 10             	add    $0x10,%esp
f0119a4f:	85 c0                	test   %eax,%eax
f0119a51:	74 1f                	je     f0119a72 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f0119a53:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0119a58:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119a5b:	c1 e2 04             	shl    $0x4,%edx
f0119a5e:	01 d0                	add    %edx,%eax
f0119a60:	8b 40 04             	mov    0x4(%eax),%eax
f0119a63:	a3 54 61 85 f0       	mov    %eax,0xf0856154
				__nl = i;
f0119a68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119a6b:	a2 3c 64 85 f0       	mov    %al,0xf085643c
				break;
f0119a70:	eb 10                	jmp    f0119a82 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_kspinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f0119a72:	ff 45 f4             	incl   -0xc(%ebp)
f0119a75:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f0119a7a:	0f b6 c0             	movzbl %al,%eax
f0119a7d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a80:	7f b4                	jg     f0119a36 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_kspinlock(&ProcessQueues.qlock);
f0119a82:	83 ec 0c             	sub    $0xc,%esp
f0119a85:	68 80 dd 83 f0       	push   $0xf083dd80
f0119a8a:	e8 93 63 ff ff       	call   f010fe22 <release_kspinlock>
f0119a8f:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f0119a92:	e8 84 1f ff ff       	call   f010ba1b <get_cpu_proc>
f0119a97:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f0119a9a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119a9e:	0f 84 82 00 00 00    	je     f0119b26 <schenv+0x120>
	{
		if (__ne != NULL)
f0119aa4:	a1 54 61 85 f0       	mov    0xf0856154,%eax
f0119aa9:	85 c0                	test   %eax,%eax
f0119aab:	74 49                	je     f0119af6 <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f0119aad:	a0 61 dd 83 f0       	mov    0xf083dd61,%al
f0119ab2:	0f b6 c0             	movzbl %al,%eax
f0119ab5:	8d 50 01             	lea    0x1(%eax),%edx
f0119ab8:	a0 3c 64 85 f0       	mov    0xf085643c,%al
f0119abd:	0f b6 c0             	movzbl %al,%eax
f0119ac0:	39 c2                	cmp    %eax,%edx
f0119ac2:	7d 62                	jge    f0119b26 <schenv+0x120>
			{
				__ne = cur_env;
f0119ac4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119ac7:	a3 54 61 85 f0       	mov    %eax,0xf0856154
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f0119acc:	a0 61 dd 83 f0       	mov    0xf083dd61,%al
f0119ad1:	0f b6 c0             	movzbl %al,%eax
f0119ad4:	8a 15 c0 63 85 f0    	mov    0xf08563c0,%dl
f0119ada:	0f b6 d2             	movzbl %dl,%edx
f0119add:	4a                   	dec    %edx
f0119ade:	39 d0                	cmp    %edx,%eax
f0119ae0:	7d 08                	jge    f0119aea <schenv+0xe4>
f0119ae2:	a0 61 dd 83 f0       	mov    0xf083dd61,%al
f0119ae7:	40                   	inc    %eax
f0119ae8:	eb 05                	jmp    f0119aef <schenv+0xe9>
f0119aea:	a0 61 dd 83 f0       	mov    0xf083dd61,%al
f0119aef:	a2 3c 64 85 f0       	mov    %al,0xf085643c
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f0119af4:	eb 30                	jmp    f0119b26 <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f0119af6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119af9:	a3 54 61 85 f0       	mov    %eax,0xf0856154
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f0119afe:	a0 61 dd 83 f0       	mov    0xf083dd61,%al
f0119b03:	0f b6 c0             	movzbl %al,%eax
f0119b06:	8a 15 c0 63 85 f0    	mov    0xf08563c0,%dl
f0119b0c:	0f b6 d2             	movzbl %dl,%edx
f0119b0f:	4a                   	dec    %edx
f0119b10:	39 d0                	cmp    %edx,%eax
f0119b12:	7d 08                	jge    f0119b1c <schenv+0x116>
f0119b14:	a0 61 dd 83 f0       	mov    0xf083dd61,%al
f0119b19:	40                   	inc    %eax
f0119b1a:	eb 05                	jmp    f0119b21 <schenv+0x11b>
f0119b1c:	a0 61 dd 83 f0       	mov    0xf083dd61,%al
f0119b21:	a2 3c 64 85 f0       	mov    %al,0xf085643c
		}
	}
}
f0119b26:	90                   	nop
f0119b27:	c9                   	leave  
f0119b28:	c3                   	ret    

f0119b29 <chksch>:

void chksch(uint8 onoff)
{
f0119b29:	55                   	push   %ebp
f0119b2a:	89 e5                	mov    %esp,%ebp
f0119b2c:	83 ec 18             	sub    $0x18,%esp
f0119b2f:	8b 45 08             	mov    0x8(%ebp),%eax
f0119b32:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f0119b35:	e8 83 db fe ff       	call   f01076bd <isSchedMethodBSD>
f0119b3a:	85 c0                	test   %eax,%eax
f0119b3c:	74 48                	je     f0119b86 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f0119b3e:	e8 fe da fe ff       	call   f0107641 <get_load_average>
f0119b43:	a3 dc 63 85 f0       	mov    %eax,0xf08563dc
f0119b48:	a1 dc 63 85 f0       	mov    0xf08563dc,%eax
f0119b4d:	a3 1c e0 83 f0       	mov    %eax,0xf083e01c
		acquire_kspinlock(&ProcessQueues.qlock);
f0119b52:	83 ec 0c             	sub    $0xc,%esp
f0119b55:	68 80 dd 83 f0       	push   $0xf083dd80
f0119b5a:	e8 1e 62 ff ff       	call   f010fd7d <acquire_kspinlock>
f0119b5f:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f0119b62:	a1 0c de 83 f0       	mov    0xf083de0c,%eax
f0119b67:	a3 b0 de 83 f0       	mov    %eax,0xf083deb0
		}
		release_kspinlock(&ProcessQueues.qlock);
f0119b6c:	83 ec 0c             	sub    $0xc,%esp
f0119b6f:	68 80 dd 83 f0       	push   $0xf083dd80
f0119b74:	e8 a9 62 ff ff       	call   f010fe22 <release_kspinlock>
f0119b79:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f0119b7c:	c7 05 64 61 85 f0 01 	movl   $0x1,0xf0856164
f0119b83:	00 00 00 
	}
	__chkstatus = onoff;
f0119b86:	8a 45 f4             	mov    -0xc(%ebp),%al
f0119b89:	a2 4c 61 85 f0       	mov    %al,0xf085614c
}
f0119b8e:	90                   	nop
f0119b8f:	c9                   	leave  
f0119b90:	c3                   	ret    

f0119b91 <chk1>:
void chk1()
{
f0119b91:	55                   	push   %ebp
f0119b92:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f0119b94:	90                   	nop
f0119b95:	5d                   	pop    %ebp
f0119b96:	c3                   	ret    

f0119b97 <chk2>:
void chk2(struct Env* __se)
{
f0119b97:	55                   	push   %ebp
f0119b98:	89 e5                	mov    %esp,%ebp
f0119b9a:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f0119b9d:	a0 4c 61 85 f0       	mov    0xf085614c,%al
f0119ba2:	84 c0                	test   %al,%al
f0119ba4:	0f 84 59 03 00 00    	je     f0119f03 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f0119baa:	e8 0e db fe ff       	call   f01076bd <isSchedMethodBSD>
f0119baf:	85 c0                	test   %eax,%eax
f0119bb1:	0f 84 4d 03 00 00    	je     f0119f04 <chk2+0x36d>
	{
		__nla = get_load_average();
f0119bb7:	e8 85 da fe ff       	call   f0107641 <get_load_average>
f0119bbc:	a3 54 df 83 f0       	mov    %eax,0xf083df54
		acquire_kspinlock(&ProcessQueues.qlock);
f0119bc1:	83 ec 0c             	sub    $0xc,%esp
f0119bc4:	68 80 dd 83 f0       	push   $0xf083dd80
f0119bc9:	e8 af 61 ff ff       	call   f010fd7d <acquire_kspinlock>
f0119bce:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0119bd1:	a1 0c de 83 f0       	mov    0xf083de0c,%eax
f0119bd6:	a3 58 61 85 f0       	mov    %eax,0xf0856158
		}
		release_kspinlock(&ProcessQueues.qlock);
f0119bdb:	83 ec 0c             	sub    $0xc,%esp
f0119bde:	68 80 dd 83 f0       	push   $0xf083dd80
f0119be3:	e8 3a 62 ff ff       	call   f010fe22 <release_kspinlock>
f0119be8:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f0119beb:	a1 64 61 85 f0       	mov    0xf0856164,%eax
f0119bf0:	85 c0                	test   %eax,%eax
f0119bf2:	74 72                	je     f0119c66 <chk2+0xcf>
		{
			acquire_kspinlock(&ProcessQueues.qlock);
f0119bf4:	83 ec 0c             	sub    $0xc,%esp
f0119bf7:	68 80 dd 83 f0       	push   $0xf083dd80
f0119bfc:	e8 7c 61 ff ff       	call   f010fd7d <acquire_kspinlock>
f0119c01:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f0119c04:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0119c08:	0f 95 c0             	setne  %al
f0119c0b:	0f b6 c0             	movzbl %al,%eax
f0119c0e:	a3 94 62 85 f0       	mov    %eax,0xf0856294
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f0119c13:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f0119c18:	0f b6 c0             	movzbl %al,%eax
f0119c1b:	48                   	dec    %eax
f0119c1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0119c1f:	eb 20                	jmp    f0119c41 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f0119c21:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0119c26:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119c29:	c1 e2 04             	shl    $0x4,%edx
f0119c2c:	01 d0                	add    %edx,%eax
f0119c2e:	8b 40 0c             	mov    0xc(%eax),%eax
f0119c31:	8b 15 94 62 85 f0    	mov    0xf0856294,%edx
f0119c37:	01 d0                	add    %edx,%eax
f0119c39:	a3 94 62 85 f0       	mov    %eax,0xf0856294
		{
			acquire_kspinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f0119c3e:	ff 4d f4             	decl   -0xc(%ebp)
f0119c41:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0119c45:	79 da                	jns    f0119c21 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f0119c47:	c7 05 64 61 85 f0 00 	movl   $0x0,0xf0856164
f0119c4e:	00 00 00 
			}
			release_kspinlock(&ProcessQueues.qlock);
f0119c51:	83 ec 0c             	sub    $0xc,%esp
f0119c54:	68 80 dd 83 f0       	push   $0xf083dd80
f0119c59:	e8 c4 61 ff ff       	call   f010fe22 <release_kspinlock>
f0119c5e:	83 c4 10             	add    $0x10,%esp
f0119c61:	e9 91 02 00 00       	jmp    f0119ef7 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f0119c66:	8b 15 b0 de 83 f0    	mov    0xf083deb0,%edx
f0119c6c:	a1 58 61 85 f0       	mov    0xf0856158,%eax
f0119c71:	39 c2                	cmp    %eax,%edx
f0119c73:	74 63                	je     f0119cd8 <chk2+0x141>
			{
				acquire_kspinlock(&ProcessQueues.qlock);
f0119c75:	83 ec 0c             	sub    $0xc,%esp
f0119c78:	68 80 dd 83 f0       	push   $0xf083dd80
f0119c7d:	e8 fb 60 ff ff       	call   f010fd7d <acquire_kspinlock>
f0119c82:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f0119c85:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0119c89:	0f 95 c0             	setne  %al
f0119c8c:	0f b6 c0             	movzbl %al,%eax
f0119c8f:	a3 94 62 85 f0       	mov    %eax,0xf0856294
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f0119c94:	a0 c0 63 85 f0       	mov    0xf08563c0,%al
f0119c99:	0f b6 c0             	movzbl %al,%eax
f0119c9c:	48                   	dec    %eax
f0119c9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0119ca0:	eb 20                	jmp    f0119cc2 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f0119ca2:	a1 10 de 83 f0       	mov    0xf083de10,%eax
f0119ca7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0119caa:	c1 e2 04             	shl    $0x4,%edx
f0119cad:	01 d0                	add    %edx,%eax
f0119caf:	8b 40 0c             	mov    0xc(%eax),%eax
f0119cb2:	8b 15 94 62 85 f0    	mov    0xf0856294,%edx
f0119cb8:	01 d0                	add    %edx,%eax
f0119cba:	a3 94 62 85 f0       	mov    %eax,0xf0856294
			{
				acquire_kspinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f0119cbf:	ff 4d f0             	decl   -0x10(%ebp)
f0119cc2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119cc6:	79 da                	jns    f0119ca2 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_kspinlock(&ProcessQueues.qlock);
f0119cc8:	83 ec 0c             	sub    $0xc,%esp
f0119ccb:	68 80 dd 83 f0       	push   $0xf083dd80
f0119cd0:	e8 4d 61 ff ff       	call   f010fe22 <release_kspinlock>
f0119cd5:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f0119cd8:	e8 fd d8 fe ff       	call   f01075da <timer_ticks>
f0119cdd:	6a 00                	push   $0x0
f0119cdf:	68 e8 03 00 00       	push   $0x3e8
f0119ce4:	52                   	push   %edx
f0119ce5:	50                   	push   %eax
f0119ce6:	e8 a9 1a 00 00       	call   f011b794 <__moddi3>
f0119ceb:	83 c4 10             	add    $0x10,%esp
f0119cee:	09 d0                	or     %edx,%eax
f0119cf0:	85 c0                	test   %eax,%eax
f0119cf2:	75 32                	jne    f0119d26 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f0119cf4:	8b 15 1c e0 83 f0    	mov    0xf083e01c,%edx
f0119cfa:	a1 54 df 83 f0       	mov    0xf083df54,%eax
f0119cff:	39 c2                	cmp    %eax,%edx
f0119d01:	75 19                	jne    f0119d1c <chk2+0x185>
f0119d03:	68 ad 58 13 f0       	push   $0xf01358ad
f0119d08:	68 e7 50 13 f0       	push   $0xf01350e7
f0119d0d:	68 b9 02 00 00       	push   $0x2b9
f0119d12:	68 2f 51 13 f0       	push   $0xf013512f
f0119d17:	e8 22 72 fe ff       	call   f0100f3e <_panic_all>
				__histla = __nla;
f0119d1c:	a1 54 df 83 f0       	mov    0xf083df54,%eax
f0119d21:	a3 1c e0 83 f0       	mov    %eax,0xf083e01c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f0119d26:	e8 af d8 fe ff       	call   f01075da <timer_ticks>
f0119d2b:	6a 00                	push   $0x0
f0119d2d:	6a 64                	push   $0x64
f0119d2f:	52                   	push   %edx
f0119d30:	50                   	push   %eax
f0119d31:	e8 5e 1a 00 00       	call   f011b794 <__moddi3>
f0119d36:	83 c4 10             	add    $0x10,%esp
f0119d39:	09 d0                	or     %edx,%eax
f0119d3b:	85 c0                	test   %eax,%eax
f0119d3d:	0f 85 b4 01 00 00    	jne    f0119ef7 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f0119d43:	8b 0d dc 63 85 f0    	mov    0xf08563dc,%ecx
f0119d49:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119d4e:	f7 e9                	imul   %ecx
f0119d50:	c1 fa 05             	sar    $0x5,%edx
f0119d53:	89 c8                	mov    %ecx,%eax
f0119d55:	c1 f8 1f             	sar    $0x1f,%eax
f0119d58:	29 c2                	sub    %eax,%edx
f0119d5a:	89 d0                	mov    %edx,%eax
f0119d5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f0119d5f:	8b 0d dc 63 85 f0    	mov    0xf08563dc,%ecx
f0119d65:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119d6a:	f7 e9                	imul   %ecx
f0119d6c:	c1 fa 05             	sar    $0x5,%edx
f0119d6f:	89 c8                	mov    %ecx,%eax
f0119d71:	c1 f8 1f             	sar    $0x1f,%eax
f0119d74:	29 c2                	sub    %eax,%edx
f0119d76:	89 d0                	mov    %edx,%eax
f0119d78:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0119d7b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0119d7e:	89 d0                	mov    %edx,%eax
f0119d80:	c1 e0 02             	shl    $0x2,%eax
f0119d83:	01 d0                	add    %edx,%eax
f0119d85:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119d8c:	01 d0                	add    %edx,%eax
f0119d8e:	c1 e0 02             	shl    $0x2,%eax
f0119d91:	29 c1                	sub    %eax,%ecx
f0119d93:	89 c8                	mov    %ecx,%eax
f0119d95:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f0119d98:	8b 0d 54 df 83 f0    	mov    0xf083df54,%ecx
f0119d9e:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119da3:	f7 e9                	imul   %ecx
f0119da5:	c1 fa 05             	sar    $0x5,%edx
f0119da8:	89 c8                	mov    %ecx,%eax
f0119daa:	c1 f8 1f             	sar    $0x1f,%eax
f0119dad:	29 c2                	sub    %eax,%edx
f0119daf:	89 d0                	mov    %edx,%eax
f0119db1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f0119db4:	8b 0d 54 df 83 f0    	mov    0xf083df54,%ecx
f0119dba:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119dbf:	f7 e9                	imul   %ecx
f0119dc1:	c1 fa 05             	sar    $0x5,%edx
f0119dc4:	89 c8                	mov    %ecx,%eax
f0119dc6:	c1 f8 1f             	sar    $0x1f,%eax
f0119dc9:	29 c2                	sub    %eax,%edx
f0119dcb:	89 d0                	mov    %edx,%eax
f0119dcd:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0119dd0:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0119dd3:	89 d0                	mov    %edx,%eax
f0119dd5:	c1 e0 02             	shl    $0x2,%eax
f0119dd8:	01 d0                	add    %edx,%eax
f0119dda:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119de1:	01 d0                	add    %edx,%eax
f0119de3:	c1 e0 02             	shl    $0x2,%eax
f0119de6:	29 c1                	sub    %eax,%ecx
f0119de8:	89 c8                	mov    %ecx,%eax
f0119dea:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f0119ded:	8b 15 58 61 85 f0    	mov    0xf0856158,%edx
f0119df3:	a1 b0 de 83 f0       	mov    0xf083deb0,%eax
f0119df8:	39 c2                	cmp    %eax,%edx
f0119dfa:	0f 85 ed 00 00 00    	jne    f0119eed <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f0119e00:	a1 94 62 85 f0       	mov    0xf0856294,%eax
f0119e05:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e08:	7e 5b                	jle    f0119e65 <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f0119e0a:	a1 94 62 85 f0       	mov    0xf0856294,%eax
f0119e0f:	83 ec 08             	sub    $0x8,%esp
f0119e12:	ff 75 e0             	pushl  -0x20(%ebp)
f0119e15:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119e18:	ff 75 e8             	pushl  -0x18(%ebp)
f0119e1b:	ff 75 ec             	pushl  -0x14(%ebp)
f0119e1e:	50                   	push   %eax
f0119e1f:	68 c0 58 13 f0       	push   $0xf01358c0
f0119e24:	e8 33 7d fe ff       	call   f0101b5c <cprintf>
f0119e29:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f0119e2c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119e2f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e32:	0f 8f b5 00 00 00    	jg     f0119eed <chk2+0x356>
f0119e38:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119e3b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e3e:	75 0c                	jne    f0119e4c <chk2+0x2b5>
f0119e40:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119e43:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119e46:	0f 8d a1 00 00 00    	jge    f0119eed <chk2+0x356>
f0119e4c:	68 08 59 13 f0       	push   $0xf0135908
f0119e51:	68 e7 50 13 f0       	push   $0xf01350e7
f0119e56:	68 ce 02 00 00       	push   $0x2ce
f0119e5b:	68 2f 51 13 f0       	push   $0xf013512f
f0119e60:	e8 d9 70 fe ff       	call   f0100f3e <_panic_all>
					}
					else if (__nproc < plaint)
f0119e65:	a1 94 62 85 f0       	mov    0xf0856294,%eax
f0119e6a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e6d:	7d 53                	jge    f0119ec2 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f0119e6f:	a1 94 62 85 f0       	mov    0xf0856294,%eax
f0119e74:	83 ec 08             	sub    $0x8,%esp
f0119e77:	ff 75 e0             	pushl  -0x20(%ebp)
f0119e7a:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119e7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0119e80:	ff 75 ec             	pushl  -0x14(%ebp)
f0119e83:	50                   	push   %eax
f0119e84:	68 48 59 13 f0       	push   $0xf0135948
f0119e89:	e8 ce 7c fe ff       	call   f0101b5c <cprintf>
f0119e8e:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f0119e91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119e94:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e97:	7c 54                	jl     f0119eed <chk2+0x356>
f0119e99:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119e9c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e9f:	75 08                	jne    f0119ea9 <chk2+0x312>
f0119ea1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119ea4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119ea7:	7e 44                	jle    f0119eed <chk2+0x356>
f0119ea9:	68 90 59 13 f0       	push   $0xf0135990
f0119eae:	68 e7 50 13 f0       	push   $0xf01350e7
f0119eb3:	68 d4 02 00 00       	push   $0x2d4
f0119eb8:	68 2f 51 13 f0       	push   $0xf013512f
f0119ebd:	e8 7c 70 fe ff       	call   f0100f3e <_panic_all>
					}
					else if (__nproc == plaint)
f0119ec2:	a1 94 62 85 f0       	mov    0xf0856294,%eax
f0119ec7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119eca:	75 21                	jne    f0119eed <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f0119ecc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119ecf:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119ed2:	74 19                	je     f0119eed <chk2+0x356>
f0119ed4:	68 d0 59 13 f0       	push   $0xf01359d0
f0119ed9:	68 e7 50 13 f0       	push   $0xf01350e7
f0119ede:	68 d8 02 00 00       	push   $0x2d8
f0119ee3:	68 2f 51 13 f0       	push   $0xf013512f
f0119ee8:	e8 51 70 fe ff       	call   f0100f3e <_panic_all>
					}
				}
				__pla = __nla;
f0119eed:	a1 54 df 83 f0       	mov    0xf083df54,%eax
f0119ef2:	a3 dc 63 85 f0       	mov    %eax,0xf08563dc
			}
		}
		__pnexit = __nnexit;
f0119ef7:	a1 58 61 85 f0       	mov    0xf0856158,%eax
f0119efc:	a3 b0 de 83 f0       	mov    %eax,0xf083deb0
f0119f01:	eb 01                	jmp    f0119f04 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f0119f03:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f0119f04:	c9                   	leave  
f0119f05:	c3                   	ret    

f0119f06 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f0119f06:	55                   	push   %ebp
f0119f07:	89 e5                	mov    %esp,%ebp
f0119f09:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f0119f0c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119f13:	eb 40                	jmp    f0119f55 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f0119f15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119f18:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f0119f1e:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0119f23:	83 ec 08             	sub    $0x8,%esp
f0119f26:	52                   	push   %edx
f0119f27:	50                   	push   %eax
f0119f28:	e8 af 01 00 00       	call   f011a0dc <check_va2pa>
f0119f2d:	83 c4 10             	add    $0x10,%esp
f0119f30:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119f33:	74 19                	je     f0119f4e <check_boot_pgdir+0x48>
f0119f35:	68 e4 59 13 f0       	push   $0xf01359e4
f0119f3a:	68 e7 50 13 f0       	push   $0xf01350e7
f0119f3f:	68 1f 03 00 00       	push   $0x31f
f0119f44:	68 2f 51 13 f0       	push   $0xf013512f
f0119f49:	e8 61 6f fe ff       	call   f0100eaf <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f0119f4e:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0119f55:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119f58:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f0119f5e:	a1 30 63 85 f0       	mov    0xf0856330,%eax
f0119f63:	39 c2                	cmp    %eax,%edx
f0119f65:	72 ae                	jb     f0119f15 <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f0119f67:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119f6e:	e9 81 00 00 00       	jmp    f0119ff4 <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f0119f73:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119f76:	25 ff 7f 00 00       	and    $0x7fff,%eax
f0119f7b:	85 c0                	test   %eax,%eax
f0119f7d:	74 6d                	je     f0119fec <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f0119f7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119f82:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f0119f88:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f0119f8d:	83 ec 08             	sub    $0x8,%esp
f0119f90:	52                   	push   %edx
f0119f91:	50                   	push   %eax
f0119f92:	e8 45 01 00 00       	call   f011a0dc <check_va2pa>
f0119f97:	83 c4 10             	add    $0x10,%esp
f0119f9a:	c7 45 f0 00 70 17 f0 	movl   $0xf0177000,-0x10(%ebp)
f0119fa1:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f0119fa8:	77 17                	ja     f0119fc1 <check_boot_pgdir+0xbb>
f0119faa:	ff 75 f0             	pushl  -0x10(%ebp)
f0119fad:	68 1c 5a 13 f0       	push   $0xf0135a1c
f0119fb2:	68 2d 03 00 00       	push   $0x32d
f0119fb7:	68 2f 51 13 f0       	push   $0xf013512f
f0119fbc:	e8 ee 6e fe ff       	call   f0100eaf <_panic>
f0119fc1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0119fc4:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f0119fca:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119fcd:	01 ca                	add    %ecx,%edx
f0119fcf:	39 d0                	cmp    %edx,%eax
f0119fd1:	74 1a                	je     f0119fed <check_boot_pgdir+0xe7>
f0119fd3:	68 50 5a 13 f0       	push   $0xf0135a50
f0119fd8:	68 e7 50 13 f0       	push   $0xf01350e7
f0119fdd:	68 2d 03 00 00       	push   $0x32d
f0119fe2:	68 2f 51 13 f0       	push   $0xf013512f
f0119fe7:	e8 c3 6e fe ff       	call   f0100eaf <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f0119fec:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f0119fed:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0119ff4:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f0119ffb:	0f 86 72 ff ff ff    	jbe    f0119f73 <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011a001:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a008:	e9 af 00 00 00       	jmp    f011a0bc <check_boot_pgdir+0x1b6>
		switch (i) {
f011a00d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a010:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011a015:	74 11                	je     f011a028 <check_boot_pgdir+0x122>
f011a017:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011a01c:	72 36                	jb     f011a054 <check_boot_pgdir+0x14e>
f011a01e:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011a023:	83 f8 02             	cmp    $0x2,%eax
f011a026:	77 2c                	ja     f011a054 <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011a028:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011a02d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a030:	c1 e2 02             	shl    $0x2,%edx
f011a033:	01 d0                	add    %edx,%eax
f011a035:	8b 00                	mov    (%eax),%eax
f011a037:	85 c0                	test   %eax,%eax
f011a039:	75 7a                	jne    f011a0b5 <check_boot_pgdir+0x1af>
f011a03b:	68 d6 5a 13 f0       	push   $0xf0135ad6
f011a040:	68 e7 50 13 f0       	push   $0xf01350e7
f011a045:	68 38 03 00 00       	push   $0x338
f011a04a:	68 2f 51 13 f0       	push   $0xf013512f
f011a04f:	e8 5b 6e fe ff       	call   f0100eaf <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011a054:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011a05b:	76 2c                	jbe    f011a089 <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011a05d:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011a062:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a065:	c1 e2 02             	shl    $0x2,%edx
f011a068:	01 d0                	add    %edx,%eax
f011a06a:	8b 00                	mov    (%eax),%eax
f011a06c:	85 c0                	test   %eax,%eax
f011a06e:	75 48                	jne    f011a0b8 <check_boot_pgdir+0x1b2>
f011a070:	68 d6 5a 13 f0       	push   $0xf0135ad6
f011a075:	68 e7 50 13 f0       	push   $0xf01350e7
f011a07a:	68 3c 03 00 00       	push   $0x33c
f011a07f:	68 2f 51 13 f0       	push   $0xf013512f
f011a084:	e8 26 6e fe ff       	call   f0100eaf <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011a089:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011a08e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a091:	c1 e2 02             	shl    $0x2,%edx
f011a094:	01 d0                	add    %edx,%eax
f011a096:	8b 00                	mov    (%eax),%eax
f011a098:	85 c0                	test   %eax,%eax
f011a09a:	74 1c                	je     f011a0b8 <check_boot_pgdir+0x1b2>
f011a09c:	68 ec 5a 13 f0       	push   $0xf0135aec
f011a0a1:	68 e7 50 13 f0       	push   $0xf01350e7
f011a0a6:	68 3e 03 00 00       	push   $0x33e
f011a0ab:	68 2f 51 13 f0       	push   $0xf013512f
f011a0b0:	e8 fa 6d fe ff       	call   f0100eaf <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011a0b5:	90                   	nop
f011a0b6:	eb 01                	jmp    f011a0b9 <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011a0b8:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011a0b9:	ff 45 f4             	incl   -0xc(%ebp)
f011a0bc:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011a0c3:	0f 86 44 ff ff ff    	jbe    f011a00d <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011a0c9:	83 ec 0c             	sub    $0xc,%esp
f011a0cc:	68 08 5b 13 f0       	push   $0xf0135b08
f011a0d1:	e8 86 7a fe ff       	call   f0101b5c <cprintf>
f011a0d6:	83 c4 10             	add    $0x10,%esp
}
f011a0d9:	90                   	nop
f011a0da:	c9                   	leave  
f011a0db:	c3                   	ret    

f011a0dc <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011a0dc:	55                   	push   %ebp
f011a0dd:	89 e5                	mov    %esp,%ebp
f011a0df:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011a0e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a0e5:	c1 e8 16             	shr    $0x16,%eax
f011a0e8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a0ef:	8b 45 08             	mov    0x8(%ebp),%eax
f011a0f2:	01 d0                	add    %edx,%eax
f011a0f4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011a0f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a0fa:	8b 00                	mov    (%eax),%eax
f011a0fc:	83 e0 01             	and    $0x1,%eax
f011a0ff:	85 c0                	test   %eax,%eax
f011a101:	75 0a                	jne    f011a10d <check_va2pa+0x31>
		return ~0;
f011a103:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011a108:	e9 87 00 00 00       	jmp    f011a194 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011a10d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a110:	8b 00                	mov    (%eax),%eax
f011a112:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a117:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a11a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a11d:	c1 e8 0c             	shr    $0xc,%eax
f011a120:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011a123:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f011a128:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011a12b:	72 17                	jb     f011a144 <check_va2pa+0x68>
f011a12d:	ff 75 f0             	pushl  -0x10(%ebp)
f011a130:	68 2c 5b 13 f0       	push   $0xf0135b2c
f011a135:	68 54 03 00 00       	push   $0x354
f011a13a:	68 2f 51 13 f0       	push   $0xf013512f
f011a13f:	e8 6b 6d fe ff       	call   f0100eaf <_panic>
f011a144:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a147:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011a14c:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011a14f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a152:	c1 e8 0c             	shr    $0xc,%eax
f011a155:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a15a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a161:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a164:	01 d0                	add    %edx,%eax
f011a166:	8b 00                	mov    (%eax),%eax
f011a168:	83 e0 01             	and    $0x1,%eax
f011a16b:	85 c0                	test   %eax,%eax
f011a16d:	75 07                	jne    f011a176 <check_va2pa+0x9a>
		return ~0;
f011a16f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011a174:	eb 1e                	jmp    f011a194 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011a176:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a179:	c1 e8 0c             	shr    $0xc,%eax
f011a17c:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a181:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a188:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a18b:	01 d0                	add    %edx,%eax
f011a18d:	8b 00                	mov    (%eax),%eax
f011a18f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011a194:	c9                   	leave  
f011a195:	c3                   	ret    

f011a196 <clone_kern_dir>:
}
 */

//

uint32* clone_kern_dir() {
f011a196:	55                   	push   %ebp
f011a197:	89 e5                	mov    %esp,%ebp
f011a199:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_fi;
	allocate_frame(&ptr_fi);
f011a19c:	83 ec 0c             	sub    $0xc,%esp
f011a19f:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011a1a2:	50                   	push   %eax
f011a1a3:	e8 9d ee fe ff       	call   f0109045 <allocate_frame>
f011a1a8:	83 c4 10             	add    $0x10,%esp
	uint32 dir_pa = to_physical_address(ptr_fi);
f011a1ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011a1ae:	83 ec 0c             	sub    $0xc,%esp
f011a1b1:	50                   	push   %eax
f011a1b2:	e8 6b e7 ff ff       	call   f0118922 <to_physical_address>
f011a1b7:	83 c4 10             	add    $0x10,%esp
f011a1ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32* dir_ptr = STATIC_KERNEL_VIRTUAL_ADDRESS(dir_pa);
f011a1bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a1c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011a1c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a1c6:	c1 e8 0c             	shr    $0xc,%eax
f011a1c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011a1cc:	a1 18 e0 83 f0       	mov    0xf083e018,%eax
f011a1d1:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f011a1d4:	72 17                	jb     f011a1ed <clone_kern_dir+0x57>
f011a1d6:	ff 75 ec             	pushl  -0x14(%ebp)
f011a1d9:	68 2c 5b 13 f0       	push   $0xf0135b2c
f011a1de:	68 d4 03 00 00       	push   $0x3d4
f011a1e3:	68 2f 51 13 f0       	push   $0xf013512f
f011a1e8:	e8 c2 6c fe ff       	call   f0100eaf <_panic>
f011a1ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a1f0:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011a1f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i = 0; i < 1024; ++i) {
f011a1f8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a1ff:	eb 23                	jmp    f011a224 <clone_kern_dir+0x8e>
		dir_ptr[i] = ptr_page_directory[i];
f011a201:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a204:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a20b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011a20e:	01 c2                	add    %eax,%edx
f011a210:	a1 38 63 85 f0       	mov    0xf0856338,%eax
f011a215:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a218:	c1 e1 02             	shl    $0x2,%ecx
f011a21b:	01 c8                	add    %ecx,%eax
f011a21d:	8b 00                	mov    (%eax),%eax
f011a21f:	89 02                	mov    %eax,(%edx)
uint32* clone_kern_dir() {
	struct FrameInfo* ptr_fi;
	allocate_frame(&ptr_fi);
	uint32 dir_pa = to_physical_address(ptr_fi);
	uint32* dir_ptr = STATIC_KERNEL_VIRTUAL_ADDRESS(dir_pa);
	for (int i = 0; i < 1024; ++i) {
f011a221:	ff 45 f4             	incl   -0xc(%ebp)
f011a224:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011a22b:	7e d4                	jle    f011a201 <clone_kern_dir+0x6b>
f011a22d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a230:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f011a233:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011a236:	0f 22 d8             	mov    %eax,%cr3
		dir_ptr[i] = ptr_page_directory[i];
	}
	lcr3(dir_pa);
	return dir_ptr;
f011a239:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f011a23c:	c9                   	leave  
f011a23d:	c3                   	ret    

f011a23e <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011a23e:	55                   	push   %ebp
f011a23f:	89 e5                	mov    %esp,%ebp
f011a241:	53                   	push   %ebx
f011a242:	83 ec 14             	sub    $0x14,%esp
f011a245:	8b 45 10             	mov    0x10(%ebp),%eax
f011a248:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a24b:	8b 45 14             	mov    0x14(%ebp),%eax
f011a24e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011a251:	8b 45 18             	mov    0x18(%ebp),%eax
f011a254:	ba 00 00 00 00       	mov    $0x0,%edx
f011a259:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011a25c:	77 55                	ja     f011a2b3 <printnum+0x75>
f011a25e:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011a261:	72 05                	jb     f011a268 <printnum+0x2a>
f011a263:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011a266:	77 4b                	ja     f011a2b3 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011a268:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011a26b:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011a26e:	8b 45 18             	mov    0x18(%ebp),%eax
f011a271:	ba 00 00 00 00       	mov    $0x0,%edx
f011a276:	52                   	push   %edx
f011a277:	50                   	push   %eax
f011a278:	ff 75 f4             	pushl  -0xc(%ebp)
f011a27b:	ff 75 f0             	pushl  -0x10(%ebp)
f011a27e:	e8 a9 16 00 00       	call   f011b92c <__udivdi3>
f011a283:	83 c4 10             	add    $0x10,%esp
f011a286:	83 ec 04             	sub    $0x4,%esp
f011a289:	ff 75 20             	pushl  0x20(%ebp)
f011a28c:	53                   	push   %ebx
f011a28d:	ff 75 18             	pushl  0x18(%ebp)
f011a290:	52                   	push   %edx
f011a291:	50                   	push   %eax
f011a292:	ff 75 0c             	pushl  0xc(%ebp)
f011a295:	ff 75 08             	pushl  0x8(%ebp)
f011a298:	e8 a1 ff ff ff       	call   f011a23e <printnum>
f011a29d:	83 c4 20             	add    $0x20,%esp
f011a2a0:	eb 1a                	jmp    f011a2bc <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011a2a2:	83 ec 08             	sub    $0x8,%esp
f011a2a5:	ff 75 0c             	pushl  0xc(%ebp)
f011a2a8:	ff 75 20             	pushl  0x20(%ebp)
f011a2ab:	8b 45 08             	mov    0x8(%ebp),%eax
f011a2ae:	ff d0                	call   *%eax
f011a2b0:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011a2b3:	ff 4d 1c             	decl   0x1c(%ebp)
f011a2b6:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011a2ba:	7f e6                	jg     f011a2a2 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011a2bc:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011a2bf:	bb 00 00 00 00       	mov    $0x0,%ebx
f011a2c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a2c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a2ca:	53                   	push   %ebx
f011a2cb:	51                   	push   %ecx
f011a2cc:	52                   	push   %edx
f011a2cd:	50                   	push   %eax
f011a2ce:	e8 69 17 00 00       	call   f011ba3c <__umoddi3>
f011a2d3:	83 c4 10             	add    $0x10,%esp
f011a2d6:	05 74 5d 13 f0       	add    $0xf0135d74,%eax
f011a2db:	8a 00                	mov    (%eax),%al
f011a2dd:	0f be c0             	movsbl %al,%eax
f011a2e0:	83 ec 08             	sub    $0x8,%esp
f011a2e3:	ff 75 0c             	pushl  0xc(%ebp)
f011a2e6:	50                   	push   %eax
f011a2e7:	8b 45 08             	mov    0x8(%ebp),%eax
f011a2ea:	ff d0                	call   *%eax
f011a2ec:	83 c4 10             	add    $0x10,%esp
}
f011a2ef:	90                   	nop
f011a2f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011a2f3:	c9                   	leave  
f011a2f4:	c3                   	ret    

f011a2f5 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011a2f5:	55                   	push   %ebp
f011a2f6:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011a2f8:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011a2fc:	7e 1c                	jle    f011a31a <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011a2fe:	8b 45 08             	mov    0x8(%ebp),%eax
f011a301:	8b 00                	mov    (%eax),%eax
f011a303:	8d 50 08             	lea    0x8(%eax),%edx
f011a306:	8b 45 08             	mov    0x8(%ebp),%eax
f011a309:	89 10                	mov    %edx,(%eax)
f011a30b:	8b 45 08             	mov    0x8(%ebp),%eax
f011a30e:	8b 00                	mov    (%eax),%eax
f011a310:	83 e8 08             	sub    $0x8,%eax
f011a313:	8b 50 04             	mov    0x4(%eax),%edx
f011a316:	8b 00                	mov    (%eax),%eax
f011a318:	eb 40                	jmp    f011a35a <getuint+0x65>
	else if (lflag)
f011a31a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011a31e:	74 1e                	je     f011a33e <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011a320:	8b 45 08             	mov    0x8(%ebp),%eax
f011a323:	8b 00                	mov    (%eax),%eax
f011a325:	8d 50 04             	lea    0x4(%eax),%edx
f011a328:	8b 45 08             	mov    0x8(%ebp),%eax
f011a32b:	89 10                	mov    %edx,(%eax)
f011a32d:	8b 45 08             	mov    0x8(%ebp),%eax
f011a330:	8b 00                	mov    (%eax),%eax
f011a332:	83 e8 04             	sub    $0x4,%eax
f011a335:	8b 00                	mov    (%eax),%eax
f011a337:	ba 00 00 00 00       	mov    $0x0,%edx
f011a33c:	eb 1c                	jmp    f011a35a <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011a33e:	8b 45 08             	mov    0x8(%ebp),%eax
f011a341:	8b 00                	mov    (%eax),%eax
f011a343:	8d 50 04             	lea    0x4(%eax),%edx
f011a346:	8b 45 08             	mov    0x8(%ebp),%eax
f011a349:	89 10                	mov    %edx,(%eax)
f011a34b:	8b 45 08             	mov    0x8(%ebp),%eax
f011a34e:	8b 00                	mov    (%eax),%eax
f011a350:	83 e8 04             	sub    $0x4,%eax
f011a353:	8b 00                	mov    (%eax),%eax
f011a355:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011a35a:	5d                   	pop    %ebp
f011a35b:	c3                   	ret    

f011a35c <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011a35c:	55                   	push   %ebp
f011a35d:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011a35f:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011a363:	7e 1c                	jle    f011a381 <getint+0x25>
		return va_arg(*ap, long long);
f011a365:	8b 45 08             	mov    0x8(%ebp),%eax
f011a368:	8b 00                	mov    (%eax),%eax
f011a36a:	8d 50 08             	lea    0x8(%eax),%edx
f011a36d:	8b 45 08             	mov    0x8(%ebp),%eax
f011a370:	89 10                	mov    %edx,(%eax)
f011a372:	8b 45 08             	mov    0x8(%ebp),%eax
f011a375:	8b 00                	mov    (%eax),%eax
f011a377:	83 e8 08             	sub    $0x8,%eax
f011a37a:	8b 50 04             	mov    0x4(%eax),%edx
f011a37d:	8b 00                	mov    (%eax),%eax
f011a37f:	eb 38                	jmp    f011a3b9 <getint+0x5d>
	else if (lflag)
f011a381:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011a385:	74 1a                	je     f011a3a1 <getint+0x45>
		return va_arg(*ap, long);
f011a387:	8b 45 08             	mov    0x8(%ebp),%eax
f011a38a:	8b 00                	mov    (%eax),%eax
f011a38c:	8d 50 04             	lea    0x4(%eax),%edx
f011a38f:	8b 45 08             	mov    0x8(%ebp),%eax
f011a392:	89 10                	mov    %edx,(%eax)
f011a394:	8b 45 08             	mov    0x8(%ebp),%eax
f011a397:	8b 00                	mov    (%eax),%eax
f011a399:	83 e8 04             	sub    $0x4,%eax
f011a39c:	8b 00                	mov    (%eax),%eax
f011a39e:	99                   	cltd   
f011a39f:	eb 18                	jmp    f011a3b9 <getint+0x5d>
	else
		return va_arg(*ap, int);
f011a3a1:	8b 45 08             	mov    0x8(%ebp),%eax
f011a3a4:	8b 00                	mov    (%eax),%eax
f011a3a6:	8d 50 04             	lea    0x4(%eax),%edx
f011a3a9:	8b 45 08             	mov    0x8(%ebp),%eax
f011a3ac:	89 10                	mov    %edx,(%eax)
f011a3ae:	8b 45 08             	mov    0x8(%ebp),%eax
f011a3b1:	8b 00                	mov    (%eax),%eax
f011a3b3:	83 e8 04             	sub    $0x4,%eax
f011a3b6:	8b 00                	mov    (%eax),%eax
f011a3b8:	99                   	cltd   
}
f011a3b9:	5d                   	pop    %ebp
f011a3ba:	c3                   	ret    

f011a3bb <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011a3bb:	55                   	push   %ebp
f011a3bc:	89 e5                	mov    %esp,%ebp
f011a3be:	56                   	push   %esi
f011a3bf:	53                   	push   %ebx
f011a3c0:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011a3c3:	eb 17                	jmp    f011a3dc <vprintfmt+0x21>
			if (ch == '\0')
f011a3c5:	85 db                	test   %ebx,%ebx
f011a3c7:	0f 84 c1 03 00 00    	je     f011a78e <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011a3cd:	83 ec 08             	sub    $0x8,%esp
f011a3d0:	ff 75 0c             	pushl  0xc(%ebp)
f011a3d3:	53                   	push   %ebx
f011a3d4:	8b 45 08             	mov    0x8(%ebp),%eax
f011a3d7:	ff d0                	call   *%eax
f011a3d9:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011a3dc:	8b 45 10             	mov    0x10(%ebp),%eax
f011a3df:	8d 50 01             	lea    0x1(%eax),%edx
f011a3e2:	89 55 10             	mov    %edx,0x10(%ebp)
f011a3e5:	8a 00                	mov    (%eax),%al
f011a3e7:	0f b6 d8             	movzbl %al,%ebx
f011a3ea:	83 fb 25             	cmp    $0x25,%ebx
f011a3ed:	75 d6                	jne    f011a3c5 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011a3ef:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011a3f3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011a3fa:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011a401:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011a408:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011a40f:	8b 45 10             	mov    0x10(%ebp),%eax
f011a412:	8d 50 01             	lea    0x1(%eax),%edx
f011a415:	89 55 10             	mov    %edx,0x10(%ebp)
f011a418:	8a 00                	mov    (%eax),%al
f011a41a:	0f b6 d8             	movzbl %al,%ebx
f011a41d:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011a420:	83 f8 5b             	cmp    $0x5b,%eax
f011a423:	0f 87 3d 03 00 00    	ja     f011a766 <vprintfmt+0x3ab>
f011a429:	8b 04 85 98 5d 13 f0 	mov    -0xfeca268(,%eax,4),%eax
f011a430:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011a432:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011a436:	eb d7                	jmp    f011a40f <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011a438:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011a43c:	eb d1                	jmp    f011a40f <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011a43e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011a445:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011a448:	89 d0                	mov    %edx,%eax
f011a44a:	c1 e0 02             	shl    $0x2,%eax
f011a44d:	01 d0                	add    %edx,%eax
f011a44f:	01 c0                	add    %eax,%eax
f011a451:	01 d8                	add    %ebx,%eax
f011a453:	83 e8 30             	sub    $0x30,%eax
f011a456:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011a459:	8b 45 10             	mov    0x10(%ebp),%eax
f011a45c:	8a 00                	mov    (%eax),%al
f011a45e:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011a461:	83 fb 2f             	cmp    $0x2f,%ebx
f011a464:	7e 3e                	jle    f011a4a4 <vprintfmt+0xe9>
f011a466:	83 fb 39             	cmp    $0x39,%ebx
f011a469:	7f 39                	jg     f011a4a4 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011a46b:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011a46e:	eb d5                	jmp    f011a445 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011a470:	8b 45 14             	mov    0x14(%ebp),%eax
f011a473:	83 c0 04             	add    $0x4,%eax
f011a476:	89 45 14             	mov    %eax,0x14(%ebp)
f011a479:	8b 45 14             	mov    0x14(%ebp),%eax
f011a47c:	83 e8 04             	sub    $0x4,%eax
f011a47f:	8b 00                	mov    (%eax),%eax
f011a481:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011a484:	eb 1f                	jmp    f011a4a5 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011a486:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a48a:	79 83                	jns    f011a40f <vprintfmt+0x54>
				width = 0;
f011a48c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011a493:	e9 77 ff ff ff       	jmp    f011a40f <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011a498:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011a49f:	e9 6b ff ff ff       	jmp    f011a40f <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011a4a4:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011a4a5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a4a9:	0f 89 60 ff ff ff    	jns    f011a40f <vprintfmt+0x54>
				width = precision, precision = -1;
f011a4af:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011a4b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011a4b5:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011a4bc:	e9 4e ff ff ff       	jmp    f011a40f <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011a4c1:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011a4c4:	e9 46 ff ff ff       	jmp    f011a40f <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011a4c9:	8b 45 14             	mov    0x14(%ebp),%eax
f011a4cc:	83 c0 04             	add    $0x4,%eax
f011a4cf:	89 45 14             	mov    %eax,0x14(%ebp)
f011a4d2:	8b 45 14             	mov    0x14(%ebp),%eax
f011a4d5:	83 e8 04             	sub    $0x4,%eax
f011a4d8:	8b 00                	mov    (%eax),%eax
f011a4da:	83 ec 08             	sub    $0x8,%esp
f011a4dd:	ff 75 0c             	pushl  0xc(%ebp)
f011a4e0:	50                   	push   %eax
f011a4e1:	8b 45 08             	mov    0x8(%ebp),%eax
f011a4e4:	ff d0                	call   *%eax
f011a4e6:	83 c4 10             	add    $0x10,%esp
			break;
f011a4e9:	e9 9b 02 00 00       	jmp    f011a789 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011a4ee:	8b 45 14             	mov    0x14(%ebp),%eax
f011a4f1:	83 c0 04             	add    $0x4,%eax
f011a4f4:	89 45 14             	mov    %eax,0x14(%ebp)
f011a4f7:	8b 45 14             	mov    0x14(%ebp),%eax
f011a4fa:	83 e8 04             	sub    $0x4,%eax
f011a4fd:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011a4ff:	85 db                	test   %ebx,%ebx
f011a501:	79 02                	jns    f011a505 <vprintfmt+0x14a>
				err = -err;
f011a503:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011a505:	83 fb 64             	cmp    $0x64,%ebx
f011a508:	7f 0b                	jg     f011a515 <vprintfmt+0x15a>
f011a50a:	8b 34 9d e0 5b 13 f0 	mov    -0xfeca420(,%ebx,4),%esi
f011a511:	85 f6                	test   %esi,%esi
f011a513:	75 19                	jne    f011a52e <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011a515:	53                   	push   %ebx
f011a516:	68 85 5d 13 f0       	push   $0xf0135d85
f011a51b:	ff 75 0c             	pushl  0xc(%ebp)
f011a51e:	ff 75 08             	pushl  0x8(%ebp)
f011a521:	e8 70 02 00 00       	call   f011a796 <printfmt>
f011a526:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011a529:	e9 5b 02 00 00       	jmp    f011a789 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011a52e:	56                   	push   %esi
f011a52f:	68 8e 5d 13 f0       	push   $0xf0135d8e
f011a534:	ff 75 0c             	pushl  0xc(%ebp)
f011a537:	ff 75 08             	pushl  0x8(%ebp)
f011a53a:	e8 57 02 00 00       	call   f011a796 <printfmt>
f011a53f:	83 c4 10             	add    $0x10,%esp
			break;
f011a542:	e9 42 02 00 00       	jmp    f011a789 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011a547:	8b 45 14             	mov    0x14(%ebp),%eax
f011a54a:	83 c0 04             	add    $0x4,%eax
f011a54d:	89 45 14             	mov    %eax,0x14(%ebp)
f011a550:	8b 45 14             	mov    0x14(%ebp),%eax
f011a553:	83 e8 04             	sub    $0x4,%eax
f011a556:	8b 30                	mov    (%eax),%esi
f011a558:	85 f6                	test   %esi,%esi
f011a55a:	75 05                	jne    f011a561 <vprintfmt+0x1a6>
				p = "(null)";
f011a55c:	be 91 5d 13 f0       	mov    $0xf0135d91,%esi
			if (width > 0 && padc != '-')
f011a561:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a565:	7e 6d                	jle    f011a5d4 <vprintfmt+0x219>
f011a567:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011a56b:	74 67                	je     f011a5d4 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011a56d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011a570:	83 ec 08             	sub    $0x8,%esp
f011a573:	50                   	push   %eax
f011a574:	56                   	push   %esi
f011a575:	e8 26 05 00 00       	call   f011aaa0 <strnlen>
f011a57a:	83 c4 10             	add    $0x10,%esp
f011a57d:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011a580:	eb 16                	jmp    f011a598 <vprintfmt+0x1dd>
					putch(padc, putdat);
f011a582:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011a586:	83 ec 08             	sub    $0x8,%esp
f011a589:	ff 75 0c             	pushl  0xc(%ebp)
f011a58c:	50                   	push   %eax
f011a58d:	8b 45 08             	mov    0x8(%ebp),%eax
f011a590:	ff d0                	call   *%eax
f011a592:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011a595:	ff 4d e4             	decl   -0x1c(%ebp)
f011a598:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a59c:	7f e4                	jg     f011a582 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011a59e:	eb 34                	jmp    f011a5d4 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011a5a0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011a5a4:	74 1c                	je     f011a5c2 <vprintfmt+0x207>
f011a5a6:	83 fb 1f             	cmp    $0x1f,%ebx
f011a5a9:	7e 05                	jle    f011a5b0 <vprintfmt+0x1f5>
f011a5ab:	83 fb 7e             	cmp    $0x7e,%ebx
f011a5ae:	7e 12                	jle    f011a5c2 <vprintfmt+0x207>
					putch('?', putdat);
f011a5b0:	83 ec 08             	sub    $0x8,%esp
f011a5b3:	ff 75 0c             	pushl  0xc(%ebp)
f011a5b6:	6a 3f                	push   $0x3f
f011a5b8:	8b 45 08             	mov    0x8(%ebp),%eax
f011a5bb:	ff d0                	call   *%eax
f011a5bd:	83 c4 10             	add    $0x10,%esp
f011a5c0:	eb 0f                	jmp    f011a5d1 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011a5c2:	83 ec 08             	sub    $0x8,%esp
f011a5c5:	ff 75 0c             	pushl  0xc(%ebp)
f011a5c8:	53                   	push   %ebx
f011a5c9:	8b 45 08             	mov    0x8(%ebp),%eax
f011a5cc:	ff d0                	call   *%eax
f011a5ce:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011a5d1:	ff 4d e4             	decl   -0x1c(%ebp)
f011a5d4:	89 f0                	mov    %esi,%eax
f011a5d6:	8d 70 01             	lea    0x1(%eax),%esi
f011a5d9:	8a 00                	mov    (%eax),%al
f011a5db:	0f be d8             	movsbl %al,%ebx
f011a5de:	85 db                	test   %ebx,%ebx
f011a5e0:	74 24                	je     f011a606 <vprintfmt+0x24b>
f011a5e2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011a5e6:	78 b8                	js     f011a5a0 <vprintfmt+0x1e5>
f011a5e8:	ff 4d e0             	decl   -0x20(%ebp)
f011a5eb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011a5ef:	79 af                	jns    f011a5a0 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011a5f1:	eb 13                	jmp    f011a606 <vprintfmt+0x24b>
				putch(' ', putdat);
f011a5f3:	83 ec 08             	sub    $0x8,%esp
f011a5f6:	ff 75 0c             	pushl  0xc(%ebp)
f011a5f9:	6a 20                	push   $0x20
f011a5fb:	8b 45 08             	mov    0x8(%ebp),%eax
f011a5fe:	ff d0                	call   *%eax
f011a600:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011a603:	ff 4d e4             	decl   -0x1c(%ebp)
f011a606:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a60a:	7f e7                	jg     f011a5f3 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011a60c:	e9 78 01 00 00       	jmp    f011a789 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011a611:	83 ec 08             	sub    $0x8,%esp
f011a614:	ff 75 e8             	pushl  -0x18(%ebp)
f011a617:	8d 45 14             	lea    0x14(%ebp),%eax
f011a61a:	50                   	push   %eax
f011a61b:	e8 3c fd ff ff       	call   f011a35c <getint>
f011a620:	83 c4 10             	add    $0x10,%esp
f011a623:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a626:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011a629:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a62c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a62f:	85 d2                	test   %edx,%edx
f011a631:	79 23                	jns    f011a656 <vprintfmt+0x29b>
				putch('-', putdat);
f011a633:	83 ec 08             	sub    $0x8,%esp
f011a636:	ff 75 0c             	pushl  0xc(%ebp)
f011a639:	6a 2d                	push   $0x2d
f011a63b:	8b 45 08             	mov    0x8(%ebp),%eax
f011a63e:	ff d0                	call   *%eax
f011a640:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011a643:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a646:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a649:	f7 d8                	neg    %eax
f011a64b:	83 d2 00             	adc    $0x0,%edx
f011a64e:	f7 da                	neg    %edx
f011a650:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a653:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011a656:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011a65d:	e9 bc 00 00 00       	jmp    f011a71e <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011a662:	83 ec 08             	sub    $0x8,%esp
f011a665:	ff 75 e8             	pushl  -0x18(%ebp)
f011a668:	8d 45 14             	lea    0x14(%ebp),%eax
f011a66b:	50                   	push   %eax
f011a66c:	e8 84 fc ff ff       	call   f011a2f5 <getuint>
f011a671:	83 c4 10             	add    $0x10,%esp
f011a674:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a677:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011a67a:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011a681:	e9 98 00 00 00       	jmp    f011a71e <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011a686:	83 ec 08             	sub    $0x8,%esp
f011a689:	ff 75 0c             	pushl  0xc(%ebp)
f011a68c:	6a 58                	push   $0x58
f011a68e:	8b 45 08             	mov    0x8(%ebp),%eax
f011a691:	ff d0                	call   *%eax
f011a693:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011a696:	83 ec 08             	sub    $0x8,%esp
f011a699:	ff 75 0c             	pushl  0xc(%ebp)
f011a69c:	6a 58                	push   $0x58
f011a69e:	8b 45 08             	mov    0x8(%ebp),%eax
f011a6a1:	ff d0                	call   *%eax
f011a6a3:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011a6a6:	83 ec 08             	sub    $0x8,%esp
f011a6a9:	ff 75 0c             	pushl  0xc(%ebp)
f011a6ac:	6a 58                	push   $0x58
f011a6ae:	8b 45 08             	mov    0x8(%ebp),%eax
f011a6b1:	ff d0                	call   *%eax
f011a6b3:	83 c4 10             	add    $0x10,%esp
			break;
f011a6b6:	e9 ce 00 00 00       	jmp    f011a789 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011a6bb:	83 ec 08             	sub    $0x8,%esp
f011a6be:	ff 75 0c             	pushl  0xc(%ebp)
f011a6c1:	6a 30                	push   $0x30
f011a6c3:	8b 45 08             	mov    0x8(%ebp),%eax
f011a6c6:	ff d0                	call   *%eax
f011a6c8:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011a6cb:	83 ec 08             	sub    $0x8,%esp
f011a6ce:	ff 75 0c             	pushl  0xc(%ebp)
f011a6d1:	6a 78                	push   $0x78
f011a6d3:	8b 45 08             	mov    0x8(%ebp),%eax
f011a6d6:	ff d0                	call   *%eax
f011a6d8:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011a6db:	8b 45 14             	mov    0x14(%ebp),%eax
f011a6de:	83 c0 04             	add    $0x4,%eax
f011a6e1:	89 45 14             	mov    %eax,0x14(%ebp)
f011a6e4:	8b 45 14             	mov    0x14(%ebp),%eax
f011a6e7:	83 e8 04             	sub    $0x4,%eax
f011a6ea:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011a6ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a6ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011a6f6:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011a6fd:	eb 1f                	jmp    f011a71e <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011a6ff:	83 ec 08             	sub    $0x8,%esp
f011a702:	ff 75 e8             	pushl  -0x18(%ebp)
f011a705:	8d 45 14             	lea    0x14(%ebp),%eax
f011a708:	50                   	push   %eax
f011a709:	e8 e7 fb ff ff       	call   f011a2f5 <getuint>
f011a70e:	83 c4 10             	add    $0x10,%esp
f011a711:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a714:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011a717:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011a71e:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011a722:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a725:	83 ec 04             	sub    $0x4,%esp
f011a728:	52                   	push   %edx
f011a729:	ff 75 e4             	pushl  -0x1c(%ebp)
f011a72c:	50                   	push   %eax
f011a72d:	ff 75 f4             	pushl  -0xc(%ebp)
f011a730:	ff 75 f0             	pushl  -0x10(%ebp)
f011a733:	ff 75 0c             	pushl  0xc(%ebp)
f011a736:	ff 75 08             	pushl  0x8(%ebp)
f011a739:	e8 00 fb ff ff       	call   f011a23e <printnum>
f011a73e:	83 c4 20             	add    $0x20,%esp
			break;
f011a741:	eb 46                	jmp    f011a789 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011a743:	83 ec 08             	sub    $0x8,%esp
f011a746:	ff 75 0c             	pushl  0xc(%ebp)
f011a749:	53                   	push   %ebx
f011a74a:	8b 45 08             	mov    0x8(%ebp),%eax
f011a74d:	ff d0                	call   *%eax
f011a74f:	83 c4 10             	add    $0x10,%esp
			break;
f011a752:	eb 35                	jmp    f011a789 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011a754:	c6 05 60 dd 83 f0 00 	movb   $0x0,0xf083dd60
			break;
f011a75b:	eb 2c                	jmp    f011a789 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011a75d:	c6 05 60 dd 83 f0 01 	movb   $0x1,0xf083dd60
			break;
f011a764:	eb 23                	jmp    f011a789 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011a766:	83 ec 08             	sub    $0x8,%esp
f011a769:	ff 75 0c             	pushl  0xc(%ebp)
f011a76c:	6a 25                	push   $0x25
f011a76e:	8b 45 08             	mov    0x8(%ebp),%eax
f011a771:	ff d0                	call   *%eax
f011a773:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011a776:	ff 4d 10             	decl   0x10(%ebp)
f011a779:	eb 03                	jmp    f011a77e <vprintfmt+0x3c3>
f011a77b:	ff 4d 10             	decl   0x10(%ebp)
f011a77e:	8b 45 10             	mov    0x10(%ebp),%eax
f011a781:	48                   	dec    %eax
f011a782:	8a 00                	mov    (%eax),%al
f011a784:	3c 25                	cmp    $0x25,%al
f011a786:	75 f3                	jne    f011a77b <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011a788:	90                   	nop
		}
	}
f011a789:	e9 35 fc ff ff       	jmp    f011a3c3 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011a78e:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011a78f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011a792:	5b                   	pop    %ebx
f011a793:	5e                   	pop    %esi
f011a794:	5d                   	pop    %ebp
f011a795:	c3                   	ret    

f011a796 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011a796:	55                   	push   %ebp
f011a797:	89 e5                	mov    %esp,%ebp
f011a799:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011a79c:	8d 45 10             	lea    0x10(%ebp),%eax
f011a79f:	83 c0 04             	add    $0x4,%eax
f011a7a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011a7a5:	8b 45 10             	mov    0x10(%ebp),%eax
f011a7a8:	ff 75 f4             	pushl  -0xc(%ebp)
f011a7ab:	50                   	push   %eax
f011a7ac:	ff 75 0c             	pushl  0xc(%ebp)
f011a7af:	ff 75 08             	pushl  0x8(%ebp)
f011a7b2:	e8 04 fc ff ff       	call   f011a3bb <vprintfmt>
f011a7b7:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011a7ba:	90                   	nop
f011a7bb:	c9                   	leave  
f011a7bc:	c3                   	ret    

f011a7bd <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011a7bd:	55                   	push   %ebp
f011a7be:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011a7c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a7c3:	8b 40 08             	mov    0x8(%eax),%eax
f011a7c6:	8d 50 01             	lea    0x1(%eax),%edx
f011a7c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a7cc:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011a7cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a7d2:	8b 10                	mov    (%eax),%edx
f011a7d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a7d7:	8b 40 04             	mov    0x4(%eax),%eax
f011a7da:	39 c2                	cmp    %eax,%edx
f011a7dc:	73 12                	jae    f011a7f0 <sprintputch+0x33>
		*b->buf++ = ch;
f011a7de:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a7e1:	8b 00                	mov    (%eax),%eax
f011a7e3:	8d 48 01             	lea    0x1(%eax),%ecx
f011a7e6:	8b 55 0c             	mov    0xc(%ebp),%edx
f011a7e9:	89 0a                	mov    %ecx,(%edx)
f011a7eb:	8b 55 08             	mov    0x8(%ebp),%edx
f011a7ee:	88 10                	mov    %dl,(%eax)
}
f011a7f0:	90                   	nop
f011a7f1:	5d                   	pop    %ebp
f011a7f2:	c3                   	ret    

f011a7f3 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011a7f3:	55                   	push   %ebp
f011a7f4:	89 e5                	mov    %esp,%ebp
f011a7f6:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011a7f9:	8b 45 08             	mov    0x8(%ebp),%eax
f011a7fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011a7ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a802:	8d 50 ff             	lea    -0x1(%eax),%edx
f011a805:	8b 45 08             	mov    0x8(%ebp),%eax
f011a808:	01 d0                	add    %edx,%eax
f011a80a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a80d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011a814:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011a818:	74 06                	je     f011a820 <vsnprintf+0x2d>
f011a81a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011a81e:	7f 07                	jg     f011a827 <vsnprintf+0x34>
		return -E_INVAL;
f011a820:	b8 03 00 00 00       	mov    $0x3,%eax
f011a825:	eb 20                	jmp    f011a847 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011a827:	ff 75 14             	pushl  0x14(%ebp)
f011a82a:	ff 75 10             	pushl  0x10(%ebp)
f011a82d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011a830:	50                   	push   %eax
f011a831:	68 bd a7 11 f0       	push   $0xf011a7bd
f011a836:	e8 80 fb ff ff       	call   f011a3bb <vprintfmt>
f011a83b:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011a83e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a841:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011a844:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011a847:	c9                   	leave  
f011a848:	c3                   	ret    

f011a849 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011a849:	55                   	push   %ebp
f011a84a:	89 e5                	mov    %esp,%ebp
f011a84c:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011a84f:	8d 45 10             	lea    0x10(%ebp),%eax
f011a852:	83 c0 04             	add    $0x4,%eax
f011a855:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011a858:	8b 45 10             	mov    0x10(%ebp),%eax
f011a85b:	ff 75 f4             	pushl  -0xc(%ebp)
f011a85e:	50                   	push   %eax
f011a85f:	ff 75 0c             	pushl  0xc(%ebp)
f011a862:	ff 75 08             	pushl  0x8(%ebp)
f011a865:	e8 89 ff ff ff       	call   f011a7f3 <vsnprintf>
f011a86a:	83 c4 10             	add    $0x10,%esp
f011a86d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011a870:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011a873:	c9                   	leave  
f011a874:	c3                   	ret    

f011a875 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011a875:	55                   	push   %ebp
f011a876:	89 e5                	mov    %esp,%ebp
f011a878:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011a87b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011a87f:	74 13                	je     f011a894 <readline+0x1f>
		cprintf("%s", prompt);
f011a881:	83 ec 08             	sub    $0x8,%esp
f011a884:	ff 75 08             	pushl  0x8(%ebp)
f011a887:	68 08 5f 13 f0       	push   $0xf0135f08
f011a88c:	e8 cb 72 fe ff       	call   f0101b5c <cprintf>
f011a891:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011a894:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011a89b:	83 ec 0c             	sub    $0xc,%esp
f011a89e:	6a 00                	push   $0x0
f011a8a0:	e8 81 71 fe ff       	call   f0101a26 <iscons>
f011a8a5:	83 c4 10             	add    $0x10,%esp
f011a8a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011a8ab:	e8 5d 71 fe ff       	call   f0101a0d <getchar>
f011a8b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011a8b3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a8b7:	79 22                	jns    f011a8db <readline+0x66>
			if (c != -E_EOF)
f011a8b9:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011a8bd:	0f 84 ad 00 00 00    	je     f011a970 <readline+0xfb>
				cprintf("read error: %e\n", c);
f011a8c3:	83 ec 08             	sub    $0x8,%esp
f011a8c6:	ff 75 ec             	pushl  -0x14(%ebp)
f011a8c9:	68 0b 5f 13 f0       	push   $0xf0135f0b
f011a8ce:	e8 89 72 fe ff       	call   f0101b5c <cprintf>
f011a8d3:	83 c4 10             	add    $0x10,%esp
			break;
f011a8d6:	e9 95 00 00 00       	jmp    f011a970 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011a8db:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011a8df:	7e 34                	jle    f011a915 <readline+0xa0>
f011a8e1:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011a8e8:	7f 2b                	jg     f011a915 <readline+0xa0>
			if (echoing)
f011a8ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a8ee:	74 0e                	je     f011a8fe <readline+0x89>
				cputchar(c);
f011a8f0:	83 ec 0c             	sub    $0xc,%esp
f011a8f3:	ff 75 ec             	pushl  -0x14(%ebp)
f011a8f6:	e8 fb 70 fe ff       	call   f01019f6 <cputchar>
f011a8fb:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011a8fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a901:	8d 50 01             	lea    0x1(%eax),%edx
f011a904:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011a907:	89 c2                	mov    %eax,%edx
f011a909:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a90c:	01 d0                	add    %edx,%eax
f011a90e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011a911:	88 10                	mov    %dl,(%eax)
f011a913:	eb 56                	jmp    f011a96b <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011a915:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011a919:	75 1f                	jne    f011a93a <readline+0xc5>
f011a91b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011a91f:	7e 19                	jle    f011a93a <readline+0xc5>
			if (echoing)
f011a921:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a925:	74 0e                	je     f011a935 <readline+0xc0>
				cputchar(c);
f011a927:	83 ec 0c             	sub    $0xc,%esp
f011a92a:	ff 75 ec             	pushl  -0x14(%ebp)
f011a92d:	e8 c4 70 fe ff       	call   f01019f6 <cputchar>
f011a932:	83 c4 10             	add    $0x10,%esp

			i--;
f011a935:	ff 4d f4             	decl   -0xc(%ebp)
f011a938:	eb 31                	jmp    f011a96b <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011a93a:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011a93e:	74 0a                	je     f011a94a <readline+0xd5>
f011a940:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011a944:	0f 85 61 ff ff ff    	jne    f011a8ab <readline+0x36>
			if (echoing)
f011a94a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a94e:	74 0e                	je     f011a95e <readline+0xe9>
				cputchar(c);
f011a950:	83 ec 0c             	sub    $0xc,%esp
f011a953:	ff 75 ec             	pushl  -0x14(%ebp)
f011a956:	e8 9b 70 fe ff       	call   f01019f6 <cputchar>
f011a95b:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011a95e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a961:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a964:	01 d0                	add    %edx,%eax
f011a966:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011a969:	eb 06                	jmp    f011a971 <readline+0xfc>
		}
	}
f011a96b:	e9 3b ff ff ff       	jmp    f011a8ab <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011a970:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011a971:	90                   	nop
f011a972:	c9                   	leave  
f011a973:	c3                   	ret    

f011a974 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011a974:	55                   	push   %ebp
f011a975:	89 e5                	mov    %esp,%ebp
f011a977:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011a97a:	e8 de 3d ff ff       	call   f010e75d <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011a97f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011a983:	74 13                	je     f011a998 <atomic_readline+0x24>
			cprintf("%s", prompt);
f011a985:	83 ec 08             	sub    $0x8,%esp
f011a988:	ff 75 08             	pushl  0x8(%ebp)
f011a98b:	68 08 5f 13 f0       	push   $0xf0135f08
f011a990:	e8 c7 71 fe ff       	call   f0101b5c <cprintf>
f011a995:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011a998:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011a99f:	83 ec 0c             	sub    $0xc,%esp
f011a9a2:	6a 00                	push   $0x0
f011a9a4:	e8 7d 70 fe ff       	call   f0101a26 <iscons>
f011a9a9:	83 c4 10             	add    $0x10,%esp
f011a9ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011a9af:	e8 59 70 fe ff       	call   f0101a0d <getchar>
f011a9b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011a9b7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a9bb:	79 22                	jns    f011a9df <atomic_readline+0x6b>
				if (c != -E_EOF)
f011a9bd:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011a9c1:	0f 84 ad 00 00 00    	je     f011aa74 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011a9c7:	83 ec 08             	sub    $0x8,%esp
f011a9ca:	ff 75 ec             	pushl  -0x14(%ebp)
f011a9cd:	68 0b 5f 13 f0       	push   $0xf0135f0b
f011a9d2:	e8 85 71 fe ff       	call   f0101b5c <cprintf>
f011a9d7:	83 c4 10             	add    $0x10,%esp
				break;
f011a9da:	e9 95 00 00 00       	jmp    f011aa74 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011a9df:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011a9e3:	7e 34                	jle    f011aa19 <atomic_readline+0xa5>
f011a9e5:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011a9ec:	7f 2b                	jg     f011aa19 <atomic_readline+0xa5>
				if (echoing)
f011a9ee:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a9f2:	74 0e                	je     f011aa02 <atomic_readline+0x8e>
					cputchar(c);
f011a9f4:	83 ec 0c             	sub    $0xc,%esp
f011a9f7:	ff 75 ec             	pushl  -0x14(%ebp)
f011a9fa:	e8 f7 6f fe ff       	call   f01019f6 <cputchar>
f011a9ff:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011aa02:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011aa05:	8d 50 01             	lea    0x1(%eax),%edx
f011aa08:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011aa0b:	89 c2                	mov    %eax,%edx
f011aa0d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011aa10:	01 d0                	add    %edx,%eax
f011aa12:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011aa15:	88 10                	mov    %dl,(%eax)
f011aa17:	eb 56                	jmp    f011aa6f <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011aa19:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011aa1d:	75 1f                	jne    f011aa3e <atomic_readline+0xca>
f011aa1f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011aa23:	7e 19                	jle    f011aa3e <atomic_readline+0xca>
				if (echoing)
f011aa25:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011aa29:	74 0e                	je     f011aa39 <atomic_readline+0xc5>
					cputchar(c);
f011aa2b:	83 ec 0c             	sub    $0xc,%esp
f011aa2e:	ff 75 ec             	pushl  -0x14(%ebp)
f011aa31:	e8 c0 6f fe ff       	call   f01019f6 <cputchar>
f011aa36:	83 c4 10             	add    $0x10,%esp
				i--;
f011aa39:	ff 4d f4             	decl   -0xc(%ebp)
f011aa3c:	eb 31                	jmp    f011aa6f <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011aa3e:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011aa42:	74 0a                	je     f011aa4e <atomic_readline+0xda>
f011aa44:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011aa48:	0f 85 61 ff ff ff    	jne    f011a9af <atomic_readline+0x3b>
				if (echoing)
f011aa4e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011aa52:	74 0e                	je     f011aa62 <atomic_readline+0xee>
					cputchar(c);
f011aa54:	83 ec 0c             	sub    $0xc,%esp
f011aa57:	ff 75 ec             	pushl  -0x14(%ebp)
f011aa5a:	e8 97 6f fe ff       	call   f01019f6 <cputchar>
f011aa5f:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011aa62:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aa65:	8b 45 0c             	mov    0xc(%ebp),%eax
f011aa68:	01 d0                	add    %edx,%eax
f011aa6a:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011aa6d:	eb 06                	jmp    f011aa75 <atomic_readline+0x101>
			}
		}
f011aa6f:	e9 3b ff ff ff       	jmp    f011a9af <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011aa74:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011aa75:	e8 f1 3c ff ff       	call   f010e76b <sys_unlock_cons>
}
f011aa7a:	90                   	nop
f011aa7b:	c9                   	leave  
f011aa7c:	c3                   	ret    

f011aa7d <strlen>:

#include <inc/string.h>

int
strlen(const char *s)
{
f011aa7d:	55                   	push   %ebp
f011aa7e:	89 e5                	mov    %esp,%ebp
f011aa80:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011aa83:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011aa8a:	eb 06                	jmp    f011aa92 <strlen+0x15>
		n++;
f011aa8c:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011aa8f:	ff 45 08             	incl   0x8(%ebp)
f011aa92:	8b 45 08             	mov    0x8(%ebp),%eax
f011aa95:	8a 00                	mov    (%eax),%al
f011aa97:	84 c0                	test   %al,%al
f011aa99:	75 f1                	jne    f011aa8c <strlen+0xf>
		n++;
	return n;
f011aa9b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011aa9e:	c9                   	leave  
f011aa9f:	c3                   	ret    

f011aaa0 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011aaa0:	55                   	push   %ebp
f011aaa1:	89 e5                	mov    %esp,%ebp
f011aaa3:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011aaa6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011aaad:	eb 09                	jmp    f011aab8 <strnlen+0x18>
		n++;
f011aaaf:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011aab2:	ff 45 08             	incl   0x8(%ebp)
f011aab5:	ff 4d 0c             	decl   0xc(%ebp)
f011aab8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011aabc:	74 09                	je     f011aac7 <strnlen+0x27>
f011aabe:	8b 45 08             	mov    0x8(%ebp),%eax
f011aac1:	8a 00                	mov    (%eax),%al
f011aac3:	84 c0                	test   %al,%al
f011aac5:	75 e8                	jne    f011aaaf <strnlen+0xf>
		n++;
	return n;
f011aac7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011aaca:	c9                   	leave  
f011aacb:	c3                   	ret    

f011aacc <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011aacc:	55                   	push   %ebp
f011aacd:	89 e5                	mov    %esp,%ebp
f011aacf:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011aad2:	8b 45 08             	mov    0x8(%ebp),%eax
f011aad5:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011aad8:	90                   	nop
f011aad9:	8b 45 08             	mov    0x8(%ebp),%eax
f011aadc:	8d 50 01             	lea    0x1(%eax),%edx
f011aadf:	89 55 08             	mov    %edx,0x8(%ebp)
f011aae2:	8b 55 0c             	mov    0xc(%ebp),%edx
f011aae5:	8d 4a 01             	lea    0x1(%edx),%ecx
f011aae8:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011aaeb:	8a 12                	mov    (%edx),%dl
f011aaed:	88 10                	mov    %dl,(%eax)
f011aaef:	8a 00                	mov    (%eax),%al
f011aaf1:	84 c0                	test   %al,%al
f011aaf3:	75 e4                	jne    f011aad9 <strcpy+0xd>
		/* do nothing */;
	return ret;
f011aaf5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011aaf8:	c9                   	leave  
f011aaf9:	c3                   	ret    

f011aafa <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011aafa:	55                   	push   %ebp
f011aafb:	89 e5                	mov    %esp,%ebp
f011aafd:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011ab00:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab03:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011ab06:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011ab0d:	eb 1f                	jmp    f011ab2e <strncpy+0x34>
		*dst++ = *src;
f011ab0f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab12:	8d 50 01             	lea    0x1(%eax),%edx
f011ab15:	89 55 08             	mov    %edx,0x8(%ebp)
f011ab18:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ab1b:	8a 12                	mov    (%edx),%dl
f011ab1d:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011ab1f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ab22:	8a 00                	mov    (%eax),%al
f011ab24:	84 c0                	test   %al,%al
f011ab26:	74 03                	je     f011ab2b <strncpy+0x31>
			src++;
f011ab28:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011ab2b:	ff 45 fc             	incl   -0x4(%ebp)
f011ab2e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ab31:	3b 45 10             	cmp    0x10(%ebp),%eax
f011ab34:	72 d9                	jb     f011ab0f <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011ab36:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011ab39:	c9                   	leave  
f011ab3a:	c3                   	ret    

f011ab3b <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011ab3b:	55                   	push   %ebp
f011ab3c:	89 e5                	mov    %esp,%ebp
f011ab3e:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011ab41:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab44:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011ab47:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ab4b:	74 30                	je     f011ab7d <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011ab4d:	eb 16                	jmp    f011ab65 <strlcpy+0x2a>
			*dst++ = *src++;
f011ab4f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab52:	8d 50 01             	lea    0x1(%eax),%edx
f011ab55:	89 55 08             	mov    %edx,0x8(%ebp)
f011ab58:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ab5b:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ab5e:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011ab61:	8a 12                	mov    (%edx),%dl
f011ab63:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011ab65:	ff 4d 10             	decl   0x10(%ebp)
f011ab68:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ab6c:	74 09                	je     f011ab77 <strlcpy+0x3c>
f011ab6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ab71:	8a 00                	mov    (%eax),%al
f011ab73:	84 c0                	test   %al,%al
f011ab75:	75 d8                	jne    f011ab4f <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011ab77:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab7a:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011ab7d:	8b 55 08             	mov    0x8(%ebp),%edx
f011ab80:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ab83:	29 c2                	sub    %eax,%edx
f011ab85:	89 d0                	mov    %edx,%eax
}
f011ab87:	c9                   	leave  
f011ab88:	c3                   	ret    

f011ab89 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011ab89:	55                   	push   %ebp
f011ab8a:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011ab8c:	eb 06                	jmp    f011ab94 <strcmp+0xb>
		p++, q++;
f011ab8e:	ff 45 08             	incl   0x8(%ebp)
f011ab91:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011ab94:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab97:	8a 00                	mov    (%eax),%al
f011ab99:	84 c0                	test   %al,%al
f011ab9b:	74 0e                	je     f011abab <strcmp+0x22>
f011ab9d:	8b 45 08             	mov    0x8(%ebp),%eax
f011aba0:	8a 10                	mov    (%eax),%dl
f011aba2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011aba5:	8a 00                	mov    (%eax),%al
f011aba7:	38 c2                	cmp    %al,%dl
f011aba9:	74 e3                	je     f011ab8e <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011abab:	8b 45 08             	mov    0x8(%ebp),%eax
f011abae:	8a 00                	mov    (%eax),%al
f011abb0:	0f b6 d0             	movzbl %al,%edx
f011abb3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011abb6:	8a 00                	mov    (%eax),%al
f011abb8:	0f b6 c0             	movzbl %al,%eax
f011abbb:	29 c2                	sub    %eax,%edx
f011abbd:	89 d0                	mov    %edx,%eax
}
f011abbf:	5d                   	pop    %ebp
f011abc0:	c3                   	ret    

f011abc1 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011abc1:	55                   	push   %ebp
f011abc2:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011abc4:	eb 09                	jmp    f011abcf <strncmp+0xe>
		n--, p++, q++;
f011abc6:	ff 4d 10             	decl   0x10(%ebp)
f011abc9:	ff 45 08             	incl   0x8(%ebp)
f011abcc:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011abcf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011abd3:	74 17                	je     f011abec <strncmp+0x2b>
f011abd5:	8b 45 08             	mov    0x8(%ebp),%eax
f011abd8:	8a 00                	mov    (%eax),%al
f011abda:	84 c0                	test   %al,%al
f011abdc:	74 0e                	je     f011abec <strncmp+0x2b>
f011abde:	8b 45 08             	mov    0x8(%ebp),%eax
f011abe1:	8a 10                	mov    (%eax),%dl
f011abe3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011abe6:	8a 00                	mov    (%eax),%al
f011abe8:	38 c2                	cmp    %al,%dl
f011abea:	74 da                	je     f011abc6 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011abec:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011abf0:	75 07                	jne    f011abf9 <strncmp+0x38>
		return 0;
f011abf2:	b8 00 00 00 00       	mov    $0x0,%eax
f011abf7:	eb 14                	jmp    f011ac0d <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011abf9:	8b 45 08             	mov    0x8(%ebp),%eax
f011abfc:	8a 00                	mov    (%eax),%al
f011abfe:	0f b6 d0             	movzbl %al,%edx
f011ac01:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ac04:	8a 00                	mov    (%eax),%al
f011ac06:	0f b6 c0             	movzbl %al,%eax
f011ac09:	29 c2                	sub    %eax,%edx
f011ac0b:	89 d0                	mov    %edx,%eax
}
f011ac0d:	5d                   	pop    %ebp
f011ac0e:	c3                   	ret    

f011ac0f <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011ac0f:	55                   	push   %ebp
f011ac10:	89 e5                	mov    %esp,%ebp
f011ac12:	83 ec 04             	sub    $0x4,%esp
f011ac15:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ac18:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011ac1b:	eb 12                	jmp    f011ac2f <strchr+0x20>
		if (*s == c)
f011ac1d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac20:	8a 00                	mov    (%eax),%al
f011ac22:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011ac25:	75 05                	jne    f011ac2c <strchr+0x1d>
			return (char *) s;
f011ac27:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac2a:	eb 11                	jmp    f011ac3d <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011ac2c:	ff 45 08             	incl   0x8(%ebp)
f011ac2f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac32:	8a 00                	mov    (%eax),%al
f011ac34:	84 c0                	test   %al,%al
f011ac36:	75 e5                	jne    f011ac1d <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011ac38:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ac3d:	c9                   	leave  
f011ac3e:	c3                   	ret    

f011ac3f <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011ac3f:	55                   	push   %ebp
f011ac40:	89 e5                	mov    %esp,%ebp
f011ac42:	83 ec 04             	sub    $0x4,%esp
f011ac45:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ac48:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011ac4b:	eb 0d                	jmp    f011ac5a <strfind+0x1b>
		if (*s == c)
f011ac4d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac50:	8a 00                	mov    (%eax),%al
f011ac52:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011ac55:	74 0e                	je     f011ac65 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011ac57:	ff 45 08             	incl   0x8(%ebp)
f011ac5a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac5d:	8a 00                	mov    (%eax),%al
f011ac5f:	84 c0                	test   %al,%al
f011ac61:	75 ea                	jne    f011ac4d <strfind+0xe>
f011ac63:	eb 01                	jmp    f011ac66 <strfind+0x27>
		if (*s == c)
			break;
f011ac65:	90                   	nop
	return (char *) s;
f011ac66:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ac69:	c9                   	leave  
f011ac6a:	c3                   	ret    

f011ac6b <memset>:

// *************** The faster implementation of memset & memcpy is implemented by *************
// ****************** Team80 (Yahia Khaled, Malek Ahmed et al) - FCIS'24-25 *******************
void *
memset(void *v, int c, uint32 n)
{
f011ac6b:	55                   	push   %ebp
f011ac6c:	89 e5                	mov    %esp,%ebp
f011ac6e:	83 ec 10             	sub    $0x10,%esp
//	m = n;
//	while (--m >= 0)
//		*p++ = c;

	/*Faster Implementation*/
	uint64* p64 = (uint64*)v;
f011ac71:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac74:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(n >= 8){
f011ac77:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f011ac7b:	76 63                	jbe    f011ace0 <memset+0x75>
		uint64 data_block = c;
f011ac7d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ac80:	99                   	cltd   
f011ac81:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011ac84:	89 55 f4             	mov    %edx,-0xc(%ebp)
		data_block |= data_block << 8;
f011ac87:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ac8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ac8d:	0f a4 c2 08          	shld   $0x8,%eax,%edx
f011ac91:	c1 e0 08             	shl    $0x8,%eax
f011ac94:	09 45 f0             	or     %eax,-0x10(%ebp)
f011ac97:	09 55 f4             	or     %edx,-0xc(%ebp)
		data_block |= data_block << 16;
f011ac9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ac9d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aca0:	0f a4 c2 10          	shld   $0x10,%eax,%edx
f011aca4:	c1 e0 10             	shl    $0x10,%eax
f011aca7:	09 45 f0             	or     %eax,-0x10(%ebp)
f011acaa:	09 55 f4             	or     %edx,-0xc(%ebp)
		data_block |= data_block << 32;
f011acad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011acb0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011acb3:	89 c2                	mov    %eax,%edx
f011acb5:	b8 00 00 00 00       	mov    $0x0,%eax
f011acba:	09 45 f0             	or     %eax,-0x10(%ebp)
f011acbd:	09 55 f4             	or     %edx,-0xc(%ebp)

		while(n >= 8)
f011acc0:	eb 18                	jmp    f011acda <memset+0x6f>
			*p64++ = data_block, n -= 8;
f011acc2:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011acc5:	8d 41 08             	lea    0x8(%ecx),%eax
f011acc8:	89 45 fc             	mov    %eax,-0x4(%ebp)
f011accb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011acce:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011acd1:	89 01                	mov    %eax,(%ecx)
f011acd3:	89 51 04             	mov    %edx,0x4(%ecx)
f011acd6:	83 6d 10 08          	subl   $0x8,0x10(%ebp)
		uint64 data_block = c;
		data_block |= data_block << 8;
		data_block |= data_block << 16;
		data_block |= data_block << 32;

		while(n >= 8)
f011acda:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f011acde:	77 e2                	ja     f011acc2 <memset+0x57>
			*p64++ = data_block, n -= 8;
	}

	if(n){
f011ace0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ace4:	74 23                	je     f011ad09 <memset+0x9e>
		uint8* p8 = (uint8*)p64;
f011ace6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ace9:	89 45 f8             	mov    %eax,-0x8(%ebp)
		while (n-- > 0)
f011acec:	eb 0e                	jmp    f011acfc <memset+0x91>
			*p8++ = (uint8)c;
f011acee:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011acf1:	8d 50 01             	lea    0x1(%eax),%edx
f011acf4:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011acf7:	8b 55 0c             	mov    0xc(%ebp),%edx
f011acfa:	88 10                	mov    %dl,(%eax)
			*p64++ = data_block, n -= 8;
	}

	if(n){
		uint8* p8 = (uint8*)p64;
		while (n-- > 0)
f011acfc:	8b 45 10             	mov    0x10(%ebp),%eax
f011acff:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ad02:	89 55 10             	mov    %edx,0x10(%ebp)
f011ad05:	85 c0                	test   %eax,%eax
f011ad07:	75 e5                	jne    f011acee <memset+0x83>
			*p8++ = (uint8)c;
	}

	return v;
f011ad09:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ad0c:	c9                   	leave  
f011ad0d:	c3                   	ret    

f011ad0e <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011ad0e:	55                   	push   %ebp
f011ad0f:	89 e5                	mov    %esp,%ebp
f011ad11:	83 ec 10             	sub    $0x10,%esp
	//	s = src;
	//	d = dst;
	//	while (n-- > 0)
	//		*d++ = *s++;
	/*Faster Implementation*/
	uint64* s64 = (uint64*)src;
f011ad14:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ad17:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint64* d64 = (uint64*)dst;
f011ad1a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ad1d:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if(n >= 8){
f011ad20:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f011ad24:	76 24                	jbe    f011ad4a <memcpy+0x3c>
		while(n >= 8){
f011ad26:	eb 1c                	jmp    f011ad44 <memcpy+0x36>
			*d64 = *s64;
f011ad28:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ad2b:	8b 50 04             	mov    0x4(%eax),%edx
f011ad2e:	8b 00                	mov    (%eax),%eax
f011ad30:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f011ad33:	89 01                	mov    %eax,(%ecx)
f011ad35:	89 51 04             	mov    %edx,0x4(%ecx)
			n -= 8;
f011ad38:	83 6d 10 08          	subl   $0x8,0x10(%ebp)
			++s64;
f011ad3c:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
			++d64;
f011ad40:	83 45 f8 08          	addl   $0x8,-0x8(%ebp)
	//		*d++ = *s++;
	/*Faster Implementation*/
	uint64* s64 = (uint64*)src;
	uint64* d64 = (uint64*)dst;
	if(n >= 8){
		while(n >= 8){
f011ad44:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f011ad48:	77 de                	ja     f011ad28 <memcpy+0x1a>
			++s64;
			++d64;
		}
	}

	if(n){
f011ad4a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ad4e:	74 31                	je     f011ad81 <memcpy+0x73>
		uint8* s8 = (uint8*)s64;
f011ad50:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ad53:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint8* d8 = (uint8*)d64;
f011ad56:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ad59:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (n-- > 0)
f011ad5c:	eb 16                	jmp    f011ad74 <memcpy+0x66>
			*d8++ = *s8++;
f011ad5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ad61:	8d 50 01             	lea    0x1(%eax),%edx
f011ad64:	89 55 f0             	mov    %edx,-0x10(%ebp)
f011ad67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ad6a:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ad6d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f011ad70:	8a 12                	mov    (%edx),%dl
f011ad72:	88 10                	mov    %dl,(%eax)
	}

	if(n){
		uint8* s8 = (uint8*)s64;
		uint8* d8 = (uint8*)d64;
		while (n-- > 0)
f011ad74:	8b 45 10             	mov    0x10(%ebp),%eax
f011ad77:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ad7a:	89 55 10             	mov    %edx,0x10(%ebp)
f011ad7d:	85 c0                	test   %eax,%eax
f011ad7f:	75 dd                	jne    f011ad5e <memcpy+0x50>
			*d8++ = *s8++;
	}
	return dst;
f011ad81:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ad84:	c9                   	leave  
f011ad85:	c3                   	ret    

f011ad86 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011ad86:	55                   	push   %ebp
f011ad87:	89 e5                	mov    %esp,%ebp
f011ad89:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011ad8c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ad8f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011ad92:	8b 45 08             	mov    0x8(%ebp),%eax
f011ad95:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011ad98:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ad9b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011ad9e:	73 50                	jae    f011adf0 <memmove+0x6a>
f011ada0:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ada3:	8b 45 10             	mov    0x10(%ebp),%eax
f011ada6:	01 d0                	add    %edx,%eax
f011ada8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011adab:	76 43                	jbe    f011adf0 <memmove+0x6a>
		s += n;
f011adad:	8b 45 10             	mov    0x10(%ebp),%eax
f011adb0:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011adb3:	8b 45 10             	mov    0x10(%ebp),%eax
f011adb6:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011adb9:	eb 10                	jmp    f011adcb <memmove+0x45>
			*--d = *--s;
f011adbb:	ff 4d f8             	decl   -0x8(%ebp)
f011adbe:	ff 4d fc             	decl   -0x4(%ebp)
f011adc1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011adc4:	8a 10                	mov    (%eax),%dl
f011adc6:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011adc9:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011adcb:	8b 45 10             	mov    0x10(%ebp),%eax
f011adce:	8d 50 ff             	lea    -0x1(%eax),%edx
f011add1:	89 55 10             	mov    %edx,0x10(%ebp)
f011add4:	85 c0                	test   %eax,%eax
f011add6:	75 e3                	jne    f011adbb <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011add8:	eb 23                	jmp    f011adfd <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011adda:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011addd:	8d 50 01             	lea    0x1(%eax),%edx
f011ade0:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011ade3:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ade6:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ade9:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011adec:	8a 12                	mov    (%edx),%dl
f011adee:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011adf0:	8b 45 10             	mov    0x10(%ebp),%eax
f011adf3:	8d 50 ff             	lea    -0x1(%eax),%edx
f011adf6:	89 55 10             	mov    %edx,0x10(%ebp)
f011adf9:	85 c0                	test   %eax,%eax
f011adfb:	75 dd                	jne    f011adda <memmove+0x54>
			*d++ = *s++;

	return dst;
f011adfd:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ae00:	c9                   	leave  
f011ae01:	c3                   	ret    

f011ae02 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011ae02:	55                   	push   %ebp
f011ae03:	89 e5                	mov    %esp,%ebp
f011ae05:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011ae08:	8b 45 08             	mov    0x8(%ebp),%eax
f011ae0b:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011ae0e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ae11:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011ae14:	eb 2a                	jmp    f011ae40 <memcmp+0x3e>
		if (*s1 != *s2)
f011ae16:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ae19:	8a 10                	mov    (%eax),%dl
f011ae1b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ae1e:	8a 00                	mov    (%eax),%al
f011ae20:	38 c2                	cmp    %al,%dl
f011ae22:	74 16                	je     f011ae3a <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011ae24:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ae27:	8a 00                	mov    (%eax),%al
f011ae29:	0f b6 d0             	movzbl %al,%edx
f011ae2c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ae2f:	8a 00                	mov    (%eax),%al
f011ae31:	0f b6 c0             	movzbl %al,%eax
f011ae34:	29 c2                	sub    %eax,%edx
f011ae36:	89 d0                	mov    %edx,%eax
f011ae38:	eb 18                	jmp    f011ae52 <memcmp+0x50>
		s1++, s2++;
f011ae3a:	ff 45 fc             	incl   -0x4(%ebp)
f011ae3d:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011ae40:	8b 45 10             	mov    0x10(%ebp),%eax
f011ae43:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ae46:	89 55 10             	mov    %edx,0x10(%ebp)
f011ae49:	85 c0                	test   %eax,%eax
f011ae4b:	75 c9                	jne    f011ae16 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011ae4d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ae52:	c9                   	leave  
f011ae53:	c3                   	ret    

f011ae54 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011ae54:	55                   	push   %ebp
f011ae55:	89 e5                	mov    %esp,%ebp
f011ae57:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f011ae5a:	8b 55 08             	mov    0x8(%ebp),%edx
f011ae5d:	8b 45 10             	mov    0x10(%ebp),%eax
f011ae60:	01 d0                	add    %edx,%eax
f011ae62:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f011ae65:	eb 15                	jmp    f011ae7c <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f011ae67:	8b 45 08             	mov    0x8(%ebp),%eax
f011ae6a:	8a 00                	mov    (%eax),%al
f011ae6c:	0f b6 d0             	movzbl %al,%edx
f011ae6f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ae72:	0f b6 c0             	movzbl %al,%eax
f011ae75:	39 c2                	cmp    %eax,%edx
f011ae77:	74 0d                	je     f011ae86 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f011ae79:	ff 45 08             	incl   0x8(%ebp)
f011ae7c:	8b 45 08             	mov    0x8(%ebp),%eax
f011ae7f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011ae82:	72 e3                	jb     f011ae67 <memfind+0x13>
f011ae84:	eb 01                	jmp    f011ae87 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f011ae86:	90                   	nop
	return (void *) s;
f011ae87:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ae8a:	c9                   	leave  
f011ae8b:	c3                   	ret    

f011ae8c <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f011ae8c:	55                   	push   %ebp
f011ae8d:	89 e5                	mov    %esp,%ebp
f011ae8f:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f011ae92:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f011ae99:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011aea0:	eb 03                	jmp    f011aea5 <strtol+0x19>
		s++;
f011aea2:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011aea5:	8b 45 08             	mov    0x8(%ebp),%eax
f011aea8:	8a 00                	mov    (%eax),%al
f011aeaa:	3c 20                	cmp    $0x20,%al
f011aeac:	74 f4                	je     f011aea2 <strtol+0x16>
f011aeae:	8b 45 08             	mov    0x8(%ebp),%eax
f011aeb1:	8a 00                	mov    (%eax),%al
f011aeb3:	3c 09                	cmp    $0x9,%al
f011aeb5:	74 eb                	je     f011aea2 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f011aeb7:	8b 45 08             	mov    0x8(%ebp),%eax
f011aeba:	8a 00                	mov    (%eax),%al
f011aebc:	3c 2b                	cmp    $0x2b,%al
f011aebe:	75 05                	jne    f011aec5 <strtol+0x39>
		s++;
f011aec0:	ff 45 08             	incl   0x8(%ebp)
f011aec3:	eb 13                	jmp    f011aed8 <strtol+0x4c>
	else if (*s == '-')
f011aec5:	8b 45 08             	mov    0x8(%ebp),%eax
f011aec8:	8a 00                	mov    (%eax),%al
f011aeca:	3c 2d                	cmp    $0x2d,%al
f011aecc:	75 0a                	jne    f011aed8 <strtol+0x4c>
		s++, neg = 1;
f011aece:	ff 45 08             	incl   0x8(%ebp)
f011aed1:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f011aed8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011aedc:	74 06                	je     f011aee4 <strtol+0x58>
f011aede:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f011aee2:	75 20                	jne    f011af04 <strtol+0x78>
f011aee4:	8b 45 08             	mov    0x8(%ebp),%eax
f011aee7:	8a 00                	mov    (%eax),%al
f011aee9:	3c 30                	cmp    $0x30,%al
f011aeeb:	75 17                	jne    f011af04 <strtol+0x78>
f011aeed:	8b 45 08             	mov    0x8(%ebp),%eax
f011aef0:	40                   	inc    %eax
f011aef1:	8a 00                	mov    (%eax),%al
f011aef3:	3c 78                	cmp    $0x78,%al
f011aef5:	75 0d                	jne    f011af04 <strtol+0x78>
		s += 2, base = 16;
f011aef7:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f011aefb:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f011af02:	eb 28                	jmp    f011af2c <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f011af04:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011af08:	75 15                	jne    f011af1f <strtol+0x93>
f011af0a:	8b 45 08             	mov    0x8(%ebp),%eax
f011af0d:	8a 00                	mov    (%eax),%al
f011af0f:	3c 30                	cmp    $0x30,%al
f011af11:	75 0c                	jne    f011af1f <strtol+0x93>
		s++, base = 8;
f011af13:	ff 45 08             	incl   0x8(%ebp)
f011af16:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f011af1d:	eb 0d                	jmp    f011af2c <strtol+0xa0>
	else if (base == 0)
f011af1f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011af23:	75 07                	jne    f011af2c <strtol+0xa0>
		base = 10;
f011af25:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f011af2c:	8b 45 08             	mov    0x8(%ebp),%eax
f011af2f:	8a 00                	mov    (%eax),%al
f011af31:	3c 2f                	cmp    $0x2f,%al
f011af33:	7e 19                	jle    f011af4e <strtol+0xc2>
f011af35:	8b 45 08             	mov    0x8(%ebp),%eax
f011af38:	8a 00                	mov    (%eax),%al
f011af3a:	3c 39                	cmp    $0x39,%al
f011af3c:	7f 10                	jg     f011af4e <strtol+0xc2>
			dig = *s - '0';
f011af3e:	8b 45 08             	mov    0x8(%ebp),%eax
f011af41:	8a 00                	mov    (%eax),%al
f011af43:	0f be c0             	movsbl %al,%eax
f011af46:	83 e8 30             	sub    $0x30,%eax
f011af49:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011af4c:	eb 42                	jmp    f011af90 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f011af4e:	8b 45 08             	mov    0x8(%ebp),%eax
f011af51:	8a 00                	mov    (%eax),%al
f011af53:	3c 60                	cmp    $0x60,%al
f011af55:	7e 19                	jle    f011af70 <strtol+0xe4>
f011af57:	8b 45 08             	mov    0x8(%ebp),%eax
f011af5a:	8a 00                	mov    (%eax),%al
f011af5c:	3c 7a                	cmp    $0x7a,%al
f011af5e:	7f 10                	jg     f011af70 <strtol+0xe4>
			dig = *s - 'a' + 10;
f011af60:	8b 45 08             	mov    0x8(%ebp),%eax
f011af63:	8a 00                	mov    (%eax),%al
f011af65:	0f be c0             	movsbl %al,%eax
f011af68:	83 e8 57             	sub    $0x57,%eax
f011af6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011af6e:	eb 20                	jmp    f011af90 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f011af70:	8b 45 08             	mov    0x8(%ebp),%eax
f011af73:	8a 00                	mov    (%eax),%al
f011af75:	3c 40                	cmp    $0x40,%al
f011af77:	7e 39                	jle    f011afb2 <strtol+0x126>
f011af79:	8b 45 08             	mov    0x8(%ebp),%eax
f011af7c:	8a 00                	mov    (%eax),%al
f011af7e:	3c 5a                	cmp    $0x5a,%al
f011af80:	7f 30                	jg     f011afb2 <strtol+0x126>
			dig = *s - 'A' + 10;
f011af82:	8b 45 08             	mov    0x8(%ebp),%eax
f011af85:	8a 00                	mov    (%eax),%al
f011af87:	0f be c0             	movsbl %al,%eax
f011af8a:	83 e8 37             	sub    $0x37,%eax
f011af8d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f011af90:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011af93:	3b 45 10             	cmp    0x10(%ebp),%eax
f011af96:	7d 19                	jge    f011afb1 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f011af98:	ff 45 08             	incl   0x8(%ebp)
f011af9b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011af9e:	0f af 45 10          	imul   0x10(%ebp),%eax
f011afa2:	89 c2                	mov    %eax,%edx
f011afa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011afa7:	01 d0                	add    %edx,%eax
f011afa9:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f011afac:	e9 7b ff ff ff       	jmp    f011af2c <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f011afb1:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f011afb2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011afb6:	74 08                	je     f011afc0 <strtol+0x134>
		*endptr = (char *) s;
f011afb8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011afbb:	8b 55 08             	mov    0x8(%ebp),%edx
f011afbe:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f011afc0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011afc4:	74 07                	je     f011afcd <strtol+0x141>
f011afc6:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011afc9:	f7 d8                	neg    %eax
f011afcb:	eb 03                	jmp    f011afd0 <strtol+0x144>
f011afcd:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011afd0:	c9                   	leave  
f011afd1:	c3                   	ret    

f011afd2 <ltostr>:

void
ltostr(long value, char *str)
{
f011afd2:	55                   	push   %ebp
f011afd3:	89 e5                	mov    %esp,%ebp
f011afd5:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f011afd8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f011afdf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f011afe6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011afea:	79 13                	jns    f011afff <ltostr+0x2d>
	{
		neg = 1;
f011afec:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f011aff3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011aff6:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f011aff9:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f011affc:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f011afff:	8b 45 08             	mov    0x8(%ebp),%eax
f011b002:	b9 0a 00 00 00       	mov    $0xa,%ecx
f011b007:	99                   	cltd   
f011b008:	f7 f9                	idiv   %ecx
f011b00a:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f011b00d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011b010:	8d 50 01             	lea    0x1(%eax),%edx
f011b013:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011b016:	89 c2                	mov    %eax,%edx
f011b018:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b01b:	01 d0                	add    %edx,%eax
f011b01d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b020:	83 c2 30             	add    $0x30,%edx
f011b023:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f011b025:	8b 4d 08             	mov    0x8(%ebp),%ecx
f011b028:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011b02d:	f7 e9                	imul   %ecx
f011b02f:	c1 fa 02             	sar    $0x2,%edx
f011b032:	89 c8                	mov    %ecx,%eax
f011b034:	c1 f8 1f             	sar    $0x1f,%eax
f011b037:	29 c2                	sub    %eax,%edx
f011b039:	89 d0                	mov    %edx,%eax
f011b03b:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f011b03e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011b042:	75 bb                	jne    f011afff <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f011b044:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f011b04b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011b04e:	48                   	dec    %eax
f011b04f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f011b052:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011b056:	74 3d                	je     f011b095 <ltostr+0xc3>
		start = 1 ;
f011b058:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f011b05f:	eb 34                	jmp    f011b095 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f011b061:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b064:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b067:	01 d0                	add    %edx,%eax
f011b069:	8a 00                	mov    (%eax),%al
f011b06b:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f011b06e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b071:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b074:	01 c2                	add    %eax,%edx
f011b076:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f011b079:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b07c:	01 c8                	add    %ecx,%eax
f011b07e:	8a 00                	mov    (%eax),%al
f011b080:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f011b082:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011b085:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b088:	01 c2                	add    %eax,%edx
f011b08a:	8a 45 eb             	mov    -0x15(%ebp),%al
f011b08d:	88 02                	mov    %al,(%edx)
		start++ ;
f011b08f:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f011b092:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f011b095:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b098:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011b09b:	7c c4                	jl     f011b061 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f011b09d:	8b 55 f8             	mov    -0x8(%ebp),%edx
f011b0a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b0a3:	01 d0                	add    %edx,%eax
f011b0a5:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f011b0a8:	90                   	nop
f011b0a9:	c9                   	leave  
f011b0aa:	c3                   	ret    

f011b0ab <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f011b0ab:	55                   	push   %ebp
f011b0ac:	89 e5                	mov    %esp,%ebp
f011b0ae:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f011b0b1:	ff 75 08             	pushl  0x8(%ebp)
f011b0b4:	e8 c4 f9 ff ff       	call   f011aa7d <strlen>
f011b0b9:	83 c4 04             	add    $0x4,%esp
f011b0bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f011b0bf:	ff 75 0c             	pushl  0xc(%ebp)
f011b0c2:	e8 b6 f9 ff ff       	call   f011aa7d <strlen>
f011b0c7:	83 c4 04             	add    $0x4,%esp
f011b0ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f011b0cd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f011b0d4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011b0db:	eb 17                	jmp    f011b0f4 <strcconcat+0x49>
		final[s] = str1[s] ;
f011b0dd:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b0e0:	8b 45 10             	mov    0x10(%ebp),%eax
f011b0e3:	01 c2                	add    %eax,%edx
f011b0e5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011b0e8:	8b 45 08             	mov    0x8(%ebp),%eax
f011b0eb:	01 c8                	add    %ecx,%eax
f011b0ed:	8a 00                	mov    (%eax),%al
f011b0ef:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f011b0f1:	ff 45 fc             	incl   -0x4(%ebp)
f011b0f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011b0f7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b0fa:	7c e1                	jl     f011b0dd <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f011b0fc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f011b103:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f011b10a:	eb 1f                	jmp    f011b12b <strcconcat+0x80>
		final[s++] = str2[i] ;
f011b10c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011b10f:	8d 50 01             	lea    0x1(%eax),%edx
f011b112:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011b115:	89 c2                	mov    %eax,%edx
f011b117:	8b 45 10             	mov    0x10(%ebp),%eax
f011b11a:	01 c2                	add    %eax,%edx
f011b11c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f011b11f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b122:	01 c8                	add    %ecx,%eax
f011b124:	8a 00                	mov    (%eax),%al
f011b126:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f011b128:	ff 45 f8             	incl   -0x8(%ebp)
f011b12b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011b12e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011b131:	7c d9                	jl     f011b10c <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f011b133:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b136:	8b 45 10             	mov    0x10(%ebp),%eax
f011b139:	01 d0                	add    %edx,%eax
f011b13b:	c6 00 00             	movb   $0x0,(%eax)
}
f011b13e:	90                   	nop
f011b13f:	c9                   	leave  
f011b140:	c3                   	ret    

f011b141 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f011b141:	55                   	push   %ebp
f011b142:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f011b144:	8b 45 14             	mov    0x14(%ebp),%eax
f011b147:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f011b14d:	8b 45 14             	mov    0x14(%ebp),%eax
f011b150:	8b 00                	mov    (%eax),%eax
f011b152:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011b159:	8b 45 10             	mov    0x10(%ebp),%eax
f011b15c:	01 d0                	add    %edx,%eax
f011b15e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011b164:	eb 0c                	jmp    f011b172 <strsplit+0x31>
			*string++ = 0;
f011b166:	8b 45 08             	mov    0x8(%ebp),%eax
f011b169:	8d 50 01             	lea    0x1(%eax),%edx
f011b16c:	89 55 08             	mov    %edx,0x8(%ebp)
f011b16f:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011b172:	8b 45 08             	mov    0x8(%ebp),%eax
f011b175:	8a 00                	mov    (%eax),%al
f011b177:	84 c0                	test   %al,%al
f011b179:	74 18                	je     f011b193 <strsplit+0x52>
f011b17b:	8b 45 08             	mov    0x8(%ebp),%eax
f011b17e:	8a 00                	mov    (%eax),%al
f011b180:	0f be c0             	movsbl %al,%eax
f011b183:	50                   	push   %eax
f011b184:	ff 75 0c             	pushl  0xc(%ebp)
f011b187:	e8 83 fa ff ff       	call   f011ac0f <strchr>
f011b18c:	83 c4 08             	add    $0x8,%esp
f011b18f:	85 c0                	test   %eax,%eax
f011b191:	75 d3                	jne    f011b166 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f011b193:	8b 45 08             	mov    0x8(%ebp),%eax
f011b196:	8a 00                	mov    (%eax),%al
f011b198:	84 c0                	test   %al,%al
f011b19a:	74 5a                	je     f011b1f6 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f011b19c:	8b 45 14             	mov    0x14(%ebp),%eax
f011b19f:	8b 00                	mov    (%eax),%eax
f011b1a1:	83 f8 0f             	cmp    $0xf,%eax
f011b1a4:	75 07                	jne    f011b1ad <strsplit+0x6c>
		{
			return 0;
f011b1a6:	b8 00 00 00 00       	mov    $0x0,%eax
f011b1ab:	eb 66                	jmp    f011b213 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f011b1ad:	8b 45 14             	mov    0x14(%ebp),%eax
f011b1b0:	8b 00                	mov    (%eax),%eax
f011b1b2:	8d 48 01             	lea    0x1(%eax),%ecx
f011b1b5:	8b 55 14             	mov    0x14(%ebp),%edx
f011b1b8:	89 0a                	mov    %ecx,(%edx)
f011b1ba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011b1c1:	8b 45 10             	mov    0x10(%ebp),%eax
f011b1c4:	01 c2                	add    %eax,%edx
f011b1c6:	8b 45 08             	mov    0x8(%ebp),%eax
f011b1c9:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f011b1cb:	eb 03                	jmp    f011b1d0 <strsplit+0x8f>
			string++;
f011b1cd:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f011b1d0:	8b 45 08             	mov    0x8(%ebp),%eax
f011b1d3:	8a 00                	mov    (%eax),%al
f011b1d5:	84 c0                	test   %al,%al
f011b1d7:	74 8b                	je     f011b164 <strsplit+0x23>
f011b1d9:	8b 45 08             	mov    0x8(%ebp),%eax
f011b1dc:	8a 00                	mov    (%eax),%al
f011b1de:	0f be c0             	movsbl %al,%eax
f011b1e1:	50                   	push   %eax
f011b1e2:	ff 75 0c             	pushl  0xc(%ebp)
f011b1e5:	e8 25 fa ff ff       	call   f011ac0f <strchr>
f011b1ea:	83 c4 08             	add    $0x8,%esp
f011b1ed:	85 c0                	test   %eax,%eax
f011b1ef:	74 dc                	je     f011b1cd <strsplit+0x8c>
			string++;
	}
f011b1f1:	e9 6e ff ff ff       	jmp    f011b164 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f011b1f6:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f011b1f7:	8b 45 14             	mov    0x14(%ebp),%eax
f011b1fa:	8b 00                	mov    (%eax),%eax
f011b1fc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011b203:	8b 45 10             	mov    0x10(%ebp),%eax
f011b206:	01 d0                	add    %edx,%eax
f011b208:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f011b20e:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011b213:	c9                   	leave  
f011b214:	c3                   	ret    

f011b215 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f011b215:	55                   	push   %ebp
f011b216:	89 e5                	mov    %esp,%ebp
f011b218:	83 ec 10             	sub    $0x10,%esp
	char* ret = dst;
f011b21b:	8b 45 08             	mov    0x8(%ebp),%eax
f011b21e:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (int i = 0; i < strlen(src); ++i)
f011b221:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011b228:	eb 4a                	jmp    f011b274 <str2lower+0x5f>
	{
		dst[i] = src[i] ;
f011b22a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b22d:	8b 45 08             	mov    0x8(%ebp),%eax
f011b230:	01 c2                	add    %eax,%edx
f011b232:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011b235:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b238:	01 c8                	add    %ecx,%eax
f011b23a:	8a 00                	mov    (%eax),%al
f011b23c:	88 02                	mov    %al,(%edx)
		if (src[i] >= 'A' && src[i] <= 'Z')
f011b23e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b241:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b244:	01 d0                	add    %edx,%eax
f011b246:	8a 00                	mov    (%eax),%al
f011b248:	3c 40                	cmp    $0x40,%al
f011b24a:	7e 25                	jle    f011b271 <str2lower+0x5c>
f011b24c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b24f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b252:	01 d0                	add    %edx,%eax
f011b254:	8a 00                	mov    (%eax),%al
f011b256:	3c 5a                	cmp    $0x5a,%al
f011b258:	7f 17                	jg     f011b271 <str2lower+0x5c>
		{
			dst[i] += 32 ;
f011b25a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b25d:	8b 45 08             	mov    0x8(%ebp),%eax
f011b260:	01 d0                	add    %edx,%eax
f011b262:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011b265:	8b 55 08             	mov    0x8(%ebp),%edx
f011b268:	01 ca                	add    %ecx,%edx
f011b26a:	8a 12                	mov    (%edx),%dl
f011b26c:	83 c2 20             	add    $0x20,%edx
f011b26f:	88 10                	mov    %dl,(%eax)


char* str2lower(char *dst, const char *src)
{
	char* ret = dst;
	for (int i = 0; i < strlen(src); ++i)
f011b271:	ff 45 fc             	incl   -0x4(%ebp)
f011b274:	ff 75 0c             	pushl  0xc(%ebp)
f011b277:	e8 01 f8 ff ff       	call   f011aa7d <strlen>
f011b27c:	83 c4 04             	add    $0x4,%esp
f011b27f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011b282:	7f a6                	jg     f011b22a <str2lower+0x15>
		if (src[i] >= 'A' && src[i] <= 'Z')
		{
			dst[i] += 32 ;
		}
	}
	return ret;
f011b284:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011b287:	c9                   	leave  
f011b288:	c3                   	ret    

f011b289 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f011b289:	55                   	push   %ebp
f011b28a:	89 e5                	mov    %esp,%ebp
f011b28c:	83 ec 18             	sub    $0x18,%esp
	int r;
	cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
f011b28f:	83 ec 0c             	sub    $0xc,%esp
f011b292:	68 1c 5f 13 f0       	push   $0xf0135f1c
f011b297:	e8 c0 68 fe ff       	call   f0101b5c <cprintf>
f011b29c:	83 c4 10             	add    $0x10,%esp
f011b29f:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011b2a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011b2a9:	89 c2                	mov    %eax,%edx
f011b2ab:	ec                   	in     (%dx),%al
f011b2ac:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011b2af:	8a 45 ef             	mov    -0x11(%ebp),%al
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011b2b2:	0f b6 c0             	movzbl %al,%eax
f011b2b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
#elif DISK_IO_METHOD == INT_SEMAPHORE
		signal_ksemaphore(&DISKsem);
#endif
	}

}
f011b2b8:	90                   	nop
f011b2b9:	c9                   	leave  
f011b2ba:	c3                   	ret    

f011b2bb <ide_init>:

void ide_init()
{
f011b2bb:	55                   	push   %ebp
f011b2bc:	89 e5                	mov    %esp,%ebp
		irq_install_handler(14, &disk_interrupt_handler);
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
		init_ksemaphore(&DISKmutex, 1, "DISK mutex");
	}
#endif
}
f011b2be:	90                   	nop
f011b2bf:	5d                   	pop    %ebp
f011b2c0:	c3                   	ret    

f011b2c1 <ide_wait_ready>:


static int ide_wait_ready(bool check_error)
{
f011b2c1:	55                   	push   %ebp
f011b2c2:	89 e5                	mov    %esp,%ebp
f011b2c4:	83 ec 18             	sub    $0x18,%esp
	int r;

#if DISK_IO_METHOD == PROGRAMMED_IO
	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011b2c7:	90                   	nop
f011b2c8:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011b2cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011b2d2:	89 c2                	mov    %eax,%edx
f011b2d4:	ec                   	in     (%dx),%al
f011b2d5:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011b2d8:	8a 45 ef             	mov    -0x11(%ebp),%al
f011b2db:	0f b6 c0             	movzbl %al,%eax
f011b2de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b2e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b2e4:	25 c0 00 00 00       	and    $0xc0,%eax
f011b2e9:	83 f8 40             	cmp    $0x40,%eax
f011b2ec:	75 da                	jne    f011b2c8 <ide_wait_ready+0x7>
#elif DISK_IO_METHOD == INT_SEMAPHORE
		wait_ksemaphore(&DISKsem);
	}
#endif
#endif
	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f011b2ee:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011b2f2:	74 24                	je     f011b318 <ide_wait_ready+0x57>
f011b2f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b2f7:	83 e0 21             	and    $0x21,%eax
f011b2fa:	85 c0                	test   %eax,%eax
f011b2fc:	74 1a                	je     f011b318 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f011b2fe:	83 ec 0c             	sub    $0xc,%esp
f011b301:	ff 75 f4             	pushl  -0xc(%ebp)
f011b304:	ff 75 f4             	pushl  -0xc(%ebp)
f011b307:	68 40 5f 13 f0       	push   $0xf0135f40
f011b30c:	6a 54                	push   $0x54
f011b30e:	68 63 5f 13 f0       	push   $0xf0135f63
f011b313:	e8 97 5b fe ff       	call   f0100eaf <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f011b318:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011b31d:	c9                   	leave  
f011b31e:	c3                   	ret    

f011b31f <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f011b31f:	55                   	push   %ebp
f011b320:	89 e5                	mov    %esp,%ebp
f011b322:	57                   	push   %edi
f011b323:	53                   	push   %ebx
f011b324:	83 ec 40             	sub    $0x40,%esp
	int r;

	assert(nsecs <= 256);
f011b327:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011b32e:	76 16                	jbe    f011b346 <ide_read+0x27>
f011b330:	68 6e 5f 13 f0       	push   $0xf0135f6e
f011b335:	68 7b 5f 13 f0       	push   $0xf0135f7b
f011b33a:	6a 5f                	push   $0x5f
f011b33c:	68 63 5f 13 f0       	push   $0xf0135f63
f011b341:	e8 69 5b fe ff       	call   f0100eaf <_panic>

	struct Env* e = get_cpu_proc();
f011b346:	e8 d0 06 ff ff       	call   f010ba1b <get_cpu_proc>
f011b34b:	89 45 f4             	mov    %eax,-0xc(%ebp)
#elif DISK_IO_METHOD == INT_SEMAPHORE
	wait_ksemaphore(&DISKmutex);
#endif
	{
		if (e) LOG_STATMENT(cprintf("ide_read: %d inside CS\n", e->env_id););
		ide_wait_ready(0);
f011b34e:	83 ec 0c             	sub    $0xc,%esp
f011b351:	6a 00                	push   $0x0
f011b353:	e8 69 ff ff ff       	call   f011b2c1 <ide_wait_ready>
f011b358:	83 c4 10             	add    $0x10,%esp

		outb(0x1F2, nsecs);
f011b35b:	8b 45 10             	mov    0x10(%ebp),%eax
f011b35e:	0f b6 c0             	movzbl %al,%eax
f011b361:	c7 45 ec f2 01 00 00 	movl   $0x1f2,-0x14(%ebp)
f011b368:	88 45 ce             	mov    %al,-0x32(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011b36b:	8a 45 ce             	mov    -0x32(%ebp),%al
f011b36e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b371:	ee                   	out    %al,(%dx)
		outb(0x1F3, secno & 0xFF);
f011b372:	8b 45 08             	mov    0x8(%ebp),%eax
f011b375:	0f b6 c0             	movzbl %al,%eax
f011b378:	c7 45 e8 f3 01 00 00 	movl   $0x1f3,-0x18(%ebp)
f011b37f:	88 45 cf             	mov    %al,-0x31(%ebp)
f011b382:	8a 45 cf             	mov    -0x31(%ebp),%al
f011b385:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b388:	ee                   	out    %al,(%dx)
		outb(0x1F4, (secno >> 8) & 0xFF);
f011b389:	8b 45 08             	mov    0x8(%ebp),%eax
f011b38c:	c1 e8 08             	shr    $0x8,%eax
f011b38f:	0f b6 c0             	movzbl %al,%eax
f011b392:	c7 45 e4 f4 01 00 00 	movl   $0x1f4,-0x1c(%ebp)
f011b399:	88 45 d0             	mov    %al,-0x30(%ebp)
f011b39c:	8a 45 d0             	mov    -0x30(%ebp),%al
f011b39f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b3a2:	ee                   	out    %al,(%dx)
		outb(0x1F5, (secno >> 16) & 0xFF);
f011b3a3:	8b 45 08             	mov    0x8(%ebp),%eax
f011b3a6:	c1 e8 10             	shr    $0x10,%eax
f011b3a9:	0f b6 c0             	movzbl %al,%eax
f011b3ac:	c7 45 e0 f5 01 00 00 	movl   $0x1f5,-0x20(%ebp)
f011b3b3:	88 45 d1             	mov    %al,-0x2f(%ebp)
f011b3b6:	8a 45 d1             	mov    -0x2f(%ebp),%al
f011b3b9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011b3bc:	ee                   	out    %al,(%dx)
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011b3bd:	a1 84 db 83 f0       	mov    0xf083db84,%eax
f011b3c2:	83 e0 01             	and    $0x1,%eax
f011b3c5:	c1 e0 04             	shl    $0x4,%eax
f011b3c8:	88 c2                	mov    %al,%dl
f011b3ca:	8b 45 08             	mov    0x8(%ebp),%eax
f011b3cd:	c1 e8 18             	shr    $0x18,%eax
f011b3d0:	83 e0 0f             	and    $0xf,%eax
f011b3d3:	09 d0                	or     %edx,%eax
f011b3d5:	83 c8 e0             	or     $0xffffffe0,%eax
f011b3d8:	0f b6 c0             	movzbl %al,%eax
f011b3db:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%ebp)
f011b3e2:	88 45 d2             	mov    %al,-0x2e(%ebp)
f011b3e5:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011b3e8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011b3eb:	ee                   	out    %al,(%dx)
f011b3ec:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%ebp)
f011b3f3:	c6 45 d3 20          	movb   $0x20,-0x2d(%ebp)
f011b3f7:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011b3fa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b3fd:	ee                   	out    %al,(%dx)
		outb(0x1F7, 0x20);	// CMD 0x20 means read sector

		for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011b3fe:	eb 64                	jmp    f011b464 <ide_read+0x145>
			if ((r = ide_wait_ready(1)) < 0)
f011b400:	83 ec 0c             	sub    $0xc,%esp
f011b403:	6a 01                	push   $0x1
f011b405:	e8 b7 fe ff ff       	call   f011b2c1 <ide_wait_ready>
f011b40a:	83 c4 10             	add    $0x10,%esp
f011b40d:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b410:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011b414:	79 14                	jns    f011b42a <ide_read+0x10b>
			{
				panic("FAILURE to read %d sectors to disk\n",nsecs);
f011b416:	ff 75 10             	pushl  0x10(%ebp)
f011b419:	68 90 5f 13 f0       	push   $0xf0135f90
f011b41e:	6a 79                	push   $0x79
f011b420:	68 63 5f 13 f0       	push   $0xf0135f63
f011b425:	e8 85 5a fe ff       	call   f0100eaf <_panic>
f011b42a:	c7 45 f0 f0 01 00 00 	movl   $0x1f0,-0x10(%ebp)
f011b431:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b434:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011b437:	c7 45 c4 80 00 00 00 	movl   $0x80,-0x3c(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f011b43e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011b441:	8b 4d c8             	mov    -0x38(%ebp),%ecx
f011b444:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b447:	89 cb                	mov    %ecx,%ebx
f011b449:	89 df                	mov    %ebx,%edi
f011b44b:	89 c1                	mov    %eax,%ecx
f011b44d:	fc                   	cld    
f011b44e:	f2 6d                	repnz insl (%dx),%es:(%edi)
f011b450:	89 c8                	mov    %ecx,%eax
f011b452:	89 fb                	mov    %edi,%ebx
f011b454:	89 5d c8             	mov    %ebx,-0x38(%ebp)
f011b457:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		outb(0x1F4, (secno >> 8) & 0xFF);
		outb(0x1F5, (secno >> 16) & 0xFF);
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
		outb(0x1F7, 0x20);	// CMD 0x20 means read sector

		for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011b45a:	ff 4d 10             	decl   0x10(%ebp)
f011b45d:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011b464:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011b468:	75 96                	jne    f011b400 <ide_read+0xe1>
	signal_ksemaphore(&DISKmutex);
#endif

	if (e) LOG_STATMENT(cprintf("ide_read: %d Left CS\n", e->env_id););

	return 0;
f011b46a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011b46f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b472:	5b                   	pop    %ebx
f011b473:	5f                   	pop    %edi
f011b474:	5d                   	pop    %ebp
f011b475:	c3                   	ret    

f011b476 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f011b476:	55                   	push   %ebp
f011b477:	89 e5                	mov    %esp,%ebp
f011b479:	56                   	push   %esi
f011b47a:	53                   	push   %ebx
f011b47b:	83 ec 40             	sub    $0x40,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f011b47e:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011b485:	76 19                	jbe    f011b4a0 <ide_write+0x2a>
f011b487:	68 6e 5f 13 f0       	push   $0xf0135f6e
f011b48c:	68 7b 5f 13 f0       	push   $0xf0135f7b
f011b491:	68 8f 00 00 00       	push   $0x8f
f011b496:	68 63 5f 13 f0       	push   $0xf0135f63
f011b49b:	e8 0f 5a fe ff       	call   f0100eaf <_panic>

	struct Env* e = get_cpu_proc();
f011b4a0:	e8 76 05 ff ff       	call   f010ba1b <get_cpu_proc>
f011b4a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	wait_ksemaphore(&DISKmutex);
#endif
	{
		if (e) LOG_STATMENT(cprintf("ide_write: %d inside CS\n", e->env_id););

		ide_wait_ready(0);
f011b4a8:	83 ec 0c             	sub    $0xc,%esp
f011b4ab:	6a 00                	push   $0x0
f011b4ad:	e8 0f fe ff ff       	call   f011b2c1 <ide_wait_ready>
f011b4b2:	83 c4 10             	add    $0x10,%esp

		//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
		outb(0x1F2, nsecs);
f011b4b5:	8b 45 10             	mov    0x10(%ebp),%eax
f011b4b8:	0f b6 c0             	movzbl %al,%eax
f011b4bb:	c7 45 ec f2 01 00 00 	movl   $0x1f2,-0x14(%ebp)
f011b4c2:	88 45 ce             	mov    %al,-0x32(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011b4c5:	8a 45 ce             	mov    -0x32(%ebp),%al
f011b4c8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b4cb:	ee                   	out    %al,(%dx)
		outb(0x1F3, secno & 0xFF);
f011b4cc:	8b 45 08             	mov    0x8(%ebp),%eax
f011b4cf:	0f b6 c0             	movzbl %al,%eax
f011b4d2:	c7 45 e8 f3 01 00 00 	movl   $0x1f3,-0x18(%ebp)
f011b4d9:	88 45 cf             	mov    %al,-0x31(%ebp)
f011b4dc:	8a 45 cf             	mov    -0x31(%ebp),%al
f011b4df:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b4e2:	ee                   	out    %al,(%dx)
		outb(0x1F4, (secno >> 8) & 0xFF);
f011b4e3:	8b 45 08             	mov    0x8(%ebp),%eax
f011b4e6:	c1 e8 08             	shr    $0x8,%eax
f011b4e9:	0f b6 c0             	movzbl %al,%eax
f011b4ec:	c7 45 e4 f4 01 00 00 	movl   $0x1f4,-0x1c(%ebp)
f011b4f3:	88 45 d0             	mov    %al,-0x30(%ebp)
f011b4f6:	8a 45 d0             	mov    -0x30(%ebp),%al
f011b4f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b4fc:	ee                   	out    %al,(%dx)
		outb(0x1F5, (secno >> 16) & 0xFF);
f011b4fd:	8b 45 08             	mov    0x8(%ebp),%eax
f011b500:	c1 e8 10             	shr    $0x10,%eax
f011b503:	0f b6 c0             	movzbl %al,%eax
f011b506:	c7 45 e0 f5 01 00 00 	movl   $0x1f5,-0x20(%ebp)
f011b50d:	88 45 d1             	mov    %al,-0x2f(%ebp)
f011b510:	8a 45 d1             	mov    -0x2f(%ebp),%al
f011b513:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011b516:	ee                   	out    %al,(%dx)
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011b517:	a1 84 db 83 f0       	mov    0xf083db84,%eax
f011b51c:	83 e0 01             	and    $0x1,%eax
f011b51f:	c1 e0 04             	shl    $0x4,%eax
f011b522:	88 c2                	mov    %al,%dl
f011b524:	8b 45 08             	mov    0x8(%ebp),%eax
f011b527:	c1 e8 18             	shr    $0x18,%eax
f011b52a:	83 e0 0f             	and    $0xf,%eax
f011b52d:	09 d0                	or     %edx,%eax
f011b52f:	83 c8 e0             	or     $0xffffffe0,%eax
f011b532:	0f b6 c0             	movzbl %al,%eax
f011b535:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%ebp)
f011b53c:	88 45 d2             	mov    %al,-0x2e(%ebp)
f011b53f:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011b542:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011b545:	ee                   	out    %al,(%dx)
f011b546:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%ebp)
f011b54d:	c6 45 d3 30          	movb   $0x30,-0x2d(%ebp)
f011b551:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011b554:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b557:	ee                   	out    %al,(%dx)
		outb(0x1F7, 0x30);	// CMD 0x30 means write sector


		for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011b558:	eb 67                	jmp    f011b5c1 <ide_write+0x14b>
			if ((r = ide_wait_ready(1)) < 0)
f011b55a:	83 ec 0c             	sub    $0xc,%esp
f011b55d:	6a 01                	push   $0x1
f011b55f:	e8 5d fd ff ff       	call   f011b2c1 <ide_wait_ready>
f011b564:	83 c4 10             	add    $0x10,%esp
f011b567:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b56a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011b56e:	79 17                	jns    f011b587 <ide_write+0x111>
			{
				panic("FAILURE to write %d sectors to disk\n",nsecs);
f011b570:	ff 75 10             	pushl  0x10(%ebp)
f011b573:	68 b4 5f 13 f0       	push   $0xf0135fb4
f011b578:	68 ab 00 00 00       	push   $0xab
f011b57d:	68 63 5f 13 f0       	push   $0xf0135f63
f011b582:	e8 28 59 fe ff       	call   f0100eaf <_panic>
f011b587:	c7 45 f0 f0 01 00 00 	movl   $0x1f0,-0x10(%ebp)
f011b58e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b591:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011b594:	c7 45 c4 80 00 00 00 	movl   $0x80,-0x3c(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f011b59b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011b59e:	8b 4d c8             	mov    -0x38(%ebp),%ecx
f011b5a1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b5a4:	89 cb                	mov    %ecx,%ebx
f011b5a6:	89 de                	mov    %ebx,%esi
f011b5a8:	89 c1                	mov    %eax,%ecx
f011b5aa:	fc                   	cld    
f011b5ab:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f011b5ad:	89 c8                	mov    %ecx,%eax
f011b5af:	89 f3                	mov    %esi,%ebx
f011b5b1:	89 5d c8             	mov    %ebx,-0x38(%ebp)
f011b5b4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		outb(0x1F5, (secno >> 16) & 0xFF);
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
		outb(0x1F7, 0x30);	// CMD 0x30 means write sector


		for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011b5b7:	ff 4d 10             	decl   0x10(%ebp)
f011b5ba:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011b5c1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011b5c5:	75 93                	jne    f011b55a <ide_write+0xe4>
	if (e) LOG_STATMENT(cprintf("ide_write: %d Left CS\n", e->env_id););

	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f011b5c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011b5cc:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b5cf:	5b                   	pop    %ebx
f011b5d0:	5e                   	pop    %esi
f011b5d1:	5d                   	pop    %ebp
f011b5d2:	c3                   	ret    

f011b5d3 <to_page_va>:
//==================================
//==================================
// [1] GET PAGE VA:
//==================================
__inline__ uint32 to_page_va(struct PageInfoElement *ptrPageInfo)
{
f011b5d3:	55                   	push   %ebp
f011b5d4:	89 e5                	mov    %esp,%ebp
f011b5d6:	83 ec 18             	sub    $0x18,%esp
	if (ptrPageInfo < &pageBlockInfoArr[0] || ptrPageInfo >= &pageBlockInfoArr[DYN_ALLOC_MAX_SIZE/PAGE_SIZE])
f011b5d9:	81 7d 08 20 e0 83 f0 	cmpl   $0xf083e020,0x8(%ebp)
f011b5e0:	72 09                	jb     f011b5eb <to_page_va+0x18>
f011b5e2:	81 7d 08 20 60 85 f0 	cmpl   $0xf0856020,0x8(%ebp)
f011b5e9:	72 14                	jb     f011b5ff <to_page_va+0x2c>
			panic("to_page_va called with invalid pageInfoPtr");
f011b5eb:	83 ec 04             	sub    $0x4,%esp
f011b5ee:	68 dc 5f 13 f0       	push   $0xf0135fdc
f011b5f3:	6a 15                	push   $0x15
f011b5f5:	68 07 60 13 f0       	push   $0xf0136007
f011b5fa:	e8 b0 58 fe ff       	call   f0100eaf <_panic>
	//Get start VA of the page from the corresponding Page Info pointer
	int idxInPageInfoArr = (ptrPageInfo - pageBlockInfoArr);
f011b5ff:	8b 45 08             	mov    0x8(%ebp),%eax
f011b602:	ba 20 e0 83 f0       	mov    $0xf083e020,%edx
f011b607:	29 d0                	sub    %edx,%eax
f011b609:	c1 f8 02             	sar    $0x2,%eax
f011b60c:	89 c2                	mov    %eax,%edx
f011b60e:	89 d0                	mov    %edx,%eax
f011b610:	c1 e0 02             	shl    $0x2,%eax
f011b613:	01 d0                	add    %edx,%eax
f011b615:	c1 e0 02             	shl    $0x2,%eax
f011b618:	01 d0                	add    %edx,%eax
f011b61a:	c1 e0 02             	shl    $0x2,%eax
f011b61d:	01 d0                	add    %edx,%eax
f011b61f:	89 c1                	mov    %eax,%ecx
f011b621:	c1 e1 08             	shl    $0x8,%ecx
f011b624:	01 c8                	add    %ecx,%eax
f011b626:	89 c1                	mov    %eax,%ecx
f011b628:	c1 e1 10             	shl    $0x10,%ecx
f011b62b:	01 c8                	add    %ecx,%eax
f011b62d:	01 c0                	add    %eax,%eax
f011b62f:	01 d0                	add    %edx,%eax
f011b631:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return dynAllocStart + (idxInPageInfoArr << PGSHIFT);
f011b634:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b637:	c1 e0 0c             	shl    $0xc,%eax
f011b63a:	89 c2                	mov    %eax,%edx
f011b63c:	a1 7c 61 85 f0       	mov    0xf085617c,%eax
f011b641:	01 d0                	add    %edx,%eax
}
f011b643:	c9                   	leave  
f011b644:	c3                   	ret    

f011b645 <to_page_info>:

//==================================
// [2] GET PAGE INFO OF PAGE VA:
//==================================
__inline__ struct PageInfoElement * to_page_info(uint32 va)
{
f011b645:	55                   	push   %ebp
f011b646:	89 e5                	mov    %esp,%ebp
f011b648:	83 ec 18             	sub    $0x18,%esp
	int idxInPageInfoArr = (va - dynAllocStart) >> PGSHIFT;
f011b64b:	a1 7c 61 85 f0       	mov    0xf085617c,%eax
f011b650:	8b 55 08             	mov    0x8(%ebp),%edx
f011b653:	29 c2                	sub    %eax,%edx
f011b655:	89 d0                	mov    %edx,%eax
f011b657:	c1 e8 0c             	shr    $0xc,%eax
f011b65a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (idxInPageInfoArr < 0 || idxInPageInfoArr >= DYN_ALLOC_MAX_SIZE/PAGE_SIZE)
f011b65d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011b661:	78 09                	js     f011b66c <to_page_info+0x27>
f011b663:	81 7d f4 ff 1f 00 00 	cmpl   $0x1fff,-0xc(%ebp)
f011b66a:	7e 14                	jle    f011b680 <to_page_info+0x3b>
		panic("to_page_info called with invalid pa");
f011b66c:	83 ec 04             	sub    $0x4,%esp
f011b66f:	68 20 60 13 f0       	push   $0xf0136020
f011b674:	6a 22                	push   $0x22
f011b676:	68 07 60 13 f0       	push   $0xf0136007
f011b67b:	e8 2f 58 fe ff       	call   f0100eaf <_panic>
	return &pageBlockInfoArr[idxInPageInfoArr];
f011b680:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b683:	89 d0                	mov    %edx,%eax
f011b685:	01 c0                	add    %eax,%eax
f011b687:	01 d0                	add    %edx,%eax
f011b689:	c1 e0 02             	shl    $0x2,%eax
f011b68c:	05 20 e0 83 f0       	add    $0xf083e020,%eax
}
f011b691:	c9                   	leave  
f011b692:	c3                   	ret    

f011b693 <initialize_dynamic_allocator>:
//==================================
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================
bool is_initialized = 0;
void initialize_dynamic_allocator(uint32 daStart, uint32 daEnd)
{
f011b693:	55                   	push   %ebp
f011b694:	89 e5                	mov    %esp,%ebp
f011b696:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		assert(daEnd <= daStart + DYN_ALLOC_MAX_SIZE);
f011b699:	8b 45 08             	mov    0x8(%ebp),%eax
f011b69c:	05 00 00 00 02       	add    $0x2000000,%eax
f011b6a1:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011b6a4:	73 16                	jae    f011b6bc <initialize_dynamic_allocator+0x29>
f011b6a6:	68 44 60 13 f0       	push   $0xf0136044
f011b6ab:	68 6a 60 13 f0       	push   $0xf013606a
f011b6b0:	6a 34                	push   $0x34
f011b6b2:	68 07 60 13 f0       	push   $0xf0136007
f011b6b7:	e8 f3 57 fe ff       	call   f0100eaf <_panic>
		is_initialized = 1;
f011b6bc:	c7 05 88 db 83 f0 01 	movl   $0x1,0xf083db88
f011b6c3:	00 00 00 
	//==================================================================================
	//==================================================================================
	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #1 initialize_dynamic_allocator
	//Your code is here
	//Comment the following line
	panic("initialize_dynamic_allocator() Not implemented yet");
f011b6c6:	83 ec 04             	sub    $0x4,%esp
f011b6c9:	68 80 60 13 f0       	push   $0xf0136080
f011b6ce:	6a 3c                	push   $0x3c
f011b6d0:	68 07 60 13 f0       	push   $0xf0136007
f011b6d5:	e8 d5 57 fe ff       	call   f0100eaf <_panic>

f011b6da <get_block_size>:

//===========================
// [2] GET BLOCK SIZE:
//===========================
__inline__ uint32 get_block_size(void *va)
{
f011b6da:	55                   	push   %ebp
f011b6db:	89 e5                	mov    %esp,%ebp
f011b6dd:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #2 get_block_size
	//Your code is here
	//Comment the following line
	panic("get_block_size() Not implemented yet");
f011b6e0:	83 ec 04             	sub    $0x4,%esp
f011b6e3:	68 b4 60 13 f0       	push   $0xf01360b4
f011b6e8:	6a 48                	push   $0x48
f011b6ea:	68 07 60 13 f0       	push   $0xf0136007
f011b6ef:	e8 bb 57 fe ff       	call   f0100eaf <_panic>

f011b6f4 <alloc_block>:

//===========================
// 3) ALLOCATE BLOCK:
//===========================
void *alloc_block(uint32 size)
{
f011b6f4:	55                   	push   %ebp
f011b6f5:	89 e5                	mov    %esp,%ebp
f011b6f7:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		assert(size <= DYN_ALLOC_MAX_BLOCK_SIZE);
f011b6fa:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f011b701:	76 16                	jbe    f011b719 <alloc_block+0x25>
f011b703:	68 dc 60 13 f0       	push   $0xf01360dc
f011b708:	68 6a 60 13 f0       	push   $0xf013606a
f011b70d:	6a 54                	push   $0x54
f011b70f:	68 07 60 13 f0       	push   $0xf0136007
f011b714:	e8 96 57 fe ff       	call   f0100eaf <_panic>
	//==================================================================================
	//==================================================================================
	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #3 alloc_block
	//Your code is here
	//Comment the following line
	panic("alloc_block() Not implemented yet");
f011b719:	83 ec 04             	sub    $0x4,%esp
f011b71c:	68 00 61 13 f0       	push   $0xf0136100
f011b721:	6a 5b                	push   $0x5b
f011b723:	68 07 60 13 f0       	push   $0xf0136007
f011b728:	e8 82 57 fe ff       	call   f0100eaf <_panic>

f011b72d <free_block>:

//===========================
// [4] FREE BLOCK:
//===========================
void free_block(void *va)
{
f011b72d:	55                   	push   %ebp
f011b72e:	89 e5                	mov    %esp,%ebp
f011b730:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		assert((uint32)va >= dynAllocStart && (uint32)va < dynAllocEnd);
f011b733:	8b 55 08             	mov    0x8(%ebp),%edx
f011b736:	a1 7c 61 85 f0       	mov    0xf085617c,%eax
f011b73b:	39 c2                	cmp    %eax,%edx
f011b73d:	72 0c                	jb     f011b74b <free_block+0x1e>
f011b73f:	8b 55 08             	mov    0x8(%ebp),%edx
f011b742:	a1 a0 db 83 f0       	mov    0xf083dba0,%eax
f011b747:	39 c2                	cmp    %eax,%edx
f011b749:	72 16                	jb     f011b761 <free_block+0x34>
f011b74b:	68 24 61 13 f0       	push   $0xf0136124
f011b750:	68 6a 60 13 f0       	push   $0xf013606a
f011b755:	6a 69                	push   $0x69
f011b757:	68 07 60 13 f0       	push   $0xf0136007
f011b75c:	e8 4e 57 fe ff       	call   f0100eaf <_panic>
	//==================================================================================

	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #4 free_block
	//Your code is here
	//Comment the following line
	panic("free_block() Not implemented yet");
f011b761:	83 ec 04             	sub    $0x4,%esp
f011b764:	68 5c 61 13 f0       	push   $0xf013615c
f011b769:	6a 71                	push   $0x71
f011b76b:	68 07 60 13 f0       	push   $0xf0136007
f011b770:	e8 3a 57 fe ff       	call   f0100eaf <_panic>

f011b775 <realloc_block>:

//===========================
// [1] REALLOCATE BLOCK:
//===========================
void *realloc_block(void* va, uint32 new_size)
{
f011b775:	55                   	push   %ebp
f011b776:	89 e5                	mov    %esp,%ebp
f011b778:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#2] KERNEL REALLOC - realloc_block
	//Your code is here
	//Comment the following line
	panic("realloc_block() Not implemented yet");
f011b77b:	83 ec 04             	sub    $0x4,%esp
f011b77e:	68 80 61 13 f0       	push   $0xf0136180
f011b783:	68 80 00 00 00       	push   $0x80
f011b788:	68 07 60 13 f0       	push   $0xf0136007
f011b78d:	e8 1d 57 fe ff       	call   f0100eaf <_panic>
f011b792:	66 90                	xchg   %ax,%ax

f011b794 <__moddi3>:
f011b794:	55                   	push   %ebp
f011b795:	57                   	push   %edi
f011b796:	56                   	push   %esi
f011b797:	53                   	push   %ebx
f011b798:	83 ec 2c             	sub    $0x2c,%esp
f011b79b:	8b 74 24 40          	mov    0x40(%esp),%esi
f011b79f:	8b 7c 24 44          	mov    0x44(%esp),%edi
f011b7a3:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f011b7a7:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f011b7ab:	89 d8                	mov    %ebx,%eax
f011b7ad:	85 ff                	test   %edi,%edi
f011b7af:	0f 88 d3 00 00 00    	js     f011b888 <__moddi3+0xf4>
f011b7b5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f011b7bc:	00 
f011b7bd:	85 c0                	test   %eax,%eax
f011b7bf:	0f 88 ab 00 00 00    	js     f011b870 <__moddi3+0xdc>
f011b7c5:	89 0c 24             	mov    %ecx,(%esp)
f011b7c8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f011b7cc:	89 74 24 10          	mov    %esi,0x10(%esp)
f011b7d0:	89 fb                	mov    %edi,%ebx
f011b7d2:	8b 14 24             	mov    (%esp),%edx
f011b7d5:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f011b7d9:	89 d0                	mov    %edx,%eax
f011b7db:	89 54 24 18          	mov    %edx,0x18(%esp)
f011b7df:	89 ca                	mov    %ecx,%edx
f011b7e1:	8b 0c 24             	mov    (%esp),%ecx
f011b7e4:	89 34 24             	mov    %esi,(%esp)
f011b7e7:	89 7c 24 14          	mov    %edi,0x14(%esp)
f011b7eb:	85 d2                	test   %edx,%edx
f011b7ed:	75 15                	jne    f011b804 <__moddi3+0x70>
f011b7ef:	89 c7                	mov    %eax,%edi
f011b7f1:	39 d8                	cmp    %ebx,%eax
f011b7f3:	76 5b                	jbe    f011b850 <__moddi3+0xbc>
f011b7f5:	89 f0                	mov    %esi,%eax
f011b7f7:	89 da                	mov    %ebx,%edx
f011b7f9:	f7 f7                	div    %edi
f011b7fb:	89 d3                	mov    %edx,%ebx
f011b7fd:	89 d8                	mov    %ebx,%eax
f011b7ff:	31 d2                	xor    %edx,%edx
f011b801:	eb 09                	jmp    f011b80c <__moddi3+0x78>
f011b803:	90                   	nop
f011b804:	39 fa                	cmp    %edi,%edx
f011b806:	76 1c                	jbe    f011b824 <__moddi3+0x90>
f011b808:	89 f0                	mov    %esi,%eax
f011b80a:	89 fa                	mov    %edi,%edx
f011b80c:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f011b810:	85 c9                	test   %ecx,%ecx
f011b812:	74 07                	je     f011b81b <__moddi3+0x87>
f011b814:	f7 d8                	neg    %eax
f011b816:	83 d2 00             	adc    $0x0,%edx
f011b819:	f7 da                	neg    %edx
f011b81b:	83 c4 2c             	add    $0x2c,%esp
f011b81e:	5b                   	pop    %ebx
f011b81f:	5e                   	pop    %esi
f011b820:	5f                   	pop    %edi
f011b821:	5d                   	pop    %ebp
f011b822:	c3                   	ret    
f011b823:	90                   	nop
f011b824:	0f bd c2             	bsr    %edx,%eax
f011b827:	83 f0 1f             	xor    $0x1f,%eax
f011b82a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f011b82e:	75 6c                	jne    f011b89c <__moddi3+0x108>
f011b830:	39 fa                	cmp    %edi,%edx
f011b832:	72 05                	jb     f011b839 <__moddi3+0xa5>
f011b834:	3b 0c 24             	cmp    (%esp),%ecx
f011b837:	77 0e                	ja     f011b847 <__moddi3+0xb3>
f011b839:	8b 34 24             	mov    (%esp),%esi
f011b83c:	29 ce                	sub    %ecx,%esi
f011b83e:	19 d3                	sbb    %edx,%ebx
f011b840:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f011b844:	89 34 24             	mov    %esi,(%esp)
f011b847:	8b 04 24             	mov    (%esp),%eax
f011b84a:	8b 54 24 14          	mov    0x14(%esp),%edx
f011b84e:	eb bc                	jmp    f011b80c <__moddi3+0x78>
f011b850:	85 c9                	test   %ecx,%ecx
f011b852:	75 0b                	jne    f011b85f <__moddi3+0xcb>
f011b854:	b8 01 00 00 00       	mov    $0x1,%eax
f011b859:	31 d2                	xor    %edx,%edx
f011b85b:	f7 f1                	div    %ecx
f011b85d:	89 c1                	mov    %eax,%ecx
f011b85f:	89 d8                	mov    %ebx,%eax
f011b861:	31 d2                	xor    %edx,%edx
f011b863:	f7 f1                	div    %ecx
f011b865:	8b 04 24             	mov    (%esp),%eax
f011b868:	f7 f1                	div    %ecx
f011b86a:	89 d3                	mov    %edx,%ebx
f011b86c:	eb 8f                	jmp    f011b7fd <__moddi3+0x69>
f011b86e:	66 90                	xchg   %ax,%ax
f011b870:	89 c8                	mov    %ecx,%eax
f011b872:	89 da                	mov    %ebx,%edx
f011b874:	f7 d8                	neg    %eax
f011b876:	83 d2 00             	adc    $0x0,%edx
f011b879:	f7 da                	neg    %edx
f011b87b:	89 04 24             	mov    %eax,(%esp)
f011b87e:	89 54 24 04          	mov    %edx,0x4(%esp)
f011b882:	e9 45 ff ff ff       	jmp    f011b7cc <__moddi3+0x38>
f011b887:	90                   	nop
f011b888:	f7 de                	neg    %esi
f011b88a:	83 d7 00             	adc    $0x0,%edi
f011b88d:	f7 df                	neg    %edi
f011b88f:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f011b896:	ff 
f011b897:	e9 21 ff ff ff       	jmp    f011b7bd <__moddi3+0x29>
f011b89c:	b8 20 00 00 00       	mov    $0x20,%eax
f011b8a1:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f011b8a5:	29 f8                	sub    %edi,%eax
f011b8a7:	89 c6                	mov    %eax,%esi
f011b8a9:	89 44 24 14          	mov    %eax,0x14(%esp)
f011b8ad:	89 f9                	mov    %edi,%ecx
f011b8af:	d3 e2                	shl    %cl,%edx
f011b8b1:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f011b8b5:	89 e8                	mov    %ebp,%eax
f011b8b7:	89 f1                	mov    %esi,%ecx
f011b8b9:	d3 e8                	shr    %cl,%eax
f011b8bb:	09 d0                	or     %edx,%eax
f011b8bd:	89 04 24             	mov    %eax,(%esp)
f011b8c0:	89 ea                	mov    %ebp,%edx
f011b8c2:	89 f9                	mov    %edi,%ecx
f011b8c4:	d3 e2                	shl    %cl,%edx
f011b8c6:	89 d7                	mov    %edx,%edi
f011b8c8:	89 da                	mov    %ebx,%edx
f011b8ca:	d3 e2                	shl    %cl,%edx
f011b8cc:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f011b8d0:	d3 e5                	shl    %cl,%ebp
f011b8d2:	8b 44 24 10          	mov    0x10(%esp),%eax
f011b8d6:	89 f1                	mov    %esi,%ecx
f011b8d8:	d3 e8                	shr    %cl,%eax
f011b8da:	09 d0                	or     %edx,%eax
f011b8dc:	d3 eb                	shr    %cl,%ebx
f011b8de:	89 da                	mov    %ebx,%edx
f011b8e0:	f7 34 24             	divl   (%esp)
f011b8e3:	89 d3                	mov    %edx,%ebx
f011b8e5:	f7 e7                	mul    %edi
f011b8e7:	89 c6                	mov    %eax,%esi
f011b8e9:	89 d1                	mov    %edx,%ecx
f011b8eb:	39 d3                	cmp    %edx,%ebx
f011b8ed:	72 29                	jb     f011b918 <__moddi3+0x184>
f011b8ef:	74 33                	je     f011b924 <__moddi3+0x190>
f011b8f1:	89 e8                	mov    %ebp,%eax
f011b8f3:	29 f0                	sub    %esi,%eax
f011b8f5:	19 cb                	sbb    %ecx,%ebx
f011b8f7:	89 de                	mov    %ebx,%esi
f011b8f9:	8a 4c 24 14          	mov    0x14(%esp),%cl
f011b8fd:	d3 e6                	shl    %cl,%esi
f011b8ff:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f011b903:	89 f9                	mov    %edi,%ecx
f011b905:	d3 e8                	shr    %cl,%eax
f011b907:	09 c6                	or     %eax,%esi
f011b909:	89 f0                	mov    %esi,%eax
f011b90b:	89 f9                	mov    %edi,%ecx
f011b90d:	d3 eb                	shr    %cl,%ebx
f011b90f:	89 da                	mov    %ebx,%edx
f011b911:	e9 f6 fe ff ff       	jmp    f011b80c <__moddi3+0x78>
f011b916:	66 90                	xchg   %ax,%ax
f011b918:	29 f8                	sub    %edi,%eax
f011b91a:	1b 14 24             	sbb    (%esp),%edx
f011b91d:	89 d1                	mov    %edx,%ecx
f011b91f:	89 c6                	mov    %eax,%esi
f011b921:	eb ce                	jmp    f011b8f1 <__moddi3+0x15d>
f011b923:	90                   	nop
f011b924:	39 c5                	cmp    %eax,%ebp
f011b926:	72 f0                	jb     f011b918 <__moddi3+0x184>
f011b928:	89 d9                	mov    %ebx,%ecx
f011b92a:	eb c5                	jmp    f011b8f1 <__moddi3+0x15d>

f011b92c <__udivdi3>:
f011b92c:	55                   	push   %ebp
f011b92d:	57                   	push   %edi
f011b92e:	56                   	push   %esi
f011b92f:	53                   	push   %ebx
f011b930:	83 ec 1c             	sub    $0x1c,%esp
f011b933:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f011b937:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f011b93b:	8b 7c 24 38          	mov    0x38(%esp),%edi
f011b93f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f011b943:	89 ca                	mov    %ecx,%edx
f011b945:	89 f8                	mov    %edi,%eax
f011b947:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f011b94b:	85 f6                	test   %esi,%esi
f011b94d:	75 2d                	jne    f011b97c <__udivdi3+0x50>
f011b94f:	39 cf                	cmp    %ecx,%edi
f011b951:	77 65                	ja     f011b9b8 <__udivdi3+0x8c>
f011b953:	89 fd                	mov    %edi,%ebp
f011b955:	85 ff                	test   %edi,%edi
f011b957:	75 0b                	jne    f011b964 <__udivdi3+0x38>
f011b959:	b8 01 00 00 00       	mov    $0x1,%eax
f011b95e:	31 d2                	xor    %edx,%edx
f011b960:	f7 f7                	div    %edi
f011b962:	89 c5                	mov    %eax,%ebp
f011b964:	31 d2                	xor    %edx,%edx
f011b966:	89 c8                	mov    %ecx,%eax
f011b968:	f7 f5                	div    %ebp
f011b96a:	89 c1                	mov    %eax,%ecx
f011b96c:	89 d8                	mov    %ebx,%eax
f011b96e:	f7 f5                	div    %ebp
f011b970:	89 cf                	mov    %ecx,%edi
f011b972:	89 fa                	mov    %edi,%edx
f011b974:	83 c4 1c             	add    $0x1c,%esp
f011b977:	5b                   	pop    %ebx
f011b978:	5e                   	pop    %esi
f011b979:	5f                   	pop    %edi
f011b97a:	5d                   	pop    %ebp
f011b97b:	c3                   	ret    
f011b97c:	39 ce                	cmp    %ecx,%esi
f011b97e:	77 28                	ja     f011b9a8 <__udivdi3+0x7c>
f011b980:	0f bd fe             	bsr    %esi,%edi
f011b983:	83 f7 1f             	xor    $0x1f,%edi
f011b986:	75 40                	jne    f011b9c8 <__udivdi3+0x9c>
f011b988:	39 ce                	cmp    %ecx,%esi
f011b98a:	72 0a                	jb     f011b996 <__udivdi3+0x6a>
f011b98c:	3b 44 24 08          	cmp    0x8(%esp),%eax
f011b990:	0f 87 9e 00 00 00    	ja     f011ba34 <__udivdi3+0x108>
f011b996:	b8 01 00 00 00       	mov    $0x1,%eax
f011b99b:	89 fa                	mov    %edi,%edx
f011b99d:	83 c4 1c             	add    $0x1c,%esp
f011b9a0:	5b                   	pop    %ebx
f011b9a1:	5e                   	pop    %esi
f011b9a2:	5f                   	pop    %edi
f011b9a3:	5d                   	pop    %ebp
f011b9a4:	c3                   	ret    
f011b9a5:	8d 76 00             	lea    0x0(%esi),%esi
f011b9a8:	31 ff                	xor    %edi,%edi
f011b9aa:	31 c0                	xor    %eax,%eax
f011b9ac:	89 fa                	mov    %edi,%edx
f011b9ae:	83 c4 1c             	add    $0x1c,%esp
f011b9b1:	5b                   	pop    %ebx
f011b9b2:	5e                   	pop    %esi
f011b9b3:	5f                   	pop    %edi
f011b9b4:	5d                   	pop    %ebp
f011b9b5:	c3                   	ret    
f011b9b6:	66 90                	xchg   %ax,%ax
f011b9b8:	89 d8                	mov    %ebx,%eax
f011b9ba:	f7 f7                	div    %edi
f011b9bc:	31 ff                	xor    %edi,%edi
f011b9be:	89 fa                	mov    %edi,%edx
f011b9c0:	83 c4 1c             	add    $0x1c,%esp
f011b9c3:	5b                   	pop    %ebx
f011b9c4:	5e                   	pop    %esi
f011b9c5:	5f                   	pop    %edi
f011b9c6:	5d                   	pop    %ebp
f011b9c7:	c3                   	ret    
f011b9c8:	bd 20 00 00 00       	mov    $0x20,%ebp
f011b9cd:	89 eb                	mov    %ebp,%ebx
f011b9cf:	29 fb                	sub    %edi,%ebx
f011b9d1:	89 f9                	mov    %edi,%ecx
f011b9d3:	d3 e6                	shl    %cl,%esi
f011b9d5:	89 c5                	mov    %eax,%ebp
f011b9d7:	88 d9                	mov    %bl,%cl
f011b9d9:	d3 ed                	shr    %cl,%ebp
f011b9db:	89 e9                	mov    %ebp,%ecx
f011b9dd:	09 f1                	or     %esi,%ecx
f011b9df:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f011b9e3:	89 f9                	mov    %edi,%ecx
f011b9e5:	d3 e0                	shl    %cl,%eax
f011b9e7:	89 c5                	mov    %eax,%ebp
f011b9e9:	89 d6                	mov    %edx,%esi
f011b9eb:	88 d9                	mov    %bl,%cl
f011b9ed:	d3 ee                	shr    %cl,%esi
f011b9ef:	89 f9                	mov    %edi,%ecx
f011b9f1:	d3 e2                	shl    %cl,%edx
f011b9f3:	8b 44 24 08          	mov    0x8(%esp),%eax
f011b9f7:	88 d9                	mov    %bl,%cl
f011b9f9:	d3 e8                	shr    %cl,%eax
f011b9fb:	09 c2                	or     %eax,%edx
f011b9fd:	89 d0                	mov    %edx,%eax
f011b9ff:	89 f2                	mov    %esi,%edx
f011ba01:	f7 74 24 0c          	divl   0xc(%esp)
f011ba05:	89 d6                	mov    %edx,%esi
f011ba07:	89 c3                	mov    %eax,%ebx
f011ba09:	f7 e5                	mul    %ebp
f011ba0b:	39 d6                	cmp    %edx,%esi
f011ba0d:	72 19                	jb     f011ba28 <__udivdi3+0xfc>
f011ba0f:	74 0b                	je     f011ba1c <__udivdi3+0xf0>
f011ba11:	89 d8                	mov    %ebx,%eax
f011ba13:	31 ff                	xor    %edi,%edi
f011ba15:	e9 58 ff ff ff       	jmp    f011b972 <__udivdi3+0x46>
f011ba1a:	66 90                	xchg   %ax,%ax
f011ba1c:	8b 54 24 08          	mov    0x8(%esp),%edx
f011ba20:	89 f9                	mov    %edi,%ecx
f011ba22:	d3 e2                	shl    %cl,%edx
f011ba24:	39 c2                	cmp    %eax,%edx
f011ba26:	73 e9                	jae    f011ba11 <__udivdi3+0xe5>
f011ba28:	8d 43 ff             	lea    -0x1(%ebx),%eax
f011ba2b:	31 ff                	xor    %edi,%edi
f011ba2d:	e9 40 ff ff ff       	jmp    f011b972 <__udivdi3+0x46>
f011ba32:	66 90                	xchg   %ax,%ax
f011ba34:	31 c0                	xor    %eax,%eax
f011ba36:	e9 37 ff ff ff       	jmp    f011b972 <__udivdi3+0x46>
f011ba3b:	90                   	nop

f011ba3c <__umoddi3>:
f011ba3c:	55                   	push   %ebp
f011ba3d:	57                   	push   %edi
f011ba3e:	56                   	push   %esi
f011ba3f:	53                   	push   %ebx
f011ba40:	83 ec 1c             	sub    $0x1c,%esp
f011ba43:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f011ba47:	8b 74 24 34          	mov    0x34(%esp),%esi
f011ba4b:	8b 7c 24 38          	mov    0x38(%esp),%edi
f011ba4f:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f011ba53:	89 44 24 0c          	mov    %eax,0xc(%esp)
f011ba57:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f011ba5b:	89 f3                	mov    %esi,%ebx
f011ba5d:	89 fa                	mov    %edi,%edx
f011ba5f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f011ba63:	89 34 24             	mov    %esi,(%esp)
f011ba66:	85 c0                	test   %eax,%eax
f011ba68:	75 1a                	jne    f011ba84 <__umoddi3+0x48>
f011ba6a:	39 f7                	cmp    %esi,%edi
f011ba6c:	0f 86 a2 00 00 00    	jbe    f011bb14 <__umoddi3+0xd8>
f011ba72:	89 c8                	mov    %ecx,%eax
f011ba74:	89 f2                	mov    %esi,%edx
f011ba76:	f7 f7                	div    %edi
f011ba78:	89 d0                	mov    %edx,%eax
f011ba7a:	31 d2                	xor    %edx,%edx
f011ba7c:	83 c4 1c             	add    $0x1c,%esp
f011ba7f:	5b                   	pop    %ebx
f011ba80:	5e                   	pop    %esi
f011ba81:	5f                   	pop    %edi
f011ba82:	5d                   	pop    %ebp
f011ba83:	c3                   	ret    
f011ba84:	39 f0                	cmp    %esi,%eax
f011ba86:	0f 87 ac 00 00 00    	ja     f011bb38 <__umoddi3+0xfc>
f011ba8c:	0f bd e8             	bsr    %eax,%ebp
f011ba8f:	83 f5 1f             	xor    $0x1f,%ebp
f011ba92:	0f 84 ac 00 00 00    	je     f011bb44 <__umoddi3+0x108>
f011ba98:	bf 20 00 00 00       	mov    $0x20,%edi
f011ba9d:	29 ef                	sub    %ebp,%edi
f011ba9f:	89 fe                	mov    %edi,%esi
f011baa1:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f011baa5:	89 e9                	mov    %ebp,%ecx
f011baa7:	d3 e0                	shl    %cl,%eax
f011baa9:	89 d7                	mov    %edx,%edi
f011baab:	89 f1                	mov    %esi,%ecx
f011baad:	d3 ef                	shr    %cl,%edi
f011baaf:	09 c7                	or     %eax,%edi
f011bab1:	89 e9                	mov    %ebp,%ecx
f011bab3:	d3 e2                	shl    %cl,%edx
f011bab5:	89 14 24             	mov    %edx,(%esp)
f011bab8:	89 d8                	mov    %ebx,%eax
f011baba:	d3 e0                	shl    %cl,%eax
f011babc:	89 c2                	mov    %eax,%edx
f011babe:	8b 44 24 08          	mov    0x8(%esp),%eax
f011bac2:	d3 e0                	shl    %cl,%eax
f011bac4:	89 44 24 04          	mov    %eax,0x4(%esp)
f011bac8:	8b 44 24 08          	mov    0x8(%esp),%eax
f011bacc:	89 f1                	mov    %esi,%ecx
f011bace:	d3 e8                	shr    %cl,%eax
f011bad0:	09 d0                	or     %edx,%eax
f011bad2:	d3 eb                	shr    %cl,%ebx
f011bad4:	89 da                	mov    %ebx,%edx
f011bad6:	f7 f7                	div    %edi
f011bad8:	89 d3                	mov    %edx,%ebx
f011bada:	f7 24 24             	mull   (%esp)
f011badd:	89 c6                	mov    %eax,%esi
f011badf:	89 d1                	mov    %edx,%ecx
f011bae1:	39 d3                	cmp    %edx,%ebx
f011bae3:	0f 82 87 00 00 00    	jb     f011bb70 <__umoddi3+0x134>
f011bae9:	0f 84 91 00 00 00    	je     f011bb80 <__umoddi3+0x144>
f011baef:	8b 54 24 04          	mov    0x4(%esp),%edx
f011baf3:	29 f2                	sub    %esi,%edx
f011baf5:	19 cb                	sbb    %ecx,%ebx
f011baf7:	89 d8                	mov    %ebx,%eax
f011baf9:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f011bafd:	d3 e0                	shl    %cl,%eax
f011baff:	89 e9                	mov    %ebp,%ecx
f011bb01:	d3 ea                	shr    %cl,%edx
f011bb03:	09 d0                	or     %edx,%eax
f011bb05:	89 e9                	mov    %ebp,%ecx
f011bb07:	d3 eb                	shr    %cl,%ebx
f011bb09:	89 da                	mov    %ebx,%edx
f011bb0b:	83 c4 1c             	add    $0x1c,%esp
f011bb0e:	5b                   	pop    %ebx
f011bb0f:	5e                   	pop    %esi
f011bb10:	5f                   	pop    %edi
f011bb11:	5d                   	pop    %ebp
f011bb12:	c3                   	ret    
f011bb13:	90                   	nop
f011bb14:	89 fd                	mov    %edi,%ebp
f011bb16:	85 ff                	test   %edi,%edi
f011bb18:	75 0b                	jne    f011bb25 <__umoddi3+0xe9>
f011bb1a:	b8 01 00 00 00       	mov    $0x1,%eax
f011bb1f:	31 d2                	xor    %edx,%edx
f011bb21:	f7 f7                	div    %edi
f011bb23:	89 c5                	mov    %eax,%ebp
f011bb25:	89 f0                	mov    %esi,%eax
f011bb27:	31 d2                	xor    %edx,%edx
f011bb29:	f7 f5                	div    %ebp
f011bb2b:	89 c8                	mov    %ecx,%eax
f011bb2d:	f7 f5                	div    %ebp
f011bb2f:	89 d0                	mov    %edx,%eax
f011bb31:	e9 44 ff ff ff       	jmp    f011ba7a <__umoddi3+0x3e>
f011bb36:	66 90                	xchg   %ax,%ax
f011bb38:	89 c8                	mov    %ecx,%eax
f011bb3a:	89 f2                	mov    %esi,%edx
f011bb3c:	83 c4 1c             	add    $0x1c,%esp
f011bb3f:	5b                   	pop    %ebx
f011bb40:	5e                   	pop    %esi
f011bb41:	5f                   	pop    %edi
f011bb42:	5d                   	pop    %ebp
f011bb43:	c3                   	ret    
f011bb44:	3b 04 24             	cmp    (%esp),%eax
f011bb47:	72 06                	jb     f011bb4f <__umoddi3+0x113>
f011bb49:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f011bb4d:	77 0f                	ja     f011bb5e <__umoddi3+0x122>
f011bb4f:	89 f2                	mov    %esi,%edx
f011bb51:	29 f9                	sub    %edi,%ecx
f011bb53:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f011bb57:	89 14 24             	mov    %edx,(%esp)
f011bb5a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f011bb5e:	8b 44 24 04          	mov    0x4(%esp),%eax
f011bb62:	8b 14 24             	mov    (%esp),%edx
f011bb65:	83 c4 1c             	add    $0x1c,%esp
f011bb68:	5b                   	pop    %ebx
f011bb69:	5e                   	pop    %esi
f011bb6a:	5f                   	pop    %edi
f011bb6b:	5d                   	pop    %ebp
f011bb6c:	c3                   	ret    
f011bb6d:	8d 76 00             	lea    0x0(%esi),%esi
f011bb70:	2b 04 24             	sub    (%esp),%eax
f011bb73:	19 fa                	sbb    %edi,%edx
f011bb75:	89 d1                	mov    %edx,%ecx
f011bb77:	89 c6                	mov    %eax,%esi
f011bb79:	e9 71 ff ff ff       	jmp    f011baef <__umoddi3+0xb3>
f011bb7e:	66 90                	xchg   %ax,%ax
f011bb80:	39 44 24 04          	cmp    %eax,0x4(%esp)
f011bb84:	72 ea                	jb     f011bb70 <__umoddi3+0x134>
f011bb86:	89 d9                	mov    %ebx,%ecx
f011bb88:	e9 62 ff ff ff       	jmp    f011baef <__umoddi3+0xb3>
